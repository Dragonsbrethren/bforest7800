;==============================================================================
; BANK 12
;------------------------------------------------------------------------------
; Caves tileset and data
;==============================================================================
        bank 12
        incbasic caves.78b
        incmapfile tiled/caves_room_0.tmx

        data caves_map_lo
        plot_caves_room_0_lo
end

        data caves_map_hi
        plot_caves_room_0_hi
end

        data caves_obj_lo
        caves_room_0_obj_lo, caves_room_1_obj_lo, caves_room_2_obj_lo, caves_room_3_obj_lo, caves_room_4_obj_lo, caves_room_5_obj_lo
        caves_room_6_obj_lo, caves_room_7_obj_lo, caves_room_8_obj_lo, caves_room_9_obj_lo, caves_room_10_obj_lo, caves_room_11_obj_lo
        caves_room_12_obj_lo, caves_room_13_obj_lo, caves_room_14_obj_lo, caves_room_15_obj_lo, caves_room_16_obj_lo, caves_room_17_obj_lo
        caves_room_18_obj_lo, caves_room_19_obj_lo, caves_room_20_obj_lo
end

        data caves_obj_hi
        caves_room_0_obj_hi, caves_room_1_obj_hi, caves_room_2_obj_hi, caves_room_3_obj_hi, caves_room_4_obj_hi, caves_room_5_obj_hi
        caves_room_6_obj_hi, caves_room_7_obj_hi, caves_room_8_obj_hi, caves_room_9_obj_hi, caves_room_10_obj_hi, caves_room_11_obj_hi
        caves_room_12_obj_hi, caves_room_13_obj_hi, caves_room_14_obj_hi, caves_room_15_obj_hi, caves_room_16_obj_hi, caves_room_17_obj_hi
        caves_room_18_obj_hi, caves_room_19_obj_hi, caves_room_20_obj_hi
end

caves_waterfall
        ; prevent blacked out waterfalls when loading pal_animation rooms
        P7C1 = getfade(PAL_WFALL1) : P7C2 = getfade(PAL_WFALL2) : P7C3 = getfade(PAL_WFALL3)
        pal_animation = 1
        return

load_caves
        if !first_load then goto caves_set_room
        first_load = 0
        player_facing = DIR_DOWN

        room_index      = F_CAVES_ENT_1_I
        menu_map_Xpos   = M_CAVES_ENT_1_X
        menu_map_Ypos   = M_CAVES_ENT_1_Y
        player_Xpos     = F_CAVES_ENT_1_X
        player_Ypos     = F_CAVES_ENT_1_Y
        goto caves_set_room

caves_set_room
        characterset caves_floors

caves_init
        asm
          lda #0
          sta no_flash
          sta alt_palette
          sta pal_animation
          sta exit_room_index
          sta save_room_index
          lda #1
          sta shadow_offset
          lda #$FF
          sta locked_zone
          ldx room_index
          lda caves_rooms,x
          tax
          lda caves_obj_lo,x
          sta pointer
          lda caves_obj_hi,x
          sta pointer_hi
          lda room_index
          asl
          sta menu_map_index
          clc
          adc #1
          sta menu_map_index_2
          cpx #0
          beq .caves_room_bank_12
end
        gosub caves_room_bank_13 bank13
        return thisbank

caves_room_bank_12
        asm
          lda caves_map_lo,x
          sta temp1
          lda caves_map_hi,x
          sta temp2
          jmp (temp1)
end

caves_pals
        asm
          ; set these all at once to save cycles
          lda flash_color
          sta P4C1
          sta P5C1
          sta P6C1
end
        bg_color = PAL_CV_GRND  ; brown ground
        P4C2 = getfade(PAL_CV_DKBRN, black)
        P4C3 = getfade(PAL_CV_DKGRN, black)
        P5C2 = getfade(PAL_CV_DKGRN, black)
        P5C3 = getfade(PAL_CV_LTGRN)
        P6C2 = getfade(PAL_CV_WATER, black)
        P6C3 = getfade(PAL_CV_EYES)
        P4C3 = getfade(PAL_CV_DKGRN, black)

caves_shared_pals
        incbasic shared_pals.78b
        goto palette_done

test_walkable_caves
        tile_properties_1 = caves_tile_properties[move_tile_1]
        tile_properties_2 = caves_tile_properties[move_tile_2]
        ; if Johanna has the Nix's Tail relic, make shorelines walkable
        if !index && m_relic_bits_2{0} then gosub walkable_water_caves
        goto walkable_return

walkable_water_caves
        ; non-shoreline water is always walkable, this tests unwalkable tiles flagged as water
        if tile_properties_1{2} then tile_properties_1{0} = 1
        if tile_properties_2{2} then tile_properties_2{0} = 1
        
        ; objects can call this part of the subroutine to test if they are in water
test_water_caves
        ; water is tested differently than other properties, it tests the tile directly under the object
        ; this helps eliminate graphical issues when approaching a non-water tile in water
        gosub get_object_pos
        temp1 = peekchar (current_map, peekX, peekY, 20, 14)
        temp1 = temp1 / 2
        temp1 = caves_tile_properties[temp1]
        asm
          ldx index
          lda temp1
          and #%00000100
          beq test_water_caves_land
          lda object_flags,x
          ora #%00000010
          jmp test_water_caves_done
test_water_caves_land
          lda object_flags,x
          and #%11111101
test_water_caves_done
          sta object_flags,x
          rts
end

        data caves_tile_properties
        %00000010, %00000010, %00000010, %00000001, %00000001, %00000010, %00000001, %00000001
        %00000010, %00000001, %00000010, %00000001, %00000001, %00000001, %00000001, %00000001
        %00000010, %00000010, %00000010, %00000001
        %00000001, %00000001, %00000001, %00000001
        %00000001, %00000001, %00000000, %00000000, %00000000, %00000000, %00000010, %00000000
        %00000000, %00000000, %00000000, %00000001, %00000000, %00000000, %00000000, %00000000
        %00000000, %00000000
        %00000110, %00000111, %00000110, %00000110, %00000110, %00000110
        %00000110, %00000110, %00000110, %00000111
        %10000100
end

torch_tile_block_caves
        ; block with a floatable tile so projectiles can hit torch
        pokechar current_map peekX peekY 20 14 $00
        goto torch_tile_block_set_flag

torch_tile_unblock_caves
        ; the poked tile doesn't affect visuals since those are plotted from ROM
        pokechar current_map peekX peekY 20 14 $06
        goto kill_torch_done

        data caves_rooms
        00, 00, 01, 00, 00, 00, 00
        00, 00, 00, 04, 02, 03, 00
        00, 00, 00, 07, 06, 05, 00
        00, 01, 17,  8,  9, 10, 11
        19, 18, 16, 15, 14, 13, 12
        20, 00, 00, 00, 00, 00, 00
        00, 00, 00, 00, 00, 00, 00
end

        data caves_room_0_obj
        TYPE_TORCH, (11*8), $80
        $00
end

        data caves_room_1_obj
        $00
end

        data caves_room_2_obj
        TYPE_BAT_SPAWNER, $01, $F0
        $00
end

        data caves_room_3_obj
        TYPE_BAT_SPAWNER, $01, $F0
        $00
end

        data caves_room_4_obj
        TYPE_ROSE, 128, $30, TYPE_ROSE, 72, $90
        $00
end

        data caves_room_5_obj
         TYPE_BAT_SPAWNER, $01, $F0
        $00
end

        data caves_room_6_obj
        TYPE_BAT_SPAWNER, $01, $F0
        $00
end

        data caves_room_7_obj
        $00
end

        data caves_room_8_obj
        $00
end

        data caves_room_9_obj
        TYPE_BAT_SPAWNER, $01, $F0
        $00
end

        data caves_room_10_obj
        TYPE_BAT_SPAWNER, $01, $F0
        $00
end

        data caves_room_11_obj
        $00
end

        data caves_room_12_obj
        $00
end

        data caves_room_13_obj
        $00
end

        data caves_room_14_obj
        $00
end

        data caves_room_15_obj
        $00
end

        data caves_room_16_obj
        $00
end

        data caves_room_17_obj
        $00
end

        data caves_room_18_obj
        $00
end

        data caves_room_19_obj
        $00
end

        data caves_room_20_obj
        $00
end

plot_caves_room_0
        menu_map_room[menu_map_index] = ROOML_UDL
        menu_map_room[menu_map_index_2] = ROOMR_UD
        memcpy current_map caves_room_0 280
        plotmapfile tiled/caves_room_0.tmx caves_room_0 0 0 20 14
        zone1_objects  = 2
        zone2_objects  = 2
        zone14_objects = 2
        exit_tileset = T_HILLS
        exit_Xpos = 72
        exit_Ypos = $20
        exit_room_index = F_HILLS_CAVE1_I
        return thisbank

;==============================================================================
; BAT SPAWNER
;------------------------------------------------------------------------------
; Unsurprisingly, exists soley to spawn bat enemies
; - Bats are spawned at player's Yposition
; - player_Xpos determines if bats spawn flying left or right
; - Yposition should be off screen since it does not have a sprite
;==============================================================================
bat_spawner_ai
        asm
          lda object_timer,x
          beq batspawn
          dec object_timer,x
          rts
batspawn  lda object_parent,x   ; less a parent, more a tracker for slot used
          tay
          lda object_type,y     ; load the spawned bat slot's object type
          bne batnspawn         ; if it's not null, prevent new spawn
          jsr .find_new_object
          cpy #0        ; make sure all object slots aren't full
          bne batsobj   ; slot available, spawn bat object
batnspawn rts
batsobj
          tya
          sta object_parent,x   ; spawned bat's index saved here
          lda #TYPE_BAT
          sta object_type,y
          lda #BAT_HP
          sta object_hp,y
          lda #BAT_SPEED_HI
          sta object_speed_hi,y
          lda #BAT_VEL_CAP_HI
          sta object_vel_cap_hi,y
          lda #BAT_SPEED_LO
          sta object_speed_lo,y
          lda #BAT_VEL_CAP_LO
          sta object_vel_cap_lo,y
          lda #BAT_DAMAGE
          sta object_damage,y
          lda #%00000100        ; object flying
          sta object_flags,y
          lda #0
          sta object_friction_hi,y
          sta object_friction_lo,y
          lda #F_BAT
          sta object_frame,y
          lda #BAT_PAL
          sta object_pal,y
          lda #<.plot_caves_160a
          sta object_spr_ptr_lo,y
          lda #>.plot_caves_160a
          sta object_spr_ptr_hi,y
batpldir  lda player_Xpos       ; determine which side
          cmp #80               ; of screen to spawn bat
          bcs batright
batleft
          lda #DIR_LEFT
          sta object_Xdir,y
          lda #159
          sta object_Xpos,y
          bne batsetY
batright
          lda #DIR_RIGHT
          sta object_Xdir,y
          lda #0
          sta object_Xpos,y
batsetY   lda player_Ypos
          sta object_Ypos,y
          sta object_state,y
          lda #DIR_DOWN
          sta object_Ydir,y
batstime  lda #BAT_SPAWN_TIME
          sta object_timer,x
          tya
          sta object_parent,x
          rts
end

;==============================================================================
; BAT
;------------------------------------------------------------------------------
; Flies in horizontally from off screen, attempts to collide with player
; - Bat Spawner sets X and Y starting positions, velocity
;==============================================================================
bat_ai
        asm
; The first thing the Bat AI does is determine if it is on screen
; There is a 12-pixel grace area off both sides of the screen to allow bats
; to spawn off screen. If the bat is outside this area, it despawns
          lda object_Xpos,x
          cmp #172            ; right edge of screen + 12
          bcs batledge          ; determine if bat is off left edge
          bcc batwave           ; position is on visible screen
batledge  cmp #243            ; left edge of screen - 12
          bcc batdie            ; bat isn't on screen, kill it 
batwave   lda object_Ydir,x     ; is the bat moving up or down?
          cmp #DIR_DOWN
          beq batdown
batup     lda object_Ypos,x     ; take the bat's current Y position
          clc
          adc #16               ; add 16 to it
          cmp object_state,x    ; compare with initial Y position
          bcs batvel            ; current + 16 >= initial, move bat up
          lda #DIR_DOWN         ; current + 16 < initial
          sta object_Ydir,x     ; so change direction to down
          bne batvel            ; bypass down comparison this frame
batdown   lda object_state,x    ; start with initial Y position
          clc
          adc #16               ; add 16 to it
          cmp object_Ypos,x     ; compare with current Y position
          bcs batvel            ; initial + 16 >= current, move bat down
          lda #DIR_UP           ; initial + 16 < current
          sta object_Ydir,x     ; so change direction to up
batvel    lda object_Xvel_lo,x
          clc
          adc object_speed_lo,x ; add speed to current X velocity
          sta object_Xvel_lo,x
          lda object_Xvel_hi,x
          adc object_speed_hi,x
          sta object_Xvel_hi,x
          lda object_Yvel_lo,x
          clc
          adc object_speed_lo,x ; add speed to current Y velocity
          sta object_Yvel_lo,x
          lda object_Yvel_hi,x
          adc object_speed_hi,x
          sta object_Yvel_hi,x
batanim   lda object_Xdir,x     ; determine bat's X direction again
          cmp #DIR_LEFT
          bne batanrt
batanlf   lda #F_BAT_L1         ; left-facing frame 1
          jmp batanfr
batanrt   lda #F_BAT_R1         ; right-facing frame 1
batanfr   sta object_frame,x    ; store it
          lda animation_frame   ; check if it needs to animate
          beq batdone
          inc object_frame,x    ; frame++ - frames are stored R1, R2, L1, L2
batdone   rts
batdie    lda #0
          sta object_type,x
          rts
end

plot_caves_160a
        plotsprite bat0 sprite_pal Xposition Yposition frame
        goto plot_next

obj_bat_spawner_stats
        asm
          ldx obj_index
          lda #1
          sta object_hp,x
          jmp .obj_next_stats
end

obj_rose_stats
        asm
          ldx obj_index
          lda #1
          sta object_hp,x
          jmp .obj_next_stats
end


;==============================================================================
; STONE ROSE
;------------------------------------------------------------------------------
; Static. Calculates position between self and player, shoots seed at player
;==============================================================================
rose_ai
        asm
          lda object_parent,x
          beq roseseed
          rts
roseseed  jsr .find_new_object
          cpy #0
          bne rosecalc
          rts   ; no empty slot
rosecalc  lda player_Xpos
          cmp object_Xpos,x
          bcs rosert
roself    lda #DIR_LEFT
          sta object_Xdir,y
          bne roseY
rosert    lda #DIR_RIGHT
          sta object_Xdir,y
roseY     lda player_Ypos
          cmp object_Ypos,x
          bcs rosedn
roseup    lda #DIR_UP
          sta object_Ydir,y
          bne rospawn
rosedn    lda #DIR_DOWN
          sta object_Ydir,y
rospawn   tya
          sta object_parent,x   ; spawned bat's index saved here
          lda #TYPE_BAT
          sta object_type,y
          lda #BAT_HP
          sta object_hp,y
          lda #BAT_SPEED_HI
          sta object_speed_hi,y
          sta object_Xvel_hi,y
          sta object_Yvel_hi,y
          lda #BAT_VEL_CAP_HI
          sta object_vel_cap_hi,y
          lda #BAT_SPEED_LO
          sta object_speed_lo,y
          sta object_Xvel_lo,y
          sta object_Yvel_lo,y
          lda #BAT_VEL_CAP_LO
          sta object_vel_cap_lo,y
          lda #BAT_DAMAGE
          sta object_damage,y
          lda #%00000100        ; object flying
          sta object_flags,y
          lda #0
          sta object_friction_hi,y
          sta object_friction_lo,y
          lda #F_BAT
          sta object_frame,y
          lda #BAT_PAL
          sta object_pal,y
          lda #<.plot_caves_160a
          sta object_spr_ptr_lo,y
          lda #>.plot_caves_160a
          sta object_spr_ptr_hi,y
          lda object_Xpos,x
          sta object_Xpos,y
          lda object_Ypos,x
          sta object_Ypos,y
          rts
end