;==============================================================================
; BANK 12
;------------------------------------------------------------------------------
; Caves tileset and data
;==============================================================================
        bank 12
        incbasic caves.78b
        incmapfile tiled/caves_room_0.tmx

        data caves_map_lo
        plot_caves_room_0_lo
end

        data caves_map_hi
        plot_caves_room_0_hi
end

        data caves_obj_lo
        caves_room_0_obj_lo, caves_room_1_obj_lo, caves_room_2_obj_lo, caves_room_3_obj_lo, caves_room_4_obj_lo, caves_room_5_obj_lo
        caves_room_6_obj_lo, caves_room_7_obj_lo, caves_room_8_obj_lo, caves_room_9_obj_lo, caves_room_10_obj_lo, caves_room_11_obj_lo
        caves_room_12_obj_lo, caves_room_13_obj_lo, caves_room_14_obj_lo, caves_room_15_obj_lo, caves_room_16_obj_lo, caves_room_17_obj_lo
        caves_room_18_obj_lo, caves_room_19_obj_lo, caves_room_20_obj_lo
end

        data caves_obj_hi
        caves_room_0_obj_hi, caves_room_1_obj_hi, caves_room_2_obj_hi, caves_room_3_obj_hi, caves_room_4_obj_hi, caves_room_5_obj_hi
        caves_room_6_obj_hi, caves_room_7_obj_hi, caves_room_8_obj_hi, caves_room_9_obj_hi, caves_room_10_obj_hi, caves_room_11_obj_hi
        caves_room_12_obj_hi, caves_room_13_obj_hi, caves_room_14_obj_hi, caves_room_15_obj_hi, caves_room_16_obj_hi, caves_room_17_obj_hi
        caves_room_18_obj_hi, caves_room_19_obj_hi, caves_room_20_obj_hi
end

caves_waterfall
        ; prevent blacked out waterfalls when loading pal_animation rooms
        P7C1 = getfade(PAL_WFALL1) : P7C2 = getfade(PAL_WFALL2) : P7C3 = getfade(PAL_WFALL3)
        pal_animation = 1
        return

load_caves
        if !first_load then goto caves_set_room
        first_load = 0
        player_facing = DIR_DOWN

        room_index      = F_CAVES_ENT_1_I
        menu_map_Xpos   = M_CAVES_ENT_1_X
        menu_map_Ypos   = M_CAVES_ENT_1_Y
        player_Xpos     = F_CAVES_ENT_1_X
        player_Ypos     = F_CAVES_ENT_1_Y
        goto caves_set_room

caves_set_room
        characterset caves_floors

caves_init
        asm
          lda #0
          sta no_flash
          sta alt_palette
          sta pal_animation
          sta exit_room_index
          sta save_room_index
          lda #1
          sta shadow_offset
          lda #$FF
          sta locked_zone
          ldx room_index
          lda caves_rooms,x
          tax
          lda caves_obj_lo,x
          sta pointer
          lda caves_obj_hi,x
          sta pointer_hi
          lda room_index
          asl
          sta menu_map_index
          clc
          adc #1
          sta menu_map_index_2
          cpx #0
          beq .caves_room_bank_12
end
        gosub caves_room_bank_13 bank13
        return thisbank

caves_room_bank_12
        asm
          lda caves_map_lo,x
          sta temp1
          lda caves_map_hi,x
          sta temp2
          jmp (temp1)
end

caves_pals
        asm
          ; set these all at once to save cycles
          lda flash_color
          sta P4C1
          sta P5C1
          sta P6C1
          sta P7C1
end
        bg_color = PAL_CV_GRND  ; brown ground
        P4C2 = getfade(PAL_CV_DKBRN, black)
        P4C3 = getfade(PAL_CV_DKGRN, black)
        P5C2 = getfade(PAL_CV_DKGRN, black)
        P5C3 = getfade(PAL_CV_LTGRN)
        P6C2 = getfade(PAL_CV_WATER, black)
        P6C3 = getfade(PAL_CV_EYES)
        P4C3 = getfade(PAL_CV_DKGRN, black)
        if pal_animation then caves_shared_pals
;       P7C2 = getfade(PAL_PUDDING_DK, black)
        P7C2 = flash_color      ; black pudding is BLACK (or purple...)
        P7C3 = getfade(PAL_PUDDING_LT)

caves_shared_pals
        incbasic shared_pals.78b
        goto palette_done

test_walkable_caves
        tile_properties_1 = caves_tile_properties[move_tile_1]
        tile_properties_2 = caves_tile_properties[move_tile_2]
        ; if Johanna has the Nix's Tail relic, make shorelines walkable
        if !index && m_relic_bits_2{0} then gosub walkable_water_caves
        goto walkable_return

walkable_water_caves
        ; non-shoreline water is always walkable, this tests unwalkable tiles flagged as water
        if tile_properties_1{2} then tile_properties_1{0} = 1
        if tile_properties_2{2} then tile_properties_2{0} = 1
        
        ; objects can call this part of the subroutine to test if they are in water
test_water_caves
        ; water is tested differently than other properties, it tests the tile directly under the object
        ; this helps eliminate graphical issues when approaching a non-water tile in water
        gosub get_object_pos
        temp1 = peekchar (current_map, peekX, peekY, 20, 14)
        temp1 = temp1 / 2
        temp1 = caves_tile_properties[temp1]
        asm
          ldx index
          lda temp1
          and #%00000100
          beq test_water_caves_land
          lda object_flags,x
          ora #%00000010
          jmp test_water_caves_done
test_water_caves_land
          lda object_flags,x
          and #%11111101
test_water_caves_done
          sta object_flags,x
          rts
end

        data caves_tile_properties
        %00000010, %00000010, %00000010, %00000001, %00000001, %00000010, %00000001, %00000001
        %00000010, %00000001, %00000010, %00000001, %00000001, %00000001, %00000001, %00000001
        %00000010, %00000010, %00000010, %00000001
        %00000001, %00000001, %00000001, %00000001
        %00000001, %00000001, %00000000, %00000000, %00000000, %00000000, %00000010, %00000000
        %00000000, %00000000, %00000000, %00000001, %00000000, %00000000, %00000000, %00000000
        %00000000, %00000000
        %00000110, %00000111, %00000110, %00000110, %00000110, %00000110
        %00000110, %00000110, %00000110, %00000111
        %10000100
end

torch_tile_block_caves
        ; block with a floatable tile so projectiles can hit torch
        pokechar current_map peekX peekY 20 14 $00
        goto torch_tile_block_set_flag

torch_tile_unblock_caves
        ; the poked tile doesn't affect visuals since those are plotted from ROM
        pokechar current_map peekX peekY 20 14 $06
        goto kill_torch_done

        data caves_rooms
        00, 00, 01, 00, 00, 00, 00
        00, 00, 00, 04, 02, 03, 00
        00, 00, 00, 07, 06, 05, 00
        00, 01, 17,  8,  9, 10, 11
        19, 18, 16, 15, 14, 13, 12
        20, 00, 00, 00, 00, 00, 00
        00, 00, 00, 00, 00, 00, 00
end

        data caves_room_0_obj
        TYPE_TORCH, (11*8), $80
        $00
end

        data caves_room_1_obj
        $00
end

        data caves_room_2_obj
        TYPE_BAT_SPAWNER, $01, $F0
        $00
end

        data caves_room_3_obj
        TYPE_BAT_SPAWNER, $01, $F0
        $00
end

        data caves_room_4_obj
        TYPE_PUDDING, 128, $30, TYPE_ROSE, 72, $90
        TYPE_CSPIDER, (4*8), $30
        $00
end

        data caves_room_5_obj
         TYPE_BAT_SPAWNER, $01, $F0
        $00
end

        data caves_room_6_obj
        TYPE_BAT_SPAWNER, $01, $F0
        $00
end

        data caves_room_7_obj
        $00
end

        data caves_room_8_obj
        $00
end

        data caves_room_9_obj
        TYPE_BAT_SPAWNER, $01, $F0
        $00
end

        data caves_room_10_obj
        TYPE_BAT_SPAWNER, $01, $F0
        $00
end

        data caves_room_11_obj
        $00
end

        data caves_room_12_obj
        $00
end

        data caves_room_13_obj
        $00
end

        data caves_room_14_obj
        $00
end

        data caves_room_15_obj
        $00
end

        data caves_room_16_obj
        $00
end

        data caves_room_17_obj
        $00
end

        data caves_room_18_obj
        $00
end

        data caves_room_19_obj
        $00
end

        data caves_room_20_obj
        $00
end

plot_caves_room_0
        menu_map_room[menu_map_index] = ROOML_UDL
        menu_map_room[menu_map_index_2] = ROOMR_UD
        memcpy current_map caves_room_0 280
        plotmapfile tiled/caves_room_0.tmx caves_room_0 0 0 20 14
        zone1_objects  = 2
        zone2_objects  = 2
        zone14_objects = 2
        exit_tileset = T_HILLS
        exit_Xpos = 72
        exit_Ypos = $20
        exit_room_index = F_HILLS_CAVE1_I
        return thisbank

;==============================================================================
; BAT SPAWNER
;------------------------------------------------------------------------------
; Unsurprisingly, exists soley to spawn bat enemies
; - Bats are spawned at player's Yposition
; - player_Xpos determines if bats spawn flying left or right
; - Needs to be off screen since it does not have a sprite
;==============================================================================
bat_spawner_ai
        asm
          lda object_timer,x    ; timer set after a bat has spawned
          beq batspawn          ; it's bat time!
          dec object_timer,x    ; timer--
          rts
batspawn  lda object_parent,x   ; tracker for number of bats
          cmp #BAT_MAX          ; set to 6 means 5 bats can spawn
          bcs batnspawn         ; at or more than BAT_MAX
          jsr .find_new_object  ; find an open object slot
          cpy #0                ; make sure all object slots aren't full
          bne batsobj           ; slot available, spawn bat object
batnspawn rts
batsobj   inc object_parent,x   ; spawned bat counter + 1
          txa
          sta object_parent,y   ; back up the spawner's object index
          lda #TYPE_BAT
          sta object_type,y
          lda #BAT_HP
          sta object_hp,y
          lda #BAT_SPEED_HI
          sta object_speed_hi,y
          lda #BAT_VEL_CAP_HI
          sta object_vel_cap_hi,y
          lda #BAT_SPEED_LO
          sta object_speed_lo,y
          lda #BAT_VEL_CAP_LO
          sta object_vel_cap_lo,y
          lda #BAT_DAMAGE
          sta object_damage,y
          lda #%00000100        ; object flying
          sta object_flags,y
          lda #0
          sta object_friction_hi,y
          sta object_friction_lo,y
          lda #BAT_PAL
          sta object_pal,y
          lda #<.plot_caves_160a
          sta object_spr_ptr_lo,y
          lda #>.plot_caves_160a
          sta object_spr_ptr_hi,y
batpldir  lda player_Xpos       ; determine which side
          cmp #80               ; of screen to spawn bat
          bcs batright
batleft
          lda #DIR_LEFT
          sta object_Xdir,y
          lda #159
          sta object_Xpos,y
          bne batsetY
batright
          lda #DIR_RIGHT
          sta object_Xdir,y
          lda #0
          sta object_Xpos,y
batsetY   lda player_Ypos
          sta object_Ypos,y
          sta object_state,y
          lda #DIR_DOWN
          sta object_Ydir,y
batstime  lda #BAT_SPAWN_TIME
          sta object_timer,x
          rts
end

;==============================================================================
; BAT
;------------------------------------------------------------------------------
; Flies in horizontally from off screen, attempts to collide with player
; - Bat Spawner sets X and Y starting positions
;==============================================================================
bat_ai
        asm
; The first thing the Bat AI does is determine if it is on screen
; There is a 12-pixel grace area off both sides of the screen to allow bats
; to spawn off screen. If the bat is outside this area, it despawns
          lda object_Xpos,x
          cmp #172            ; right edge of screen + 12
          bcs batledge          ; determine if bat is off left edge
          bcc batwave           ; position is on visible screen
batledge  cmp #243            ; left edge of screen - 12
          bcc batdie            ; bat isn't on screen, kill it 
batwave   lda object_Ydir,x     ; is the bat moving up or down?
          cmp #DIR_DOWN
          beq batdown
batup     lda object_Ypos,x     ; take the bat's current Y position
          clc
          adc #16               ; add 16 to it
          cmp object_state,x    ; compare with initial Y position
          bcs batvel            ; current + 16 >= initial, move bat up
          lda #DIR_DOWN         ; current + 16 < initial
          sta object_Ydir,x     ; so change direction to down
          bne batvel            ; bypass down comparison this frame
batdown   lda object_state,x    ; start with initial Y position
          clc
          adc #16               ; add 16 to it
          cmp object_Ypos,x     ; compare with current Y position
          bcs batvel            ; initial + 16 >= current, move bat down
          lda #DIR_UP           ; initial + 16 < current
          sta object_Ydir,x     ; so change direction to up
batvel    lda object_Xvel_lo,x
          clc
          adc object_speed_lo,x ; add speed to current X velocity
          sta object_Xvel_lo,x
          lda object_Xvel_hi,x
          adc object_speed_hi,x
          sta object_Xvel_hi,x
          lda object_Yvel_lo,x
          clc
          adc object_speed_lo,x ; add speed to current Y velocity
          sta object_Yvel_lo,x
          lda object_Yvel_hi,x
          adc object_speed_hi,x
          sta object_Yvel_hi,x
batanim   lda object_Xdir,x     ; determine bat's X direction again
          cmp #DIR_LEFT
          bne batanrt
batanlf   lda #F_BAT_L1         ; left-facing frame 1
          jmp batanfr
batanrt   lda #F_BAT_R1         ; right-facing frame 1
batanfr   sta object_frame,x    ; store it
          lda animation_frame   ; check if it needs to animate
          beq batdone
          inc object_frame,x    ; frame++ - frames are stored R1, R2, L1, L2
batdone   rts
batdie    lda object_parent,x   ; get the spawner object that created this bat
          tax
          dec object_parent,x   ; decrement spawner's bat counter
          ldx index             ; reload this object's index
          lda #0
          sta object_type,x     ; and kill it
          rts
end

obj_bat_spawner_stats
        asm
          ldx obj_index
          lda #1
          sta object_hp,x
          jmp .obj_next_stats
end

obj_rose_stats
        asm
          ldx obj_index
          lda #ROSE_HP
          sta object_hp,x
          lda #ROSE_DAMAGE
          sta object_damage,x
          lda #<.plot_caves_160b
          sta object_spr_ptr_lo,x
          lda #>.plot_caves_160b
          sta object_spr_ptr_hi,x
          lda #4
          sta object_pal,x
          lda #1
          sta object_elevation,x
          jmp .obj_next_stats
end


;==============================================================================
; STONE ROSE
;------------------------------------------------------------------------------
; Static. Calculates position between self and player, shoots seed at player
;==============================================================================
rose_ai
        asm
          lda object_timer,x
          beq roseseed
          dec object_timer,x
          rts
roseseed  lda object_parent,x
          tay
          lda object_type,y
          bne rosenos
          jsr .find_new_object
          cpy #0
          bne rosecalc
rosenos   rts   ; no empty slot/seed already spawned
rosecalc  jsr .calculate_distance
rospawn   tya
          sta object_parent,x   ; spawned seed's index saved here
          lda #TYPE_SEED
          sta object_type,y
          lda #1
          sta object_hp,y
          lda player_Xpos
          cmp object_Xpos,x
          bcs rosXrt
rosXlf    lda #DIR_LEFT
          bne rosXst
rosXrt    lda #DIR_RIGHT
rosXst    sta object_Xdir,y
          lda player_Ypos
          cmp object_Ypos,x
          bcs rosYdn
rosYup    lda #DIR_UP
          bne rosYst
rosYdn    lda #DIR_DOWN
rosYst    sta object_Ydir,y
          lda temp3
          bne rofastY
rofastX   lda #SEED_FAST_SPEED_HI
          sta object_speed_hi,y
          sta object_Xvel_hi,y
          lda #SEED_FAST_SPEED_LO
          sta object_speed_lo,y
          sta object_Xvel_lo,y
          lda #SEED_SPEED_HI
          sta object_Yvel_hi,y
          lda #SEED_SPEED_LO
          sta object_Yvel_lo,y
rofastY   lda #SEED_SPEED_HI
          sta object_Xvel_hi,y
          lda #SEED_SPEED_LO
          sta object_Xvel_lo,y
          lda #SEED_FAST_SPEED_HI
          sta object_speed_hi,y
          sta object_Yvel_hi,y
          lda #SEED_FAST_SPEED_LO
          sta object_speed_lo,y
          sta object_Yvel_lo,y
          lda #SEED_VEL_CAP_HI
          sta object_vel_cap_hi,y
          lda #SEED_VEL_CAP_LO
          sta object_vel_cap_lo,y
          lda #SEED_DAMAGE
          sta object_damage,y
          lda #%00010000        ; object floating
          sta object_flags,y
          lda #0
          sta object_friction_hi,y
          sta object_friction_lo,y
          lda #F_SEED
          sta object_frame,y
          lda #SEED_PAL
          sta object_pal,y
          lda #<.plot_caves_160a
          sta object_spr_ptr_lo,y
          lda #>.plot_caves_160a
          sta object_spr_ptr_hi,y
          lda object_Xpos,x
          sta object_Xpos,y
          lda object_Ypos,x
          sta object_Ypos,y
          lda #64
          sta object_timer,x
          lda #1
          sta object_elevation,y
          rts
end

;=========================================================
; CAVE SPIDER
;---------------------------------------------------------
; Crawls along ledges until lined up with player,
; then decends and becomes a standard ground enemy
;=========================================================
cave_spider_ai
        asm
          lda object_flags,x
          ; flag 7 causes spider to drop
          bmi cave_spider_drop_horiz
          ; flag 4 makes spider stalk
          and #%00010000
          bne cave_spider_stalk

cave_spider_init
          lda #CSPIDER_PAL 
          sta object_pal,x
        ; TODO: Wall crawl flag?
        ; spiders originally were set to "float" so they could walk on ledges
        ; this is no longer used but the flag is still needed for this init
          lda #%00010000
          sta object_flags,x
        ; always start at player's elevation
          lda player_elevation
          sta object_elevation,x

cave_spider_stalk
          ; vertical spiders unused, omitted code to detect them

cave_spider_horiz
          lda object_Ypos,x
;         sec
;         sbc #32
          sta temp1
          lda object_Xpos,x
          sec
          sbc #12
          sta temp2
        ; cave_spider checks for player proximity before moving
          QBOXCOLLISIONCHECK temp2,temp1,36,48,player_Xpos,player_Ypos,PLAYER_WIDTH,PLAYER_HEIGHT
          bcs cave_spider_drop_clear_timer
          rts

;cave_spider_vert
        ; not implemented
;         rts

cave_spider_drop_clear_timer
          lda #0
          sta object_timer,x
cave_spider_drop_horiz
          lda object_flags,x
          and #%00010000
          beq cave_spider_dir
          lda object_timer,x
          bne cave_spider_drop_move
          ; test flag 7
          lda object_flags,x
          bmi cave_spider_drop_done
          ; flag 7 = horizontal drop started
          ora #%10000000
          sta object_flags,x
          lda #CSPIDER_DROP_TIME
          sta object_timer,x
;         lda player_elevation
;         sta object_elevation,x
;         lda object_Ypos,x
;         cmp player_Ypos
;         bcc cave_spider_drop_down
;         lda #DIR_UP
;         sta object_Ydir,x
;         lda #F_CSPIDER_UP
;         sta object_frame,x
;         jmp cave_spider_drop_next
cave_spider_drop_down
          lda #DIR_DOWN
          sta object_Ydir,x
          lda #F_CSPIDER_DOWN
          sta object_frame,x
cave_spider_drop_next
          ; wait a frame to start movement
          rts
cave_spider_drop_move
          ; does the cave_spider drop or crawl up cliff?
;         lda object_Ydir,x
;         cmp #DIR_DOWN
;         bne cave_spider_climb_up
          inc object_Ypos,x
;         jmp cave_spider_dec_timer
;ave_spider_climb_up
;         dec object_Ypos,x

cave_spider_dec_timer
          dec object_timer,x
          rts

cave_spider_drop_done
          ; turn off "floating" flag to signify drop done
          lda object_flags,x
          and #%11101111
          sta object_flags,x

cave_spider_dir
          lda object_timer,x
          beq cave_spider_set_timer
          jmp cave_spider_walk
cave_spider_set_timer
          lda #CSPIDER_WALK_TIMER
          sta object_timer,x
          jsr randomize
          bpl cave_spider_move_vert

cave_spider_move_horz
          lda #0
          sta object_Ydir,x
          lda object_Xpos,x
          cmp player_Xpos
          bcs cave_spider_move_left
cave_spider_move_right
          lda #DIR_RIGHT
          bne cave_spider_move_h_store
cave_spider_move_left
          lda #DIR_LEFT
cave_spider_move_h_store
          sta object_facing,x
          sta object_Xdir,x
          bne cave_spider_walk

cave_spider_move_vert
          lda #0
          sta object_Xdir,x
          lda object_Ypos,x
          cmp player_Ypos
          bcc cave_spider_move_down
cave_spider_move_up
          lda #DIR_UP
          bne cave_spider_move_v_store
cave_spider_move_down
          lda #DIR_DOWN

cave_spider_move_v_store
          sta object_facing,x
          sta object_Ydir,x

cave_spider_walk
          dec object_timer,x
          lda object_Xdir,x
          beq cave_spider_walk_y

cave_spider_walk_x
          lda object_Xvel_lo,x
          clc
          adc object_speed_lo,x
          sta object_Xvel_lo,x
          lda object_Xvel_hi,x
          adc object_speed_hi,x
          sta object_Xvel_hi,x
          jmp cave_spider_walk_anim
        
cave_spider_walk_y
          lda object_Yvel_lo,x
          clc
          adc object_speed_lo,x
          sta object_Yvel_lo,x
          lda object_Yvel_hi,x
          adc object_speed_hi,x
          sta object_Yvel_hi,x

cave_spider_walk_anim
          lda object_facing,x
          tay
          lda cave_spider_walk_frames,y
          sta object_frame,x
          lda animation_frame
          beq cave_spider_walk_return
          inc object_frame,x

cave_spider_walk_return
          rts
end

        data cave_spider_walk_frames
        0, F_CSPIDER_UP, F_CSPIDER_DOWN, F_CSPIDER_LEFT, F_CSPIDER_RIGHT
end

obj_cave_spider_stats
        object_hp[obj_index] = CSPIDER_HP
        object_vel_cap_hi[obj_index] = CSPIDER_VEL_CAP_HI
        object_vel_cap_lo[obj_index] = CSPIDER_VEL_CAP_LO
        object_damage[obj_index] = CSPIDER_DAMAGE
        object_def[obj_index] = CSPIDER_DEF
        object_mdef[obj_index] = CSPIDER_MDEF
        object_friction_hi[obj_index] = CSPIDER_FRICTION_HI
        object_friction_lo[obj_index] = CSPIDER_FRICTION_LO
        object_speed_hi[obj_index] = CSPIDER_SPEED_HI
        object_speed_lo[obj_index] = CSPIDER_SPEED_LO
        object_flags[obj_index] = 0
        asm
          ldx obj_index
          lda #F_CSPIDER_DOWN
          sta object_frame,x
          jmp .caves_160a_sprite
end

        dmahole 0
;=========================================================
; BLACK PUDDING
;---------------------------------------------------------
; Caves variant of Slime
;=========================================================
mpudding_ai
        asm
          lda #PUDDING_PAL
          sta object_pal,x
          lda #F_MPUDDING_1
          sta object_frame,x
          jmp pudding_anim
end

pudding_ai
        asm
          lda #PUDDING_PAL
          sta object_pal,x
          lda #F_PUDDING_1
          sta object_frame,x
pudding_anim
          lda animation_frame
          beq pudding_ooze
          inc object_frame,x
pudding_ooze
          jmp .follow_player
end

split_pudding
        ; replace slime mobj with mini slime
        asm
          lda #TYPE_MPUDDING
          sta object_type,x
          lda #MPUDDING_HP
          sta object_hp,x
          lda #MPUDDING_DEF
          sta object_def,x
          lda #F_MPUDDING_1
          sta object_frame,x
;         lda #<.plot_caves_160a
;         sta object_spr_ptr_lo,x
;         lda #>.plot_caves_160a
;         sta object_spr_ptr_hi,x
end
        gosub find_new_object
        ; if no slots, the slime just becomes a single mini slime
        if no_empty_slot then goto set_enemy_name
        asm
          ; move the original slime to the left
          lda object_Xpos,x
          ; push Xpos to stack for later use
          pha
          sec
          sbc #1
          sta object_Xpos,x
          lda object_Ypos,x
        ; initialize the new mini slime object
          ldx spawn_index
          sta object_Ypos,y
          lda #TYPE_MPUDDING
          sta object_type,y
          lda #MPUDDING_HP
          sta object_hp,y
          lda #PUDDING_VEL_CAP_HI
          sta object_vel_cap_hi,y
          lda #PUDDING_VEL_CAP_LO
          sta object_vel_cap_lo,y
          lda #PUDDING_DAMAGE
          sta object_damage,y
          lda #MPUDDING_DEF
          sta object_def,y
          lda #MPUDDING_MDEF
          sta object_mdef,y
          lda #PUDDING_FRICTION_HI
          sta object_friction_hi,y
          lda #PUDDING_FRICTION_LO
          sta object_friction_lo,y
          lda #PUDDING_SPEED_HI
          sta object_speed_hi,y
          lda #PUDDING_SPEED_LO
          sta object_speed_lo,y
          lda #F_MPUDDING_1
          sta object_frame,y
          ; pull parent X position from stack and move spawned slime to the right
          pla
          clc
          adc #9
          sta object_Xpos,y
          lda #6
          sta object_pal,y
          lda #<.plot_caves_160a
          sta object_spr_ptr_lo,y
          lda #>.plot_caves_160a
          sta object_spr_ptr_hi,y
end
        goto set_enemy_name

obj_pudding_stats
        object_hp[obj_index] = PUDDING_HP
        object_vel_cap_hi[obj_index] = PUDDING_VEL_CAP_HI
        object_vel_cap_lo[obj_index] = PUDDING_VEL_CAP_LO
        object_damage[obj_index] = PUDDING_DAMAGE
        object_def[obj_index] = PUDDING_DEF
        object_mdef[obj_index] = PUDDING_MDEF
        object_friction_hi[obj_index] = PUDDING_FRICTION_HI
        object_friction_lo[obj_index] = PUDDING_FRICTION_LO
        object_speed_hi[obj_index] = PUDDING_SPEED_HI
        object_speed_lo[obj_index] = PUDDING_SPEED_LO
        object_flags[obj_index] = 0
        object_elevation[obj_index] = player_elevation
        goto caves_160a_sprite

caves_160a_sprite
        asm
          ldx obj_index
          lda #<.plot_caves_160a
          sta object_spr_ptr_lo,x
          lda #>.plot_caves_160a
          sta object_spr_ptr_hi,x
end
        goto obj_next_stats  

plot_caves_160a
        plotsprite bat0 sprite_pal Xposition Yposition frame
        goto plot_next

plot_caves_160b
        plotsprite rose0 sprite_pal Xposition Yposition frame
        goto plot_next