;==============================================================================
; BANK 11
;------------------------------------------------------------------------------
; Magic Menu, Game Over Screen, Password Menu, Main Menu Maps
;==============================================================================
        bank 11
        incbasic menu_shared.78b

        inline hiscore.asm
        inline 7800vox.asm

load_hsc
        loadmemory pw_index0-pw_index
        return otherbank

encode_password
        asm
        lda tileset
        sta pw_tileset
        lda save_room_index
        sta pw_saveroom
        lda player_sword
        sta pw_sword
        lda player_shield
        sta pw_shield
        lda player_armor
        sta pw_armor
        lda player_charm
        sta pw_charm
        lda m_item_bits_1
        sta pw_inventory_1
        lda m_item_bits_2
        sta pw_inventory_2
        lda m_spell_bits_1
        sta pw_spells_1
        lda m_spell_bits_2
        sta pw_spells_2
        lda m_sword_bits_1
        sta pw_swords_1
        lda m_sword_bits_2
        sta pw_swords_2
        lda m_shield_bits_1
        sta pw_shields_1
        lda m_shield_bits_2
        sta pw_shields_2
        lda m_armor_bits_1
        sta pw_armor_1
        lda m_armor_bits_2
        sta pw_armor_2
        lda m_charm_bits_1
        sta pw_charms_1
        lda m_charm_bits_2
        sta pw_charms_2
        lda m_relic_bits_1
        sta pw_relics_1
        lda m_relic_bits_2
        sta pw_relics_2
        lda m_map_bits
        sta pw_index20
        lda m_key_bits
        sta pw_index21
        lda #0
        sta pw_index22
        jsr .calculate_pw_checksum
        sta pw_checksum

encode_font_offset
        ldx #0
encode_font_offset_loop
        lda pw_index0,x
        clc
        adc #PW_0
        sta pw_index0,x
        inx
        cpx #24
        bne encode_font_offset_loop
        stx pw_index
end
        savememory pw_index0-pw_index
        return

decode_password
        asm
        ldx #0
decode_font_offset
        lda pw_index0,x
        sec
        sbc #PW_0
        sta pw_index0,x
        inx
        cpx #24
        bne decode_font_offset

        jsr .calculate_pw_checksum
        cmp pw_checksum
        beq write_to_gamestate
        jsr encode_font_offset         ; reencode the font for display if the password fails
        lda #$E0
        sta pw_error
        rts

write_to_gamestate
        lda pw_tileset
        sta tileset
        lda pw_saveroom
        sta save_room_index
        lda pw_sword
        sta player_sword
        lda pw_shield
        sta player_shield
        lda pw_armor
        sta player_armor
        lda pw_charm
        sta player_charm
        lda pw_inventory_1
        sta m_item_bits_1
        lda pw_inventory_2
        sta m_item_bits_2
        lda pw_spells_1
        sta m_spell_bits_1
        lda pw_spells_2
        sta m_spell_bits_2
        lda pw_swords_1
        sta m_sword_bits_1
        lda pw_swords_2
        sta m_sword_bits_2
        lda pw_shields_1
        sta m_shield_bits_1
        lda pw_shields_2
        sta m_shield_bits_2
        lda pw_armor_1
        sta m_armor_bits_1
        lda pw_armor_2
        sta m_armor_bits_2
        lda pw_charms_1
        sta m_charm_bits_1
        lda pw_charms_2
        sta m_charm_bits_2
        lda pw_relics_1
        sta m_relic_bits_1
        lda pw_relics_2
        sta m_relic_bits_2
        lda pw_index20
        sta m_map_bits
        lda pw_index21
        sta m_key_bits
        lda #1
        sta pw_success
        rts
end

calculate_pw_checksum
        asm
        lda pw_tileset
        clc
        adc pw_saveroom
        adc pw_sword
        adc pw_shield
        adc pw_armor
        adc pw_charm
        adc pw_inventory_1
        adc pw_inventory_2
        adc pw_spells_1
        adc pw_spells_2
        adc pw_swords_1
        adc pw_swords_2
        adc pw_shields_1
        adc pw_shields_2
        adc pw_armor_1
        adc pw_armor_2
        adc pw_charms_1
        adc pw_charms_2
        adc pw_relics_1
        adc pw_relics_2
        adc pw_index20
        adc pw_index21
        adc pw_index22
        and #$1F
        rts
end

password_to_buffer
        asm
        ldx #23
pw_buffer_loop
        lda pw_index0,x
        sta pw_buffer,x
        dex
        bpl pw_buffer_loop
        rts
end

buffer_to_password
        asm
        ldx #23
buffer_pw_loop
        lda pw_buffer,x
        sta pw_index0,x
        dex
        bpl buffer_pw_loop
        rts
end

plot_gameover
        sCTRL{2} = 1 : CTRL = sCTRL
        if !menu_change then goto gameover_updater
        clearscreen
        gosub plot_menu_border
        menu_change = 0
        menu_selection = 0
        menu_columns = 1
        characterset menu_font
        alphachars '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz -!&[$#]{}(_*)'
        if in_save_room then plotchars 'Password' 0 64 2 singlewide : goto gameover_options
        plotchars 'GAME  OVER' 0 60 2 singlewide
        if demo_end then demo_end_text
gameover_options
        plotchars 'Continue' 0 60 9 singlewide
        plotchars 'Quit' 0 60 10 singlewide
        savescreen

gameover_updater
        restorescreen
        if demo_end then menu_selection = 1 : goto gameover_controls
        gosub plot_password
        gosub plot_menu_cursor

gameover_controls
        if !action_debounce && joy0fire0 && action_button = 0 then gameover_input
        if !action_debounce && joy0fire1 && action_button = 1 then gameover_input
        if demo_end then goto main
        if up_debounce >= MENU_TAP_FRAMES then gosub menu_selection_up
        if !up_debounce && joy0up then gosub menu_selection_up
        if down_debounce >= MENU_TAP_FRAMES then gosub menu_selection_down
        if !down_debounce && joy0down then gosub menu_selection_down
        if menu_selection > 1 then menu_selection = 0
        menu_cursor_X = 56
        if !menu_selection then menu_cursor_Y = 144 : goto main
        menu_cursor_Y = 160
        goto main

gameover_input
        if menu_selection then menu_selection = 0 : demo_end = 0 : menu_change = 1 : goto title_init bank10
        gosub decode_password
        in_save_room = 0
        menu = MENU_MAIN
        goto title_continue bank10

demo_end_text
        plotchars 'DEMO' 0 60 2 singlewide

        plotchars 'Thank you for playing!' 0 36 6 singlewide
        plotchars 'Please submit your feedback' 0 28 7 singlewide
        plotchars 'on the AtariAge Forums' 0 36 8 singlewide
        plotchars 'Push button to reset' 0 40 10 singlewide
        savescreen
        goto main

plot_password_menu
        ; turn on Kangaroo mode so "Password Error" prints over saved screen
        sCTRL{2} = 1 : CTRL = sCTRL
        menu = MENU_PASSWORD
        if !menu_change then goto password_menu_updater
        clearscreen
        gosub calc_inv_array
        gosub password_to_buffer
        gosub plot_menu_border
        menu_change = 0
        if pw_index >= 24 then menu_selection = 39 else menu_selection = 0
        menu_max = 40
        menu_columns = 13
        plotchars 'Enter Password' 0 52 2 singlewide
        plotchars '0 1 2 3 4 5 6 7 8 9 Erase' 0 28 9 singlewide
        plotchars 'A B C D E F G H I J K L M' 0 28 10 singlewide
        plotchars 'N O P Q R S T U V W X Y Z' 0 28 11 singlewide
        plotchars 'Confirm  Exit'             0 84 12 singlewide
        savescreen

password_menu_updater
        restorescreen
        gosub plot_password
        gosub plot_menu_cursor
        ; $E0 is a checksum error code set by the decode subroutine
        if !pw_error then goto password_menu_controls
        plotchars 'Password Error' 0 52 2 singlewide
        ; used to detect if cursor is moved after displaying error
        prev_menu_selection = menu_selection

password_menu_controls
        if !menu_debounce && joy0fire0 && action_button = 1 then pw_backspace
        if !menu_debounce && joy0fire1 && action_button = 0 then pw_backspace
        ; Pause is a quickie way of getting back to the action
        if !pause_debounce && switchpause then gosub buffer_to_password : goto close_menu
        if !action_debounce && joy0fire0 && action_button = 0 then encode_sel_to_pw
        if !action_debounce && joy0fire1 && action_button = 1 then encode_sel_to_pw
        gosub menu_dirs

password_menu_dirs_done
        ; set by decode password subroutine
        if pw_success = 1 then goto init_field bank10
        ; clear the Password Error message if the cursor was moved
        if menu_selection <> prev_menu_selection then pw_error = 0
        ; Handles the Erase option spanning multiple columns
        if menu_selection > 39 then menu_selection = 40
        if menu_selection = 11 then menu_selection = 10
        if menu_selection = 12 then menu_selection = 10
        if menu_selection < 13 then menu_cursor_X = 24 + (menu_selection * 8) : goto password_menu_cursor_Y
        if menu_selection < 26 then menu_cursor_X = 24 + ((menu_selection - 13) * 8) : goto password_menu_cursor_Y
        menu_cursor_X = 24 + ((menu_selection - 26) * 8)
password_menu_cursor_Y
        menu_cursor_Y = 144
        if menu_selection > 12 then menu_cursor_Y = 160
        if menu_selection > 25 then menu_cursor_Y = 176
        if menu_selection = 39 then menu_cursor_X = 80 : menu_cursor_Y = MENU_EQUIP_EXIT_Y
        if menu_selection = 40 then menu_cursor_X = 116 : menu_cursor_Y = MENU_EQUIP_EXIT_Y
        goto main

encode_sel_to_pw
        pw_error = 0
        action_debounce = 1
        temp1 = PW_0
        if menu_selection > 10 then temp1 = PW_A        ; "Erase" spans 3 colums, font offset needs to change
        if menu_selection = 10 then pw_backspace                        ; Erase
        if menu_selection = 39 then gosub decode_password : goto main   ; Confirm
        if menu_selection = 40 then menu_selection = 0 : menu_change = 1 : goto title_init bank10 ; Exit
        ; don't allow entering the 24th character since it corrupts pw_index
        if pw_index >= 24 then goto password_menu_dirs_done
        pw_index0[pw_index] = menu_selection + temp1
        pw_index = pw_index + 1
        goto password_menu_dirs_done

pw_backspace
        pw_error = 0
        menu_debounce = 1
        if pw_index >= 24 then pw_index = 24
        pw_index = pw_index - 1
        ; replace with dash character
        pw_index0[pw_index] = 82
        if pw_index > 23 then pw_index = 0
        goto main

plot_password
        plotchars pw_index0 0 52 3 6 singlewide
        plotchars pw_index6 0 84 3 6 singlewide
        plotchars pw_index12 0 52 4 6 singlewide
        plotchars pw_index18 0 84 4 6 singlewide
        return thisbank

plot_magic_menu
        if !menu_change then goto magic_menu_updater
        clearscreen
        menu_change = 0
        menu_selection = 0
        m_inv_scroll = 0
        menu_columns = 2
        menu_max = 9
        gosub plot_menu_border
        plotchars 'Spell Tomes' 0 60 1 singlewide
        plotchars 'MP Needed' 0 24 11 singlewide
        plotchars 'Exit' 0 128 12 singlewide
        gosub calc_inv_array

        savescreen
        menu_change = 0

magic_menu_updater
        restorescreen

magic_palettes
        ; reuses palette variables from equip menu
        temp1 = m_item_inv[0] + m_inv_scroll
        m_inv0_pal1 = pal_items1[temp1]
        m_inv0_pal2 = pal_items2[temp1]
        temp1 = m_item_inv[1] + m_inv_scroll
        m_sword_pal1 = pal_items1[temp1]
        m_sword_pal2 = pal_items2[temp1]
        temp1 = m_item_inv[2] + m_inv_scroll
        m_inv1_pal1 = pal_items1[temp1]
        m_inv1_pal2 = pal_items2[temp1]
        temp1 = m_item_inv[3] + m_inv_scroll
        m_shield_pal1 = pal_items1[temp1]
        m_shield_pal2 = pal_items2[temp1]
        temp1 = m_item_inv[4] + m_inv_scroll
        m_inv2_pal1 = pal_items1[temp1]
        m_inv2_pal2 = pal_items2[temp1]
        temp1 = m_item_inv[5] + m_inv_scroll
        m_armor_pal1 = pal_items1[temp1]
        m_armor_pal2 = pal_items2[temp1]
        temp1 = m_item_inv[6] + m_inv_scroll
        m_inv3_pal1 = pal_items1[temp1]
        m_inv3_pal2 = pal_items2[temp1]
        temp1 = m_item_inv[7] + m_inv_scroll
        m_charm_pal1 = pal_items1[temp1]
        m_charm_pal2 = pal_items2[temp1]

        ; plot the inventory
        m_spriteX = 16
        m_spriteY = 48
        m_textX = 24
        m_textY = 3
        m_palette = 4
        pointer = m_spell_inv_lo
        pointer_hi = m_spell_inv_hi
        menu_items = 7
        ; reuse obj_index here because index is used by menu coloring code and breaks item list
        for obj_index = m_inv_scroll to menu_items
        item_name = pointer[[obj_index]]
        if !item_name then magic_left
plot_magic_names
        plotsprite menu_potion0 m_palette m_spriteX m_spriteY
        plotmap magic_names m_palette m_textX m_textY 11 1 0 item_name 11

magic_left
        if m_spriteX = 16 then m_palette = 0 : m_spriteX = 84 : m_textX = 92 : goto magic_right
        m_palette = 4
        m_spriteX = 16 : m_textX = 24
        m_spriteY = m_spriteY + 32
        m_textY = m_textY + 2
magic_right
        next
        
        ; bypass description if on Exit
        if menu_selection >= 9 then magic_menu_cursor
        temp1 = pointer[[menu_selection]]
        if menu = MENU_RELICS then relic_descriptions
magic_descriptions
        ; magic all has unique descriptions
        m_desc = temp1
        plotmap magic_desc 0 28 12 19 1 0 m_desc 19
        
magic_menu_cursor
        gosub update_magic_cursor

magic_menu_controls

        if !menu_debounce && joy0fire0 && action_button = 1 then open_main_menu
        if !menu_debounce && joy0fire1 && action_button = 0 then open_main_menu
        ; Pause is a quickie way of getting back to the action
        if !pause_debounce && switchpause then close_menu
        if !action_debounce && joy0fire0 then open_main_menu
        if !action_debounce && joy0fire1 then open_main_menu
        gosub menu_dirs
        goto main

update_magic_cursor
        temp4 = 48
magic_cursor_Y
        if menu_selection = 0 || menu_selection = 1 then menu_cursor_Y = temp4 : goto magic_cursor_X
        if menu_selection = 2 || menu_selection = 3 then menu_cursor_Y = temp4 + 32 : goto magic_cursor_X
        if menu_selection = 4 || menu_selection = 5 then menu_cursor_Y = temp4 + 64 : goto magic_cursor_X
        if menu_selection = 6 || menu_selection = 7 then menu_cursor_Y = temp4 + 96 : goto magic_cursor_X
magic_cursor_exit_y
        menu_cursor_Y = MENU_EQUIP_EXIT_Y

magic_cursor_X
        ; kludge - makes up from the exit option go into right column instead of left
        if menu_selection = 8 then menu_selection = 9
        if menu_selection = 9 then menu_cursor_X = MENU_EQUIP_EXIT_X : goto magic_cursor_set
        if menu_selection = 1 || menu_selection = 3 then menu_cursor_X = 80 : goto magic_cursor_set
        if menu_selection = 5 || menu_selection = 7 then menu_cursor_X = 80 : goto magic_cursor_set
        menu_cursor_X = 12

magic_cursor_set
; plot menu cursor used for return
        goto plot_menu_cursor

        alphadata magic_names menu_font singlewide
        '           '
        'Fireball   '
        'Ice Flakes '
        'Wind Slash '
        'Thunderbolt'
        'Spell 5    '
        'Spell 6    '
        'Spell 7    '
        'Spell 8    '
end

        alphadata magic_desc menu_font singlewide
        '                   '
        'Throw a Fireball   '
        'Spread Ice Attack  '
        'Diagonal Wind Slash'
        'Cast Down Lightning'
        'Learn Monster Names'
        'Traverse Water     '
        'Ascend Waterfalls  '
        'Scale Ledges       '
end

copy_menu_map
        ; only reveal the map once, so that secret rooms persist when opening the menu as long as tileset doesn't change
        if menu_map_revealed{0} then copy_castle_map
        if tileset = T_FOREST && m_map_bits{0} then memcpy menu_map_room forest_menu_map 98 : menu_map_revealed{0} = 1 : entered_save_room = %11111111
copy_castle_map
        if menu_map_revealed{1} then copy_river_map
        if tileset = T_CASTLE && m_map_bits{1} then memcpy menu_map_room castle_menu_map 98 : menu_map_revealed{1} = 1 : entered_save_room = %11111111
copy_river_map
        if menu_map_revealed{2} then copy_menu_map_done
        if tileset = T_RIVER  && m_map_bits{2} then memcpy menu_map_room river_menu_map 98  : menu_map_revealed{2} = 1 : entered_save_room = %11111111
copy_menu_map_done
        return

        data forest_menu_map
        ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_D  , ROOMR_D  , ROOML_N  , ROOMR_R  , ROOML_DL , ROOMR_D  , ROOML_B  , ROOMR_B
        ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_D  , ROOMR_DR , ROOML_UL , ROOMR_UR , ROOML_DL , ROOMR_DR , ROOML_UDL, ROOMR_UD , ROOML_B  , ROOMR_B
        ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_UD , ROOMR_UD , ROOML_D  , ROOMR_D  , ROOML_UD , ROOMR_UDR, ROOML_UL , ROOMR_U  , ROOML_B  , ROOMR_B
        ROOML_B  , ROOMR_B  , ROOML_D  , ROOMR_D  , ROOML_UD , ROOMR_UDR, ROOML_UL , ROOMR_UR , ROOML_UDL, ROOMR_UD , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B
        ROOML_B  , ROOMR_B  , ROOML_UD , ROOMR_UDR, ROOML_UDL, ROOMR_UD , ROOML_B  , ROOMR_B  , ROOML_U  , ROOMR_U  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B
        ROOML_B  , ROOMR_B  , ROOML_UD , ROOMR_UDR, ROOML_UDL, ROOMR_UD , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B
        ROOML_B  , ROOMR_B  , ROOML_U  , ROOMR_UR , ROOML_UL , ROOMR_U  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B 
end

        data castle_menu_map
        ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B
        ROOML_D  , ROOMR_DR , ROOML_L  , ROOMR_N  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B
        ROOML_UD , ROOMR_UD , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_D  , ROOMR_D  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B
        ROOML_UD , ROOMR_UDR, ROOML_DL , ROOMR_DR , ROOML_DL , ROOMR_DR , ROOML_L  , ROOMR_R  , ROOML_UDL, ROOMR_UD , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B
        ROOML_UD , ROOMR_UD , ROOML_B  , ROOMR_B  , ROOML_UD , ROOMR_UD , ROOML_B  , ROOMR_B  , ROOML_UD , ROOMR_UDR, ROOML_L  , ROOMR_R  , ROOML_DL , ROOMR_D
        ROOML_UD , ROOMR_UD , ROOML_B  , ROOMR_B  , ROOML_UD , ROOMR_UD , ROOML_B  , ROOMR_B  , ROOML_UD , ROOMR_UD , ROOML_B  , ROOMR_B  , ROOML_UD , ROOMR_UD
        ROOML_U  , ROOMR_UR , ROOML_L  , ROOMR_R  , ROOML_UL , ROOMR_UR , ROOML_L  , ROOMR_R  , ROOML_UL , ROOMR_U  , ROOML_B  , ROOMR_B  , ROOML_UD , ROOMR_UD
end

        data river_menu_map
        ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_D  , ROOMR_D  , ROOML_N  , ROOMR_R  , ROOML_DL , ROOMR_D  , ROOML_B  , ROOMR_B
        ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_D  , ROOMR_DR , ROOML_UL , ROOMR_UR , ROOML_DL , ROOMR_DR , ROOML_UDL, ROOMR_UD , ROOML_B  , ROOMR_B
        ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_UD , ROOMR_UD , ROOML_D  , ROOMR_D  , ROOML_UD , ROOMR_UDR, ROOML_UL , ROOMR_U  , ROOML_B  , ROOMR_B
        ROOML_B  , ROOMR_B  , ROOML_D  , ROOMR_D  , ROOML_UD , ROOMR_UDR, ROOML_UL , ROOMR_UR , ROOML_UDL, ROOMR_UD , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B
        ROOML_B  , ROOMR_B  , ROOML_UD , ROOMR_UDR, ROOML_UDL, ROOMR_UD , ROOML_B  , ROOMR_B  , ROOML_U  , ROOMR_U  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B
        ROOML_B  , ROOMR_B  , ROOML_UD , ROOMR_UDR, ROOML_UDL, ROOMR_UD , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B
        ROOML_B  , ROOMR_B  , ROOML_U  , ROOMR_UR , ROOML_UL , ROOMR_U  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B  , ROOML_B  , ROOMR_B 
end