;==============================================================================
; BANK 6
;------------------------------------------------------------------------------
; River tileset and data
;==============================================================================
        bank 6
        incgraphic gfx/tiles/forest_trees.png 160A 1 0 2 3 4
        incgraphic gfx/tiles/forest_rocks.png 160A 1 0 2 3 5
        incgraphic gfx/tiles/forest_water.png 160A 1 2 0 3 6
        incgraphic gfx/tiles/forest_ledges.png 160A 1 0 2 3 5
        incgraphic gfx/forest/hud.png 160A 0 3 1 2
        incgraphic gfx/forest/hud2.png 160A 0 3 1 2
        incgraphic gfx/tiles/river_deep.png 160A 1 0 2 4 5
        incgraphic gfx/tiles/river_waterf.png 160A 0 2 3 1 7
        incgraphic gfx/tiles/river_veg.png 160A 1 2 3 1 5
        incgraphic gfx/tiles/river_walls.png 160A 1 1 3 2 5
        incgraphic gfx/sprites/rghost0.png 160A 0 1 2 3
        incgraphic gfx/sprites/rghost1.png 160A 0 1 2 3
        incgraphic gfx/sprites/octopus0.png 160A
        incgraphic gfx/sprites/octopus1.png 160A
        incgraphic gfx/sprites/octopus2.png 160A
        incgraphic gfx/sprites/octopus3.png 160A
        incgraphic gfx/sprites/octopus4.png 160A
        incgraphic gfx/sprites/octopus5.png 160A
        incgraphic gfx/sprites/octopus6.png 160A
        incgraphic gfx/sprites/octoink.png 160A
        incgraphic gfx/sprites/nix0.png 160A
        incgraphic gfx/sprites/nix1.png 160A
        incgraphic gfx/sprites/nix2.png 160A 0 3 2 1
        incgraphic gfx/sprites/nix3.png 160A 0 3 2 1
        incgraphic gfx/sprites/nix4.png 160A
        incgraphic gfx/sprites/nix5.png 160A

        incmapfile tiled/river_room_0.tmx
        incmapfile tiled/river_room_1.tmx
        incmapfile tiled/river_room_2.tmx
        incmapfile tiled/river_room_3.tmx
        incmapfile tiled/river_room_4.tmx
        incmapfile tiled/river_room_5.tmx
        incmapfile tiled/river_room_6.tmx
        incmapfile tiled/river_room_7.tmx
        incmapfile tiled/river_room_8.tmx
        incmapfile tiled/river_room_9.tmx
        incmapfile tiled/river_room_10.tmx
        incmapfile tiled/river_room_11.tmx
        incmapfile tiled/river_room_12.tmx
        incmapfile tiled/river_room_13.tmx
        incmapfile tiled/river_room_14.tmx
        incmapfile tiled/river_room_15.tmx
        incmapfile tiled/river_room_16.tmx
        incmapfile tiled/river_room_17.tmx
        incmapfile tiled/river_room_18.tmx
        incmapfile tiled/river_room_19.tmx
        incmapfile tiled/river_room_20.tmx
        incmapfile tiled/river_room_21.tmx

        const plot_river_room_0_lo = #<.plot_river_room_0
        const plot_river_room_0_hi = #>.plot_river_room_0
        const plot_river_room_1_lo = #<.plot_river_room_1
        const plot_river_room_1_hi = #>.plot_river_room_1
        const plot_river_room_2_lo = #<.plot_river_room_2
        const plot_river_room_2_hi = #>.plot_river_room_2
        const plot_river_room_3_lo = #<.plot_river_room_3
        const plot_river_room_3_hi = #>.plot_river_room_3
        const plot_river_room_4_lo = #<.plot_river_room_4
        const plot_river_room_4_hi = #>.plot_river_room_4
        const plot_river_room_5_lo = #<.plot_river_room_5
        const plot_river_room_5_hi = #>.plot_river_room_5
        const plot_river_room_6_lo = #<.plot_river_room_6
        const plot_river_room_6_hi = #>.plot_river_room_6
        const plot_river_room_7_lo = #<.plot_river_room_7
        const plot_river_room_7_hi = #>.plot_river_room_7
        const plot_river_room_8_lo = #<.plot_river_room_8
        const plot_river_room_8_hi = #>.plot_river_room_8
        const plot_river_room_9_lo = #<.plot_river_room_9
        const plot_river_room_9_hi = #>.plot_river_room_9
        const plot_river_room_10_lo = #<.plot_river_room_10
        const plot_river_room_10_hi = #>.plot_river_room_10
        const plot_river_room_11_lo = #<.plot_river_room_11
        const plot_river_room_11_hi = #>.plot_river_room_11
        const plot_river_room_12_lo = #<.plot_river_room_12
        const plot_river_room_12_hi = #>.plot_river_room_12
        const plot_river_room_13_lo = #<.plot_river_room_13
        const plot_river_room_13_hi = #>.plot_river_room_13
        const plot_river_room_14_lo = #<.plot_river_room_14
        const plot_river_room_14_hi = #>.plot_river_room_14
        const plot_river_room_15_lo = #<.plot_river_room_15
        const plot_river_room_15_hi = #>.plot_river_room_15
        const plot_river_room_16_lo = #<.plot_river_room_16
        const plot_river_room_16_hi = #>.plot_river_room_16
        const plot_river_room_17_lo = #<.plot_river_room_17
        const plot_river_room_17_hi = #>.plot_river_room_17
        const plot_river_room_18_lo = #<.plot_river_room_18
        const plot_river_room_18_hi = #>.plot_river_room_18
        const plot_river_room_19_lo = #<.plot_river_room_19
        const plot_river_room_19_hi = #>.plot_river_room_19
        const plot_river_room_20_lo = #<.plot_river_room_20
        const plot_river_room_20_hi = #>.plot_river_room_20
        const plot_river_room_21_lo = #<.plot_river_room_21
        const plot_river_room_21_hi = #>.plot_river_room_21

        data river_map_lo
        plot_river_room_0_lo, plot_river_room_1_lo, plot_river_room_2_lo, plot_river_room_3_lo, plot_river_room_4_lo,
        plot_river_room_5_lo, plot_river_room_6_lo, plot_river_room_7_lo, plot_river_room_8_lo, plot_river_room_9_lo,
        plot_river_room_10_lo, plot_river_room_11_lo, plot_river_room_12_lo, plot_river_room_13_lo, plot_river_room_14_lo,
        plot_river_room_15_lo, plot_river_room_16_lo, plot_river_room_17_lo, plot_river_room_18_lo, plot_river_room_19_lo,
        plot_river_room_20_lo, plot_river_room_21_lo
end

        data river_map_hi
        plot_river_room_0_hi, plot_river_room_1_hi, plot_river_room_2_hi, plot_river_room_3_hi, plot_river_room_4_hi,
        plot_river_room_5_hi, plot_river_room_6_hi, plot_river_room_7_hi, plot_river_room_8_hi, plot_river_room_9_hi,
        plot_river_room_10_hi, plot_river_room_11_hi, plot_river_room_12_hi, plot_river_room_13_hi, plot_river_room_14_hi,
        plot_river_room_15_hi, plot_river_room_16_hi, plot_river_room_17_hi, plot_river_room_18_hi, plot_river_room_19_hi,
        plot_river_room_20_hi, plot_river_room_21_hi
end

        data river_obj_lo
        river_room_0_obj_lo, river_room_1_obj_lo, river_room_2_obj_lo, river_room_3_obj_lo, river_room_4_obj_lo,
        river_room_5_obj_lo, river_room_6_obj_lo, river_room_7_obj_lo, river_room_8_obj_lo, river_room_9_obj_lo,
        river_room_10_obj_lo, river_room_11_obj_lo, river_room_12_obj_lo, river_room_13_obj_lo, river_room_14_obj_lo,
        river_room_15_obj_lo, river_room_16_obj_lo, river_room_17_obj_lo, river_room_18_obj_lo, river_room_19_obj_lo,
        river_room_20_obj_lo, river_room_21_obj_lo
end

        data river_obj_hi
        river_room_0_obj_hi, river_room_1_obj_hi, river_room_2_obj_hi, river_room_3_obj_hi, river_room_4_obj_hi,
        river_room_5_obj_hi, river_room_6_obj_hi, river_room_7_obj_hi, river_room_8_obj_hi, river_room_9_obj_hi,
        river_room_10_obj_hi, river_room_11_obj_hi, river_room_12_obj_hi, river_room_13_obj_hi, river_room_14_obj_hi,
        river_room_15_obj_hi, river_room_16_obj_hi, river_room_17_obj_hi, river_room_18_obj_hi, river_room_19_obj_hi,
        river_room_20_obj_hi, river_room_21_obj_hi
end

load_river
        if !first_load then river_set_room
        first_load = 0

        room_index    = F_RIVER_START_I ; 21
        menu_map_Xpos = M_RIVER_START_X ; 54
        menu_map_Ypos = M_RIVER_START_Y ; 112
        player_Xpos   = F_RIVER_START_X ; 50
        player_Ypos   = F_RIVER_START_Y ; 80
        player_facing = F_RIVER_START_D ; DIR_UP
        goto river_set_room

river_set_room
        characterset forest_trees
        asm
          lda $0
          sta no_flash
          sta alt_palette
          sta pal_animation
          ldx room_index
          lda river_rooms,x
          tax
          lda river_obj_lo,x
          sta pointer
          lda river_obj_hi,x
          sta pointer_hi
          lda room_index
          asl
          sta menu_map_index
          clc
          adc #1
          sta menu_map_index_2
          cpx #12
          bcc .river_room_bank_6
end
        gosub river_room_bank_7 bank7
        return thisbank

river_room_bank_6
        asm
          lda river_map_lo,x
          sta temp1               ; temp1 + 2 used for indirect jmp
          lda river_map_hi,x
          sta temp2
          jmp (temp1)
end

river_pals
        P4C1 = flash_color : P4C2 = getfade(PAL_F_DKGRN, black) : P4C3 = getfade (PAL_F_LTGRN)     ; greens used by trees and slimes
        if alt_palette then river_pals_cliffs
        P5C1 = flash_color : P5C2 = getfade(PAL_F_WATER, black) : P5C3 = getfade(PAL_F_DKGRN, black)     ; water vegetation
river_pals_rocks
        P6C1 = flash_color : P6C2 = getfade(PAL_F_WATER, black) : P6C3 = getfade(PAL_F_LTWTR)     ; blue and gray used by water
        P7C1 = getfade(PAL_WFALL1) : P7C2 = getfade(PAL_WFALL2)  : P7C3 = getfade(PAL_WFALL3)      ; blues, waterfalls
        ; palette registers are read-only, need soft versions of their data
        sP7C1 = getfade(PAL_WFALL1) : sP7C2 = getfade(PAL_WFALL2) : sP7C3 = getfade(PAL_WFALL3)

river_shared_pals
        bg_color = PAL_F_GRND   ; ground color shared with forest
        incbasic shared_pals.78b
        goto palette_done

river_pals_cliffs
        P5C1 = flash_color : P5C2 = getfade(PAL_F_DKBRN,black) : P5C3 = getfade(PAL_F_LTBRN)
        goto river_pals_rocks


plot_river_room_0
        menu_map_room[menu_map_index] = ROOML_UD
        menu_map_room[menu_map_index_2] = ROOMR_UD
        memcpy current_map river_room_0 280
        plotmapfile tiled/river_room_0.tmx river_room_0 0 0 20 14
        zone1_objects  = 2
        zone2_objects  = 2
        zone14_objects = 1
        return thisbank

        data river_room_0_obj
        TYPE_TORCH, $20, $50, TYPE_TORCH, $38, $50, TYPE_TORCH, $60, $50, TYPE_TORCH, $78, $50
        TYPE_BESTIARY, $48, $90,
        $00
end

plot_river_room_1
        menu_map_room[menu_map_index] = ROOML_U
        menu_map_room[menu_map_index_2] = ROOMR_UR
        memcpy current_map river_room_1 280
        plotmapfile tiled/river_room_1.tmx river_room_1 0 0 20 14
        zone1_objects  = 2
        zone2_objects  = 2
        zone14_objects = 1
        return thisbank

        data river_room_1_obj
        TYPE_RGHOST, $48, $80, TYPE_RGHOST, $56, $80, TYPE_RGHOST, $60, $70,
        TYPE_TORCH, $20, $50, TYPE_TORCH, $80, $50,
        $00
end

plot_river_room_2
        menu_map_room[menu_map_index] = ROOML_UDL
        menu_map_room[menu_map_index_2] = ROOMR_UD
        memcpy current_map river_room_2 280
        plotmapfile tiled/river_room_2.tmx river_room_2 0 0 20 14
        zone1_objects  = 4
        zone2_objects  = 6
        zone14_objects = 4
        return thisbank

        data river_room_2_obj
        TYPE_MERMAN, $38, $60, TYPE_TORCH, $88, $10,
        TYPE_NIXTAIL, $0C, $50,
        $00
end

plot_river_room_3
        menu_map_room[menu_map_index] = ROOML_UD
        menu_map_room[menu_map_index_2] = ROOMR_UDR
        memcpy current_map river_room_3 280
        plotmapfile tiled/river_room_3.tmx river_room_3 0 0 20 14
        zone1_objects  = 4
        zone2_objects  = 4
        zone14_objects = 3
        return thisbank

        data river_room_3_obj
        TYPE_OCTOPUS, $48, $60, TYPE_OCTOPUS, $70, $70,
        TYPE_TORCH, $80, $20, TYPE_TORCH, $30, $50, TYPE_TORCH, $80, $B0,
        $00
end

plot_river_room_4
        menu_map_room[menu_map_index] = ROOML_UL
        menu_map_room[menu_map_index_2] = ROOMR_UR
        memcpy current_map river_room_4 280
        plotmapfile tiled/river_room_4.tmx river_room_4 0 0 20 14
        zone1_objects  = 4
        zone2_objects  = 4
        zone14_objects = 5
        return thisbank

        data river_room_4_obj
        TYPE_NIX, $68, $70, TYPE_NIX, $30, $80,
        TYPE_TORCH, $40, $20, TYPE_TORCH, $58, $20,
        $00
end

        dmahole 0
        data river_rooms
        00, 00, 00, 13, 17, 16, 00
        00, 00, 07,  8,  9, 15, 00
        00, 00, 06, 05, 10, 14, 00
        00, 00, 03, 04, 11, 00, 00
        00, 01, 02, 00, 12, 00, 00
        00, 20, 18, 00, 00, 00, 00
        00, 21, 19, 00, 00, 00, 00
end

plot_river_room_5
        menu_map_room[menu_map_index] = ROOML_D
        menu_map_room[menu_map_index_2] = ROOMR_D
        memcpy current_map river_room_5 280
        plotmapfile tiled/river_room_5.tmx river_room_5 0 0 20 14
        zone1_objects  = 4
        zone2_objects  = 4
        zone14_objects = 5
        return thisbank

        data river_room_5_obj
        $00
end

plot_river_room_6
        menu_map_room[menu_map_index] = ROOML_UD
        menu_map_room[menu_map_index_2] = ROOMR_UD
        memcpy current_map river_room_6 280
        plotmapfile tiled/river_room_6.tmx river_room_6 0 0 20 14
        zone1_objects  = 4
        zone2_objects  = 4
        zone14_objects = 5
        return thisbank

        data river_room_6_obj
        $00
end

plot_river_room_7
        menu_map_room[menu_map_index] = ROOML_D
        menu_map_room[menu_map_index_2] = ROOMR_DR
        memcpy current_map river_room_7 280
        plotmapfile tiled/river_room_7.tmx river_room_7 0 0 20 14
        zone1_objects  = 4
        zone2_objects  = 4
        zone14_objects = 5
        return thisbank

        data river_room_7_obj
        $00
end

plot_river_room_8
        menu_map_room[menu_map_index] = ROOML_UL
        menu_map_room[menu_map_index_2] = ROOMR_UR
        memcpy current_map river_room_8 280
        plotmapfile tiled/river_room_8.tmx river_room_8 0 0 20 14
        zone1_objects  = 4
        zone2_objects  = 4
        zone14_objects = 5
        return thisbank

        data river_room_8_obj
        $00
end

plot_river_room_9
        menu_map_room[menu_map_index] = ROOML_DL
        menu_map_room[menu_map_index_2] = ROOMR_DR
        memcpy current_map river_room_9 280
        plotmapfile tiled/river_room_9.tmx river_room_9 0 0 20 14
        zone1_objects  = 4
        zone2_objects  = 4
        zone14_objects = 5
        return thisbank

        data river_room_9_obj
        $00
end

plot_river_room_10
        menu_map_room[menu_map_index] = ROOML_UD
        menu_map_room[menu_map_index_2] = ROOMR_UDR
        memcpy current_map river_room_10 280
        plotmapfile tiled/river_room_10.tmx river_room_10 0 0 20 14
        zone1_objects  = 4
        zone2_objects  = 7
        zone14_objects = 5
        return thisbank

        data river_room_10_obj
        $00
end

plot_river_room_11
        menu_map_room[menu_map_index] = ROOML_UDL
        menu_map_room[menu_map_index_2] = ROOMR_UD
        memcpy current_map river_room_11 280
        plotmapfile tiled/river_room_11.tmx river_room_11 0 0 20 14
        zone1_objects  = 4
        zone2_objects  = 4
        zone14_objects = 5
        return thisbank

        data river_room_11_obj
        $00
end

        data river_room_12_obj
        $00
end

        data river_room_13_obj
        $00
end

        data river_room_14_obj
        $00
end

        data river_room_15_obj
        $00
end

        data river_room_16_obj
        $00
end

        data river_room_17_obj
        $00
end

test_walkable_river
; water is tested differently than other properties, it tests the tile directly under the object
; this helps eliminate graphical issues when approaching a non-water tile in water
test_water_river
        gosub get_object_pos
        temp1 = peekchar (current_map, peekX, peekY, 20, 14)
        asm
          ldx #0
twar_loop lda river_water_tiles,x
          cmp temp1
          bne twar_next
          lda flags
          ora #%00000010
          sta flags
          jmp twar_done
twar_next inx
          cpx #river_water_tiles_length
          bne twar_loop
          lda flags
          and #%11111101
          sta flags
twar_done
          ldx #0
twr_loop  lda river_walkable_tiles,x
          cmp move_tile_1
          bne twrtile2
          pha
          lda #1
          sta walkable_1
          pla
twrtile2  cmp move_tile_2
          bne twr_next
          lda #1
          sta walkable_2
          ; optimization: bypass the rest of the array if both tiles walkable
          ;   further optimization possible by sorting arrays by tile frequency
          lda walkable_1
          bne twr_walkable
twr_next  inx
          cpx #river_walkable_tiles_length
          bne twr_loop
          lda walkable_1
          beq twr_done
          lda walkable_2
          beq twr_done
twr_walkable
          sta walkable
          jmp .walkable_return
twr_done
        ; test if the Nix's Locket is enabled
          lda m_relic_bits_2
          lsr
          bcc twwr_done
          ; TODO: River monsters need a bit to determine if they should run this test 
          ldx #0
twwr_loop  lda river_water_tiles,x
          cmp move_tile_1
          bne twwrtile2
          pha
          lda #1
          sta walkable_1
          pla
twwrtile2  cmp move_tile_2
          bne twwr_next
          lda #1
          sta walkable_2
          ; optimization: bypass the rest of the array if both tiles walkable
          ;   further optimization possible by sorting arrays by tile frequency
          lda walkable_1
          bne twwr_walkable
twwr_next  inx
          cpx #river_water_tiles_length
          bne twwr_loop
          lda walkable_1
          beq twwr_done
          lda walkable_2
          beq twwr_done
twwr_walkable
          sta walkable
          jmp .walkable_return
twwr_done

tfr_flags
          lda flags
          and #%00010000
          bne tfr_done
test_floatable_river
          ldx #0
tfr_loop  lda river_floatable_tiles,x
          cmp move_tile_1
          bne tfrtile2
          pha
          lda #1
          sta floatable_1
          pla
tfrtile2  cmp move_tile_2
          bne tfr_next
          lda #1
          sta floatable_2
          lda floatable_1
          bne tfr_floatable
tfr_next  inx
          cpx #river_floatable_tiles_length
          bne tfr_loop
          lda floatable_1
          beq tfr_done
          lda floatable_2
          beq tfr_done
tfr_floatable
          sta floatable
tfr_done  jmp .walkable_return
end

        data river_walkable_tiles
        $00, $02, $04, $0E, $12, $14, $16, $18, $1A, $1C, $1E, $20
end

        data river_water_tiles
        $38, $3A, $3C, $3E, $40, $42, $44, $46, $48, $4A, $B4, $B6, $B8, $BA
end

        data river_floatable_tiles
        $2A, $24, $26, $22, $2C, $2E, $30, $32, $34, $36, $38, $3A, $3C, $40, $42, $44, $46, $48
end

torch_tile_block_river
        ; block with a floatable tile so projectiles can hit torch
        pokechar current_map peekX peekY 20 14 river_floatable_tiles
        return

torch_tile_unblock_river
        ; the poked tile doesn't affect visuals since those are plotted from ROM
        pokechar current_map peekX peekY 20 14 river_walkable_tiles
        return

        data river_room_18_obj
        $00
end

        data river_room_19_obj
        $00
end

        data river_room_20_obj
        $00
end

        data river_room_21_obj
        $00
end

;==============================================================================
; SUBROUTINE: NIX AI
;------------------------------------------------------------------------------
; Nix (Formerly Merman) is an underwater enemy which starts invisible
; When the player gets within their territory, they switch to a shadow
; The shadow approaches the player, then emerges from the water to attack!
; After attacking, a tail splash frame is shown and they move to a random
; coordinate in water, then go invisible again, to start the process over
;==============================================================================
nix_ai
        if !flags{4} then nix_init
        if !flags{1} then nix_repos
        if flags{3} then nix_tail_anim
        if flags{6} then nix_attack
        if flags{7} then nix_stalk

nix_range
        ; set upper left corner of Nix range, zero if underflow
        temp1 = Xposition - NIX_OFFSET_X
        if temp1 > Xposition then temp1 = 0
        temp2 = Yposition - NIX_OFFSET_Y
        if temp2 > Yposition then temp2 = 0
        if boxcollision(player_Xpos, player_Ypos, PLAYER_WIDTH, PLAYER_HEIGHT, temp1, temp2, NIX_RANGE_X, NIX_RANGE_Y) then goto nix_shadow
        ; just return here if player not in range
        return thisbank

nix_shadow
        frame = F_NIX_SHADOW
        flags{7} = 1

nix_stalk
        ; due to the Nix attack animation, always emerge above or on the player
        temp2 = player_Ypos - 8
        if boxcollision(player_Xpos, temp2, PLAYER_WIDTH, PLAYER_HEIGHT, Xposition, Yposition, NIX_WIDTH, NIX_HEIGHT) then goto nix_emerge
        ; followplayer handles the return for this frame
        goto followplayer

nix_emerge
        flags{0} = 0
        ; start a timer for the attack animation
        timer = NIX_ATK_TIME
        frame = F_NIX_EMERGE
        flags{6} = 1
        Xvelocity_hi = 0
        Xvelocity_lo = 0
        Yvelocity_hi = 0
        Yvelocity_lo = 0

nix_attack
        timer = timer - 1
        if timer then return thisbank
        ; some trickery to limit number of flags here
        ; if 7 is set, first phase of attack
        ; if 7 unset, then countdown is to submerge
        if !flags{7} then nix_submerge
        frame = F_NIX_ATTACK
        flags{7} = 0
        timer = NIX_ATK2_TIME
        return thisbank

nix_submerge
        timer = NIX_TAIL_TIME
        flags{3} = 1
        object_pal[index] = 3
nix_tail_anim
        if animation_frame then frame = F_NIX_TAIL2 : goto nix_tail_timer
        frame = F_NIX_TAIL
nix_tail_timer
        timer = timer - 1
        if timer then return thisbank

nix_repos
        ; Nix is made invisible and invulnerable
        ; Water flag check will ensure it repositions until on a water tile
        frame = F_NIX_BLANK
        flags{0} = 1
        flags{3} = 0
        flags{6} = 0
reposX
        Xposition = rand
        if Xposition > 160 then reposX
reposY
        Yposition = rand
        if Yposition > 224 then reposY
        return thisbank

nix_init
        ; start in water invulnerable and invisible
        ; floating flag is repurposed to tell AI Nix has been initiated
        flags = %00010011
        frame = F_NIX_BLANK
        goto nix_range


obj_nix_stats
        object_hp[obj_index] = WOLF_HP
        object_vel_cap_hi[obj_index] = WOLF_VEL_CAP_HI
        object_vel_cap_lo[obj_index] = WOLF_VEL_CAP_LO
        object_damage[obj_index] = WOLF_DAMAGE
        object_def[obj_index] = WOLF_DEF
        object_mdef[obj_index] = WOLF_MDEF
        object_friction_hi[obj_index] = WOLF_FRICTION_HI
        object_friction_lo[obj_index] = WOLF_FRICTION_LO
        object_speed_hi[obj_index] = WOLF_SPEED_HI
        object_speed_lo[obj_index] = WOLF_SPEED_LO
        object_flags[obj_index] = 0
        asm
          ldx obj_index
          lda #<.plot_nix
          sta object_spr_ptr_lo,x
          lda #>.plot_nix
          sta object_spr_ptr_hi,x
end
        goto obj_next_stats


plot_nix
        plotsprite nix0 4 Xposition Yposition frame
        goto plot_next

;==============================================================================
; RIVER BEAST
;------------------------------------------------------------------------------
; It's an octorock from Zelda but instead of walking, it dives under water
;==============================================================================
octopus_ai
        if debug_time then BACKGRND = $78
        if flags{6} then goto octo_shoot_2
        if flags{0} then goto octo_swim
        if timer then goto octo_pop_2
        ; hacky land kill needs water flag on before any movement
        flags{1} = 1
        ; set up a timer to make the octopus appear out of water before diving
octo_pop
        timer = OCTOPUS_POP_TIMER
        flags{0} = 0
octo_pop_2
        timer = timer - 1
        if !timer then goto octo_submerge
        frame = F_OCTO_POP
        object_pal[index] = OCTO_PAL
;        if animation_frame then frame = F_OCTO_POP_2
        ; octo_test_shoot handles return for this frame
        goto octo_test_shoot

octo_submerge
        timer = OCTOPUS_SWIM_TIMER
        flags{0} = 1
        object_pal[index] = OCTO_SHADOW_PAL
        frame = F_OCTO_SHADOW

octo_swim
        ; this is a horrible stopgap: if the octopus gets on land, it kills itself
        if !flags{1} then object_type[index] = 0
        timer = timer - 1
        if !timer then goto octo_pop
;        gosub octo_test_shoot
        ; followplayer used for return this frame
        object_parent[index] = 0
        goto followplayer


octo_test_shoot
        if object_parent[index] then octo_done
octo_test_y
        ; vertical range check
        if boxcollision(player_Xpos, player_Ypos, PLAYER_WIDTH, PLAYER_HEIGHT, Xposition, 0, 12, 224) then goto octo_shoot_y

octo_test_x
        ; horizontal range check
        if boxcollision(player_Xpos, player_Ypos, PLAYER_WIDTH, PLAYER_HEIGHT, 0, Yposition, 160, 16) then goto octo_shoot_x

octo_test_return
        ; horiz and vert tests both failed
        goto octo_done

octo_shoot_y
        object_facing[index] = DIR_UP
        if Yposition < player_Ypos then object_facing[index] = DIR_DOWN
        goto octo_shoot

octo_shoot_x
        object_facing[index] = DIR_LEFT
        if Xposition < player_Xpos then object_facing[index] = DIR_RIGHT

octo_shoot
        gosub find_new_object
        if no_empty_slot then goto octo_done
        object_parent[spawn_index] = index
        flags{6} = 1
        flags{0} = 0
        object_pal[index] = OCTO_PAL
        frame_index = object_facing[index]
        frame = octo_shoot_frames[frame_index]
        asm
          lda #0
          sta Xvelocity_hi
          sta Xvelocity_lo
          sta Yvelocity_hi
          sta Yvelocity_lo
end
        timer = OCTOPUS_SHOOT_FRAMES

octo_shoot_2
        timer = timer - 1
        if timer then goto octo_done

load_octoink
        asm
          ldx spawn_index
          ldy index
          lda #TYPE_OCTOINK
          sta object_type,x
          lda #OCTOINK_SPEED_HI
          sta object_vel_cap_hi,x
          sta object_speed_hi,x
          lda #OCTOINK_SPEED_LO
          sta object_vel_cap_lo,x
          sta object_speed_lo,x
          lda #OCTOINK_DAMAGE
          sta object_damage,x
          lda #<.plot_octoink
          sta object_spr_ptr_lo,x
          lda #>.plot_octoink
          sta object_spr_ptr_hi,x
          tya
          sta object_parent,x
          txa
          sta object_parent,y
          jsr set_cast_direction
end
        flags{6} = 0
        timer = OCTOPUS_POP_TIMER
octo_done
        if debug_time then BACKGRND = bg_color
        return thisbank

        data octo_shoot_frames
        0, F_OCTO_SHOOT_U, F_OCTO_SHOOT_D, F_OCTO_SHOOT_L, F_OCTO_SHOOT_R
end

obj_octo_stats
        asm
          ldx obj_index
          lda #<.plot_octopus
          sta object_spr_ptr_lo,x
          lda #>.plot_octopus
          sta object_spr_ptr_hi,x
end
        object_hp[obj_index] = OCTOPUS_HP
        object_vel_cap_hi[obj_index] = 1
        object_vel_cap_lo[obj_index] = 0
        object_damage[obj_index] = 4
        object_def[obj_index] = 0
        object_mdef[obj_index] = 2
        object_friction_hi[obj_index] = 1
        object_friction_lo[obj_index] = 0
        object_speed_hi[obj_index] = 0
        object_speed_lo[obj_index] = 10
        object_flags[obj_index] = 0
        goto obj_next_stats

;==============================================================================
; RIVER GHOST AI
;------------------------------------------------------------------------------
; Floats through walls to attack player
;==============================================================================
rghost_ai
        flags{2} = 1
        if timer then goto rghost_follow
        timer = 4
        if !object_pal[index] then object_pal[index] = 2 : goto rghost_follow
        object_pal[index] = 0
rghost_follow
        timer = timer - 1
        gosub followplayer
        return thisbank

obj_rghost_stats
        object_hp[obj_index] = 5
        object_vel_cap_hi[obj_index] = 1
        object_vel_cap_lo[obj_index] = 0
        object_damage[obj_index] = 4
        object_def[obj_index] = 2
        object_mdef[obj_index] = 0
        object_friction_hi[obj_index] = 1
        object_friction_lo[obj_index] = 0
        object_speed_hi[obj_index] = 0
        object_speed_lo[obj_index] = 20
        object_flags[obj_index] = 0
        asm
          ldx obj_index
          lda #<.plot_rghost
          sta object_spr_ptr_lo,x
          lda #>.plot_rghost
          sta object_spr_ptr_hi,x
end
        goto obj_next_stats

plot_octopus
        plotsprite octopus0 sprite_pal Xposition Yposition frame
        goto plot_next

plot_octoink
        plotsprite octoink 6 Xposition Yposition 0
        goto plot_next

plot_rghost
        plotsprite rghost0 sprite_pal Xposition Yposition animation_frame
        goto plot_next