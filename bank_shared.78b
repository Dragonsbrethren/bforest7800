;==============================================================================
; BANK 17
;------------------------------------------------------------------------------
; Permanently loaded bank. Contains sprites and code used with every tileset
;==============================================================================
        bank 17
        incbasic shared_gfx.78b

field_handler
        if reload_map = 1 then goto load_map
        exit_dir = EXIT_NONE
        ; essentially trigger a game over at end of demo
        if demo_end then goto password_display
        goto player_handler
player_handler_done
        gosub object_handler
        ; set by close menu, needed to make torches block movement after menu access
        torch_reblock = 0
        gosub check_collisions
        ; check if spawned items are duplicates, remove/sub them
        if item_spawned then gosub remove_duplicates

set_pickup_string

        if pickup_timer then get_pickup_string

pickup_clear
        ; when the pickup timer expires, zero the string
        asm
          ldx #PICKUP_STRING_LENGTH
          lda #0
          ; clear item_pickup here so an enemy name string can be shown
          sta item_pickup
pickup_clear_loop
          sta pickup_string,x
          dex
          bpl pickup_clear_loop
          jmp .pickup_done
end


get_pickup_string
        asm
          dec pickup_timer
        ; only run this code once per string
          lda new_pickup
          beq .pickup_done
        ; set pickup string based on pickup pointer
          ; start at index 0 because string is null terminated
          ldy #0
pickup_string_loop
          lda (pickup_ptr),y
          beq pickup_pad
          sta pickup_string,y
          iny
          cpy #PICKUP_STRING_LENGTH+1
          bne pickup_string_loop
          beq .pickup_done
pickup_pad
          ; back up the value of Y for centering later
          sty temp1
          lda #0
pickup_pad_loop
          sta pickup_string,y
          iny
          cpy #PICKUP_STRING_LENGTH+1
          bne pickup_pad_loop

pickup_center
        ; subtract however many chars were copied from max length
        lda #PICKUP_STRING_LENGTH
        sec
        sbc temp1
        ; divide by 2 and add result to previous string length
        lsr
        pha     ; backup divided value
        clc
        adc temp1
        tay
        ldx temp1
pickup_center_loop
        ; advance the string on the buffer to its centered position
        lda pickup_string,x
        sta pickup_string,y
        dey
        dex
        bpl pickup_center_loop
        ; lastly blank the left part of the string
        pla
        beq .pickup_done
        tax
        lda #0
pickup_left_loop
        dex
        sta pickup_string,x
        bne pickup_left_loop
end


pickup_done

check_darkness
        ; bypass the darkness check for dead player
        if player_state = STATE_DEATH then darkness_done
        ; TODO: save the normal fade value in a variable?
        if player_status{1} then fade = FADE_DARKNESS else fade = FADE_NORMAL

darkness_done

        restorescreen
        if !lightning_timer then no_lightning
        if tileset = T_CASTLE then goto castle_lightning
no_lightning
;        if tileset = T_FOREST then goto forest_pals
        if tileset = T_CASTLE then goto castle_pals
        if tileset = T_RIVER then goto river_pals
        if tileset = T_HILLS then goto hills_pals

palette_done
        gosub update_pickup_objs

plot_objects
        ; Iterates through all objects and determines which sprites need to be plotted by type
        asm
          ldx #MAX_OBJECTS
          stx index
plot_loop
          lda object_type,x
          sta plot_index
        ; first rule out zero objects (player handled separately)
        ; and spawners, which do not need to be plotted
          bne tp_spawn
          jmp .plot_next
tp_spawn  cmp #TYPE_SPAWNER
          bne plot_stats
end

plot_next
        asm
        ; restore X, decrease, and back up
          ldx index
          dex
          stx index
          bne plot_loop
          jmp plot_done

plot_stats
        ; now copy object stats to zeropage
          lda object_spr_ptr_lo,x
          sta pointer
          lda object_spr_ptr_hi,x
          sta pointer_hi
          lda object_Xpos,x
          sta Xposition
          lda object_Ypos,x
          sta Yposition
          lda object_frame,x
          sta frame
          lda object_pal,x
          sta sprite_pal
        ; restore the object type and do this comparison code
          lda plot_index
          cmp #TYPE_STATIC
          ; TODO: set spr_ptr for all object types, not just ones with stats
          bcs plot_items
          jmp (pointer)

plot_items
tp_charm  cmp #TYPE_CHARM1
          bcc tp_armor
          jmp .plot_charms
tp_armor  cmp #TYPE_ARMOR1
          bcc tp_shield
          jmp .plot_armor
tp_shield cmp #TYPE_SHIELD1
          bcc tp_sword
          jmp .plot_shields
tp_sword  cmp #TYPE_SWORD1
          bcc tp_relic
          jmp .plot_swords
tp_relic  cmp #TYPE_RELIC1
          bcc tp_item
          jmp .plot_relics
tp_item   cmp #TYPE_ITEM1
          bcc tp_spell
          jmp .plot_items
tp_spell  cmp #TYPE_SPELL1
          bcc tp_key
          jmp .plot_spells
tp_key
          cmp #TYPE_KEY1
          bcc tp_map
          jmp .plot_keys
tp_map
          cmp #TYPE_MAP1
          bcc tp_coin
          jmp .plot_maps
tp_coin   cmp #TYPE_COIN
          bne tp_prism
          jmp .plot_coin
tp_prism  cmp #TYPE_PRISM
          bne tp_harpy_sh
          jmp .plot_prism
tp_harpy_sh cmp #TYPE_HARPY_SH
          bne tp_blood
          jmp .plot_harpy_sh
tp_blood  cmp #TYPE_BLOOD
          bne tp_dooro
          jmp .plot_blood
tp_dooro  cmp #TYPE_DOOR_OPEN
          bne tp_door
          lda #1
          sta frame
          jmp .plot_door
tp_door   cmp #TYPE_DOOR
          bne tp_doorl
          jmp .plot_door
tp_doorl  cmp #TYPE_DOOR_LOCK
          bne tp_food
          jmp .plot_door
tp_food   jmp .plot_food

plot_done
end
        goto plot_player

plot_door
        plotsprite door0 1 Xposition Yposition frame
        goto plot_next

plot_torch
        PLOTSPRITE torch0 0 Xposition Yposition frame
        goto plot_next

plot_coin
        plotsprite coin 3 Xposition Yposition 0
        goto plot_next

plot_prism
        plotsprite prism 0 Xposition Yposition 0
        goto plot_next

plot_food
        plotsprite chimkin 1 Xposition Yposition 0
        goto plot_next

plot_items
        temp1 = object_type[index] - (TYPE_ITEM1 - 1)
        sprite_pal = f_item_pals[temp1]
        plotsprite potion0 sprite_pal Xposition Yposition 0
        goto plot_next

plot_relics
        temp1 = object_type[index] - (TYPE_RELIC1 - 1)
        sprite_pal = f_relic_pals[temp1]
        frame = f_relic_frames[temp1]
        plotsprite relic0 sprite_pal Xposition Yposition frame
        goto plot_next

plot_spells
        temp1 = object_type[index] - (TYPE_SPELL1 - 1)
        sprite_pal = f_spell_pals[temp1]
        plotsprite relic0 sprite_pal Xposition Yposition 1
        goto plot_next

plot_keys
        temp1 = object_type[index] - (TYPE_KEY1 - 1)
        sprite_pal = f_key_pals[temp1]
        plotsprite key0 sprite_pal Xposition Yposition 0
        goto plot_next

plot_maps
        temp1 = object_type[index] - (TYPE_MAP1 - 1)
        sprite_pal = f_item_pals[temp1]
        plotsprite map0 1 Xposition Yposition
        goto plot_next


plot_swords
        temp1 = object_type[index] - (TYPE_SWORD1 - 1)
        sprite_pal = f_sword_pals[temp1]
        plotsprite sword0 sprite_pal Xposition Yposition 0
        goto plot_next

plot_shields
        temp1 = object_type[index] - (TYPE_SHIELD1 - 1)
        sprite_pal = f_shield_pals[temp1]
        plotsprite shield0 sprite_pal Xposition Yposition 0
        goto plot_next

plot_armor
        temp1 = object_type[index] - (TYPE_ARMOR1 - 1)
        sprite_pal = f_armor_pals[temp1]
        plotsprite armor0 sprite_pal Xposition Yposition 0
        goto plot_next

plot_charms
        temp1 = object_type[index] - (TYPE_CHARM1 - 1)
;        plotsprite charm0 sprite_pal Xposition Yposition 0
;        goto plot_next

plot_rosary
        sprite_pal = f_charm_pals[temp1]
        plotsprite rosary sprite_pal Xposition Yposition 0
        goto plot_next

plot_fireball
        plotsprite fireball0 2 Xposition Yposition frame
        goto plot_next


;==============================================================================
; DRAW HUD
;------------------------------------------------------------------------------
; Draws the player's HP and MP bar in zones 1-2 using sprites.
; Bars must be plotted in separate zones or there isn't enough DMA time
;==============================================================================
draw_hud
        plotsprite  hp   0  8  0       ; HP is 160B
        ; prep plot_par to draw the rest of the HP segments
        Xposition = 24
        asm
        lda #0
        sta Yposition
        sta temp1
end
        temp2 = 5
        temp3 = (2 * 32)
        gosub plot_bar
        plotsprite  mp   0  8 16        ; Need to use plotsprite here to avoid rendering error on MP bar
        ; prep plot_bar for MP bar
        Xposition = 24
        Yposition = 16
        temp1 = 6
        temp2 = 11
        temp3 = 0
        ; code runs directly into 
plot_bar
        for index = temp1 to temp2
        frame = hp_seg_1[index]
        PLOTSPRITE bar0 temp3 Xposition Yposition frame
        Xposition = Xposition + 8
        next
        return thisbank

plot_debug_hud
        if tileset = T_CASTLE then plot_hud_castle
        if tileset = T_HILLS then plot_hud_hills
        ; plotvalue hud 0 player_hp 2 72 0
        ; plotvalue hud 0 player_mp 2 72 1
        plotvalue hud 0 player_Xpos 4 32 12
        plotvalue hud2 0 move_tile_1 4 32 11
;        plotvalue hud 0 tile_properties_1 2 64 12
;        plotvalue hud 0 tile_properties_2 2 80 12
        ; plotvalue hud 0 room_index 2 32 13
        ; plotvalue hud 0 room 2 48 13
;        plotvalue hud 0 input_buffer 16 16 13
        ; plotvalue hud 0 chant_input 2 8 13
        ; plotvalue hud 0 retract_counter 2 64 13
        return thisbank

open_menu
        gosub clear_palettes
        ; prevent menu access from loading wrong tileset on exit
        exit_tileset = 0
        ; TODO: Should previously opened submenu be remembered?
        menu = MENU_MAIN
        menu_debounce = 1
        pause_debounce = 1
        goto menu_init bank3

test_follow_box
        ; check a box around the object and determine if object should follow
        ; prevents following objects from getting stuck on top of player
        temp1 = player_Xpos - (FAIRY_CHASE_X / 2)
        if temp1 >=161 then temp1 = 0
        temp2 = player_Ypos - (FAIRY_CHASE_Y / 2)
        if temp2 >=225 then temp2 = 0
        if boxcollision(Xposition, Yposition, 12, 16, temp1, temp2, FAIRY_CHASE_X, FAIRY_CHASE_Y) then return thisbank

followplayer
        ; add a little randomness to stop a constant movement pattern from happening
        if rand >= 240 then follow_player_Y
        if Xposition >= player_Xpos then Xvelocity = Xvelocity + move_speed : Xdirection = DIR_LEFT
        if Xposition < player_Xpos then Xvelocity = Xvelocity + move_speed : Xdirection = DIR_RIGHT
follow_player_Y
        if rand >= 240 then follow_player_done
        if Yposition >= player_Ypos then Yvelocity = Yvelocity + move_speed : Ydirection = DIR_UP
        if Yposition < player_Ypos then Yvelocity = Yvelocity + move_speed : Ydirection = DIR_DOWN
follow_player_done
        return thisbank

get_player_pos
        Xdestination = player_Xpos : Ydestination = player_Ypos
        return

get_player_dir
        Xdirection = player_Xdir
        Ydirection = player_Ydir
        return

go_to_destination
        if Xposition > Xdestination then Xvelocity = Xvelocity + move_speed : Xdirection = DIR_LEFT
        if Xposition < Xdestination then Xvelocity = Xvelocity + move_speed : Xdirection = DIR_RIGHT
        if Yposition > Ydestination then Yvelocity = Yvelocity + move_speed : Ydirection = DIR_UP
        if Yposition < Ydestination then Yvelocity = Yvelocity + move_speed : Ydirection = DIR_DOWN
        if Xposition = Xdestination then flags{3} = 0
        if Yposition = Ydestination then flags{3} = 0
        return

swoop_X
        return

swoop_Y
        return

;==============================================================================
; TEST MELEE
;------------------------------------------------------------------------------
; Can object hit player with melee attack?
;==============================================================================
test_melee
        temp6 = 0
        if object_facing[index] = DIR_UP then melee_up
        if object_facing[index] = DIR_DOWN then melee_down
        if object_facing[index] = DIR_LEFT then melee_left
melee_right
        temp1 = Xposition + 12
        temp2 = Yposition - 8
        goto melee_range

melee_up
        temp1 = Xposition
        temp2 = Yposition - 16
        if temp2 >= 225 then temp2 = 0
        goto melee_range

melee_down
        temp1 = Xposition
        temp2 = Yposition
        goto melee_range

melee_left
        temp1 = Xposition
        temp2 = Yposition - 8

melee_range
        if boxcollision(temp1, temp2, 12, 32, player_Xpos, player_Ypos, 16, 12) then temp6 = 1
        return thisbank

;==============================================================================
; POSITION SWORD
;------------------------------------------------------------------------------
; Same as player code (can probably be shared with some tweaks)
;-=============================================================================
position_sword
        if object_facing[index] = DIR_DOWN then pos_swd_down
        if object_facing[index] = DIR_UP then pos_swd_up
        if object_facing[index] = DIR_LEFT then pos_swd_left

pos_swd_right
        temp1 = object_Xpos[index] + SWORD_OFFSET_RIGHT_X
        temp2 = object_Ypos[index] + SWORD_OFFSET_RIGHT_Y
        ;temp3 = 12
        ;temp4 = 4
        temp5 = 2
        return thisbank

pos_swd_down
        temp1 = object_Xpos[index] + SWORD_OFFSET_DOWN_X
        temp2 = object_Ypos[index] + SWORD_OFFSET_DOWN_Y
        ;temp3 = 4
        ;temp4 = 16
        temp5 = 0
        return thisbank

pos_swd_up
        temp1 = object_Xpos[index] + SWORD_OFFSET_UP_X
        temp2 = object_Ypos[index] + SWORD_OFFSET_UP_Y
        ;temp3 = 4
        ;temp4 = 16
        temp5 = 1
        return thisbank

pos_swd_left
        temp1 = object_Xpos[index] + SWORD_OFFSET_LEFT_X
        temp2 = object_Ypos[index] + SWORD_OFFSET_LEFT_Y
        ;temp3 = 12
        ;temp4 = 4
        temp5 = 3
        return thisbank

        data object_ai_lo
        0, 0, wolf_ai_lo, warg_ai_lo, nix_ai_lo, octopus_ai_lo, slime_ai_lo, mslime_ai_lo, 
        raven_ai_lo, priest_ai_lo, priest_ai_lo, redslime_ai_lo, mredslime_ai_lo,
        ghost_ai_lo, rghost_ai_lo, harpy_ai_lo, spider_ai_lo, spider_ai_lo, hslime_ai_lo, mhslime_ai_lo
        hghost_ai_lo
end

        data object_ai_hi
        0, 0, wolf_ai_hi, warg_ai_hi, nix_ai_hi, octopus_ai_hi, slime_ai_hi, mslime_ai_hi, 
        raven_ai_hi, priest_ai_hi, priest_ai_hi, redslime_ai_hi, mredslime_ai_hi,
        ghost_ai_hi, rghost_ai_hi, harpy_ai_hi, spider_ai_hi, spider_ai_hi, hslime_ai_hi, mhslime_ai_hi
        hghost_ai_hi
end

        data projectile_ai_lo
        skelsword_ai_lo, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        darkspark_ai_lo, octoink_ai_lo, 0, 0, 0, 0, 0, 0, 0, 0,
        fireball_ai_lo, fairy_ai_lo, 0, 0, 0, 0
end

        data projectile_ai_hi
        skelsword_ai_hi, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        darkspark_ai_hi, octoink_ai_hi, 0, 0, 0, 0, 0, 0, 0, 0,
        fireball_ai_hi, fairy_ai_hi, 0, 0, 0, 0
end

load_ai_pointer
        asm
          ldx index
          lda object_type,x
          cmp #TYPE_PROJECTILE
          bcc load_object_ai
          ; need to offset X for projectile arrays
          sbc #TYPE_PROJECTILE
          tax
          lda projectile_ai_lo,x
          sta pointer
          lda projectile_ai_hi,x
          sta pointer_hi
          jmp (pointer)

load_object_ai
          tax
          lda object_ai_lo,x
          sta pointer
          lda object_ai_hi,x
          sta pointer_hi
          jmp (pointer)
end

object_handler
        for index = 1 to 15
        if !object_type[index] then object_done    ; 0 = no object
        if object_type[index] = TYPE_DOOR_LOCK then goto torch_tile_block
        if object_type[index] >= TYPE_STATIC then object_done      ;  coins, prisms are static
        if object_type[index] = TYPE_SPAWNER then spawn_object
        if object_type[index] = TYPE_TORCH then goto torch_tile_block
        gosub copy_object_props 
        if flags{5} then gosub ledge_hop : goto object_restore
        gosub decelerate_object
        gosub load_ai_pointer
object_ai_loaded
        gosub move_object
object_restore
        gosub restore_object_props
object_done
        next
        return

;==============================================================================
; FIREBALL AI
;------------------------------------------------------------------------------
; Fireballs poof out of existence when velocities = 0
;==============================================================================
fireball_ai
        if !Xvelocity_hi && !Yvelocity_hi && !Xvelocity_lo && !Yvelocity_lo then fireball_poof
fireball_animate
        frame = 0
        if animation_frame then frame++
fireball_done
        return thisbank

fireball_poof
        object_type[index] = 0
        return thisbank


torch_tile_block
        ; flags are used to track if the tile has already been blocked
        ; however, this fails when the map reloads after the menu is opened
        if torch_reblock then goto torch_tile_block_get_pos
        if object_type[index] = TYPE_TORCH then torch_animation
torch_flag_check
        if object_flags[index] then object_done
        if object_type[index] = TYPE_TORCH then goto torch_tile_block_get_pos

locked_door_block
        ; KISS: keys are tied to one tileset so multiple lock types or object flags aren't needed
        ;     - side effect of this is key shouldn't be in the same room as a locked door
        if tileset = T_CASTLE && m_key_bits = %00000001 then goto unlock_door

torch_tile_block_get_pos
        gosub get_torch_pos
        pointer = torch_tileset_lo[tileset]
        pointer_hi = torch_tileset_hi[tileset]
        asm
          jmp (pointer)
end
torch_tile_block_set_flag
        ; this is a workaround, set the flying flag on torch so elevation doesn't matter
        object_flags[index] = %10000100
        goto object_done

unlock_door
        ; needed for door animation handling and disabling locked string
        object_type[index] = TYPE_DOOR
        goto object_done

torch_animation
        temp1 = animation_frame
        if tileset = T_CASTLE then temp1 = temp1 + 2
        object_frame[index] = temp1
        goto torch_flag_check

spawn_object
        asm
        ; index is still set by object_handler
          ldx index
        ; spawner objects store old type in flags
          lda object_flags,x
        ; exclude projectiles and collectible objects
          bmi spawn_nothing
        ; save old type in y for drop indexing
          tay
        ; torches have special logic for changing drops
          cmp #TYPE_TORCH
          beq .spawns_torch
        ; hack - if type was Harpy, remove its shadow
          cmp #TYPE_HARPY
          bne spawn_zero_nibble
          jmp .remove_harpy_shadow
spawn_zero_nibble
        ; zero Ypos lower nibble to avoid gfx glitch
          lda object_Ypos,x
          and #$F0
          sta object_Ypos,x
          jsr randomize
          ; for remove duplicates logic
          stx item_spawned
          cmp #RARE_DROP_RATE
          bcs spawn_rare
          cmp #COMMON_DROP_RATE
          bcs spawn_common
spawn_nothing
          lda #0
          sta object_type,x
          jmp .object_done

spawn_rare
          lda rare_drops,y
          sta object_type,x
          jmp .object_done

spawn_common
          lda common_drops,y
          sta object_type,x
          jmp .object_done
end


spawns_torch
        if player_hp = player_max_hp then torch_mp_check
        if rand > 128 then _spawn_food
torch_mp_check
        if player_mp = player_max_mp then _spawn_coin
        goto _spawn_mana

_spawn_food
        object_type[index] = TYPE_FOOD
        object_hp[index] = 1
        goto object_done

_spawn_mana
        object_type[index] = TYPE_PRISM
        object_hp[index] = 1
        goto object_done

_spawn_coin
        object_type[index] = TYPE_COIN
        object_hp[index] = 1
        goto object_done

        data rare_drops
        0               ; player
        0               ; torch (handled separately)
        TYPE_POTION     ; wolf
        TYPE_HIPOTION   ; warg
        TYPE_LIFEAPPLE  ; merman
        TYPE_HIPOTION   ; octopus
        TYPE_HIETHER    ; slime
        0               ; mini-slime
        TYPE_POTION     ; raven
        TYPE_CHARM2     ; priest
        TYPE_SWORD2     ; skeleton
        TYPE_HIETHER    ; red slime
        0               ; mini red slime
        TYPE_HIETHER    ; ghost
        TYPE_HIETHER    ; river ghost
        TYPE_LIFEAPPLE  ; harpy
        TYPE_LIFEAPPLE  ; spider
        TYPE_LIFEAPPLE  ; vertical spider
        TYPE_ELIXIR     ; ochre jelly
        0               ; mini ochre jelly
        TYPE_SHIELD4    ; feuermann
end

        data common_drops
        0               ; player
        0               ; torch (handled separately)
        TYPE_FOOD       ; wolf
        TYPE_EYEDROP    ; warg
        TYPE_EYEDROP    ; merman
        TYPE_EYEDROP    ; octopus
        TYPE_ANTIDOTE   ; slime
        0               ; mini-slime
        TYPE_FOOD       ; raven
        TYPE_ETHER      ; priest
        TYPE_SHIELD2    ; skeleton
        TYPE_ANTIDOTE   ; red slime
        0               ; mini red slime
        TYPE_UNCURSE    ; ghost
        TYPE_UNCURSE    ; river ghost
        TYPE_CHARM4     ; harpy
        TYPE_ANTIDOTE   ; spider
        TYPE_ANTIDOTE   ; vertical spider
        TYPE_ANTIDOTE   ; ochre jelly
        0               ; mini ochre jelly
        TYPE_UNCURSE    ; feuermann
end

        ; handles poison and regen
poison_damage
        poison_timer = poison_timer + 1
        if poison_timer < POISON_FRAMES then return thisbank
        poison_timer = 0
        hp_change = POISON_DMG
        if player_status{5} then goto increase_player_hp
        if player_status{0} then goto damage_player_hp

player_handler
        ; TODO: saving cutscene
        if in_save_room then old_tileset = tileset : goto save_room_handler
        if player_state = STATE_DEATH then goto death_fade
        
        if player_status{0} || player_status{5} then gosub poison_damage
;        gosub copy_player_props
        index = 0 : gosub decelerate_player
;        gosub restore_player_props

;==============================================================================
; SUBROUTINE: HANDLE INPUT FIELD
;------------------------------------------------------------------------------
; This routine handles all player input in the field
;==============================================================================
handle_input_field
        if !player_flags{5} then player_no_hop
        index = 0
        gosub copy_player_props
        gosub ledge_hop
        gosub restore_player_props
        goto test_joy_done
player_no_hop
        ; player timer is set for knockback and attack timing
        if !player_timer then no_player_timer
        player_timer = player_timer - 1
        if player_state = STATE_ATTACK then test_joy_done
        if player_flags{0} then player_test_state

no_player_timer
        player_flags{0} = 0     ; clear invulnerability flag

;------------------------------------------------------------------------------
        ; handles chanting and sword retracting. Zero if not doing these
player_test_state
        if player_state = STATE_CHANT then chant_handler
        if player_state = STATE_ATTACK then retract_sword
        if joy0fire0 && action_button = 0 then goto player_attack
        if joy0fire1 && action_button = 1 then goto player_attack

        asm
        lda #0
        sta retract_counter
        sta chant_timer
        sta player_state        ; STATE_STAND
        sta player_exiting_chant
        sta sword_hit
end

;------------------------------------------------------------------------------

        if player_facing = DIR_UP then player_frame = FRAME_UP : goto frames_done
        if player_facing = DIR_DOWN then player_frame = FRAME_DOWN : goto frames_done
        if player_facing = DIR_LEFT then player_frame = FRAME_LEFT : goto frames_done
        player_frame = FRAME_RIGHT

frames_done
        if joy0up    then player_Ydir = DIR_UP    : player_facing = DIR_UP    : player_Yvel = player_Yvel + player_speed : player_state = STATE_MOVING : test_joy_done
        if joy0down  then player_Ydir = DIR_DOWN  : player_facing = DIR_DOWN  : player_Yvel = player_Yvel + player_speed : player_state = STATE_MOVING : test_joy_done
        if joy0left  then player_Xdir = DIR_LEFT  : player_facing = DIR_LEFT  : player_Xvel = player_Xvel + player_speed : player_state = STATE_MOVING : test_joy_done
        if joy0right then player_Xdir = DIR_RIGHT : player_facing = DIR_RIGHT : player_Xvel = player_Xvel + player_speed : player_state = STATE_MOVING : test_joy_done

test_joy_done
        if !menu_debounce && joy0fire0 && action_button = 1 then goto open_menu
        if !menu_debounce && joy0fire1 && action_button = 0 then goto open_menu
        if !pause_debounce && switchpause then goto open_menu
        if player_state = STATE_STAND || player_state = STATE_ATTACK then player_move_done
        if player_flags{5} then player_move_done
        index = 0 : gosub copy_player_props
        gosub move_object
        gosub restore_player_props

player_move_done

position_shield
        temp2 = SHIELD_OFFSET_Y
        ; the shield changes frames based on the player's direction and state
        if player_state = STATE_STAND then position_shield_stand
        ; TODO: Table of frames for different shield graphics
        if player_facing = DIR_UP || player_facing = DIR_DOWN then shield_frame = 2 else shield_frame = 0
        if player_facing = DIR_LEFT then temp1 = SHIELD_OFFSET_X_LEFT
        if player_facing = DIR_RIGHT then temp1 = SHIELD_OFFSET_X_RIGHT
        if player_facing = DIR_DOWN then temp1 = SHIELD_OFFSET_X_DOWN
        if player_facing = DIR_UP then temp1 = SHIELD_OFFSET_X_UP : temp2 = SHIELD_OFFSET_Y_UP 
        goto position_shield_done

position_shield_stand
        ; TODO: Table of frames for different shield graphics
        if player_facing = DIR_UP || player_facing = DIR_DOWN then shield_frame = 0 else shield_frame = 2
        if player_facing = DIR_LEFT then temp1 = SHIELD_OFFSET_X_LEFT_STAND
        if player_facing = DIR_RIGHT then temp1 = SHIELD_OFFSET_X_RIGHT_STAND
        if player_facing = DIR_DOWN then temp1 = SHIELD_OFFSET_X_DOWN_STAND
        if player_facing = DIR_UP then temp1 = SHIELD_OFFSET_X_UP_STAND : temp2 = SHIELD_OFFSET_Y_UP_STAND ; raise shield slightly for up frame

position_shield_done
        shield_Xpos = player_Xpos + temp1
        shield_Ypos = player_Ypos + temp2

input_frame_done
        if !player_Xvel && !player_Yvel && player_state <> STATE_ATTACK && player_state <> STATE_CHANT then player_state = STATE_STAND
        if animation_frame && player_state = STATE_MOVING then player_frame = player_frame + 1

check_room_boundary
        if player_Xpos < 2  then exit_dir = EXIT_EAST  : room_index = room_index - 1 : menu_map_Xpos = menu_map_Xpos - 8
        if player_Xpos > 149 then exit_dir = EXIT_WEST  : room_index = room_index + 1 : menu_map_Xpos = menu_map_Xpos + 8
        if player_Ypos < 2  then exit_dir = EXIT_NORTH : room_index = room_index - ROOMS_PER_ROW : menu_map_Ypos = menu_map_Ypos - 16
        if player_Ypos > 188 then exit_dir = EXIT_SOUTH : room_index = room_index + ROOMS_PER_ROW : menu_map_Ypos = menu_map_Ypos + 16
        if exit_dir then reload_map = 1 : exit_tileset = 0
        ; if this room can transition to another tileset, check its exit coordinates
        if exit_tileset then check_room_exit
        goto player_handler_done

check_room_exit
        ; Exits are a 16x8 box, same width as a 2-tile wide path or door graphic
        if !boxcollision(player_Xpos, player_Ypos, PLAYER_WIDTH, PLAYER_HEIGHT, exit_Xpos, exit_Ypos, 16, 8) then goto player_handler_done
        reload_map = 1
        goto player_handler_done

player_attack
        ; workaround for wierdness of attacking while obscurred - TODO: detect if sword is on obscurred tile & hide?
        if obscure_player && player_obscure then goto player_handler_done
        sword_hit = 0
        ; player exiting chant tracks if the player cast magic to exit chant with button held
        if player_exiting_chant then test_joy_done
        if retract_counter then retract_sword
        if player_sword then temp1 = PLAYER_WIDTH : temp2 = PLAYER_HEIGHT else temp1 = 4 : temp2 = 4 
        if player_facing = DIR_DOWN then player_frame = FRAME_ATK_D : sword_Xpos = player_Xpos + SWORD_OFFSET_DOWN_X : sword_Ypos = player_Ypos + SWORD_OFFSET_DOWN_Y : sword_width = 3 : sword_height = temp2 : sword_frame = 0 : goto sword_done
        if player_facing = DIR_UP   then player_frame = FRAME_ATK_U : sword_Xpos = player_Xpos + SWORD_OFFSET_UP_X   : sword_Ypos = player_Ypos + SWORD_OFFSET_UP_Y   : sword_width = 3 : sword_height = temp2 : sword_frame = 1 : goto sword_done
        if player_facing = DIR_LEFT then player_frame = FRAME_ATK_L : sword_Xpos = player_Xpos + SWORD_OFFSET_LEFT_X : sword_Ypos = player_Ypos + SWORD_OFFSET_LEFT_Y : sword_width = temp1 : sword_height = 3 :sword_frame = 3 : goto sword_done
        player_frame = FRAME_ATK_R : sword_Xpos = player_Xpos + SWORD_OFFSET_RIGHT_X : sword_Ypos = player_Ypos + SWORD_OFFSET_RIGHT_Y : sword_width = temp1 : sword_height = 3 : sword_frame = 2
sword_done

player_attack_return
        player_state = STATE_ATTACK
        player_timer = ATTACK_FRAMES
        goto player_handler_done

retract_sword
        if player_facing = DIR_DOWN  then sword_Ypos = sword_Ypos - 4 : retract_step_done
        if player_facing = DIR_UP    then sword_Ypos = sword_Ypos + 4 : retract_step_done
        if player_facing = DIR_LEFT  then sword_Xpos = sword_Xpos + 2 : retract_step_done
        if player_facing = DIR_RIGHT then sword_Xpos = sword_Xpos - 2

retract_step_done
        retract_counter = retract_counter + 1
        if retract_counter < 3 then test_joy_done

retract_stand
        if !joy0fire0 && action_button = 0 then player_state = STATE_STAND : goto test_joy_done
        if !joy0fire1 && action_button = 1 then player_state = STATE_STAND : goto test_joy_done
        ; retract finished and button still held - code runs into player_chant_start

player_chant_start
        if chant_timer > CHANT_START_TIME then set_state_chant
        player_state = STATE_CHANT_START
        asm
        inc chant_timer
end
        if player_facing = DIR_UP    then player_frame = FRAME_UP
        if player_facing = DIR_DOWN  then player_frame = FRAME_DOWN
        if player_facing = DIR_LEFT  then player_frame = FRAME_LEFT
        if player_facing = DIR_RIGHT then player_frame = FRAME_RIGHT
        goto test_joy_done

set_state_chant
        ; set player state to chant and facing direction to down
        ; facing down when coming out of chant just feels more natural
        player_state = STATE_CHANT
        player_facing = DIR_DOWN
        player_frame = FRAME_CHANT

chant_handler

        if !joy0fire0 && action_button = 0 then chant_done_no_hold
        if !joy0fire1 && action_button = 1 then chant_done_no_hold

        ; chant_new_input is set when a direction is pressed
        if chant_new_input then chant_input_test_release

        ; parse the most recent directional entered and test for combos
        if input_buffer[chant_index] = DIR_UP    then chant_spells_up
        if input_buffer[chant_index] = DIR_DOWN  then chant_spells_down
        if input_buffer[chant_index] = DIR_LEFT  then chant_spells_left
        if input_buffer[chant_index] = DIR_RIGHT then chant_spells_right

chant_test_dirs
        if joy0left  then chant_input = DIR_LEFT  : chant_new_input = 1
        if joy0right then chant_input = DIR_RIGHT : chant_new_input = 1
        if joy0up    then chant_input = DIR_UP    : chant_new_input = 1
        if joy0down  then chant_input = DIR_DOWN  : chant_new_input = 1
        goto test_joy_done

; Require a release of a single direction (TODO: 8dir?) before buffering input
chant_input_test_release
        if joy0up    then test_joy_done
        if joy0down  then test_joy_done
        if joy0left  then test_joy_done
        if joy0right then test_joy_done
        ; TODO: Test for holds? Long times between inputs?

chant_buffer_input
        input_buffer[input_buffer_index] = chant_input
        ; chant_index is always updated to input buffer index but is its own
        ; variable so that it can be manipulated by the parsing routines
        ; without losing the input buffer index for the next frame
        chant_index = input_buffer_index
        input_buffer_index = input_buffer_index + 1
        if input_buffer_index > INPUT_BUFFER_MAX then input_buffer_index = 0
        chant_new_input = 0
        goto test_joy_done

; all chant tests seach for button combos "backwards" from the most recent input
chant_spells_up
        chant_index = chant_index - 1
        ; chant index will underflow to 255, set to 7
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] = DIR_DOWN then parse_fireball_up

chant_spells_down
        chant_index = chant_index - 1
        ; chant index will underflow to 255, set to 7
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] = DIR_UP then parse_fireball_down
        goto chant_test_dirs

chant_spells_left
        chant_index = chant_index - 1
        ; chant index will underflow to 255, set to 7
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] = DIR_RIGHT then parse_fireball_left
        goto chant_test_dirs

chant_spells_right
        chant_index = chant_index - 1
        ; chant index will underflow to 255, set to 7
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] = DIR_LEFT then parse_fireball_right
        goto chant_test_dirs

parse_fireball_up
        chant_index = chant_index - 1
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] <> DIR_UP then chant_test_dirs
        player_facing = DIR_UP : player_frame = FRAME_UP
        gosub cast_fireball
        goto chant_done

parse_fireball_down
        chant_index = chant_index - 1
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] <> DIR_DOWN then chant_test_dirs
        player_frame = FRAME_DOWN
        gosub cast_fireball
        goto chant_done

parse_fireball_left
        chant_index = chant_index - 1
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] <> DIR_LEFT then chant_test_dirs
        player_facing = DIR_LEFT : player_frame = FRAME_LEFT
        gosub cast_fireball
        goto chant_done

parse_fireball_right
        chant_index = chant_index - 1
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] <> DIR_RIGHT then chant_test_dirs
        player_facing = DIR_RIGHT : player_frame = FRAME_RIGHT
        gosub cast_fireball
        goto chant_done ; because I know I'll cause a bug adding code later...

chant_done
        player_exiting_chant = 1
chant_done_no_hold
        asm
        lda #0
        sta player_state        ; STATE_STAND
        sta chant_timer
        sta chant_input
        sta input_buffer_index
        sta chant_new_input
        ldx #8
clear_input_buffer
        dex
        sta input_buffer,x
        bne clear_input_buffer
end
        gosub decrease_player_mp
        goto test_joy_done

decelerate_player
        asm
        ldx index
        lda object_friction,x
        beq decel_return
        lda object_Xvel,x
        beq decel_Y
        pha
        sec
        sbc object_friction_hi,x
        sta object_Xvel_hi,x
        pla
        cmp object_Xvel_hi,x
        bcs decel_Y
        lda #0
        sta object_Xvel_lo,x
        sta object_Xvel_hi,x

decel_Y
        lda object_Yvel_hi,x
        beq decel_return
        pha
        sec
        sbc object_friction_hi,x
        sta object_Yvel_hi,x
        pla
        cmp object_Yvel_hi,x
        bcs decel_return
        lda #0
        sta object_Yvel_lo,x
        sta object_Yvel_hi,x

decel_return
        rts
end

;==============================================================================
; SUBROUTINE: MOVE_OBJECT
;------------------------------------------------------------------------------
; Moves an object based on the non-fractional component of their velocities.
; Tests against an array of walkable tiles for current tileset before moving.
;
; All move test labels add 8 to Yposistion to allow objects to overlap
; unwalkable tiles that are above them. Objects are assumed to be 12x16
; and magic numbers are used throughout the code to improve the feel of
; player collisions with map tiles at the expense of other sprite proportions
;==============================================================================
move_object

        ; Cap the object's velocity TODO: separate X/Y cap?
        if Xvelocity > vel_cap then Xvelocity = vel_cap
        if Yvelocity > vel_cap then Yvelocity = vel_cap

        ; Current direction(s) are determined by player input or AI logic
        ; optimization: bypass direction checks if no velocity
        if !Yvelocity then move_object_X
        if Ydirection = DIR_UP    then gosub move_test_up
        if Ydirection = DIR_DOWN  then gosub move_test_down
move_object_X
        if !Xvelocity then move_object_done
        if Xdirection = DIR_LEFT  then gosub move_test_left
        if Xdirection = DIR_RIGHT then gosub move_test_right
move_object_done
        goto move_return

move_test_up
        if flags{2} then move_up
        asm
        lda Xposition
        clc
        adc #2
        lsr
        lsr
        lsr
        sta peekX
        lda Yposition
        clc
        adc #8
        sec
        sbc Yvelocity_hi
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_1 = peekchar (current_map, peekX, peekY, 20, 14)
;        peekX = (Xposition + 8) / TILE_WIDTH
        asm
        lda Xposition
        clc
        adc #8
        lsr
        lsr
        lsr
        sta peekX
end
        move_tile_2 = peekchar (current_map, peekX, peekY, 20, 14)
        gosub test_walkable
        if !flags{4} then test_walkable_up
        if tile_properties{1} then move_up
test_walkable_up
        ; test for downward ledge, set hopping flag
        if m_relic_bits_2{2} && tile_properties{4} then Xdirection = 0 : Ydirection = DIR_UP : flags{5} = 1
        if !tile_properties{0} then Yvelocity = 0 : return
move_up
        Yposition = Yposition - Yvelocity_hi
        if Yposition >= 224 then Yposition = 0
        return thisbank

move_test_down
        if flags{2} then move_down
        ;peekX = (Xposition + 2) / TILE_WIDTH
        ;peekY = ((Yposition + Yvelocity_hi) + 15) / TILE_HEIGHT
        asm
        lda Xposition
        clc
        adc #2
        lsr
        lsr
        lsr
        sta peekX
        lda Yposition
        clc
        adc #15
        clc
        adc Yvelocity_hi
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_1 = peekchar (current_map, peekX, peekY, 20, 14)
        ;peekX = (Xposition + 8) / TILE_WIDTH
        asm
        lda Xposition
        clc
        adc #8
        lsr
        lsr
        lsr
        sta peekX
end
        move_tile_2 = peekchar (current_map, peekX, peekY, 20, 14)
        gosub test_walkable
        if !flags{4} then test_walkable_down
        if tile_properties{1} then move_down
test_walkable_down
        ; test for downward ledge, set hopping flag
        if tile_properties{4} then Xdirection = 0 : Ydirection = DIR_DOWN : flags{5} = 1
        if !tile_properties{0} then Yvelocity = 0 : return
move_down
        Yposition = Yposition + Yvelocity_hi
        ; keep objects out of bottom zone
        if Yposition >= 208 then Yposition = 208
        return thisbank

move_test_left
        if flags{2} then move_left
;        peekX = ((Xposition + 2) - Xvelocity_hi) / TILE_WIDTH
        ; Add 8 to Y position to allow object to overlap solid tiles above it slightly
;        peekY = (Yposition + 8) / TILE_HEIGHT
        asm
        lda Xposition
        clc
        adc #2
        sec
        sbc Xvelocity_hi
        lsr
        lsr
        lsr
        sta peekX
        lda Yposition
        clc
        adc #8
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_1 = peekchar (current_map, peekX, peekY, 20, 14)
;        peekY = (Yposition + 15) / TILE_HEIGHT
        asm
        lda Yposition
        clc
        adc #15
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_2 = peekchar (current_map, peekX, peekY, 20, 14)
        gosub test_walkable
        if !flags{4} then test_walkable_left
        ; floating objects bypass walk test
        if tile_properties{1} then move_left
test_walkable_left
        ; test for leftward ledge, set hopping flag
        if tile_properties{6} then Xdirection = DIR_LEFT : flags{5} = 1
        ; test if Harpy's Claw is available, allow hopping up ledge
        if m_relic_bits_2{2} && tile_properties{5} then Xdirection = DIR_LEFT : flags{5} = 1
        if !tile_properties{0} then Xvelocity = 0 : return
move_left
        Xposition = Xposition - Xvelocity_hi
        if Xposition >= 160 then Xposition = 0
        return thisbank

move_test_right
        if flags{2} then move_right
;        peekX = ((Xposition + 9) + Xvelocity_hi) / TILE_WIDTH
        ; Add 8 to Y position to allow object to overlap solid tiles above it slightly
;        peekY = (Yposition + 8) / TILE_HEIGHT
        asm
        lda Xposition
        clc
        adc #9
        clc
        adc Xvelocity_hi
        lsr
        lsr
        lsr
        sta peekX
        lda Yposition
        clc
        adc #8
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_1 = peekchar (current_map, peekX, peekY, 20, 14)
;        peekY = (Yposition + 15) / TILE_HEIGHT
        asm
        lda Yposition
        clc
        adc #15
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_2 = peekchar (current_map, peekX, peekY, 20, 14)
        gosub test_walkable
        if !flags{4} then test_walkable_right
        if tile_properties{1} then move_right
test_walkable_right
        ; test for rightward ledge, set hopping flag
        if tile_properties{5} then Xdirection = DIR_RIGHT : flags{5} = 1
        ; test if Harpy's Claw is available, allow hopping up ledge
        if m_relic_bits_2{2} && tile_properties{6} then Xdirection = DIR_RIGHT : flags{5} = 1
        if !tile_properties{0} then Xvelocity = 0 : return
move_right
        Xposition = Xposition + Xvelocity_hi
        if Xposition >= 160 then Xposition = 160
        return thisbank
        
move_return
        return thisbank

test_walkable
        move_tile_1 = move_tile_1 / 2
        move_tile_2 = move_tile_2 / 2
        asm
          ldx tileset
          lda walkable_jump_lo,x
          sta pointer
          lda walkable_jump_hi,x
          sta pointer_hi
          jmp (pointer)
end
walkable_return
        tile_properties = tile_properties_1 & tile_properties_2
        ; obscure player moving onto obscuring tile
        if !index && tile_properties{3} then player_obscure = 1
        ; obscure flag is treated as a wall for non-player objects
        if index && tile_properties{3} then tile_properties = tile_properties & %11111100
        asm
          lda tile_properties
          ; if all ledge bits toggled, tile is a ramp
          cmp #%01110001
          bne walkable_return_no_elev
          ; set the tile to walkable
          lda #1
          sta tile_properties
          ; compare against the previous frame's move tiles so elevation only toggles once
          lda move_tile_1_old
          cmp move_tile_1
          bne walkable_change_elev
          lda move_tile_2_old
          cmp move_tile_2
          beq walkable_return_no_elev
walkable_change_elev
          ; set the object's elevation flag
          ldx index
          lda object_elevation,x
          beq walkable_set_elev
          lda #0
          sta object_elevation,x
          jmp walkable_return_no_elev
walkable_set_elev
          lda #1
          sta object_elevation,x
walkable_return_no_elev
          ; back up the old move tile
          lda move_tile_1
          sta move_tile_1_old
          lda move_tile_2
          sta move_tile_2_old
end
        return thisbank


        data walkable_jump_lo
        walkable_return_lo, test_walkable_forest_lo, test_walkable_castle_lo, test_walkable_river_lo, test_walkable_hills_lo
end

        data walkable_jump_hi
        walkable_return_hi, test_walkable_forest_hi, test_walkable_castle_hi, test_walkable_river_hi, test_walkable_hills_hi
end

check_collisions
        for index = 0 to 15
        ; bypass collision checks for blank objects and fairy familar
        if !object_type[index] then cc_next
        if object_type[index] = TYPE_F_FAIRY then cc_next
        Xposition = object_Xpos[index]
        Yposition = object_Ypos[index]
        if object_type[index] >= TYPE_STATIC then cc_door
        if object_type[index] >= TYPE_FIREBALL then magic_collision
        if player_state <> STATE_ATTACK then cc_player_contact
        gosub sword_collision
        if !object_hp[index] then kill_object
cc_player_contact
        ; need to test torches here so the sword can still damage them
        ; but they don't knock the player back on contact
        if object_type[index] = TYPE_TORCH then cc_next
        hp_change = object_damage[index]
        gosub player_knockback
        if player_state = STATE_DEATH then goto kill_player
cc_next
        next
cc_return
        return

cc_door
        ; exclude static decorations so they don't get killed on collision
        if object_type[index] < TYPE_DOOR then cc_next
        if object_type[index] >=TYPE_COIN then cc_pickup
        temp1 = Xposition - 4
        if temp1 < player_Xpos && (temp1 + 16) >= player_Xpos && Yposition < player_Ypos && (Yposition + 16) >= player_Ypos then pickup_object
        goto cc_next

cc_pickup
        if Xposition >= player_Xpos && Xposition < (player_Xpos + 12) && Yposition >= player_Ypos && Yposition < (player_Ypos + 16) then pickup_object
        goto cc_next

pickup_object
        if object_type[index] >=TYPE_COIN then playsfx sfx_strum
        if object_type[index] = TYPE_DOOR then playsfx sfx_advbite
        asm
          ldx index
          lda object_type,x
          cmp #TYPE_DOOR_LOCK
          beq pustring
          cmp #TYPE_MAP1
          bcc pudoor
          sta temp1
pustring  ldy #PICKUP_TIME
          sty pickup_timer
          ldy #1
          sty new_pickup
          sty item_pickup
          cmp #TYPE_CHARM1
          bcc puarmor
          jmp .pickup_charm
puarmor   cmp #TYPE_ARMOR1
          bcc pushield
          jmp .pickup_armor
pushield  cmp #TYPE_SHIELD1
          bcc pusword
          jmp .pickup_shield
pusword   cmp #TYPE_SWORD1
          bcc purelic
          jmp .pickup_sword
purelic   cmp #TYPE_RELIC1
          bcc puitem
          jmp .pickup_relic
puitem    cmp #TYPE_ITEM1
          bcc puspell
          jmp .pickup_item
puspell   cmp #TYPE_SPELL1
          bcc pukey
          jmp .pickup_spell
pukey     cmp #TYPE_KEY1
          bcc pumap
          jmp .pickup_key
pumap     cmp #TYPE_MAP1
          bcc pudoorl
          jmp .pickup_map
pudoorl   jmp .set_locked_string
pudoor    cmp #TYPE_DOOR
          bne pufood
          lda #TYPE_DOOR_OPEN
          sta object_type,x
          jmp .cc_next
pufood    cmp #TYPE_FOOD
          bne puprism
          lda #HP_CHANGE_FOOD
          sta hp_change
          jsr .increase_player_hp
          bne .kill_object
puprism   cmp #TYPE_PRISM
          bne pucoin
          lda #MP_CHANGE_PRISM
          sta mp_change
          jsr .increase_player_mp
pucoin
end

kill_object
        asm
          ldx index
          lda object_type,x
          cmp #TYPE_TORCH
          bne change_to_spawner
          ; torches make their tile walkable
          jsr .kill_torch
          ldx index
          bne spawner_flag
change_to_spawner
spawner_flag
          lda object_type,x
          sta object_flags,x
          lda #TYPE_SPAWNER
          sta object_type,x
spawner_done
          jmp .cc_next
end

sword_collision
        temp1 = object_flags[index]
        if temp1{0} then return thisbank
test_sword_box
        if temp1{2} then sword_bypass_elevation
        if object_elevation <> object_elevation[index] then return thisbank
sword_bypass_elevation
        if !boxcollision (sword_Xpos, sword_Ypos, sword_width, sword_height, Xposition, Yposition, 12, 16) then return thisbank
        if object_type[index] < TYPE_SPAWNER then playsfx sfx_poof2
        if object_type[index] = TYPE_SKELSWORD then playsfx sfx_gotthecoin
sword_damage
        ; TODO: Much better damage calculations
        asm
          ldx index
sword_damage_dec_invuln
          lda object_invuln,x
          ; if invuln is zero, damage object, otherwise dec invuln frames
          beq damage_object
          dec object_invuln,x
          rts

damage_object
          lda object_def,x
          cmp #255
          beq .test_slime_index
end
        temp_hp = object_hp[index]
        temp1 = temp_hp
        hp_change = player_atk - object_def[index]
        if hp_change > player_atk then hp_change = 1
        ; cursed players deal half damage
        if player_status{2} then hp_change = hp_change / 2

        ; players under fury deal double damage
        if player_status{4} then hp_change = hp_change * 2
        if hp_change < 1 then hp_change = 1
        gosub decrease_hp
        if temp1 < temp_hp then temp_hp = 0
        object_hp[index] = temp_hp
sword_damage_set_invuln
        object_invuln[index] = INVULN_FRAMES
        goto set_enemy_name

test_slime_index
        asm
          lda object_type,x
          cmp #TYPE_SLIME
          bne test_river_slime
          jmp .split_slime
test_river_slime
          cmp #TYPE_RSLIME
          bne test_hills_slime
          jmp .split_rslime
test_hills_slime
          cmp #TYPE_HSLIME
          bne not_a_slime
          jmp .split_hslime
not_a_slime
          jmp .sword_damage_set_invuln
end

kill_torch
        gosub get_torch_pos
        pointer = torch_unblock_tileset_lo[tileset]
        pointer_hi = torch_unblock_tileset_hi[tileset]
        asm
          jmp (pointer)
end
kill_torch_done
        return thisbank

enemy_sword_collision
        temp1 = player_Xpos + 2
        temp2 = player_Ypos + 1
        asm
          ldx index
          lda object_facing,x
          tay
          dey
          lda sword_widths,y
          sta temp3
          lda sword_heights,y
          sta temp4
end
        if boxcollision(Xposition, Yposition, temp3, temp4, temp1, temp2, 9, 14) then goto pc_damage
        return thisbank

        data sword_widths
        3, 3, 12, 12
end

        data sword_heights
        16, 16, 3, 3
end


player_knockback
        ; projectiles should always test box so they are destroyed even by invulnerable player
        if object_type[index] >= TYPE_DARKSPARK then test_player_box
        if player_flags{0}         then return thisbank ; player is invulnerable, bypass collision check to save cycles
        asm
          ldx index
          lda object_flags,x
          ; tests object invunerablility flag
          lsr
          bcc .test_player_box
          rts
end
test_player_box
        ; enemies can only hit player when on same elevation unless flying
        if object_elevation[index] <> object_elevation && !flags{2} then return
        if object_type[index] = TYPE_SKELSWORD then goto enemy_sword_collision
        temp1 = player_Xpos + 2
        temp2 = player_Ypos + 1
        temp3 = Xposition + 3
        temp4 = Yposition + 2
        if !boxcollision (player_Xpos, player_Ypos, 9, 14, temp3, temp4, 7, 12) then return
;        if Yposition <= player_Ypos then player_Yvel = 10.0 : player_Ydir = DIR_DOWN  : player_frame = FRAME_UP    : goto pc_damage
;        if Yposition >= player_Ypos then player_Yvel = 10.0 : player_Ydir = DIR_UP    : player_frame = FRAME_DOWN  : goto pc_damage
;        if Xposition >= player_Xpos then player_Xvel = 5.0 : player_Xdir = DIR_LEFT  : player_frame = FRAME_RIGHT : goto pc_damage
;        if Xposition <= player_Xpos then player_Xvel = 5.0 : player_Xdir = DIR_RIGHT : player_frame = FRAME_LEFT

        ;  check player's shield and destroy projectile
        if object_type[index] >= TYPE_DARKSPARK then shield_check
player_knockback_status
        ; TODO: reorder objects to add ranges for inflicting status effects
        asm
          ldx index
          lda object_type,x
          cmp #TYPE_SLIME
          beq set_poison_status
          cmp #TYPE_MSLIME
          beq set_poison_status
          cmp #TYPE_RSLIME
          beq set_poison_status
          cmp #TYPE_MRSLIME
          beq set_poison_status
          cmp #TYPE_HSLIME
          beq set_poison_status
          cmp #TYPE_MHSLIME
          beq set_poison_status
          cmp #TYPE_SPIDER
          beq set_poison_status
          cmp #TYPE_GHOST
          beq set_curse_status
          cmp #TYPE_RGHOST
          beq set_curse_status
          cmp #TYPE_HGHOST
          beq set_curse_status
          jmp .pc_damage

set_poison_status
          lda #BITS_POISON
          bne set_status_temp
set_curse_status
          lda #BITS_CURSE
set_status_temp
          sta temp1
          jsr .set_status
          jmp .pc_damage
end


pc_damage
        if player_flags{0} then return thisbank
        player_flags{0} = 1
        player_state = STATE_KNOCKBACK
        player_timer = INVULN_FRAMES

        ; moved damage subroutine here to avoid a goto
damage_player_hp
        ; TODO: This currently can't scale, only works with max HP 48...
        dec temp1 = player_hp        ; temp1 used to detect underflow
        dec temp2 = hp_change
        dec temp3 = player_def
        ; players under fury have quarter defense
        if player_status{4} then temp3 = temp3 / 4
        dec hp_change = hp_change - temp3
        ; don't want total immunity to damage, that's boring!
        if hp_change > temp2 then hp_change = 1
        dec player_hp = player_hp - hp_change
        if player_hp > temp1 then player_hp = 0

update_hp_bar
        dec temp1 = player_hp
        dec hp_seg_1 = player_hp
        if hp_seg_1 > temp1 then hp_seg_1 = 0
        dec temp1 = hp_seg_1
        dec hp_seg_2 = hp_seg_1 - 8
        if hp_seg_2 > temp1 then hp_seg_2 = 0
        dec temp1 = hp_seg_2
        dec hp_seg_3 = hp_seg_2 - 8
        if hp_seg_3 > temp1 then hp_seg_3 = 0
        dec temp1 = hp_seg_3
        dec hp_seg_4 = hp_seg_3 - 8
        if hp_seg_4 > temp1 then hp_seg_4 = 0
        dec temp1 = hp_seg_4
        dec hp_seg_5 = hp_seg_4 - 8
        if hp_seg_5 > temp1 then hp_seg_5 = 0
        dec temp1 = hp_seg_5
        dec hp_seg_6 = hp_seg_5 - 8
        if hp_seg_6 > temp1 then hp_seg_6 = 0
        if hp_seg_6 > 8 then hp_seg_6 = 8
        if hp_seg_5 > 8 then hp_seg_5 = 8
        if hp_seg_4 > 8 then hp_seg_4 = 8
        if hp_seg_3 > 8 then hp_seg_3 = 8
        if hp_seg_2 > 8 then hp_seg_2 = 8
        if hp_seg_1 > 8 then hp_seg_1 = 8
        hp_bar_1 = (hp_seg_1 * 2) + BAR_OFFSET
        hp_bar_2 = (hp_seg_2 * 2) + BAR_OFFSET
        hp_bar_3 = (hp_seg_3 * 2) + BAR_OFFSET
        hp_bar_4 = (hp_seg_4 * 2) + BAR_OFFSET
        hp_bar_5 = (hp_seg_5 * 2) + BAR_OFFSET
        hp_bar_6 = (hp_seg_6 * 2) + BAR_OFFSET


        if player_hp = 0 then player_state = STATE_DEATH
        return

shield_check
        ; copy the projectile's type to its flags for status effects
        flags = object_type[index]
        ; TODO: projectile properties, maybe some shouldn't be destroyed on contact?
        object_type[index] = 0
        ; if the player doesn't have a shield or they aren't standing still, damage the player
        if !player_shield || player_state <> STATE_STAND then goto projectile_status
        ; TODO: different shield properties
        if player_facing = DIR_UP && object_facing[index]    = DIR_DOWN  then deflect_projectile
        if player_facing = DIR_DOWN && object_facing[index]  = DIR_UP    then deflect_projectile
        if player_facing = DIR_LEFT && object_facing[index]  = DIR_RIGHT then deflect_projectile
        if player_facing = DIR_RIGHT && object_facing[index] = DIR_LEFT  then deflect_projectile

projectile_status
        ; hardcode Octoink to set dark status for now
        if flags = TYPE_OCTOINK then temp1 = BITS_DARK : gosub set_status
        goto pc_damage

deflect_projectile
        playsfx sfx_gotthecoin
        return thisbank

set_status
        asm
          lda player_status
          ora temp1
          sta player_status
          rts
end

increase_player_hp
        dec player_hp = player_hp + hp_change
        if player_hp > player_max_hp then player_hp = player_max_hp
        hp_change = 0
        goto update_hp_bar

increase_player_mp
        dec player_mp = player_mp + mp_change
        if player_mp > player_max_mp then player_mp = player_max_mp
        goto update_mp_bar

decrease_player_mp
        ; TODO: This currently can't scale, only works with max HP 48...
        dec temp1 = player_mp        ; temp1 used to detect underflow
        dec player_mp = player_mp - mp_change
        if player_mp > temp1 then player_mp = 0

update_mp_bar
        mp_change = 0
        dec temp1 = player_mp
        dec mp_seg_1 = player_mp
        if mp_seg_1 > temp1 then mp_seg_1 = 0
        dec temp1 = mp_seg_1
        dec mp_seg_2 = mp_seg_1 - 8
        if mp_seg_2 > temp1 then mp_seg_2 = 0
        dec temp1 = mp_seg_2
        dec mp_seg_3 = mp_seg_2 - 8
        if mp_seg_3 > temp1 then mp_seg_3 = 0
        dec temp1 = mp_seg_3
        dec mp_seg_4 = mp_seg_3 - 8
        if mp_seg_4 > temp1 then mp_seg_4 = 0
        dec temp1 = mp_seg_4
        dec mp_seg_5 = mp_seg_4 - 8
        if mp_seg_5 > temp1 then mp_seg_5 = 0
        dec temp1 = mp_seg_5
        dec mp_seg_6 = mp_seg_5 - 8
        if mp_seg_6 > temp1 then mp_seg_6 = 0
        if mp_seg_6 > 8 then mp_seg_6 = 8
        if mp_seg_5 > 8 then mp_seg_5 = 8
        if mp_seg_4 > 8 then mp_seg_4 = 8
        if mp_seg_3 > 8 then mp_seg_3 = 8
        if mp_seg_2 > 8 then mp_seg_2 = 8
        if mp_seg_1 > 8 then mp_seg_1 = 8

        mp_bar_1 = (mp_seg_1 * 2) + BAR_OFFSET
        mp_bar_2 = (mp_seg_2 * 2) + BAR_OFFSET
        mp_bar_3 = (mp_seg_3 * 2) + BAR_OFFSET
        mp_bar_4 = (mp_seg_4 * 2) + BAR_OFFSET
        mp_bar_5 = (mp_seg_5 * 2) + BAR_OFFSET
        mp_bar_6 = (mp_seg_6 * 2) + BAR_OFFSET
        return thisbank

test_spell_cost
        if mp_change < player_mp then return
        ; routines can test if mp_change is 0 after calling this subroutine
        mp_change = 0
        return

increase_hp
        temp_hp = temp_hp + hp_change
        return

decrease_hp
        temp_hp = temp_hp - hp_change
        return

; takes a torch's X & Y position and determines the map tile under it, stores in peekX & Y
get_torch_pos
get_object_pos
        asm
        ldx index
        lda object_Xpos,x
        clc
        adc #4          ; forces X calculation onto correct map tile
        lsr
        lsr
        lsr
        sta peekX
        lda object_Ypos,x
        clc
        adc #8          ; forces Y calculation onto correct map tile
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        return thisbank