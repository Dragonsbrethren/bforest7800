;==============================================================================
; BANK 17
;------------------------------------------------------------------------------
; Permanently loaded bank. Contains sprites and code used with every tileset
;==============================================================================
        bank 17
        incbasic shared_gfx.78b

;==============================================================================
; LOAD OBJECTS
;------------------------------------------------------------------------------
; Fills all 16 object slots with type and position data from ROM,
; then interates through each type to set object properties
; Utilizes pointers so multiple maps can reuse the same object data if desired
;==============================================================================
load_objects
        asm
        ldx #MAX_OBJECTS
        lda #0
clear_obj_loop
        sta object_type,x
        sta object_Xpos,x
        sta object_Ypos,x
        sta object_Xvel_lo,x
        sta object_Xvel_hi,x
        sta object_Yvel_lo,x
        sta object_Yvel_hi,x
        sta object_Xdir,x
        sta object_Ydir,x
        sta object_facing,x
        sta object_frame,x
        sta object_state,x
        sta object_speed_lo,x
        sta object_speed_hi,x
        sta object_vel_cap_lo,x
        sta object_vel_cap_hi,x
        sta object_friction_lo,x
        sta object_friction_hi,x
        sta object_hp,x
        sta object_damage,x
        sta object_elem_atk,x
        sta object_def,x
        sta object_mdef,x
        sta object_elem_def,x
        sta object_parent,x
        sta object_flags,x
        sta object_timer,x
        sta object_dest,x
        sta object_hop_dir,x
        sta object_pal,x
        dex
        bne clear_obj_loop
        sta temp1
        ; failsafe for objects without sprite pointer
        lda #<.plot_next
        sta object_spr_ptr_lo,x
        lda #>.plot_next
        sta object_spr_ptr_hi,x
end
        for obj_index = 1 to MAX_OBJECTS
        object_type[obj_index] = pointer[[temp1]]
        if !object_type[obj_index] then object_stats
        temp1 = temp1 + 1
        object_Xpos[obj_index] = pointer[[temp1]]
        temp1 = temp1 + 1
        object_Ypos[obj_index] = pointer[[temp1]]
        temp1 = temp1 + 1
        next
        ; TODO: pointer table for stats as well
object_stats
        for obj_index = 1 to MAX_MAP_OBJECTS
        if !object_type[obj_index] then next_obj_stats
        if object_type[obj_index] = TYPE_WOLF then obj_wolf_stats
        if object_type[obj_index] = TYPE_TORCH then obj_torch_stats
        if object_type[obj_index] = TYPE_SLIME then obj_slime_stats
        if object_type[obj_index] = TYPE_MSLIME then obj_slime_stats : object_hp[obj_index] = MSLIME_HP : object_def[obj_index] = MSLIME_DEF
        if object_type[obj_index] = TYPE_RSLIME then obj_redslime_stats
        if object_type[obj_index] = TYPE_MRSLIME then obj_redslime_stats : object_hp[obj_index] = MRSLIME_HP : object_def[obj_index] = MRSLIME_DEF
        if object_type[obj_index] = TYPE_RAVEN then obj_raven_stats
        if object_type[obj_index] = TYPE_PRIEST then obj_priest_stats
        if object_type[obj_index] = TYPE_SKELETON then obj_skel_stats
        if object_type[obj_index] = TYPE_GHOST then obj_ghost_stats
        if object_type[obj_index] = TYPE_MERMAN then obj_nix_stats


obj_next_stats
        next
        return

obj_torch_stats
        object_hp[obj_index] = 1
        asm
          ldx obj_index
          lda #<.plot_torch
          sta object_spr_ptr_lo,x
          lda #>.plot_torch
          sta object_spr_ptr_hi,x
end
        goto obj_next_stats

load_map
        clearscreen
        displaymode 160A
        adjustvisible 0 14
        if tileset = T_FOREST then gosub load_forest bank2
        if tileset = T_CASTLE then gosub load_castle bank4
        if tileset = T_RIVER  then gosub load_river bank6

        gosub draw_hud
draw_pickup_hud
        Xposition = 36
        for index = 0 to 13
        Xposition = Xposition + 6                  
        
        PLOTSPRITE font_spr 0 Xposition 208 0
        next
map_loaded
        savescreen
        gosub update_hp_bar
        gosub update_mp_bar
        if !save_objects then gosub load_objects
        asm
        lda #0
        sta reload_map
        sta save_objects
end
        if exit_dir = EXIT_SOUTH then player_Ypos = 16  : player_Ydir = DIR_DOWN
        if exit_dir = EXIT_NORTH then player_Ypos = 176 : player_Ydir = DIR_UP
        if exit_dir = EXIT_EAST  then player_Xpos = 148 : player_Xdir = DIR_LEFT
        if exit_dir = EXIT_WEST  then player_Xpos = 8  : player_Xdir = DIR_RIGHT
        exit_dir = EXIT_NONE

field_handler
        if reload_map = 1 then goto load_map

        goto player_handler
player_handler_done
        gosub object_handler
        ; set by close menu, needed to make torches block movement after menu access
        torch_reblock = 0
        gosub check_collisions
        gosub remove_duplicates

        if !lightning_timer then no_lightning
        if tileset = T_CASTLE then goto castle_lightning
no_lightning
        if tileset = T_CASTLE then goto castle_pals

lightning_done

set_pickup_string
        if pickup_timer then get_pickup_string

pickup_clear
        for index = 0 to 13
        pickup_string[index] = 0
        next
        item_pickup = 0
        goto pickup_done

get_pickup_string
        pickup_timer = pickup_timer - 1
        if !new_pickup then pickup_done
        ; set pickup string based on pickup pointer
        for index = 0 to 13
        pickup_string[index] = pickup_ptr[[index]]
        if !pickup_string[index] then pickup_pad
        next

pickup_pad
        ; now pad with blanks to 16 chars
        temp1 = index
        if temp1 = 13 then pickup_done
        for index = temp1 to 13
        pickup_string[index] = 0
        next

pickup_center

pickup_done
        new_pickup = 0

        restorescreen
        gosub update_pickup_objs

plot_objects
        if debug_time then BACKGRND = $06
        ; Iterates through all objects and determines which sprites need to be plotted by type
        asm
          ldx #MAX_OBJECTS
          stx index
plot_loop
          lda object_type,x
          sta plot_index
        ; first rule out zero objects (player handled separately)
        ; and spawners, which do not need to be plotted
          bne tp_spawn
          jmp .plot_next
tp_spawn  cmp #TYPE_SPAWNER
          bne plot_stats
end

plot_next
        asm
        ; restore X, decrease, and back up
          ldx index
          dex
          stx index
          bne plot_loop
          jmp plot_done

plot_stats
        ; now copy object stats to zeropage
          lda object_spr_ptr_lo,x
          sta pointer
          lda object_spr_ptr_hi,x
          sta pointer_hi
          lda object_Xpos,x
          sta Xposition
          lda object_Ypos,x
          sta Yposition
          lda object_frame,x
          sta frame
          lda object_pal,x
          sta sprite_pal
        ; restore the object type and do this comparison code
          lda plot_index
          cmp #TYPE_STATIC
          ; TODO: set spr_ptr for all object types, not just ones with stats
          bcs plot_items
          jmp (pointer)

plot_items
tp_charm  cmp #TYPE_CHARM1
          bcc tp_armor
          jmp .plot_charms
tp_armor  cmp #TYPE_ARMOR1
          bcc tp_shield
          jmp .plot_armor
tp_shield cmp #TYPE_SHIELD1
          bcc tp_sword
          jmp .plot_shields
tp_sword  cmp #TYPE_SWORD1
          bcc tp_item
          jmp .plot_swords
tp_item   cmp #TYPE_ITEM1
          bcc tp_coin
          jmp .plot_items
tp_coin   cmp #TYPE_COIN
          bne tp_prism
          jmp .plot_coin
tp_prism  cmp #TYPE_PRISM
          bne tp_blood
          jmp .plot_prism
tp_blood  cmp #TYPE_BLOOD
          bne tp_food
          jmp .plot_blood
tp_food   jmp .plot_food

plot_done
end
        goto plot_player

plot_torch
        PLOTSPRITE torch0 0 Xposition Yposition frame
        goto plot_next

plot_coin
        plotsprite coin 3 Xposition Yposition 0
        goto plot_next

plot_prism
        plotsprite prism 0 Xposition Yposition 0
        goto plot_next

plot_food
        plotsprite chimkin 1 Xposition Yposition 0
        goto plot_next

plot_items
        temp1 = object_type[index] - (TYPE_ITEM1 - 1)
        sprite_pal = f_item_pals[temp1]
        plotsprite potion0 sprite_pal Xposition Yposition 0
        goto plot_next

plot_swords
        temp1 = object_type[index] - (TYPE_SWORD1 - 1)
        sprite_pal = f_sword_pals[temp1]
        plotsprite sword0 sprite_pal Xposition Yposition 0
        goto plot_next

plot_shields
        temp1 = object_type[index] - (TYPE_SHIELD1 - 1)
        sprite_pal = f_shield_pals[temp1]
        plotsprite shield0 sprite_pal Xposition Yposition 0
        goto plot_next

plot_armor
        temp1 = object_type[index] - (TYPE_ARMOR1 - 1)
        sprite_pal = f_armor_pals[temp1]
        plotsprite armor0 sprite_pal Xposition Yposition 0
        goto plot_next

plot_charms
        temp1 = object_type[index] - (TYPE_CHARM1 - 1)
;        plotsprite charm0 sprite_pal Xposition Yposition 0
;        goto plot_next

plot_rosary
        sprite_pal = f_charm_pals[temp1]
        plotsprite rosary sprite_pal Xposition Yposition 0
        goto plot_next

plot_fireball
        plotsprite fireball0 2 Xposition Yposition frame
        goto plot_next


;==============================================================================
; DRAW HUD
;------------------------------------------------------------------------------
; Draws the player's HP and MP bar in zones 1-2 using sprites.
; Bars must be plotted in separate zones or there isn't enough DMA time
;==============================================================================
draw_hud
        plotsprite  hp   0  8  0       ; HP is 160B
        ; prep plot_par to draw the rest of the HP segments
        Xposition = 24
        asm
        lda #0
        sta Yposition
        sta temp1
end
        temp2 = 5
        temp3 = (2 * 32)
        gosub plot_bar
        plotsprite  mp   0  8 16        ; Need to use plotsprite here to avoid rendering error on MP bar
        ; prep plot_bar for MP bar
        Xposition = 24
        Yposition = 16
        temp1 = 6
        temp2 = 11
        temp3 = 0
        ; code runs directly into 
plot_bar
        for index = temp1 to temp2
        frame = hp_seg_1[index]
        PLOTSPRITE bar0 temp3 Xposition Yposition frame
        Xposition = Xposition + 8
        next
        return thisbank

plot_debug_hud
        if tileset = T_CASTLE then plot_hud_castle
        ; plotvalue hud 0 player_hp 2 72 0
        ; plotvalue hud 0 player_mp 2 72 1
        plotvalue hud 0 player_Xpos 4 32 12
        plotvalue hud2 0 move_tile_1 4 32 11
        ; plotvalue hud 0 room_index 2 32 13
        ; plotvalue hud 0 room 2 48 13
        plotvalue hud 0 input_buffer 16 16 13
        ; plotvalue hud 0 chant_input 2 8 13
        ; plotvalue hud 0 retract_counter 2 64 13
        return

plot_hud_castle
        plotvalue castle_hud 0 player_Xpos 2 32 12
        plotvalue castle_hud 0 player_Ypos 2 48 12
        plotvalue castle_hud 0 move_tile_1 4 32 13
        return

open_menu
        gosub clear_palettes
        ; TODO: Should previously opened submenu be remembered?
        menu = MENU_MAIN
        menu_debounce = 1
        pause_debounce = 1
        goto menu_init bank3

followplayer
        if Xposition > player_Xpos then Xvelocity = Xvelocity + move_speed : Xdirection = DIR_LEFT
        if Xposition < player_Xpos then Xvelocity = Xvelocity + move_speed : Xdirection = DIR_RIGHT
        if Yposition > player_Ypos then Yvelocity = Yvelocity + move_speed : Ydirection = DIR_UP
        if Yposition < player_Ypos then Yvelocity = Yvelocity + move_speed : Ydirection = DIR_DOWN
        return thisbank

get_player_pos
        Xdestination = player_Xpos : Ydestination = player_Ypos
        return

get_player_dir
        Xdirection = player_Xdir
        Ydirection = player_Ydir
        return

go_to_destination
        if Xposition > Xdestination then Xvelocity = Xvelocity + move_speed : Xdirection = DIR_LEFT
        if Xposition < Xdestination then Xvelocity = Xvelocity + move_speed : Xdirection = DIR_RIGHT
        if Yposition > Ydestination then Yvelocity = Yvelocity + move_speed : Ydirection = DIR_UP
        if Yposition < Ydestination then Yvelocity = Yvelocity + move_speed : Ydirection = DIR_DOWN
        if Xposition = Xdestination then flags{3} = 0
        if Yposition = Ydestination then flags{3} = 0
        return

swoop_X
        return

swoop_Y
        return

;==============================================================================
; TEST MELEE
;------------------------------------------------------------------------------
; Can object hit player with melee attack?
; ** temp1: object X to left of player
; ** temp2: object X to right of player
; ** temp3: incremented on each successful melee range check
; ** temp4: object Y above player
; ** temp5: object Y below player
; ** temp6: if set, player within melee range
;==============================================================================
test_melee
        temp6 = 0
        if object_facing[index] = DIR_UP then melee_up
        if object_facing[index] = DIR_DOWN then melee_down
        if object_facing[index] = DIR_LEFT then melee_left
melee_right
        temp1 = Xposition
        temp2 = Xposition + 16
        temp4 = Yposition - 8
        temp5 = Yposition + 16
        goto melee_range

melee_up
        temp1 = Xposition - 4
        temp2 = Xposition + 8
        temp4 = Yposition
        temp5 = Yposition - 24
        goto melee_range

melee_down
        temp1 = Xposition - 4
        temp2 = Xposition + 8
        temp4 = Yposition + 24
        temp5 = Yposition
        goto melee_range

melee_left
        temp1 = Xposition - 16
        temp2 = Xposition
        temp4 = Yposition - 8
        temp5 = Yposition + 16

melee_range
        if player_Xpos >= temp1 && player_Xpos < temp2 then temp3 = 1
        if player_Ypos >= temp4 && player_Ypos < temp5 then temp3 = temp3 + 1
        if temp3 > 1 then temp6 = 1
        return

;==============================================================================
; POSITION SWORD
;------------------------------------------------------------------------------
; Same as player code (can probably be shared with some tweaks)
;-=============================================================================
position_sword
        if object_facing[index] = DIR_DOWN then pos_swd_down
        if object_facing[index] = DIR_UP then pos_swd_up
        if object_facing[index] = DIR_LEFT then pos_swd_left

pos_swd_right
        temp1 = object_Xpos[index] + SWORD_OFFSET_RIGHT
        temp2 = object_Ypos[index]
        ;temp3 = 12
        ;temp4 = 4
        temp5 = 2
        return

pos_swd_down
        temp1 = object_Xpos[index]
        temp2 = object_Ypos[index] + SWORD_OFFSET_DOWN
        ;temp3 = 4
        ;temp4 = 16
        temp5 = 0
        return

pos_swd_up
        temp1 = object_Xpos[index]
        temp2 = object_Ypos[index] + SWORD_OFFSET_UP
        ;temp3 = 4
        ;temp4 = 16
        temp5 = 1
        return

pos_swd_left
        temp1 = object_Xpos[index] + SWORD_OFFSET_LEFT
        temp2 = object_Ypos[index]
        ;temp3 = 12
        ;temp4 = 4
        temp5 = 3
        return

object_handler
        for index = 1 to 15
        if !object_type[index] then object_done    ; 0 = no object
        if object_type[index] >= TYPE_STATIC then object_done      ;  coins, prisms are static
        if object_type[index] = TYPE_SPAWNER then spawn_object
        if object_type[index] = TYPE_TORCH then torch_tile_block
        gosub copy_object_props 
        if flags{5} then gosub ledge_hop : goto object_restore
        gosub decelerate_object
        if object_type[index] = TYPE_SKELSWORD then gosub skelsword_ai
        if object_type[index] = TYPE_WOLF then gosub wolf_ai
        if object_type[index] = TYPE_SLIME then gosub slime_ai
        if object_type[index] = TYPE_MSLIME then gosub slime_ai
        if object_type[index] = TYPE_RSLIME then gosub redslime_ai
        if object_type[index] = TYPE_MRSLIME then gosub redslime_ai
        if object_type[index] = TYPE_RAVEN then gosub raven_ai
        if object_type[index] = TYPE_PRIEST then gosub priest_ai
        if object_type[index] = TYPE_SKELETON then gosub priest_ai
        if object_type[index] = TYPE_FIREBALL then gosub fireball_ai
        if object_type[index] = TYPE_DARKSPARK then gosub fireball_ai
        if object_type[index] = TYPE_GHOST then gosub ghost_ai
        if object_type[index] = TYPE_MERMAN then gosub nix_ai
        gosub move_object
object_restore
        gosub restore_object_props
object_done
        next
        return

;==============================================================================
; FIREBALL AI
;------------------------------------------------------------------------------
; Fireballs poof out of existence when velocities = 0
;==============================================================================
fireball_ai
        if Xvelocity then fireball_animate
        if Yvelocity then fireball_animate
        object_type[index] = 0
        return thisbank
fireball_animate
        frame = 0
        if animation_frame then frame = 1
fireball_done
        return thisbank


torch_tile_block
        ; flags are used to track if the tile has already been blocked
        ; however, this fails when the map reloads after the menu is opened
        if torch_reblock then goto torch_tile_block_get_pos
        temp1 = animation_frame
        if tileset = T_CASTLE then temp1 = temp1 + 2
        object_frame[index] = temp1
        if object_flags[index] then object_done
torch_tile_block_get_pos
        gosub get_torch_pos
        if tileset = T_FOREST then gosub torch_tile_block_forest
        if tileset = T_CASTLE then gosub torch_tile_block_castle
        if tileset = T_RIVER then gosub torch_tile_block_river
        object_flags[index] = %10000000
        goto object_done

spawn_object
        asm
        ; index is still set by object_handler
          ldx index
        ; spawner objects store old type in flags
          lda object_flags,x
        ; exclude projectiles and collectible objects
          bmi spawn_nothing
        ; save old type in y for drop indexing
          tay
        ; torches have special logic for changing drops
          cmp #TYPE_TORCH
          beq .spawns_torch
        ; zero Ypos lower nibble to avoid gfx glitch
          lda object_Ypos,x
          and #$F0
          sta object_Ypos,x
          jsr randomize
          cmp #RARE_DROP_RATE
          bcs spawn_rare
          cmp #COMMON_DROP_RATE
          bcs spawn_common
spawn_nothing
          lda #0
          sta object_type,x
          jmp .object_done

spawn_rare
          lda rare_drops,y
          sta object_type,x
          jmp .object_done

spawn_common
          lda common_drops,y
          sta object_type,x
          jmp .object_done
end


spawns_torch
        if player_hp = player_max_hp then torch_mp_check
        if rand > 128 then _spawn_food
torch_mp_check
        if player_mp = player_max_mp then _spawn_coin
        goto _spawn_mana

_spawn_food
        object_type[index] = TYPE_FOOD
        object_hp[index] = 1
        goto object_done

_spawn_mana
        object_type[index] = TYPE_PRISM
        object_hp[index] = 1
        goto object_done

_spawn_coin
        object_type[index] = TYPE_COIN
        object_hp[index] = 1
        goto object_done

        data rare_drops
        0               ; player
        0               ; torch (handled separately)
        TYPE_POTION     ; wolf
        TYPE_HIPOTION   ; warg
        TYPE_HIPOTION   ; merman
        TYPE_HIPOTION   ; octopus
        TYPE_HIETHER    ; slime
        TYPE_HIETHER    ; mini-slime
        TYPE_POTION     ; raven
        TYPE_CHARM2     ; priest
        TYPE_SWORD2     ; skeleton
        TYPE_HIETHER    ; red slime
        0               ; mini red slime
        TYPE_HIETHER    ; ghost
end

        data common_drops
        0               ; player
        0               ; torch (handled separately)
        TYPE_FOOD       ; wolf
        TYPE_FOOD       ; warg
        TYPE_FOOD       ; merman
        TYPE_FOOD       ; octopus
        TYPE_ANTIDOTE   ; slime
        TYPE_ANTIDOTE   ; mini-slime
        TYPE_FOOD       ; raven
        TYPE_ETHER      ; priest
        TYPE_SHIELD2    ; skeleton
        TYPE_ANTIDOTE   ; red slime
        0               ; mini red slime
        TYPE_UNCURSE    ; ghost
end

player_handler
        ; TODO: saving cutscene
        if in_save_room then goto save_room_handler
        if player_state = STATE_DEATH then goto death_fade
;        gosub copy_player_props
        index = 0 : gosub decelerate_player
;        gosub restore_player_props

;==============================================================================
; SUBROUTINE: HANDLE INPUT FIELD
;------------------------------------------------------------------------------
; This routine handles all player input in the field
;==============================================================================
handle_input_field
        if !player_flags{5} then player_no_hop
        index = 0
        gosub copy_player_props
        gosub ledge_hop
        gosub restore_player_props
        goto test_joy_done
player_no_hop
        ; player timer is set for knockback and attack timing
        if !player_timer then no_player_timer
        player_timer = player_timer - 1
        if player_state = STATE_ATTACK then test_joy_done
        if player_flags{0} then player_test_state

no_player_timer
        player_flags{0} = 0     ; clear invulnerability flag

;------------------------------------------------------------------------------
        ; handles chanting and sword retracting. Zero if not doing these
player_test_state
        if player_state = STATE_CHANT then chant_handler
        if player_state = STATE_ATTACK then retract_sword
        if joy0fire0 && action_button = 0 then goto player_attack
        if joy0fire1 && action_button = 1 then goto player_attack

        asm
        lda #0
        sta retract_counter
        sta chant_timer
        sta player_state        ; STATE_STAND
        sta player_exiting_chant
        sta sword_hit
end

;------------------------------------------------------------------------------

        if player_facing = DIR_UP then player_frame = FRAME_UP : goto frames_done
        if player_facing = DIR_DOWN then player_frame = FRAME_DOWN : goto frames_done
        if player_facing = DIR_LEFT then player_frame = FRAME_LEFT : goto frames_done
        player_frame = FRAME_RIGHT

frames_done
        if joy0up    then player_Ydir = DIR_UP    : player_facing = DIR_UP    : player_frame = FRAME_UP    : player_Yvel = player_Yvel + player_speed : player_state = STATE_MOVING : test_joy_done
        if joy0down  then player_Ydir = DIR_DOWN  : player_facing = DIR_DOWN  : player_frame = FRAME_DOWN  : player_Yvel = player_Yvel + player_speed : player_state = STATE_MOVING : test_joy_done
        if joy0left  then player_Xdir = DIR_LEFT  : player_facing = DIR_LEFT  : player_frame = FRAME_LEFT  : player_Xvel = player_Xvel + player_speed : player_state = STATE_MOVING : test_joy_done
        if joy0right then player_Xdir = DIR_RIGHT : player_facing = DIR_RIGHT : player_frame = FRAME_RIGHT : player_Xvel = player_Xvel + player_speed : player_state = STATE_MOVING : test_joy_done

test_joy_done
        if !menu_debounce && joy0fire0 && action_button = 1 then goto open_menu
        if !menu_debounce && joy0fire1 && action_button = 0 then goto open_menu
        if !pause_debounce && switchpause then goto open_menu
        if player_state = STATE_STAND || player_state = STATE_ATTACK then player_move_done
        if player_flags{5} then player_move_done
        index = 0 : gosub copy_player_props
        gosub move_object
        gosub restore_player_props

player_move_done

        shield_Xpos = player_Xpos + SHIELD_OFFSET_X
        shield_Ypos = player_Ypos + SHIELD_OFFSET_Y

input_frame_done
        if !player_Xvel && !player_Yvel && player_state <> STATE_ATTACK && player_state <> STATE_CHANT then player_state = STATE_STAND
        if animation_frame && player_state = STATE_MOVING then player_frame = player_frame + 1

check_room_boundary
        if player_Xpos < 2  then exit_dir = EXIT_EAST  : room_index = room_index - 1 : menu_map_Xpos = menu_map_Xpos - 8
        if player_Xpos > 149 then exit_dir = EXIT_WEST  : room_index = room_index + 1 : menu_map_Xpos = menu_map_Xpos + 8
        if player_Ypos < 2  then exit_dir = EXIT_NORTH : room_index = room_index - ROOMS_PER_ROW : menu_map_Ypos = menu_map_Ypos - 16
        if player_Ypos > 188 then exit_dir = EXIT_SOUTH : room_index = room_index + ROOMS_PER_ROW : menu_map_Ypos = menu_map_Ypos + 16
        if exit_dir then reload_map = 1
        goto player_handler_done

player_attack
        sword_hit = 0
        ; player exiting chant tracks if the player cast magic to exit chant with button held
        if player_exiting_chant then test_joy_done
        if retract_counter then retract_sword
        if player_facing = DIR_DOWN then sword_Xpos = player_Xpos : sword_Ypos = player_Ypos + SWORD_OFFSET_DOWN : sword_width = 4 : sword_height = 16 : sword_frame = 0 : goto sword_done
        if player_facing = DIR_UP   then sword_Xpos = player_Xpos : sword_Ypos = player_Ypos + SWORD_OFFSET_UP   : sword_width = 4 : sword_height = 16 : sword_frame = 1 : goto sword_done
        if player_facing = DIR_LEFT then sword_Xpos = player_Xpos + SWORD_OFFSET_LEFT : sword_Ypos = player_Ypos : sword_width = 12 : sword_height = 4 :sword_frame = 3 : goto sword_done
        sword_Xpos = player_Xpos + SWORD_OFFSET_RIGHT : sword_Ypos = player_Ypos : sword_width = 12 : sword_height = 4 : sword_frame = 2
sword_done
        if player_facing = DIR_LEFT  then player_frame = FRAME_ATK_L : goto player_attack_return
        if player_facing = DIR_RIGHT then player_frame = FRAME_ATK_R : goto player_attack_return
        if player_facing = DIR_UP    then player_frame = FRAME_ATK_U : goto player_attack_return
        if player_facing = DIR_DOWN  then player_frame = FRAME_ATK_D

player_attack_return
        player_state = STATE_ATTACK
        player_timer = ATTACK_FRAMES
        goto player_handler_done

retract_sword
        if player_facing = DIR_DOWN  then sword_Ypos = sword_Ypos - 4 : retract_step_done
        if player_facing = DIR_UP    then sword_Ypos = sword_Ypos + 4 : retract_step_done
        if player_facing = DIR_LEFT  then sword_Xpos = sword_Xpos + 2 : retract_step_done
        if player_facing = DIR_RIGHT then sword_Xpos = sword_Xpos - 2

retract_step_done
        retract_counter = retract_counter + 1
        if retract_counter < 3 then test_joy_done

retract_stand
        if !joy0fire0 && action_button = 0 then player_state = STATE_STAND : goto test_joy_done
        if !joy0fire1 && action_button = 1 then player_state = STATE_STAND : goto test_joy_done
        ; retract finished and button still held - code runs into player_chant_start

player_chant_start
        if chant_timer > CHANT_START_TIME then set_state_chant
        player_state = STATE_CHANT_START
        asm
        inc chant_timer
end
        if player_facing = DIR_UP    then player_frame = FRAME_UP
        if player_facing = DIR_DOWN  then player_frame = FRAME_DOWN
        if player_facing = DIR_LEFT  then player_frame = FRAME_LEFT
        if player_facing = DIR_RIGHT then player_frame = FRAME_RIGHT
        goto test_joy_done

set_state_chant
        ; set player state to chant and facing direction to down
        ; facing down when coming out of chant just feels more natural
        player_state = STATE_CHANT
        player_facing = DIR_DOWN
        player_frame = FRAME_CHANT

chant_handler
        if debug_time = 1 then BACKGRND = $B9

        if !joy0fire0 && action_button = 0 then chant_done_no_hold
        if !joy0fire1 && action_button = 1 then chant_done_no_hold

        ; chant_new_input is set when a direction is pressed
        if chant_new_input then chant_input_test_release

        ; parse the most recent directional entered and test for combos
        if input_buffer[chant_index] = DIR_UP    then chant_spells_up
        if input_buffer[chant_index] = DIR_DOWN  then chant_spells_down
        if input_buffer[chant_index] = DIR_LEFT  then chant_spells_left
        if input_buffer[chant_index] = DIR_RIGHT then chant_spells_right

chant_test_dirs
        if joy0left  then chant_input = DIR_LEFT  : chant_new_input = 1
        if joy0right then chant_input = DIR_RIGHT : chant_new_input = 1
        if joy0up    then chant_input = DIR_UP    : chant_new_input = 1
        if joy0down  then chant_input = DIR_DOWN  : chant_new_input = 1
        goto test_joy_done

; Require a release of a single direction (TODO: 8dir?) before buffering input
chant_input_test_release
        if joy0up    then test_joy_done
        if joy0down  then test_joy_done
        if joy0left  then test_joy_done
        if joy0right then test_joy_done
        ; TODO: Test for holds? Long times between inputs?

chant_buffer_input
        input_buffer[input_buffer_index] = chant_input
        ; chant_index is always updated to input buffer index but is its own
        ; variable so that it can be manipulated by the parsing routines
        ; without losing the input buffer index for the next frame
        chant_index = input_buffer_index
        input_buffer_index = input_buffer_index + 1
        if input_buffer_index > INPUT_BUFFER_MAX then input_buffer_index = 0
        chant_new_input = 0
        goto test_joy_done

; all chant tests seach for button combos "backwards" from the most recent input
chant_spells_up
        chant_index = chant_index - 1
        ; chant index will underflow to 255, set to 7
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] = DIR_DOWN then parse_fireball_up
        goto chant_test_dirs

chant_spells_down
        chant_index = chant_index - 1
        ; chant index will underflow to 255, set to 7
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] = DIR_UP then parse_fireball_down
        goto chant_test_dirs

chant_spells_left
        chant_index = chant_index - 1
        ; chant index will underflow to 255, set to 7
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] = DIR_RIGHT then parse_fireball_left
        goto chant_test_dirs

chant_spells_right
        chant_index = chant_index - 1
        ; chant index will underflow to 255, set to 7
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] = DIR_LEFT then parse_fireball_right
        goto chant_test_dirs

parse_fireball_up
        chant_index = chant_index - 1
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] <> DIR_UP then chant_test_dirs
        player_facing = DIR_UP : player_frame = FRAME_UP
        gosub cast_fireball
        goto chant_done

parse_fireball_down
        chant_index = chant_index - 1
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] <> DIR_DOWN then chant_test_dirs
        player_frame = FRAME_DOWN
        gosub cast_fireball
        goto chant_done

parse_fireball_left
        chant_index = chant_index - 1
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] <> DIR_LEFT then chant_test_dirs
        player_facing = DIR_LEFT : player_frame = FRAME_LEFT
        gosub cast_fireball
        goto chant_done

parse_fireball_right
        chant_index = chant_index - 1
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] <> DIR_RIGHT then chant_test_dirs
        player_facing = DIR_RIGHT : player_frame = FRAME_RIGHT
        gosub cast_fireball
        goto chant_done ; because I know I'll cause a bug adding code later...

chant_done
        player_exiting_chant = 1
chant_done_no_hold
        asm
        lda #0
        sta player_state        ; STATE_STAND
        sta chant_timer
        sta chant_input
        sta input_buffer_index
        sta chant_new_input
        ldx #8
clear_input_buffer
        dex
        sta input_buffer,x
        bne clear_input_buffer
end
        gosub decrease_player_mp
        goto test_joy_done

decelerate_player
decelerate_object
        asm
        ldx index
        lda object_friction,x
        beq decel_return
        lda object_Xvel,x
        beq decel_Y
        pha
        sec
        sbc object_friction_hi,x
        sta object_Xvel_hi,x
        pla
        cmp object_Xvel_hi,x
        bcs decel_Y
        lda #0
        sta object_Xvel_lo,x
        sta object_Xvel_hi,x

decel_Y
        lda object_Yvel_hi,x
        beq decel_return
        pha
        sec
        sbc object_friction_hi,x
        sta object_Yvel_hi,x
        pla
        cmp object_Yvel_hi,x
        bcs decel_return
        lda #0
        sta object_Yvel_lo,x
        sta object_Yvel_hi,x

decel_return
        rts
end

;==============================================================================
; SUBROUTINE: MOVE_OBJECT
;------------------------------------------------------------------------------
; Moves an object based on the non-fractional component of their velocities.
; Tests against an array of walkable tiles for current tileset before moving.
;
; All move test labels add 8 to Yposistion to allow objects to overlap
; unwalkable tiles that are above them. Objects are assumed to be 12x16
; and magic numbers are used throughout the code to improve the feel of
; player collisions with map tiles at the expense of other sprite proportions
;==============================================================================
move_object
        if debug_time then BACKGRND = $96

        ; Cap the object's velocity TODO: separate X/Y cap?
        if Xvelocity > vel_cap then Xvelocity = vel_cap
        if Yvelocity > vel_cap then Yvelocity = vel_cap

        ; Current direction(s) are determined by player input or AI logic
        ; optimization: bypass direction checks if no velocity
        if !Yvelocity then move_object_X
        if Ydirection = DIR_UP    then gosub move_test_up
        if Ydirection = DIR_DOWN  then gosub move_test_down
move_object_X
        if !Xvelocity then move_object_done
        if Xdirection = DIR_LEFT  then gosub move_test_left
        if Xdirection = DIR_RIGHT then gosub move_test_right
move_object_done
        goto move_return

move_test_up
        if flags{2} then move_up
        asm
        lda Xposition
        clc
        adc #2
        lsr
        lsr
        lsr
        sta peekX
        lda Yposition
        clc
        adc #8
        sec
        sbc Yvelocity_hi
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_1 = peekchar (current_map, peekX, peekY, 20, 14)
;        peekX = (Xposition + 8) / TILE_WIDTH
        asm
        lda Xposition
        clc
        adc #8
        lsr
        lsr
        lsr
        sta peekX
end
        move_tile_2 = peekchar (current_map, peekX, peekY, 20, 14)
        gosub test_walkable
        if !flags{4} then test_walkable_up
        if floatable then move_up
test_walkable_up
        if !walkable then Yvelocity = 0 : return
move_up
        Yposition = Yposition - Yvelocity_hi
        if Yposition > 224 then object_type[index] = 0
        return

move_test_down
        if flags{2} then move_down
        ;peekX = (Xposition + 2) / TILE_WIDTH
        ;peekY = ((Yposition + Yvelocity_hi) + 15) / TILE_HEIGHT
        asm
        lda Xposition
        clc
        adc #2
        lsr
        lsr
        lsr
        sta peekX
        lda Yposition
        clc
        adc #15
        clc
        adc Yvelocity_hi
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_1 = peekchar (current_map, peekX, peekY, 20, 14)
        ;peekX = (Xposition + 8) / TILE_WIDTH
        asm
        lda Xposition
        clc
        adc #8
        lsr
        lsr
        lsr
        sta peekX
end
        move_tile_2 = peekchar (current_map, peekX, peekY, 20, 14)
        ledge_dir = DIR_DOWN
        gosub test_walkable
        if !flags{4} then test_walkable_down
        if floatable then move_down
test_walkable_down
        if ledge then Xdirection = 0 : flags{5} = 1
        if !walkable then Yvelocity = 0 : return
move_down
        Yposition = Yposition + Yvelocity_hi
        if Yposition > 224 then object_type[index] = 0
        return

move_test_left
        if flags{2} then move_left
;        peekX = ((Xposition + 2) - Xvelocity_hi) / TILE_WIDTH
        ; Add 8 to Y position to allow object to overlap solid tiles above it slightly
;        peekY = (Yposition + 8) / TILE_HEIGHT
        asm
        lda Xposition
        clc
        adc #2
        sec
        sbc Xvelocity_hi
        lsr
        lsr
        lsr
        sta peekX
        lda Yposition
        clc
        adc #8
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_1 = peekchar (current_map, peekX, peekY, 20, 14)
;        peekY = (Yposition + 15) / TILE_HEIGHT
        asm
        lda Yposition
        clc
        adc #15
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_2 = peekchar (current_map, peekX, peekY, 20, 14)
        ledge_dir = DIR_LEFT
        gosub test_walkable
        if !flags{4} then test_walkable_left
        if floatable then move_left
test_walkable_left
        if ledge then Xdirection = DIR_LEFT : flags{5} = 1
        if !walkable then Xvelocity = 0 : return
move_left
        Xposition = Xposition - Xvelocity_hi
        if Xposition > 160 then object_type[index] = 0
        return

move_test_right
        if flags{2} then move_right
;        peekX = ((Xposition + 9) + Xvelocity_hi) / TILE_WIDTH
        ; Add 8 to Y position to allow object to overlap solid tiles above it slightly
;        peekY = (Yposition + 8) / TILE_HEIGHT
        asm
        lda Xposition
        clc
        adc #9
        clc
        adc Xvelocity_hi
        lsr
        lsr
        lsr
        sta peekX
        lda Yposition
        clc
        adc #8
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_1 = peekchar (current_map, peekX, peekY, 20, 14)
;        peekY = (Yposition + 15) / TILE_HEIGHT
        asm
        lda Yposition
        clc
        adc #15
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_2 = peekchar (current_map, peekX, peekY, 20, 14)
        ledge_dir = DIR_RIGHT
        gosub test_walkable
        if !flags{4} then test_walkable_right
        if floatable then move_right
test_walkable_right
        if ledge then Xdirection = DIR_RIGHT : flags{5} = 1
        if !walkable then Xvelocity = 0 : return
move_right
        Xposition = Xposition + Xvelocity_hi
        if Xposition > 160 then object_type[index] = 0
        return
        
move_return
        if debug_time then BACKGRND = bg_color
        return

test_walkable
        if debug_time then BACKGRND = $1A
        ; start by assuming the tile isn't walkable (fewer tests)
        asm
        lda #0
        sta walkable
        sta walkable_1
        sta walkable_2
        sta floatable
        sta floatable_1
        sta floatable_2
        sta ledge
        sta ledge_1
        sta ledge_2
        sta in_water
;        sta water_1
;        sta water_2
end
        if tileset = T_FOREST then goto test_walkable_forest
        if tileset = T_CASTLE then goto test_walkable_castle
        if tileset = T_RIVER  then goto test_walkable_river
walkable_return
        if debug_time then BACKGRND = bg_color
        return

check_collisions
        if debug_time = 1 then BACKGRND = $95
        for index = 0 to 15
        if !object_type[index] then cc_next
        Xposition = object_Xpos[index]
        Yposition = object_Ypos[index]
        if object_type[index] >= TYPE_COIN then cc_pickup
        if object_type[index] >= TYPE_FIREBALL then magic_collision
        if player_state <> STATE_ATTACK then cc_player_contact
        gosub sword_collision
        if !object_hp[index] then kill_object
cc_player_contact
        ; need to test torches here so the sword can still damage them
        ; but they don't knock the player back on contact
        if object_type[index] = TYPE_TORCH then cc_next
        hp_change = object_damage[index]
        gosub player_knockback
        if player_state = STATE_DEATH then goto kill_player
cc_next
        if debug_time = 1 then BACKGRND = bg_color
        next
cc_return
        return

cc_pickup
        if Xposition >= player_Xpos && Xposition < (player_Xpos + 12) && Yposition >= player_Ypos && Yposition < (player_Ypos + 16) then pickup_object
        goto cc_next

pickup_object
        playsfx sfx_strum
        asm
          ldx index
          lda object_type,x
          cmp #TYPE_ITEM1
          bcc puconsum
          sta temp1
          ldy #PICKUP_TIME
          sty pickup_timer
          ldy #1
          sty new_pickup
          sty item_pickup
          cmp #TYPE_CHARM1
          bcc puarmor
          jmp .pickup_charm
puarmor   cmp #TYPE_ARMOR1
          bcc pushield
          jmp .pickup_armor
pushield  cmp #TYPE_SHIELD1
          bcc pusword
          jmp .pickup_shield
pusword   cmp #TYPE_SWORD1
          bcc puitem
          jmp .pickup_sword
puitem    jmp .pickup_item
puconsum  cmp #TYPE_FOOD
          bne puprism
          lda #HP_CHANGE_FOOD
          sta hp_change
          jsr .increase_player_hp
          bne .kill_object
puprism   cmp #TYPE_PRISM
          bne pucoin
          lda #MP_CHANGE_PRISM
          sta mp_change
          jsr .increase_player_mp
pucoin
end

kill_object
        asm
          ldx index
          lda object_type,x
          cmp #TYPE_TORCH
          bne change_to_spawner
          ; torches make their tile walkable
          jsr .kill_torch
          ldx index
          bne spawner_flag
change_to_spawner
          cmp #TYPE_SLIME
          bne spawner_rslime
          ldy animation_frame
          beq spawner_rslime
          jmp .split_slime
spawner_rslime
          cmp #TYPE_RSLIME
          bne spawner_flag
          ldy animation_frame
          beq spawner_flag
          jmp .split_rslime
spawner_flag
          lda object_type,x
          sta object_flags,x
          lda #TYPE_SPAWNER
          sta object_type,x
spawner_done
          jmp .cc_next
end

sword_collision
        asm
          ldx index
          lda object_flags,x
          ; tests object invunerablility flag
          lsr
          bcc test_sword_box
          rts
test_sword_box
end
        if !boxcollision (sword_Xpos, sword_Ypos, sword_width, sword_height, Xposition, Yposition, 12, 16) then return thisbank
        if object_type[index] < TYPE_SPAWNER then playsfx sfx_poof2
        if object_type[index] = TYPE_SKELSWORD then playsfx sfx_gotthecoin
sword_damage
        ; TODO: Much better damage calculations
        if object_def[index] = 255 then return thisbank
        temp_hp = object_hp[index]
        temp1 = temp_hp
        hp_change = player_atk - object_def[index]
        if hp_change > player_atk then hp_change = 1
        gosub decrease_hp
        if temp1 < temp_hp then temp_hp = 0
        object_hp[index] = temp_hp
        goto set_enemy_name

kill_torch
        gosub get_torch_pos
        if tileset = T_FOREST then gosub torch_tile_unblock_forest
        if tileset = T_CASTLE then gosub torch_tile_unblock_castle
        if tileset = T_RIVER  then gosub torch_tile_unblock_river
        return thisbank

player_knockback
        if player_flags{0}         then return thisbank ; player is invulnerable, bypass collision check to save cycles
        asm
          ldx index
          lda object_flags,x
          ; tests object invunerablility flag
          lsr
          bcc test_player_box
          rts
test_player_box
end
        if !boxcollision (player_Xpos, player_Ypos, PLAYER_WIDTH, PLAYER_HEIGHT, Xposition, Yposition, 12, 16) then return
;        if Yposition <= player_Ypos then player_Yvel = 10.0 : player_Ydir = DIR_DOWN  : player_frame = FRAME_UP    : goto pc_damage
;        if Yposition >= player_Ypos then player_Yvel = 10.0 : player_Ydir = DIR_UP    : player_frame = FRAME_DOWN  : goto pc_damage
;        if Xposition >= player_Xpos then player_Xvel = 5.0 : player_Xdir = DIR_LEFT  : player_frame = FRAME_RIGHT : goto pc_damage
;        if Xposition <= player_Xpos then player_Xvel = 5.0 : player_Xdir = DIR_RIGHT : player_frame = FRAME_LEFT

        ;  check player's shield and destroy projectile
        if object_type[index] >= TYPE_DARKSPARK then shield_check

pc_damage
        player_flags{0} = 1
        player_state = STATE_KNOCKBACK
        player_timer = INVULN_FRAMES

        ; moved damage subroutine here to avoid a goto
damage_player_hp
        ; TODO: This currently can't scale, only works with max HP 48...
        dec temp1 = player_hp        ; temp1 used to detect underflow
        dec temp2 = hp_change
        dec hp_change = hp_change - player_def
        ; don't want total immunity to damage, that's boring!
        if hp_change > temp2 then hp_change = 1
        dec player_hp = player_hp - hp_change
        if player_hp > temp1 then player_hp = 0

update_hp_bar
        dec temp1 = player_hp
        dec hp_seg_1 = player_hp
        if hp_seg_1 > temp1 then hp_seg_1 = 0
        dec temp1 = hp_seg_1
        dec hp_seg_2 = hp_seg_1 - 8
        if hp_seg_2 > temp1 then hp_seg_2 = 0
        dec temp1 = hp_seg_2
        dec hp_seg_3 = hp_seg_2 - 8
        if hp_seg_3 > temp1 then hp_seg_3 = 0
        dec temp1 = hp_seg_3
        dec hp_seg_4 = hp_seg_3 - 8
        if hp_seg_4 > temp1 then hp_seg_4 = 0
        dec temp1 = hp_seg_4
        dec hp_seg_5 = hp_seg_4 - 8
        if hp_seg_5 > temp1 then hp_seg_5 = 0
        dec temp1 = hp_seg_5
        dec hp_seg_6 = hp_seg_5 - 8
        if hp_seg_6 > temp1 then hp_seg_6 = 0
        if hp_seg_6 > 8 then hp_seg_6 = 8
        if hp_seg_5 > 8 then hp_seg_5 = 8
        if hp_seg_4 > 8 then hp_seg_4 = 8
        if hp_seg_3 > 8 then hp_seg_3 = 8
        if hp_seg_2 > 8 then hp_seg_2 = 8
        if hp_seg_1 > 8 then hp_seg_1 = 8
        hp_bar_1 = hp_seg_1 * 2
        hp_bar_2 = hp_seg_2 * 2
        hp_bar_3 = hp_seg_3 * 2
        hp_bar_4 = hp_seg_4 * 2
        hp_bar_5 = hp_seg_5 * 2
        hp_bar_6 = hp_seg_6 * 2


        if player_hp = 0 then player_state = STATE_DEATH
        return

shield_check
        ; projectiles are destroyed on contact
        object_type[index] = 0
        ; TODO: different shield properties
        if !player_shield then goto pc_damage
        if player_facing = DIR_UP && object_facing[index]    = DIR_DOWN  then return thisbank
        if player_facing = DIR_DOWN && object_facing[index]  = DIR_UP    then return thisbank
        if player_facing = DIR_LEFT && object_facing[index]  = DIR_RIGHT then return thisbank
        if player_facing = DIR_RIGHT && object_facing[index] = DIR_LEFT  then return thisbank
        goto pc_damage

increase_player_hp
        dec player_hp = player_hp + hp_change
        if player_hp > player_max_hp then player_hp = player_max_hp
        hp_change = 0
        goto update_hp_bar

increase_player_mp
        dec player_mp = player_mp + mp_change
        if player_mp > player_max_mp then player_mp = player_max_mp
        goto update_mp_bar

decrease_player_mp
        ; TODO: This currently can't scale, only works with max HP 48...
        dec temp1 = player_mp        ; temp1 used to detect underflow
        dec player_mp = player_mp - mp_change
        if player_mp > temp1 then player_mp = 0

update_mp_bar
        mp_change = 0
        dec temp1 = player_mp
        dec mp_seg_1 = player_mp
        if mp_seg_1 > temp1 then mp_seg_1 = 0
        dec temp1 = mp_seg_1
        dec mp_seg_2 = mp_seg_1 - 8
        if mp_seg_2 > temp1 then mp_seg_2 = 0
        dec temp1 = mp_seg_2
        dec mp_seg_3 = mp_seg_2 - 8
        if mp_seg_3 > temp1 then mp_seg_3 = 0
        dec temp1 = mp_seg_3
        dec mp_seg_4 = mp_seg_3 - 8
        if mp_seg_4 > temp1 then mp_seg_4 = 0
        dec temp1 = mp_seg_4
        dec mp_seg_5 = mp_seg_4 - 8
        if mp_seg_5 > temp1 then mp_seg_5 = 0
        dec temp1 = mp_seg_5
        dec mp_seg_6 = mp_seg_5 - 8
        if mp_seg_6 > temp1 then mp_seg_6 = 0
        if mp_seg_6 > 8 then mp_seg_6 = 8
        if mp_seg_5 > 8 then mp_seg_5 = 8
        if mp_seg_4 > 8 then mp_seg_4 = 8
        if mp_seg_3 > 8 then mp_seg_3 = 8
        if mp_seg_2 > 8 then mp_seg_2 = 8
        if mp_seg_1 > 8 then mp_seg_1 = 8

        mp_bar_1 = mp_seg_1 * 2
        mp_bar_2 = mp_seg_2 * 2
        mp_bar_3 = mp_seg_3 * 2
        mp_bar_4 = mp_seg_4 * 2
        mp_bar_5 = mp_seg_5 * 2
        mp_bar_6 = mp_seg_6 * 2
        return thisbank

test_spell_cost
        if mp_change < player_mp then return
        ; routines can test if mp_change is 0 after calling this subroutine
        mp_change = 0
        return

increase_hp
        temp_hp = temp_hp + hp_change
        return

decrease_hp
        temp_hp = temp_hp - hp_change
        return

; takes a torch's X & Y position and determines the map tile under it, stores in peekX & Y
get_torch_pos
get_object_pos
        asm
        ldx index
        lda object_Xpos,x
        clc
        adc #4          ; forces X calculation onto correct map tile
        lsr
        lsr
        lsr
        sta peekX
        lda object_Ypos,x
        clc
        adc #8          ; forces Y calculation onto correct map tile
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        return


copy_player_props
copy_object_props
        asm
        ldx index
        lda object_Xpos,x
        sta Xposition
        lda object_Xdir,x
        sta Xdirection
        lda object_Xvel_lo,x
        sta Xvelocity_lo
        lda object_Xvel_hi,x
        sta Xvelocity_hi
        lda object_Ypos,x
        sta Yposition
        lda object_Ydir,x
        sta Ydirection
        lda object_Yvel_lo,x
        sta Yvelocity_lo
        lda object_Yvel_hi,x
        sta Yvelocity_hi
        lda object_speed_lo,x
        sta move_speed_lo
        lda object_speed_hi,x
        sta move_speed_hi
        lda object_vel_cap_lo,x
        sta vel_cap_lo
        lda object_vel_cap_hi,x
        sta vel_cap_hi
        lda object_friction_lo,x
        sta friction_lo
        lda object_friction_hi,x
        sta friction_hi
        lda object_frame,x
        sta frame
        lda object_flags,x
        sta flags
        lda object_dest,x
        sta hop_dest
        lda object_hop_dir,x
        sta hop_dir
        lda object_timer,x
        sta timer
        rts
end

restore_player_props
restore_object_props
        asm
        ldx index
        lda Xposition
        sta object_Xpos,x
        lda Xdirection
        sta object_Xdir,x
        lda Xvelocity_lo
        sta object_Xvel_lo,x
        lda Xvelocity_hi
        sta object_Xvel_hi,x
        lda Yposition
        sta object_Ypos,x
        lda Ydirection
        sta object_Ydir,x
        lda Yvelocity_lo
        sta object_Yvel_lo,x
        lda Yvelocity_hi
        sta object_Yvel_hi,x
        lda frame
        sta object_frame,x
        lda flags
        sta object_flags,x
        lda #0
        sta flags
        lda hop_dest
        sta object_dest,x
        lda hop_dir
        sta object_hop_dir,x
        lda timer
        sta object_timer,x
        rts
end

;==============================================================================
; SUBROUTINE: FIND NEW OBJECT
;------------------------------------------------------------------------------
; Iterates through all 16 object slots and sets the index variable to a 0 slot
;==============================================================================
find_new_object
        asm
        ldx #0
        stx no_empty_slot
new_obj_loop
        inx
        lda object_type,x
        beq new_obj_found
        cpx #MAX_MAP_OBJECTS
        bne new_obj_loop
        ; no empty obj slot found, routines can test if this is non-zero
        stx no_empty_slot
        rts
new_obj_found
        stx spawn_index
        rts
end