;==============================================================================
; BANK 2
;------------------------------------------------------------------------------
; Contains forest tileset graphics, maps, and enemy AI
;==============================================================================
        bank 2
        incgraphic gfx/tiles/forest_trees.png 160A 1 0 2 3 4
        incgraphic gfx/tiles/forest_rocks.png 160A 1 0 2 3 5
        incgraphic gfx/tiles/forest_water.png 160A 1 2 0 3 6
        incgraphic gfx/tiles/forest_ledges.png 160A 1 0 2 3 7
        incgraphic gfx/forest/hud.png 160A 0 3 1 2
        incgraphic gfx/forest/hud2.png 160A 0 3 1 2
        incgraphic gfx/sprites/wolf0.png 160A 0 2 3 1
        incgraphic gfx/sprites/wolf1.png 160A 0 2 3 1
        incgraphic gfx/sprites/wolf2.png 160A 0 2 3 1
        incgraphic gfx/sprites/wolf3.png 160A 0 2 3 1
        incgraphic gfx/sprites/slime0.png 160A 0 2 3 1
        incgraphic gfx/sprites/slime1.png 160A 0 2 3 1
        incgraphic gfx/sprites/minislime0.png 160A 0 2 3 1
        incgraphic gfx/sprites/minislime1.png 160A 0 2 3 1
        incgraphic gfx/sprites/raven0.png 160A 0 1 3 2
        incgraphic gfx/sprites/raven1.png 160A 0 1 3 2
        incgraphic gfx/sprites/raven2.png 160A 0 1 3 2
        incgraphic gfx/sprites/raven3.png 160A 0 1 3 2
        incgraphic gfx/sprites/raven4.png 160A 0 1 3 2
        incgraphic gfx/sprites/raven5.png 160A 0 1 3 2

        incmapfile tiled/forest.tmx
        incmapfile tiled/forest_room_1.tmx
        incmapfile tiled/forest_room_2.tmx
        incmapfile tiled/forest_room_3.tmx
        incmapfile tiled/forest_room_4.tmx
        incmapfile tiled/forest_room_5.tmx
        incmapfile tiled/forest_room_6.tmx
        incmapfile tiled/forest_room_7.tmx
        incmapfile tiled/forest_room_8.tmx
        incmapfile tiled/forest_room_9.tmx
        incmapfile tiled/forest_room_10.tmx
        incmapfile tiled/forest_room_11.tmx
        incmapfile tiled/forest_room_12.tmx

load_forest
        if !first_load then forest_pals
        first_load = 0
        if save_room_index = 1 then forest_save_1

; Initial player location on game start
        room_index = 17
        menu_map_Xpos = 78
        menu_map_Ypos = 96
        player_Xpos = 24
        player_Ypos = 60
        player_facing = DIR_DOWN
        goto forest_pals

forest_save_1
        room_index = 12
        menu_map_Xpos = 94
        menu_map_Ypos = 80
        player_Xpos = 24
        player_Ypos = 60
        player_facing = DIR_DOWN

forest_pals
        bg_color = PAL_F_GRND                          ; brown
        incbasic shared_pals.78b
        P4C1 = PAL_BLACK  : P4C2 = PAL_F_DKGRN : P4C3 = PAL_F_LTGRN    ; greens used by trees and slimes
        P5C1 = PAL_BLACK  : P5C2 = PAL_F_DKGRY : P5C3 = PAL_F_LTGRY    ; grays used by rocks and wolves
        P6C1 = PAL_BLACK  : P6C2 = PAL_F_WATER : P6C3 = PAL_F_LTWTR    ; blue and gray used by water
        P7C1 = PAL_BLACK  : P7C2 = PAL_F_DKBRN : P7C3 = PAL_F_LTBRN    ; ledges, dark and light browns

        characterset forest_trees
        room = forest_rooms[room_index]
        if room = 1 then pointer = forest_room_1_obj_lo : pointer_hi = forest_room_1_obj_hi : goto plot_forest_room_1
        if room = 2 then pointer = forest_room_2_obj_lo : pointer_hi = forest_room_2_obj_hi : goto plot_forest_room_2
        if room = 3 then pointer = forest_room_3_obj_lo : pointer_hi = forest_room_3_obj_hi : goto plot_forest_room_3
        if room = 4 then pointer = forest_room_4_obj_lo : pointer_hi = forest_room_4_obj_hi : goto plot_forest_room_4
        if room = 5 then pointer = forest_room_5_obj_lo : pointer_hi = forest_room_5_obj_hi : goto plot_forest_room_5
        if room = 6 then pointer = forest_room_6_obj_lo : pointer_hi = forest_room_6_obj_hi : goto plot_forest_room_6
        if room = 7 then pointer = forest_room_7_obj_lo : pointer_hi = forest_room_7_obj_hi : goto plot_forest_room_7
        if room = 8 then pointer = forest_room_8_obj_lo : pointer_hi = forest_room_8_obj_hi : goto plot_forest_room_8
        if room = 9 then pointer = forest_room_9_obj_lo : pointer_hi = forest_room_9_obj_hi : goto plot_forest_room_9
        if room = 10 then pointer = forest_room_10_obj_lo : pointer_hi = forest_room_10_obj_hi : goto plot_forest_room_10
        if room = 11 then pointer = forest_room_11_obj_lo : pointer_hi = forest_room_11_obj_hi : goto plot_forest_room_11
        if room = 12 then pointer = forest_room_12_obj_lo : pointer_hi = forest_room_12_obj_hi : goto plot_forest_room_12

; room 1 is the default and uses a "crossroads" setup in case the player gets out of bounds somehow
plot_forest_room_1
        menu_map_index = room_index * 2
        menu_map_room[menu_map_index] = 2
        menu_map_index = menu_map_index + 1
        menu_map_room[menu_map_index] = 3
        plotmapfile tiled/forest_room_1.tmx forest_room_1 0 0 20 14
        memcpy current_map forest_room_1 280
        zone1_objects  = 2
        zone2_objects  = 2
        zone14_objects = 1
        return

        data forest_room_1_obj
        $00
end


plot_forest_room_2
        menu_map_index = room_index * 2
        menu_map_room[menu_map_index] = $08
        menu_map_index = menu_map_index + 1
        menu_map_room[menu_map_index] = $09
        plotmapfile tiled/forest_room_2.tmx forest_room_2 0 0 20 14
        memcpy current_map forest_room_2 280
        zone1_objects  = 3
        zone2_objects  = 3
        zone14_objects = 1
        return

        data forest_room_2_obj
        TYPE_TORCH, $28, $9D,  TYPE_TORCH, $6F, $9D,  TYPE_RAVEN, $1E, $28,  TYPE_SLIME, $51, $58,
        $00
end

plot_forest_room_3
        pw_success = 0
        menu_map_index = room_index * 2
        menu_map_room[menu_map_index] = $0E
        menu_map_index = menu_map_index + 1
        menu_map_room[menu_map_index] = $09
        plotmapfile tiled/forest_room_3.tmx forest_room_3 0 0 20 14
        memcpy current_map forest_room_3 280
        zone1_objects  = 2
        zone2_objects  = 2
        zone14_objects = 1
        return

        data forest_room_3_obj
        TYPE_NIXTAIL, $4E, $40,  $00
end

plot_forest_room_4
        menu_map_index = room_index * 2
        menu_map_room[menu_map_index] = 2
        menu_map_index = menu_map_index + 1
        menu_map_room[menu_map_index] = 3
        plotmapfile tiled/forest_room_4.tmx forest_room_4 0 0 20 14
        memcpy current_map forest_room_4 280
        zone1_objects  = 2
        zone2_objects  = 2
        zone14_objects = 1
        return

        data forest_room_4_obj
        TYPE_WOLF, $54, $79,  TYPE_TORCH, $2A, $30,  $00
end

plot_forest_room_5
        menu_map_index = room_index * 2
        menu_map_room[menu_map_index] = 2
        menu_map_index = menu_map_index + 1
        menu_map_room[menu_map_index] = $0B
        plotmapfile tiled/forest_room_5.tmx forest_room_5 0 0 20 14
        memcpy current_map forest_room_5 280
        zone1_objects  = 2
        zone2_objects  = 2
        zone14_objects = 2
        return

        data forest_room_5_obj
        TYPE_TORCH, $38, $30,  TYPE_TORCH, $68, $30,  TYPE_WOLF, $49, $63,  $00
end

plot_forest_room_6
        menu_map_index = room_index * 2
        menu_map_room[menu_map_index] = 6
        menu_map_index = menu_map_index + 1
        menu_map_room[menu_map_index] = $0D
        plotmapfile tiled/forest_room_6.tmx forest_room_6 0 0 20 14
        memcpy current_map forest_room_6 280
        zone1_objects  = 2
        zone2_objects  = 2
        zone14_objects = 2
        return

        data forest_room_6_obj
        TYPE_WOLF, $30, $30,
        $00, $69, $20,
        $00, $39, $20,
        TYPE_TORCH, $5E, $AF,
        TYPE_TORCH, $42, $AF,
        TYPE_WOLF, $6B, $51,
        TYPE_SLIME, $40, $67,
        TYPE_SLIME, $80, $90,
        $00, $90, $88,
        $00, $40, $70,
        $00, $30, $20,
        $00, $80, $40,
        $00, $b0, $c0,
        $00, $77, $55,
        $00, $44, $22,
        $00, $33, $66,
end

plot_forest_room_7
        menu_map_index = room_index * 2
        menu_map_room[menu_map_index] = 6
        menu_map_index = menu_map_index + 1
        menu_map_room[menu_map_index] = 7
        plotmapfile tiled/forest_room_7.tmx forest_room_7 0 0 20 14
        memcpy current_map forest_room_7 280
        zone1_objects  = 2
        zone2_objects  = 2
        zone14_objects = 1
        return

        data forest_room_7_obj
        TYPE_SLIME, $45, $7F,  TYPE_SLIME, $36, $A0,  $00
end

plot_forest_room_8
        menu_map_index = room_index * 2
        menu_map_room[menu_map_index] = $10
        menu_map_index = menu_map_index + 1
        menu_map_room[menu_map_index] = 5
        plotmapfile tiled/forest_room_8.tmx forest_room_8 0 0 20 14
        memcpy current_map forest_room_8 280
        zone1_objects  = 2
        zone2_objects  = 2
        zone14_objects = 1
        return

        data forest_room_8_obj
        TYPE_RAVEN, $26, $28,  TYPE_RAVEN, $1E, $90,  $00
end

plot_forest_room_9
        menu_map_index = room_index * 2
        menu_map_room[menu_map_index] = 4
        menu_map_index = menu_map_index + 1
        menu_map_room[menu_map_index] = 5
        plotmapfile tiled/forest_room_9.tmx forest_room_9 0 0 20 14
        memcpy current_map forest_room_9 280
        zone1_objects  = 2
        zone2_objects  = 2
        zone14_objects = 1
        return

        data forest_room_9_obj
        $00
end

plot_forest_room_10
        menu_map_index = room_index * 2
        menu_map_room[menu_map_index] = 2
        menu_map_index = menu_map_index + 1
        menu_map_room[menu_map_index] = 3
        plotmapfile tiled/forest_room_10.tmx forest_room_10 0 0 20 14
        memcpy current_map forest_room_10 280
        zone1_objects  = 2
        zone2_objects  = 2
        zone14_objects = 1
        return

        data forest_room_10_obj
        $00
end

plot_forest_room_11
        if !pw_success then in_save_room = 1
        pw_success = 0
        save_room_index = 1
        entered_save_room{0} = 1
        menu_map_index = room_index * 2
        menu_map_room[menu_map_index] = $0C
        menu_map_index = menu_map_index + 1
        menu_map_room[menu_map_index] = $0D
        plotmapfile tiled/forest_room_11.tmx forest_room_11 0 0 20 14
        memcpy current_map forest_room_11 280
        zone1_objects  = 2
        zone2_objects  = 2
        zone14_objects = 1
        return

        data forest_room_11_obj
        $00
end

plot_forest_room_12
        menu_map_index = room_index * 2
        menu_map_room[menu_map_index] = $08
        menu_map_index = menu_map_index + 1
        menu_map_room[menu_map_index] = $0F
        plotmapfile tiled/forest_room_12.tmx forest_room_12 0 0 20 14
        memcpy current_map forest_room_12 280
        zone14_objects = 1
        return

        data forest_room_12_obj
        $00
end

        data forest_rooms
        00, 00,  8, 07, 06, 00, 00,
        00, 10,  9, 04, 05, 11, 00,
        00, 00, 00, 03, 02, 12, 00,
        00, 00, 00, 01, 00, 00, 00,
        00, 00, 00, 00, 00, 00, 00,
        00, 00, 00, 00, 00, 00, 00,
        00, 00, 00, 00, 00, 00, 00
end

        dmahole 0
test_walkable_forest
        tile_properties_1 = forest_tile_properties[move_tile_1]
        tile_properties_2 = forest_tile_properties[move_tile_2]
        ; if Johanna has the Nix's Tail relic, make shorelines walkable
        if !index && m_relic_bits_2{0} then gosub walkable_water_forest
        goto walkable_return

walkable_water_forest
        ; non-shoreline water is always walkable, this tests unwalkable tiles flagged as water
        if tile_properties_1{2} then tile_properties_1{0} = 1
        if tile_properties_2{2} then tile_properties_2{0} = 1

        ; objects can call this part of the subroutine to test if they are in water
test_water_forest
        ; water is tested differently than other properties, it tests the tile directly under the object
        ; this helps eliminate graphical issues when approaching a non-water tile in water
        gosub get_object_pos
        temp1 = peekchar (current_map, peekX, peekY, 20, 14)
        temp1 = temp1 / 2
        temp1 = forest_tile_properties[temp1]
        if temp1{2} then flags = flags | %00000010 else flags = flags & %11111101
        return thisbank

        ; %00000001 = walkable
        ; %00000010 = floatable
        ; %00000100 = water
        ; %00001000 = unused (shore)
        ; %00010000 = ledge - hop down
        ; %00100000 = ledge - hop right
        ; %01000000 = ledge - hop left
        ; %10000000 = waterfall
        data forest_tile_properties
        %00000001, %00000001, %00000001, %00000000, %00000000, %00000000, %00000000, %00000001,
        %00000001, %00000001, %00000001, %00000001, %00000001, %00000001, %00000001, %00000001,
        %00000001, %00010010, %00010010, %00010010, %00000000, %00000010, %00100010, %00100010,
        %00100010, %01000010, %01000010, %01000010, %00000110, %00000111, %00000110, %00000000,
        %00000110, %00000110, %00000110, %00000110, %00000110, %00000110, %00000000, %00000000,
        %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000, %00000000,
        %00000001, %00000000, %00000000
end

torch_tile_block_forest
        ; block with a floatable tile so projectiles can hit torch
        pokechar current_map peekX peekY 20 14 20
        if object_type[index] <> TYPE_DOOR_LOCK then return thisbank
        ; doors need to block a second tile to the right of the first
        peekX = peekX + 1
        pokechar current_map peekX peekY 20 14 20
        return thisbank

torch_tile_unblock_forest
        ; the poked tile doesn't affect visuals since those are plotted from ROM
        pokechar current_map peekX peekY 20 14 0
        return

;==============================================================================
; WOLF AI
;------------------------------------------------------------------------------
; Wolves wait for the player to get close (WOLF_CHASE_DIST), then give chase
;==============================================================================
wolf_ai
        ; Once wolves start chasing, they don't stop
        if flags{7} then wolf_chase

        ; Test player distance to wolf
        temp1 = Xposition - player_Xpos
        if temp1 < WOLF_CHASE_DIST then wolf_chase
        temp1 = Yposition - player_Ypos
        if temp1 < (WOLF_CHASE_DIST * 2) then wolf_chase

wolf_anim
        ; Wolves flip left or right facing depending on player position
        frame = 0
        if Xposition <= player_Xpos then frame = frame + 2
        if animation_frame then frame = frame + 1
        return

wolf_chase
        flags{7} = 1
        gosub get_player_pos
        gosub go_to_destination
        goto wolf_anim

obj_wolf_stats
; TODO: Make this implementation suck less
        object_hp[obj_index] = WOLF_HP
        object_vel_cap_hi[obj_index] = WOLF_VEL_CAP_HI
        object_vel_cap_lo[obj_index] = WOLF_VEL_CAP_LO
        object_damage[obj_index] = WOLF_DAMAGE
        object_def[obj_index] = WOLF_DEF
        object_mdef[obj_index] = WOLF_MDEF
        object_friction_hi[obj_index] = WOLF_FRICTION_HI
        object_friction_lo[obj_index] = WOLF_FRICTION_LO
        object_speed_hi[obj_index] = WOLF_SPEED_HI
        object_speed_lo[obj_index] = WOLF_SPEED_LO
        object_flags[obj_index] = 0
        asm
          ldx obj_index
          lda #<.plot_wolf
          sta object_spr_ptr_lo,x
          lda #>.plot_wolf
          sta object_spr_ptr_hi,x
end
        goto obj_next_stats

;==============================================================================
; SLIME AI
;------------------------------------------------------------------------------
; A Slime draws near!
; Command?
;==============================================================================
slime_ai
        ; slimes have no physical defense on their squished frame
        if !animation_frame then temp1 = SLIME_DEF : goto slime_chase
        ; this will allow them to split into mini-slimes
        temp1 = 0
slime_chase
        object_def[index] = temp1
        gosub get_player_pos
        gosub go_to_destination
        return

obj_slime_stats
        object_hp[obj_index] = SLIME_HP
        object_vel_cap_hi[obj_index] = SLIME_VEL_CAP_HI
        object_vel_cap_lo[obj_index] = SLIME_VEL_CAP_LO
        object_damage[obj_index] = SLIME_DAMAGE
        object_def[obj_index] = SLIME_DEF
        object_mdef[obj_index] = SLIME_MDEF
        object_friction_hi[obj_index] = SLIME_FRICTION_HI
        object_friction_lo[obj_index] = SLIME_FRICTION_LO
        object_speed_hi[obj_index] = SLIME_SPEED_HI
        object_speed_lo[obj_index] = SLIME_SPEED_LO
        object_flags[obj_index] = 0
        asm
          ldx obj_index
          lda #<.plot_slime
          sta object_spr_ptr_lo,x
          lda #>.plot_slime
          sta object_spr_ptr_hi,x
end
        goto obj_next_stats

split_slime
        ; replace slime mobj with mini slime
        object_type[index] = TYPE_MSLIME
        object_hp[index] = MSLIME_HP
        object_def[index] = MSLIME_DEF
        temp1 = object_Xpos[index]
        temp2 = object_Ypos[index]
        ; mini slime is moved to the left of the parent slime's pos
        object_Xpos[index] = object_Xpos[index] - 1
        asm
          ldx index
          lda #<.plot_minislime
          sta object_spr_ptr_lo,x
          lda #>.plot_minislime
          sta object_spr_ptr_hi,x
end
        gosub find_new_object
        index = spawn_index
        ; if no slots, the slime just becomes a single mini slime
        if no_empty_slot then object_Xpos[index] = temp1 : cc_next
        ; initialize the new mini slime object
        object_type[index] = TYPE_MSLIME
        object_hp[index] = MSLIME_HP
        object_vel_cap_hi[index] = SLIME_VEL_CAP_HI
        object_vel_cap_lo[index] = SLIME_VEL_CAP_LO
        object_damage[index] = SLIME_DAMAGE
        object_def[index] = MSLIME_DEF
        object_mdef[index] = MSLIME_MDEF
        object_friction_hi[index] = SLIME_FRICTION_HI
        object_friction_lo[index] = SLIME_FRICTION_LO
        object_speed_hi[index] = SLIME_SPEED_HI
        object_speed_lo[index] = SLIME_SPEED_LO
        ; mini slime spawns to the right of the parent slime's pos
        object_Xpos[index] = temp1 + 9
        object_Ypos[index] = temp2
        asm
          ldx index
          lda #<.plot_minislime
          sta object_spr_ptr_lo,x
          lda #>.plot_minislime
          sta object_spr_ptr_hi,x
end
        goto cc_next

;==============================================================================
; RAVEN AI
;------------------------------------------------------------------------------
; Flies without testing walkability and perches on trees
;==============================================================================
raven_ai
        if debug_time = 1 then BACKGRND = $A0
        flags{2} = 1
        temp1 = 0
        temp2 = 0
        ; flags{7} = not perched
        if flags{7} then goto raven_change_pos
        frame = 0
        Xvelocity = 0.0
        Yvelocity = 0.0

test_dist_to_player
        if Xposition > player_Xpos then wake_raven_right
        if Xposition < player_Xpos then wake_raven_left
        if Yposition > player_Ypos then wake_raven_down
        if Yposition < player_Ypos then wake_raven_up
        ; raven and player occupy same space, handle this

wake_raven_right
        temp1 = Xposition - player_Xpos
        if temp1 < RAVEN_CHASE_DIST then raven_change_pos
        goto raven_return

wake_raven_left
        temp1 = Xposition + player_Xpos
        if temp1 < RAVEN_CHASE_DIST then raven_change_pos
        goto raven_return

wake_raven_up
        temp2 = Yposition + player_Ypos
        if temp2 < RAVEN_CHASE_DIST then raven_change_pos
        goto raven_return

wake_raven_down
        temp2 = Yposition - player_Ypos
        if temp2 < RAVEN_CHASE_DIST then raven_change_pos
        goto raven_return


raven_change_pos
        flags{7} = 1
        frame = 1
        if animation_frame then frame = frame + 2
        if !object_timer[index] then object_timer[index] = RAVEN_FLIGHT_TIME
        if flags{3} then raven_move
        if rand > 128 then gosub swoop_Y : raven_move
        gosub swoop_X
raven_move
        gosub go_to_destination

raven_perch
        temp1 = object_timer[index]
        object_timer[index] = object_timer[index] - 1
        if temp1 < object_timer[index] then object_timer[index] = 0
        if object_timer[index] > 0 then raven_return
        gosub test_walkable
        if !tile_properties{0} then flags{7} = 0

raven_return
        if Xposition >= player_Xpos then frame = frame + 1
        if debug_time = 1 then BACKGRND = bg_color
        return

obj_raven_stats
        object_hp[obj_index] = RAVEN_HP
        object_vel_cap_hi[obj_index] = RAVEN_VEL_CAP_HI
        object_vel_cap_lo[obj_index] = RAVEN_VEL_CAP_LO
        object_damage[obj_index] = RAVEN_DAMAGE
        object_def[obj_index] = RAVEN_DEF
        object_mdef[obj_index] = RAVEN_MDEF
        object_friction_hi[obj_index] = RAVEN_FRICTION_HI
        object_friction_lo[obj_index] = RAVEN_FRICTION_LO
        object_speed_hi[obj_index] = RAVEN_SPEED_HI
        object_speed_lo[obj_index] = RAVEN_SPEED_LO
        object_flags[obj_index] = 0
        asm
          ldx obj_index
          lda #<.plot_raven
          sta object_spr_ptr_lo,x
          lda #>.plot_raven
          sta object_spr_ptr_hi,x
end
        goto obj_next_stats

plot_wolf
        PLOTSPRITE wolf0 5 Xposition Yposition frame
        goto plot_next

plot_slime
        PLOTSPRITE slime0 4 Xposition Yposition animation_frame
        goto plot_next

plot_minislime
        PLOTSPRITE minislime0 4 Xposition Yposition animation_frame
        goto plot_next

plot_raven
        PLOTSPRITE raven0 5 Xposition Yposition frame
        goto plot_next
