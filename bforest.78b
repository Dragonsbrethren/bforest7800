;------------------------------------------------------------------------------
; 7800BASIC INITIALIZATION
;------------------------------------------------------------------------------
        set romsize 128kRAM
        set pokeysupport on
        set screenheight 224
        set doublewide on
        set collisionwrap off
;        set multibutton on
;        set multibuttonpause on

        const debug_hud = 1
        const debug_time = 0

;------------------------------------------------------------------------------
; GAME STATES
;------------------------------------------------------------------------------
        const STATE_TITLE = 0
        const STATE_FIELD = 1
        const STATE_MENU  = 2
        
        const ANIM_TIME = 16
        const INVULN_FRAMES = 60

;------------------------------------------------------------------------------
; MOVEMENT CONSTANTS
;------------------------------------------------------------------------------
        const DIR_UP    = 1
        const DIR_DOWN  = 2
        const DIR_LEFT  = 3
        const DIR_RIGHT = 4

        const EXIT_NONE  = 0
        const EXIT_NORTH = 1
        const EXIT_SOUTH = 2
        const EXIT_EAST  = 3
        const EXIT_WEST  = 4

        const BUTTON_HOLD_FRAMES = 15

;------------------------------------------------------------------------------
; PLAYER DATA
;------------------------------------------------------------------------------
        const PLAYER_HEIGHT = 16
        const PLAYER_WIDTH  = 12

        const SWORD_FRAMES = 4
        const SWORD_OFFSET_DOWN  = 15
        const SWORD_OFFSET_UP    = -16
        const SWORD_OFFSET_LEFT  = -12
        const SWORD_OFFSET_RIGHT = 12
        
        const SHIELD_FRAMES = 4
        const SHIELD_OFFSET_X = 8
        const SHIELD_OFFSET_Y = 7

        const STATE_STAND       = 0
        const STATE_MOVING      = 1
        const STATE_ATTACK      = 2
        const STATE_CHANT_START = 3
        const STATE_CHANT       = 4
        const STATE_KNOCKBACK   = 5

        const FRAME_UP    = 2
        const FRAME_DOWN  = 0
        const FRAME_LEFT  = 4
        const FRAME_RIGHT = 6
        const FRAME_ATK_D = 8
        const FRAME_ATK_U = 9
        const FRAME_ATK_L = 10
        const FRAME_ATK_R = 11

        const ATTACK_FRAMES = 8
        const CHANT_START_TIME = 12
        const HAIR_COLOR = $10
        const CHANT_COLOR = $60
        const BAR_NORMAL_COLOR = $76
        const BAR_FLASH_COLOR = $79

;------------------------------------------------------------------------------
; MAP DATA
;------------------------------------------------------------------------------
        const TILE_HEIGHT = 16
        const TILE_WIDTH  = 8

        const T_TITLE  = 0
        const T_FOREST = 1
        const T_CASTLE = 2
        const T_RIVER  = 3
        const T_HILLS  = 4

        const ROOMS_PER_ROW = 7
        const MAX_MAP_OBJECTS = 12
        const MAX_OBJECTS = 15

;==============================================================================
; OBJECT DATA
;==============================================================================
        const TYPE_WOLF    =  1
        const TYPE_TORCH   =  2
        const TYPE_SPAWNER =  3
        const TYPE_COIN    =  4
        const TYPE_PRISM   =  5
        const TYPE_SLIME   =  6
        const TYPE_MSLIME  =  7
        const TYPE_RAVEN   =  8

;------------------------------------------------------------------------------
; SYSTEM VARIABLES
;------------------------------------------------------------------------------
        dim temp_hp_sign = temp1        ; tracks underflow during subtraction

        autodim init a z
        autodim byte index
        autodim byte game_state
        autodim byte pointer
        autodim byte pointer_hi
        autodim byte Xposition
        autodim byte Yposition
        autodim byte Xdestination
        autodim byte Ydestination
        autodim byte Xdirection
        autodim byte Ydirection
        autodim 8.8  Xvelocity
        autodim 8.8  Yvelocity
        autodim 8.8  move_speed
        autodim 8.8  vel_cap
        autodim 8.8  friction
        autodim byte temp_hp
        autodim byte hp_change
        autodim byte bg_color
        autodim byte animation_timer
        autodim byte retract_counter

;------------------------------------------------------------------------------
; PLAYER
;------------------------------------------------------------------------------
        autodim init var0 var99
        autodim byte player_Xpos
        autodim byte player_Ypos
        autodim 8.8  player_Xvel
        autodim 8.8  player_Yvel
        autodim 8.8  player_vel_cap
        autodim 8.8  player_friction
        autodim byte player_Xdir
        autodim byte player_Ydir
        autodim byte player_facing      ; facing is separate from direction for knockback purposes
        autodim byte player_state
        autodim byte player_frame
        autodim byte player_flags
        autodim byte player_timer
        autodim byte player_hp
        autodim byte player_max_hp
        autodim byte player_mp
        autodim byte player_max_mp
        autodim byte player_level
        dim player_exp = score1
        autodim byte player_str
        autodim byte player_atk ; str + wpn atk
        autodim byte player_damage
        autodim byte player_atk_elem
        autodim byte player_def
        autodim byte player_def_elem
        autodim 8.8  player_speed
        autodim byte player_sword
        autodim byte player_shield
        autodim byte player_helm
        autodim byte player_armor
        autodim byte player_relic
        autodim byte player_status
        autodim byte sword_pal
        autodim byte sword_Xpos
        autodim byte sword_Ypos
        autodim byte sword_frame
        autodim byte sword_width
        autodim byte sword_height
        autodim byte shield_pal
        autodim byte shield_Xpos
        autodim byte shield_Ypos
        autodim byte shield_frame
        autodim byte hp_seg_1
        autodim byte hp_seg_2
        autodim byte hp_seg_3
        autodim byte hp_seg_4
        autodim byte hp_seg_5
        autodim byte hp_seg_6
        autodim byte mp_seg_1
        autodim byte mp_seg_2
        autodim byte mp_seg_3
        autodim byte mp_seg_4
        autodim byte mp_seg_5
        autodim byte mp_seg_6
        autodim byte mp_change
        autodim byte chant_timer
        autodim byte flash_color
        autodim byte player_exiting_chant

;------------------------------------------------------------------------------
; CONTROLLER
;------------------------------------------------------------------------------
        autodim byte controller_state
        dim controller_debounce_bit0 = controller_state
        dim controller_left_bit1     = controller_state
        dim controller_right_bit2    = controller_state
        dim controller_up_bit3       = controller_state
        dim controller_down_bit4     = controller_state
        autodim byte controller_button_state
        dim controller_button_debounce_bit0 = controller_button_state
        dim controller_button1_press_bit1   = controller_button_state
        dim controller_button1_tap_bit2     = controller_button_state
        dim controller_button1_hold_bit3    = controller_button_state
        dim controller_button2_press_bit4   = controller_button_state
        dim controller_button2_tap_bit5     = controller_button_state
        dim controller_button2_hold_bit6    = controller_button_state
        autodim byte controller_button1_counter
        autodim byte controller_button2_counter


;------------------------------------------------------------------------------
; MOVING OBJECT ARRAYS
;------------------------------------------------------------------------------
        autodim init $2200 $23FF
        autodim byte object_type 16
        autodim byte object_Xpos 16
        autodim byte object_Ypos 16
        autodim 8.8  object_Xvel 16
        autodim 8.8  object_Yvel 16
        autodim byte object_Xdir 16
        autodim byte object_Ydir 16
        autodim byte object_frame 16
        autodim byte object_action 16
        autodim 8.8  object_speed 16
        autodim 8.8  object_vel_cap 16
        autodim 8.8  object_friction 16
        autodim byte object_hp 16
        autodim byte object_damage 16
        autodim byte object_contact 16
        autodim byte object_flags 16
        autodim byte object_timer 16

        autodim init $2400 $24FF
        autodim byte reload_map
        autodim byte map_height
        autodim byte map_width
        autodim byte peekX
        autodim byte peekY
        autodim byte move_tile_1
        autodim byte move_tile_2
        autodim byte animation_frame
        autodim byte frame
        autodim byte flags
        autodim byte obj_index
        autodim byte joy0fire1_held
        autodim byte drop_rate
        autodim byte no_empty_slot

        ; ROOM HEADER
        autodim byte room
        autodim byte tileset
        autodim byte exit_dir
        autodim byte music
        autodim byte walkable
        autodim byte walkable_1
        autodim byte walkable_2
        autodim byte walk_test
        autodim byte walk_index
        autodim byte room_index

        dim current_map = $2600

        player_Xpos = 24
        player_Ypos = 60

        player_speed = 1.0
        player_friction = player_speed
        player_vel_cap = 5.0

        dec player_max_hp = $48
        dec player_hp = $48

        dec player_mp = $48
        dec player_max_mp = $48

        dec hp_seg_1 = 8
        dec hp_seg_2 = 8
        dec hp_seg_3 = 8
        dec hp_seg_4 = 8
        dec hp_seg_5 = 8
        dec hp_seg_6 = 8
        dec mp_seg_1 = 8
        dec mp_seg_2 = 8
        dec mp_seg_3 = 8
        dec mp_seg_4 = 8
        dec mp_seg_5 = 8
        dec mp_seg_6 = 8

        sword_pal = 2
        shield_pal = 2

;==============================================================================
; BANK 1
;------------------------------------------------------------------------------
; 7800basic initialization, title sequence code and graphics
;------------------------------------------------------------------------------
;==============================================================================
        incgraphic gfx/title/logo.png  320B 1 2 3 1 4
        incgraphic gfx/title/trees.png 320B 0 3 0 0 0
        incgraphic gfx/title/moon.png  320B 0 3 2 2 4
        incgraphic gfx/font.png        320A 0 2
        incmapfile tiled/title_blackforest.tmx
        game_state = STATE_TITLE

title_init
        gosub clear_palettes
        displaymode 320B
        bg_color = $71
        clearscreen
        characterset logo
        plotmapfile tiled/title_blackforest.tmx title_blackforest 0 0 40 14
        savescreen

title_handler
        restorescreen
        adjustvisible 0 4
        ; TODO: Handle, well, everything
        if !joy0fire0 || !joy0fire1 then goto main
        reload_map = 1
        room_index = 17
        tileset = T_FOREST
        game_state = STATE_FIELD

        ; shared_palettes
        P0C1 = $60 : P0C2 = $76 : P0C3 = $0F    ; purple, light purple, white -- magic HUD, torches
        P1C1 = $10 : P1C2 = $23 : P1C3 = $3B    ; dark brown, light brown, peach -- Johanna
        P2C1 = $30 : P2C2 = $45 : P2C3 = $1F    ; red, light red, gold -- HP HUD, equipment
        P3C1 = $50 : P3C2 = $55 : P3C3 = $5B    ; currently unused blues, equipment
        
        goto main

;==============================================================================
; BANK 2
;------------------------------------------------------------------------------
; Contains forest tileset graphics, maps, and enemy AI
;==============================================================================
        bank 2
        incgraphic gfx/tiles/forest_trees.png 160A 1 0 2 3 4
        incgraphic gfx/tiles/forest_rocks.png 160A 1 0 2 3 5
        incgraphic gfx/tiles/forest_water.png 160A 1 2 0 3 6
        incgraphic gfx/tiles/forest_map.png 160A 0 2 1 3
        incgraphic gfx/forest/hud.png 160A 0 3 1 2
        incgraphic gfx/forest/hud2.png 160A 0 3 1 2
        incgraphic gfx/sprites/wolf0.png 160A 0 2 3 1
        incgraphic gfx/sprites/wolf1.png 160A 0 2 3 1
        incgraphic gfx/sprites/wolf2.png 160A 0 2 3 1
        incgraphic gfx/sprites/wolf3.png 160A 0 2 3 1
        incgraphic gfx/sprites/slime0.png 160A 0 2 3 1
        incgraphic gfx/sprites/slime1.png 160A 0 2 3 1
        incgraphic gfx/sprites/minislime0.png 160A 0 2 3 1
        incgraphic gfx/sprites/minislime1.png 160A 0 2 3 1
        incgraphic gfx/sprites/raven0.png 160A 0 1 3 2
        incgraphic gfx/sprites/raven1.png 160A 0 1 3 2
        incgraphic gfx/sprites/raven2.png 160A 0 1 3 2
        incgraphic gfx/sprites/raven3.png 160A 0 1 3 2
        incgraphic gfx/sprites/raven4.png 160A 0 1 3 2
        incgraphic gfx/sprites/raven5.png 160A 0 1 3 2

        incmapfile tiled/forest.tmx
        incmapfile tiled/forest_room_1.tmx
        incmapfile tiled/forest_room_2.tmx
        incmapfile tiled/forest_room_3.tmx
        incmapfile tiled/forest_room_4.tmx
        incmapfile tiled/forest_room_5.tmx
        incmapfile tiled/forest_room_6.tmx
        incmapfile tiled/forest_room_7.tmx
        incmapfile tiled/forest_room_8.tmx
        incmapfile tiled/forest_room_9.tmx
        incmapfile tiled/forest_room_10.tmx
        incmapfile tiled/forest_room_11.tmx

load_forest

        ; forest_palettes
        bg_color = $11                          ; brown
        P4C1 = $00 : P4C2 = $C0 : P4C3 = $C3    ; greens used by trees and slimes
        P5C1 = $00 : P5C2 = $03 : P5C3 = $06    ; grays used by rocks and wolves
        P6C1 = $00 : P6C2 = $A1 : P6C3 = $06    ; blue and gray used by water
        P7C1 = $00 : P7C2 = $24 : P7C3 = $5B    ; currently unused, light browns?

        characterset forest_trees
        room = forest_rooms[room_index]
        if room = 1 then pointer = forest_room_1_obj_lo : pointer_hi = forest_room_1_obj_hi : goto plot_forest_room_1
        if room = 2 then pointer = forest_room_2_obj_lo : pointer_hi = forest_room_2_obj_hi : goto plot_forest_room_2
        if room = 3 then pointer = forest_room_3_obj_lo : pointer_hi = forest_room_3_obj_hi : goto plot_forest_room_3
        if room = 4 then pointer = forest_room_4_obj_lo : pointer_hi = forest_room_4_obj_hi : goto plot_forest_room_4
        if room = 5 then pointer = forest_room_5_obj_lo : pointer_hi = forest_room_5_obj_hi : goto plot_forest_room_5
        if room = 6 then pointer = forest_room_6_obj_lo : pointer_hi = forest_room_6_obj_hi : goto plot_forest_room_6
        if room = 7 then pointer = forest_room_7_obj_lo : pointer_hi = forest_room_7_obj_hi : goto plot_forest_room_7
        if room = 8 then pointer = forest_room_8_obj_lo : pointer_hi = forest_room_8_obj_hi : goto plot_forest_room_8
        if room = 9 then pointer = forest_room_9_obj_lo : pointer_hi = forest_room_9_obj_hi : goto plot_forest_room_9
        if room = 10 then pointer = forest_room_10_obj_lo : pointer_hi = forest_room_10_obj_hi : goto plot_forest_room_10
        if room = 11 then pointer = forest_room_11_obj_lo : pointer_hi = forest_room_11_obj_hi : goto plot_forest_room_11

; room 1 is the default and uses a "crossroads" setup in case the player gets out of bounds somehow
plot_forest_room_1
        plotmapfile tiled/forest_room_1.tmx forest_room_1 0 0 20 14
        memcpy current_map forest_room_1 280
        return

        data forest_room_1_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end


plot_forest_room_2
        plotmapfile tiled/forest_room_2.tmx forest_room_2 0 0 20 14
        memcpy current_map forest_room_2 280
        return

        data forest_room_2_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

plot_forest_room_3
        plotmapfile tiled/forest_room_3.tmx forest_room_3 0 0 20 14
        memcpy current_map forest_room_3 280
        return

        data forest_room_3_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  TYPE_SLIME, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

plot_forest_room_4
        plotmapfile tiled/forest_room_4.tmx forest_room_4 0 0 20 14
        memcpy current_map forest_room_4 280
        return

        data forest_room_4_obj
        TYPE_RAVEN, $54, $79,  $02, $2A, $30,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

plot_forest_room_5
        plotmapfile tiled/forest_room_5.tmx forest_room_5 0 0 20 14
        memcpy current_map forest_room_5 280
        return

        data forest_room_5_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

plot_forest_room_6
        plotmapfile tiled/forest_room_6.tmx forest_room_6 0 0 20 14
        memcpy current_map forest_room_6 280
        return

        data forest_room_6_obj
        TYPE_WOLF, $30, $30,
        TYPE_TORCH, $69, $20,
        TYPE_TORCH, $39, $20,
        TYPE_TORCH, $5E, $AF,
        TYPE_TORCH, $42, $AF,
        TYPE_WOLF, $70, $30,
        TYPE_SLIME, $40, $67,
        TYPE_SLIME, $80, $90,
        $00, $90, $88,
        $00, $40, $70,
        $00, $30, $20,
        $00, $80, $40,
        $00, $b0, $c0,
        $00, $77, $55,
        $00, $44, $22,
        $00, $33, $66,
end

plot_forest_room_7
        plotmapfile tiled/forest_room_7.tmx forest_room_7 0 0 20 14
        memcpy current_map forest_room_7 280
        return

        data forest_room_7_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

plot_forest_room_8
        plotmapfile tiled/forest_room_8.tmx forest_room_8 0 0 20 14
        memcpy current_map forest_room_8 280
        return

        data forest_room_8_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

plot_forest_room_9
        plotmapfile tiled/forest_room_9.tmx forest_room_9 0 0 20 14
        memcpy current_map forest_room_9 280
        return

        data forest_room_9_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

plot_forest_room_10
        plotmapfile tiled/forest_room_10.tmx forest_room_10 0 0 20 14
        memcpy current_map forest_room_10 280
        return

        data forest_room_10_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

plot_forest_room_11
        plotmapfile tiled/forest_room_11.tmx forest_room_11 0 0 20 14
        memcpy current_map forest_room_11 280
        return

        data forest_room_11_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

        data forest_rooms
        00, 00,  8, 07, 06, 00, 00,
        00,  9, 10, 04, 05, 11, 00,
        00, 00, 00, 03, 00, 00, 00,
        00, 00, 00, 02, 00, 00, 00,
        00, 00, 00, 01, 00, 00, 00,
        00, 00, 00, 00, 00, 00, 00,
        00, 00, 00, 00, 00, 00, 00
end

test_walkable_forest
        asm
        ldx #0
.loop   lda forest_walkable_tiles,x
        cmp move_tile_1
        bne .tile2
        pha
        lda #1
        sta walkable_1
        pla
.tile2  cmp move_tile_2
        bne .next
        lda #1
        sta walkable_2
.next   inx
        cpx #forest_walkable_tiles_length
        bne .loop
        lda walkable_1
        beq .done
        lda walkable_2
        beq .done
        lda #1
        sta walkable
.done
end
        goto walkable_return
;        for walk_index = 0 to forest_walkable_tiles_length
;        walk_test = forest_walkable_tiles[walk_index]
;        if walk_test = move_tile_1 then walkable_1 = 1
;        if walk_test = move_tile_2 then walkable_2 = 1
;        next
;        if !walkable_1 then walkable_return
;        if !walkable_2 then walkable_return
;        walkable = 1
;        goto walkable_return

        data forest_walkable_tiles
        $00, $02, $04, $0E, $12, $14, $16, $18, $1A, $1C, $1E, $20
end

;==============================================================================
; WOLF AI
;------------------------------------------------------------------------------
; Wolves wait for the player to get close (WOLF_CHASE_DIST), then give chase
;==============================================================================
wolf_ai
        const WOLF_CHASE_DIST = 32
        ; Once wolves start chasing, they don't stop
        if flags{7} then wolf_chase

        ; Test player distance to wolf
        temp1 = Xposition - player_Xpos
        if temp1 < WOLF_CHASE_DIST then wolf_chase
        temp1 = Yposition - player_Ypos
        if temp1 < (WOLF_CHASE_DIST * 2) then wolf_chase

wolf_anim
        ; Wolves flip left or right facing depending on player position
        frame = 0
        if Xposition < player_Xpos then frame = frame + 2
        if animation_frame then frame = frame + 1
        return

wolf_chase
        flags{7} = 1
        gosub get_player_pos
        gosub go_to_destination
        goto wolf_anim

obj_wolf_stats
; TODO: Make this implementation suck less
        const WOLF_SPEED_HI = 1
        const WOLF_SPEED_LO = 0
        const WOLF_HP = 2
        const WOLF_VEL_CAP_HI = 2
        const WOLF_VEL_CAP_LO = 0
        const WOLF_FRICTION_HI = 1
        const WOLF_FRICTION_LO = 0
        const WOLF_DAMAGE = 1
        const WOLF_CONTACT = 1
        const WOLF_DROP_RATE = 64

        object_hp[obj_index] = WOLF_HP
        object_contact[obj_index] = WOLF_CONTACT
        object_vel_cap_hi[obj_index] = WOLF_VEL_CAP_HI
        object_vel_cap_lo[obj_index] = WOLF_VEL_CAP_LO
        object_damage[obj_index] = WOLF_DAMAGE
        object_friction_hi[obj_index] = WOLF_FRICTION_HI
        object_friction_lo[obj_index] = WOLF_FRICTION_LO
        object_speed_hi[obj_index] = WOLF_SPEED_HI
        object_speed_lo[obj_index] = WOLF_SPEED_LO
        object_flags[obj_index] = 0
        goto obj_next_stats

;==============================================================================
; SLIME AI
;------------------------------------------------------------------------------
; A Slime draws near!
; Command?
;==============================================================================
slime_ai
        gosub get_player_pos
        gosub go_to_destination
        return

obj_slime_stats
        const SLIME_DROP_RATE = 128
        const SLIME_HP = 4
        const MSLIME_HP = SLIME_HP / 2
        const SLIME_CONTACT = 4
        const SLIME_VEL_CAP_HI = 1
        const SLIME_VEL_CAP_LO = 0
        const SLIME_DAMAGE = 4
        const SLIME_FRICTION_HI = 1
        const SLIME_FRICTION_LO = 0
        const SLIME_SPEED_HI = 0
        const SLIME_SPEED_LO = 50
        object_hp[obj_index] = SLIME_HP
        object_contact[obj_index] = SLIME_CONTACT
        object_vel_cap_hi[obj_index] = SLIME_VEL_CAP_HI
        object_vel_cap_lo[obj_index] = SLIME_VEL_CAP_LO
        object_damage[obj_index] = SLIME_DAMAGE
        object_friction_hi[obj_index] = SLIME_FRICTION_HI
        object_friction_lo[obj_index] = SLIME_FRICTION_LO
        object_speed_hi[obj_index] = SLIME_SPEED_HI
        object_speed_lo[obj_index] = SLIME_SPEED_LO
        object_flags[obj_index] = 0
        goto obj_next_stats

;==============================================================================
; RAVEN AI
;------------------------------------------------------------------------------
; Flies without testing walkability and perches on trees
;==============================================================================
raven_ai
        if debug_time = 1 then BACKGRND = $A0
        flags{2} = 1
        temp1 = 0
        temp2 = 0
        ; flags{7} = not perched
        if flags{7} then goto raven_change_pos
        frame = 0
        Xvelocity = 0.0
        Yvelocity = 0.0

test_dist_to_player
        if Xposition > player_Xpos then wake_raven_right
        if Xposition < player_Xpos then wake_raven_left
        if Yposition > player_Ypos then wake_raven_down
        if Yposition < player_Ypos then wake_raven_up
        ; raven and player occupy same space, handle this

wake_raven_right
        temp1 = Xposition - player_Xpos
        if temp1 < RAVEN_CHASE_DIST then raven_change_pos
        goto raven_return

wake_raven_left
        temp1 = Xposition + player_Xpos
        if temp1 < RAVEN_CHASE_DIST then raven_change_pos
        goto raven_return

wake_raven_up
        temp2 = Yposition + player_Ypos
        if temp2 < RAVEN_CHASE_DIST then raven_change_pos
        goto raven_return

wake_raven_down
        temp2 = Yposition - player_Ypos
        if temp2 < RAVEN_CHASE_DIST then raven_change_pos
        goto raven_return


raven_change_pos
        flags{7} = 1
        frame = 1
        if animation_frame then frame = frame + 2
        if !object_timer[index] then object_timer[index] = RAVEN_FLIGHT_TIME
        if flags{3} then raven_move
        if rand > 128 then gosub swoop_Y : raven_move
        gosub swoop_X
raven_move
        gosub go_to_destination

raven_perch
        temp1 = object_timer[index]
        object_timer[index] = object_timer[index] - 1
        if temp1 < object_timer[index] then object_timer[index] = 0
        if object_timer[index] > 0 then raven_return
        gosub test_walkable
        if !walkable then flags{7} = 0

raven_return
        if Xposition > player_Xpos then frame = frame + 1
        if debug_time = 1 then BACKGRND = bg_color
        return

obj_raven_stats
        const RAVEN_CHASE_DIST = 50
        const RAVEN_FLIGHT_TIME = 10
        const RAVEN_DROP_RATE = 128
        const RAVEN_HP = 4
        const RAVEN_CONTACT = 4
        const RAVEN_VEL_CAP_HI = 2
        const RAVEN_VEL_CAP_LO = 0
        const RAVEN_DAMAGE = 4
        const RAVEN_FRICTION_HI = 0
        const RAVEN_FRICTION_LO = 0
        const RAVEN_SPEED_HI = 1
        const RAVEN_SPEED_LO = 0
        object_hp[obj_index] = RAVEN_HP
        object_contact[obj_index] = RAVEN_CONTACT
        object_vel_cap_hi[obj_index] = RAVEN_VEL_CAP_HI
        object_vel_cap_lo[obj_index] = RAVEN_VEL_CAP_LO
        object_damage[obj_index] = RAVEN_DAMAGE
        object_friction_hi[obj_index] = RAVEN_FRICTION_HI
        object_friction_lo[obj_index] = RAVEN_FRICTION_LO
        object_speed_hi[obj_index] = RAVEN_SPEED_HI
        object_speed_lo[obj_index] = RAVEN_SPEED_LO
        object_flags[obj_index] = 0
        goto obj_next_stats

;==============================================================================
; BANK 8
;------------------------------------------------------------------------------
; Permanently loaded bank. Contains sprites and code used with every tileset
;==============================================================================
        bank 8
        incgraphic gfx/sprites/heroine0.png  160B 0 4 5 3 6 1 ; FRAME_DOWN
        incgraphic gfx/sprites/heroine1.png  160B 0 4 5 3 6 1 ; FRAME_DOWN_2
        incgraphic gfx/sprites/heroine2.png  160B 0 4 5 6 3   ; FRAME_UP
        incgraphic gfx/sprites/heroine3.png  160B 0 4 5 6 3   ; FRAME_UP_2
        incgraphic gfx/sprites/heroine4.png  160B 0 4 5 6 3 1 ; FRAME_LEFT
        incgraphic gfx/sprites/heroine5.png  160B 0 4 5 6 3 1 ; FRAME_LEFT_2
        incgraphic gfx/sprites/heroine6.png  160B 0 4 5 3 6 1 ; FRAME_RIGHT
        incgraphic gfx/sprites/heroine7.png  160B 0 4 5 3 6 1 ; FRAME_RIGHT_2
        incgraphic gfx/sprites/heroine8.png  160B 0 4 5 3 6 1 ; FRAME_ATK_D
        incgraphic gfx/sprites/heroine9.png  160B 0 4 6 5 3   ; FRAME_ATK_U
        incgraphic gfx/sprites/heroine10.png 160B 0 4 5 6 3 1 ; FRAME_ATK_L
        incgraphic gfx/sprites/heroine11.png 160B 0 4 5 3 6 1 ; FRAME_ATK_R
        incgraphic gfx/sprites/link.png      160B 0 4 5 6 3 1 ; FRAME_CHANT (bugged if heroine12.png is used?)
        incgraphic gfx/sprites/sword0.png 160A 0 1 3
        incgraphic gfx/sprites/sword1.png 160A 0 3 1
        incgraphic gfx/sprites/sword2.png 160A 0 1 3
        incgraphic gfx/sprites/sword3.png 160A 0 1 3
        incgraphic gfx/sprites/shield.png 160A 0 2 1
        incgraphic gfx/sprites/torch0.png 160B 0 1 2 3 6 5 4
        incgraphic gfx/sprites/torch1.png 160B 0 1 2 3 5 6 4
        incgraphic gfx/sprites/hp.png 160B 0 3 7 8 1 2
        incgraphic gfx/sprites/mp.png 160A 0 3 1
        incgraphic gfx/sprites/bar0.png 160A 0 1
        incgraphic gfx/sprites/bar1.png 160A 0 2 1
        incgraphic gfx/sprites/bar2.png 160A 0 2 1
        incgraphic gfx/sprites/bar3.png 160A 0 2 1
        incgraphic gfx/sprites/bar4.png 160A 0 2 1
        incgraphic gfx/sprites/bar5.png 160A 0 2 1
        incgraphic gfx/sprites/bar6.png 160A 0 2 1
        incgraphic gfx/sprites/bar7.png 160A 0 2 1
        incgraphic gfx/sprites/bar8.png 160A 0 2 1
        incgraphic gfx/sprites/coin.png 160A 0 3 2
        incgraphic gfx/sprites/prism.png 160A 0 3 2 1

;==============================================================================
; LOAD OBJECTS
;------------------------------------------------------------------------------
; Fills all 16 object slots with type and position data from ROM,
; then interates through each type to set object properties
; Utilizes pointers so multiple maps can reuse the same object data if desired
;==============================================================================
load_objects
        temp1 = 0
        for obj_index = 0 to MAX_OBJECTS
        object_type[obj_index] = pointer[[temp1]]
        temp1 = temp1 + 1
        object_Xpos[obj_index] = pointer[[temp1]]
        temp1 = temp1 + 1
        object_Ypos[obj_index] = pointer[[temp1]]
        temp1 = temp1 + 1
        next
        for obj_index = 0 to MAX_MAP_OBJECTS
        if !object_type[obj_index] then next_obj_stats
        if object_type[obj_index] = TYPE_WOLF then obj_wolf_stats
        if object_type[obj_index] = TYPE_TORCH then obj_torch_stats
        if object_type[obj_index] = TYPE_SLIME then obj_slime_stats
        if object_type[obj_index] = TYPE_MSLIME then obj_slime_stats : object_hp[obj_index] = MSLIME_HP
        if object_type[obj_index] = TYPE_RAVEN then obj_raven_stats


obj_next_stats
        next
        return

obj_torch_stats
        object_hp[obj_index] = 1
        object_contact[obj_index] = 0
        object_vel_cap_hi[obj_index] = 0
        object_vel_cap_lo[obj_index] = 0
        object_damage[obj_index] = 0
        object_friction_hi[obj_index] = 0
        object_friction_lo[obj_index] = 0
        object_speed_hi[obj_index] = 0
        object_speed_lo[obj_index] = 0
        object_flags[obj_index] = 0
        goto obj_next_stats

load_map
        clearscreen
        displaymode 160A
        adjustvisible 0 14
        game_state = STATE_FIELD
        if tileset = T_FOREST then loadrombank 2 : gosub load_forest
        savescreen
        gosub load_objects
        reload_map = 0
        if exit_dir = EXIT_SOUTH then player_Ypos = 16  : player_Ydir = DIR_DOWN
        if exit_dir = EXIT_NORTH then player_Ypos = 204 : player_Ydir = DIR_UP
        if exit_dir = EXIT_EAST  then player_Xpos = 148 : player_Xdir = DIR_LEFT
        if exit_dir = EXIT_WEST  then player_Xpos = 16  : player_Xdir = DIR_RIGHT
        exit_dir = EXIT_NONE

field_handler
        if reload_map = 1 then goto load_map
        gosub player_handler
        gosub object_handler
        gosub check_collisions

        ; Currently only two frames of animation supported. Needs to be changed if more than 2
        animation_frame = 0
        if animation_timer > (ANIM_TIME / 2) then animation_frame = 1
        
        restorescreen
        if debug_time then BACKGRND = $06
        ; Iterates through all objects and determined which sprites need to be plotted by type
        for index = 0 to 15
        if !object_type[index] then goto plot_next
        if object_type[index] = TYPE_SPAWNER then plot_next
        Xposition = object_Xpos[index] : Yposition = object_Ypos[index] : frame = object_frame[index]
        if object_type[index] = TYPE_WOLF then plot_wolf
        if object_type[index] = TYPE_TORCH then plot_torch
        if object_type[index] = TYPE_COIN then plot_coin
        if object_type[index] = TYPE_PRISM then plot_prism
        if object_type[index] = TYPE_SLIME then plot_slime
        if object_type[index] = TYPE_MSLIME then plot_minislime
        if object_type[index] = TYPE_RAVEN then plot_raven
plot_next
        next
        ; Plot the player, their shield, and sword if attacking
        if player_state = STATE_CHANT then plotsprite link 0 player_Xpos player_Ypos 0 : goto plot_hud
        if player_state = STATE_ATTACK then plotsprite sword0 sword_pal sword_Xpos sword_Ypos sword_frame
        plotsprite heroine0 0 player_Xpos player_Ypos player_frame
        ; TODO: Multiple shield frames depending on direction/state
        plotsprite shield shield_pal shield_Xpos shield_Ypos shield_frame
        if debug_time then BACKGRND = bg_color
plot_hud
        gosub draw_hud
        goto main

plot_wolf
        PLOTSPRITE wolf0 5 Xposition Yposition frame
        goto plot_next

plot_torch
        PLOTSPRITE torch0 0 Xposition Yposition animation_frame
        goto plot_next

plot_coin
        PLOTSPRITE coin 3 Xposition Yposition 0
        goto plot_next

plot_prism
        PLOTSPRITE prism 0 Xposition Yposition 0
        goto plot_next

plot_slime
        PLOTSPRITE slime0 4 Xposition Yposition animation_frame
        goto plot_next

plot_minislime
        PLOTSPRITE minislime0 4 Xposition Yposition animation_frame
        goto plot_next

plot_raven
        PLOTSPRITE raven0 5 Xposition Yposition frame
        goto plot_next


;==============================================================================
; DRAW HUD
;------------------------------------------------------------------------------
; Draws the player's HP and MP bar in zones 1-2 using sprites.
; Bars must be plotted in separate zones or there isn't enough DMA time
;==============================================================================
draw_hud
        if debug_time then BACKGRND = $43
        plotsprite  hp   0  8  0       ; HP is 160B
        plotsprite  bar0 2 24  0 hp_seg_1
        PLOTSPRITE4 bar0 2 32  0 hp_seg_2
        PLOTSPRITE4 bar0 2 40  0 hp_seg_3
        PLOTSPRITE4 bar0 2 48  0 hp_seg_4
        PLOTSPRITE4 bar0 2 56  0 hp_seg_5
        PLOTSPRITE4 bar0 2 64  0 hp_seg_6
        plotsprite  mp   0  8 16        ; Need to use plotsprite here to avoid rendering error on MP bar
        PLOTSPRITE4 bar0 0 24 16 mp_seg_1
        PLOTSPRITE4 bar0 0 32 16 mp_seg_2
        PLOTSPRITE4 bar0 0 40 16 mp_seg_3
        PLOTSPRITE4 bar0 0 48 16 mp_seg_4
        PLOTSPRITE4 bar0 0 56 16 mp_seg_5
        PLOTSPRITE4 bar0 0 64 16 mp_seg_6
        if debug_hud = 0 then return
        plotvalue hud 0 player_hp 2 72 0
        plotvalue hud 0 player_mp 2 72 1
        plotvalue hud 0 player_Xpos 4 32 12
        plotvalue hud2 0 move_tile_1 4 32 13
        plotvalue hud 0 room_index 2 32 13
        plotvalue hud 0 room 2 48 13
        ; plotvalue hud 0 retract_counter 2 64 13
        if debug_time then BACKGRND = bg_color
        return

menu_handler
        goto field_handler

followplayer
        if Xposition > player_Xpos then Xvelocity = Xvelocity + move_speed : Xdirection = DIR_LEFT
        if Xposition < player_Xpos then Xvelocity = Xvelocity + move_speed : Xdirection = DIR_RIGHT
        if Yposition > player_Ypos then Yvelocity = Yvelocity + move_speed : Ydirection = DIR_UP
        if Yposition < player_Ypos then Yvelocity = Yvelocity + move_speed : Ydirection = DIR_DOWN
        return

get_player_pos
        Xdestination = player_Xpos : Ydestination = player_Ypos
        return

get_player_dir
        Xdirection = player_Xdir
        Ydirection = player_Ydir
        return

go_to_destination
        if Xposition > Xdestination then Xvelocity = Xvelocity + move_speed : Xdirection = DIR_LEFT
        if Xposition < Xdestination then Xvelocity = Xvelocity + move_speed : Xdirection = DIR_RIGHT
        if Yposition > Ydestination then Yvelocity = Yvelocity + move_speed : Ydirection = DIR_UP
        if Yposition < Ydestination then Yvelocity = Yvelocity + move_speed : Ydirection = DIR_DOWN
        if Xposition = Xdestination then flags{3} = 0
        if Yposition = Ydestination then flags{3} = 0
        return

swoop_X
        gosub get_player_dir
        gosub get_player_pos
        if Ydirection = DIR_DOWN then Ydestination = Ydestination + 32
        Ydestination = Ydestination - 32
swoop_X_vel
        Xvelocity = Xvelocity + move_speed
        Yvelocity = Yvelocity + move_speed
        flags{3} = 1
        return

swoop_Y
        gosub get_player_dir
        gosub get_player_pos
        if Xdirection = DIR_LEFT then Xdestination = Xdestination - 16 : swoop_Y_vel
        Xdestination = Xdestination + 16
swoop_Y_vel
        temp3 = move_speed / 2
        temp4 = move_speed + move_speed
        Xvelocity = Xvelocity + temp3
        Yvelocity = Yvelocity + temp4
        flags{3} = 1
        return

object_handler
        for index = 0 to 15
        if !object_type[index] then object_done    ; 0 = no object
        if object_type[index] = TYPE_COIN then object_done      ;  coins, prisms are static
        if object_type[index] = TYPE_PRISM then object_done
        if object_type[index] = TYPE_SPAWNER then spawn_object
        if object_type[index] = TYPE_TORCH then torch_tile_block
        gosub copy_object_props 
        gosub decelerate_object
        if object_type[index] = TYPE_WOLF then gosub wolf_ai
        if object_type[index] = TYPE_SLIME then gosub slime_ai
        if object_type[index] = TYPE_MSLIME then gosub slime_ai
        if object_type[index] = TYPE_RAVEN then gosub raven_ai     
        gosub move_object
        gosub restore_object_props
object_done
        if debug_time = 1 then BACKGRND = bg_color
        next
        return

torch_tile_block
        if debug_time = 1 then BACKGRND = $76
        if object_flags[index] then object_done
        gosub get_torch_pos
        pokechar current_map peekX peekY 20 14 10
        object_flags[index] = 1
        goto object_done

spawn_object
        ; index is still set by object_handler
        if object_flags[index] = TYPE_TORCH then spawns_torch
        drop_rate = 0
        if object_flags[index] = TYPE_WOLF then drop_rate = WOLF_DROP_RATE
        if object_flags[index] = TYPE_SLIME then drop_rate = SLIME_DROP_RATE

        if rand > drop_rate then spawn_nothing

        if object_flags[index] = TYPE_WOLF then spawns_wolf
        if object_flags[index] = TYPE_SLIME then spawns_slime
        goto object_done

spawns_slime
        ; TODO: Unique drops

spawns_wolf
        ; TODO: Unique wolf item drops
spawns_torch
        if player_mp = player_max_mp then _spawn_coin

_spawn_mana
        object_type[index] = TYPE_PRISM
        object_hp[index] = 1
        goto object_done

_spawn_coin
        object_type[index] = TYPE_COIN
        object_hp[index] = 1
        goto object_done

spawn_nothing
        object_type[index] = 0
        goto object_done

player_handler
        dec player_damage = $1
;        gosub copy_player_props
        gosub decelerate_player
;        gosub restore_player_props

;==============================================================================
; SUBROUTINE: HANDLE INPUT FIELD
;------------------------------------------------------------------------------
; This routine handles all player input in the field
;==============================================================================
handle_input_field
        if debug_time then BACKGRND = $70

        ; player timer is set for knockback and attack timing
        if !player_timer then no_player_timer
        player_timer = player_timer - 1
        if player_state = STATE_KNOCKBACK then test_joy_done
        if player_state = STATE_ATTACK then test_joy_done

no_player_timer
        player_flags{0} = 0     ; clear invulnerability flag

;------------------------------------------------------------------------------
        ; handles chanting and sword retracting. Zero if not doing these
        if player_state = STATE_CHANT then chant_handler
        if player_state = STATE_ATTACK then retract_sword
        if joy0fire0 then goto player_attack

        asm
        lda #0
        sta retract_counter
        sta chant_timer
        sta player_state        ; STATE_STAND
        sta player_exiting_chant
end

;------------------------------------------------------------------------------

        if player_facing = DIR_UP then player_frame = FRAME_UP : goto frames_done
        if player_facing = DIR_DOWN then player_frame = FRAME_DOWN : goto frames_done
        if player_facing = DIR_LEFT then player_frame = FRAME_LEFT : goto frames_done
        player_frame = FRAME_RIGHT

frames_done
        if joy0up    then player_Ydir = DIR_UP    : player_facing = DIR_UP    : player_frame = FRAME_UP    : player_Yvel = player_Yvel + player_speed : player_state = STATE_MOVING : test_joy_done
        if joy0down  then player_Ydir = DIR_DOWN  : player_facing = DIR_DOWN  : player_frame = FRAME_DOWN  : player_Yvel = player_Yvel + player_speed : player_state = STATE_MOVING : test_joy_done
        if joy0left  then player_Xdir = DIR_LEFT  : player_facing = DIR_LEFT  : player_frame = FRAME_LEFT  : player_Xvel = player_Xvel + player_speed : player_state = STATE_MOVING : test_joy_done
        if joy0right then player_Xdir = DIR_RIGHT : player_facing = DIR_RIGHT : player_frame = FRAME_RIGHT : player_Xvel = player_Xvel + player_speed : player_state = STATE_MOVING : test_joy_done

test_joy_done
        if joy0fire1 then goto open_menu
        if player_state = STATE_STAND || player_state = STATE_ATTACK then player_move_done
        gosub copy_player_props
        gosub move_object
        gosub restore_player_props

player_move_done

        shield_Xpos = player_Xpos + SHIELD_OFFSET_X
        shield_Ypos = player_Ypos + SHIELD_OFFSET_Y

input_frame_done
        if !player_Xvel && !player_Yvel && player_state <> STATE_ATTACK && player_state <> STATE_CHANT then player_state = STATE_STAND
        if animation_frame && player_state = STATE_MOVING then player_frame = player_frame + 1

check_room_boundary
        if player_Xpos < 2  then exit_dir = EXIT_EAST  : room_index = room_index - 1
        if player_Xpos > 149 then exit_dir = EXIT_WEST  : room_index = room_index + 1
        if player_Ypos < 2  then exit_dir = EXIT_NORTH : room_index = room_index - ROOMS_PER_ROW
        if player_Ypos > 204 then exit_dir = EXIT_SOUTH : room_index = room_index + ROOMS_PER_ROW
        if exit_dir then reload_map = 1
        if debug_time then BACKGRND = bg_color
        return

open_menu
        game_state = STATE_MENU
        return

player_attack
        ; player exiting chant tracks if the player cast magic to exit chant with button held
        if player_exiting_chant then test_joy_done
        if retract_counter then retract_sword
        if player_facing = DIR_DOWN then sword_Xpos = player_Xpos : sword_Ypos = player_Ypos + SWORD_OFFSET_DOWN : sword_width = 4 : sword_height = 16 : sword_frame = 0 : goto sword_done
        if player_facing = DIR_UP   then sword_Xpos = player_Xpos : sword_Ypos = player_Ypos + SWORD_OFFSET_UP   : sword_width = 4 : sword_height = 16 : sword_frame = 1 : goto sword_done
        if player_facing = DIR_LEFT then sword_Xpos = player_Xpos + SWORD_OFFSET_LEFT : sword_Ypos = player_Ypos : sword_width = 12 : sword_height = 4 :sword_frame = 3 : goto sword_done
        sword_Xpos = player_Xpos + SWORD_OFFSET_RIGHT : sword_Ypos = player_Ypos : sword_width = 12 : sword_height = 4 : sword_frame = 2
sword_done
        if player_facing = DIR_LEFT  then player_frame = FRAME_ATK_L : goto player_attack_return
        if player_facing = DIR_RIGHT then player_frame = FRAME_ATK_R : goto player_attack_return
        if player_facing = DIR_UP    then player_frame = FRAME_ATK_U : goto player_attack_return
        if player_facing = DIR_DOWN  then player_frame = FRAME_ATK_D

player_attack_return
        player_state = STATE_ATTACK
        player_timer = ATTACK_FRAMES
        if debug_time then BACKGRND = bg_color
        return

retract_sword
        if player_facing = DIR_DOWN  then sword_Ypos = sword_Ypos - 4 : retract_step_done
        if player_facing = DIR_UP    then sword_Ypos = sword_Ypos + 4 : retract_step_done
        if player_facing = DIR_LEFT  then sword_Xpos = sword_Xpos + 2 : retract_step_done
        if player_facing = DIR_RIGHT then sword_Xpos = sword_Xpos - 2

retract_step_done
        retract_counter = retract_counter + 1
        if retract_counter < 3 then test_joy_done

retract_stand
        if !joy0fire0 then player_state = STATE_STAND : goto test_joy_done
        ; retract finished and button still held - code runs into player_chant_start

player_chant_start
        if chant_timer > CHANT_START_TIME then set_state_chant
        player_state = STATE_CHANT_START
        asm
        inc chant_timer
end
        if player_facing = DIR_UP    then player_frame = FRAME_UP
        if player_facing = DIR_DOWN  then player_frame = FRAME_DOWN
        if player_facing = DIR_LEFT  then player_frame = FRAME_LEFT
        if player_facing = DIR_RIGHT then player_frame = FRAME_RIGHT
        goto test_joy_done

set_state_chant
        ; set player state to chant and facing direction to down
        ; facing down when coming out of chant just feels more natural
        player_state = STATE_CHANT
        player_facing = DIR_DOWN

chant_handler
        ; TODO: EVERYTHING!!!

        ; flash the light purple palette entry (MP bar)
        ; P0C2 = BAR_NORMAL_COLOR
        ; if player_state = STATE_CHANT && animation_timer > ANIM_TIME / 2 then P0C2 = BAR_FLASH_COLOR
        
        ; Test: summon a wolf on left input

        if joy0left then summon_test_wolf
        if !joy0fire0 then chant_done_no_hold
        goto test_joy_done

chant_done
        player_exiting_chant = 1
chant_done_no_hold
        player_state = STATE_STAND
        chant_timer = 0
        gosub decrease_player_mp
        goto test_joy_done

summon_test_wolf
        dec mp_change = $20
        gosub test_spell_cost
        if !mp_change then test_joy_done ; allow player to try a different input
        object_type[14] = TYPE_WOLF
        object_Xpos[14] = player_Xpos
        object_Ypos[14] = player_Ypos + 18
        goto chant_done

decelerate_player
        asm
        lda player_friction
        beq decel_preturn
        lda player_Xvel
        beq decel_pY
        pha
;        lda player_Xvel_lo
        sec
;        sbc player_friction_lo
;        sta player_Xvel_lo
;        lda player_Xvel_hi
        sbc player_friction_hi
        sta player_Xvel_hi
        pla
        cmp player_Xvel_hi
        bcs decel_pY
        lda #0
        sta player_Xvel_lo
        sta player_Xvel_hi

decel_pY
        lda player_Yvel_hi
        beq decel_preturn
        pha
        lda player_Yvel_lo
        sec
        sbc player_friction_lo
        sta player_Yvel_lo
        lda player_Yvel_hi
        sbc player_friction_hi
        sta player_Yvel_hi
        pla
        cmp player_Yvel_hi
        bcs decel_return
        lda #0
        sta player_Yvel_lo
        sta player_Yvel_hi

decel_preturn
        rts
end

decelerate_object
        asm
        ldx index
        lda object_friction,x
        beq decel_return
        lda object_Xvel,x
        beq decel_Y
        pha
        lda object_Xvel_lo,x
        sec
        sbc object_friction_lo,x
        sta object_Xvel_lo,x
        lda object_Xvel_hi,x
        sbc object_friction_hi,x
        sta object_Xvel_hi,x
        pla
        cmp object_Xvel_hi,x
        bcs decel_Y
        lda #0
        sta object_Xvel_lo,x
        sta object_Xvel_hi,x

decel_Y
        lda object_Yvel_hi,x
        beq decel_return
        pha
        lda object_Yvel_lo,x
        sec
        sbc object_friction_lo,x
        sta object_Yvel_lo,x
        lda object_Yvel_hi,x
        sbc object_friction_hi,x
        sta object_Yvel_hi,x
        pla
        cmp object_Yvel_hi,x
        bcs decel_return
        lda #0
        sta object_Yvel_lo,x
        sta object_Yvel_hi,x

decel_return
        rts
end

;==============================================================================
; SUBROUTINE: MOVE_OBJECT
;------------------------------------------------------------------------------
; Moves an object based on the non-fractional component of their velocities.
; Tests against an array of walkable tiles for current tileset before moving.
;
; All move test labels add 8 to Yposistion to allow objects to overlap
; unwalkable tiles that are above them. Objects are assumed to be 12x16
; and magic numbers are used throughout the code to improve the feel of
; player collisions with map tiles at the expense of other sprite proportions
;==============================================================================
move_object
        if debug_time then BACKGRND = $96

        ; Cap the object's velocity TODO: separate X/Y cap?
        if Xvelocity > vel_cap then Xvelocity = vel_cap
        if Yvelocity > vel_cap then Yvelocity = vel_cap

        ; Current direction(s) are determined by player input or AI logic
        if Ydirection = DIR_UP    then gosub move_test_up
        if Ydirection = DIR_DOWN  then gosub move_test_down
        if Xdirection = DIR_LEFT  then gosub move_test_left
        if Xdirection = DIR_RIGHT then gosub move_test_right
        goto move_return

move_test_up
        if flags{2} then move_up
        asm
        lda Xposition
        clc
        adc #2
        lsr
        lsr
        lsr
        sta peekX
        lda Yposition
        clc
        adc #8
        sec
        sbc Yvelocity_hi
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_1 = peekchar (current_map, peekX, peekY, 20, 14)
;        peekX = (Xposition + 8) / TILE_WIDTH
        asm
        lda Xposition
        clc
        adc #8
        lsr
        lsr
        lsr
        sta peekX
end
        move_tile_2 = peekchar (current_map, peekX, peekY, 20, 14)
        gosub test_walkable
        if !walkable then return
move_up
        Yposition = Yposition - Yvelocity_hi
        return

move_test_down
        if flags{2} then move_down
        ;peekX = (Xposition + 2) / TILE_WIDTH
        ;peekY = ((Yposition + Yvelocity_hi) + 15) / TILE_HEIGHT
        asm
        lda Xposition
        clc
        adc #2
        lsr
        lsr
        lsr
        sta peekX
        lda Yposition
        clc
        adc #15
        clc
        adc Yvelocity_hi
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_1 = peekchar (current_map, peekX, peekY, 20, 14)
        ;peekX = (Xposition + 8) / TILE_WIDTH
        asm
        lda Xposition
        clc
        adc #8
        lsr
        lsr
        lsr
        sta peekX
end
        move_tile_2 = peekchar (current_map, peekX, peekY, 20, 14)
        gosub test_walkable
        if !walkable then return
move_down
        Yposition = Yposition + Yvelocity_hi
        return

move_test_left
        if flags{2} then move_left
;        peekX = ((Xposition + 2) - Xvelocity_hi) / TILE_WIDTH
        ; Add 8 to Y position to allow object to overlap solid tiles above it slightly
;        peekY = (Yposition + 8) / TILE_HEIGHT
        asm
        lda Xposition
        clc
        adc #2
        sec
        sbc Xvelocity_hi
        lsr
        lsr
        lsr
        sta peekX
        lda Yposition
        clc
        adc #8
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_1 = peekchar (current_map, peekX, peekY, 20, 14)
;        peekY = (Yposition + 15) / TILE_HEIGHT
        asm
        lda Yposition
        clc
        adc #15
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_2 = peekchar (current_map, peekX, peekY, 20, 14)
        gosub test_walkable
        if !walkable then return
move_left
        Xposition = Xposition - Xvelocity_hi
        return

move_test_right
        if flags{2} then move_right
;        peekX = ((Xposition + 9) + Xvelocity_hi) / TILE_WIDTH
        ; Add 8 to Y position to allow object to overlap solid tiles above it slightly
;        peekY = (Yposition + 8) / TILE_HEIGHT
        asm
        lda Xposition
        clc
        adc #9
        clc
        adc Xvelocity_hi
        lsr
        lsr
        lsr
        sta peekX
        lda Yposition
        clc
        adc #8
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_1 = peekchar (current_map, peekX, peekY, 20, 14)
;        peekY = (Yposition + 15) / TILE_HEIGHT
        asm
        lda Yposition
        clc
        adc #15
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_2 = peekchar (current_map, peekX, peekY, 20, 14)
        gosub test_walkable
        if !walkable then return
move_right
        Xposition = Xposition + Xvelocity_hi
        return
        
move_return
        if debug_time then BACKGRND = bg_color
        return

test_walkable
        ; start by assuming the tile isn't walkable (fewer tests)
;        walkable = 0
;        walkable_1 = 0
;        walkable_2 = 0
        asm
        lda #0
        sta walkable
        sta walkable_1
        sta walkable_2
end
        if tileset = T_FOREST then test_walkable_forest
walkable_return
        return

check_collisions
        if debug_time = 1 then BACKGRND = $95
        for index = 0 to 15
        if !object_type[index] then cc_next
        Xposition = object_Xpos[index]
        Yposition = object_Ypos[index]
        if object_type[index] = TYPE_COIN then cc_pickup
        if object_type[index] = TYPE_PRISM then cc_pickup
        if player_state <> STATE_ATTACK then cc_player_contact
        gosub sword_collision
        if !object_hp[index] then kill_object
cc_player_contact
        ; need to test torches here so the sword can still damage them
        ; but they don't knock the player back on contact
        if object_type[index] = TYPE_TORCH then cc_next
        hp_change = object_contact[index]
        gosub player_knockback
cc_next
        if debug_time = 1 then BACKGRND = bg_color
        next
cc_return
        return

cc_pickup
        if Xposition > player_Xpos && Xposition < (player_Xpos + 12) && Yposition > player_Ypos && Yposition < (player_Ypos + 16) then pickup_item
        goto cc_next

pickup_item
        if object_type[index] = TYPE_PRISM then mp_change = $10 : gosub increase_player_mp
        ; runs into kill_object

kill_object
        ; TODO: Death animation
        if object_type[index] <> TYPE_TORCH then change_to_spawner
        ; torches make their tile walkable
        if debug_time = 1 then BACKGRND = $73
        gosub get_torch_pos
        pokechar current_map peekX peekY 20 14 0
        if debug_time = 1 then BACKGRND = bg_color
change_to_spawner
        if object_type[index] = TYPE_SLIME && animation_frame then goto split_slime
        ; switch the object's flags to its old type and its type to a spwaner
        object_flags[index] = object_type[index]
        object_type[index] = TYPE_SPAWNER
        goto cc_next

split_slime
        if debug_time = 1 then BACKGRND = $B9
        ; replace slime mobj with mini slime
        object_type[index] = TYPE_MSLIME
        object_hp[index] = MSLIME_HP
        temp1 = object_Xpos[index]
        temp2 = object_Ypos[index]
        ; mini slime is moved to the left of the parent slime's pos
        object_Xpos[index] = object_Xpos[index] - 1
        gosub find_new_object
        ; if no slots, the slime just becomes a single mini slime
        if no_empty_slot then object_Xpos[index] = temp1 : cc_next
        ; initialize the new mini slime object
        object_type[index] = TYPE_MSLIME
        object_hp[index] = MSLIME_HP
        object_contact[index] = SLIME_CONTACT
        object_vel_cap_hi[index] = SLIME_VEL_CAP_HI
        object_vel_cap_lo[index] = SLIME_VEL_CAP_LO
        object_damage[index] = SLIME_DAMAGE
        object_friction_hi[index] = SLIME_FRICTION_HI
        object_friction_lo[index] = SLIME_FRICTION_LO
        object_speed_hi[index] = SLIME_SPEED_HI
        object_speed_lo[index] = SLIME_SPEED_LO
        ; mini slime spawns to the right of the parent slime's pos
        object_Xpos[index] = temp1 + 9
        object_Ypos[index] = temp2
        goto cc_next

sword_collision
        if !boxcollision (sword_Xpos, sword_Ypos, sword_width, sword_height, Xposition, Yposition, 12, 16) then return
sword_damage
        ; TODO: Much better damage calculations
        temp_hp = object_hp[index]
        hp_change = player_damage
        gosub decrease_hp
        object_hp[index] = temp_hp
        return

player_knockback
        if player_flags{0} then return  ; player is invulnerable, bypass collision check to save cycles
        if !boxcollision (player_Xpos, player_Ypos, PLAYER_WIDTH, PLAYER_HEIGHT, Xposition, Yposition, 12, 16) then return
        if Yposition <= player_Ypos then player_Yvel = 10.0 : player_Ydir = DIR_DOWN  : player_frame = FRAME_UP    : goto pc_damage
        if Yposition >= player_Ypos then player_Yvel = 10.0 : player_Ydir = DIR_UP    : player_frame = FRAME_DOWN  : goto pc_damage
        if Xposition >= player_Xpos then player_Xvel = 5.0 : player_Xdir = DIR_LEFT  : player_frame = FRAME_RIGHT : goto pc_damage
        if Xposition <= player_Xpos then player_Xvel = 5.0 : player_Xdir = DIR_RIGHT : player_frame = FRAME_LEFT
pc_damage
        ; avoid a tail call with goto
        player_flags{0} = 1
        player_state = STATE_KNOCKBACK
        player_timer = INVULN_FRAMES
        goto damage_player_hp

; takes a torch's X & Y position and determines the map tile under it, stores in peekX & Y
get_torch_pos
        asm
        ldx index
        lda object_Xpos,x
        clc
        adc #4          ; forces X calculation onto correct map tile
        lsr
        lsr
        lsr
        sta peekX
        lda object_Ypos,x
        clc
        adc #8          ; forces Y calculation onto correct map tile
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        return

; copies player movement variables to be manipulated by movement subroutines
copy_player_props
        if debug_time = 1 then BACKGRND = $E9
        asm
        lda player_Xpos
        sta Xposition
        lda player_Xdir
        sta Xdirection
        lda player_Xvel_lo
        sta Xvelocity_lo
        lda player_Xvel_hi
        sta Xvelocity_hi
        lda player_Ypos
        sta Yposition
        lda player_Ydir
        sta Ydirection
        lda player_Yvel_lo
        sta Yvelocity_lo
        lda player_Yvel_hi
        sta Yvelocity_hi
        lda player_vel_cap
        sta vel_cap
        lda player_friction
        sta friction
end
        if debug_time = 1 then BACKGRND = bg_color
        return

; restores movement variables from subroutines back to player
restore_player_props
        if debug_time = 1 then BACKGRND = $E7
        asm
        lda Xposition
        sta player_Xpos
        lda Xvelocity_lo
        sta player_Xvel_lo
        lda Xvelocity_hi
        sta player_Xvel_hi
        lda Yposition
        sta player_Ypos
        lda Yvelocity_lo
        sta player_Yvel_lo
        lda Yvelocity_hi
        sta player_Yvel_hi
end
        if debug_time = 1 then BACKGRND = bg_color
        return

copy_object_props
        if debug_time then BACKGRND = $D6
        asm
        ldx index
        lda object_Xpos,x
        sta Xposition
        lda object_Xdir,x
        sta Xdirection
        lda object_Xvel_lo,x
        sta Xvelocity_lo
        lda object_Xvel_hi,x
        sta Xvelocity_hi
        lda object_Ypos,x
        sta Yposition
        lda object_Ydir,x
        sta Ydirection
        lda object_Yvel_lo,x
        sta Yvelocity_lo
        lda object_Yvel_hi,x
        sta Yvelocity_hi
        lda object_speed_lo,x
        sta move_speed_lo
        lda object_speed_hi,x
        sta move_speed_hi
        lda object_vel_cap_lo,x
        sta vel_cap_lo
        lda object_vel_cap_hi,x
        sta vel_cap_hi
        lda object_friction_lo,x
        sta friction_lo
        lda object_friction_hi,x
        sta friction_hi
        lda object_frame,x
        sta frame
        lda object_flags,x
        sta flags
end
        if debug_time then BACKGRND = bg_color
        asm
        rts
end

restore_object_props
        if debug_time then BACKGRND = $36
        asm
        ldx index
        lda Xposition
        sta object_Xpos,x
        lda Xvelocity_lo
        sta object_Xvel_lo,x
        lda Xvelocity_hi
        sta object_Xvel_hi,x
        lda Yposition
        sta object_Ypos,x
        lda Yvelocity_lo
        sta object_Yvel_lo,x
        lda Yvelocity_hi
        sta object_Yvel_hi,x
        lda frame
        sta object_frame,x
        lda flags
        sta object_flags,x
        lda #0
        sta flags
end
        if debug_time then BACKGRND = bg_color
        asm
        rts
end


damage_player_hp
        ; TODO: This currently can't scale, only works with max HP 48...
        dec temp1 = player_hp        ; temp1 used to detect underflow
        dec player_hp = player_hp - hp_change
        if player_hp > temp1 then player_hp = 0

update_hp_bar
        dec temp1 = player_hp
        dec hp_seg_1 = player_hp
        if hp_seg_1 > temp1 then hp_seg_1 = 0
        dec temp1 = hp_seg_1
        dec hp_seg_2 = hp_seg_1 - 8
        if hp_seg_2 > temp1 then hp_seg_2 = 0
        dec temp1 = hp_seg_2
        dec hp_seg_3 = hp_seg_2 - 8
        if hp_seg_3 > temp1 then hp_seg_3 = 0
        dec temp1 = hp_seg_3
        dec hp_seg_4 = hp_seg_3 - 8
        if hp_seg_4 > temp1 then hp_seg_4 = 0
        dec temp1 = hp_seg_4
        dec hp_seg_5 = hp_seg_4 - 8
        if hp_seg_5 > temp1 then hp_seg_5 = 0
        dec temp1 = hp_seg_5
        dec hp_seg_6 = hp_seg_5 - 8
        if hp_seg_6 > temp1 then hp_seg_6 = 0
        if hp_seg_6 > 8 then hp_seg_6 = 8
        if hp_seg_5 > 8 then hp_seg_5 = 8
        if hp_seg_4 > 8 then hp_seg_4 = 8
        if hp_seg_3 > 8 then hp_seg_3 = 8
        if hp_seg_2 > 8 then hp_seg_2 = 8
        if hp_seg_1 > 8 then hp_seg_1 = 8
        return

increase_player_mp
        dec player_mp = player_mp + mp_change
        if player_mp > player_max_mp then player_mp = player_max_mp
        goto update_mp_bar

decrease_player_mp
        ; TODO: This currently can't scale, only works with max HP 48...
        dec temp1 = player_mp        ; temp1 used to detect underflow
        dec player_mp = player_mp - mp_change
        if player_mp > temp1 then player_mp = 0

update_mp_bar
        dec temp1 = player_mp
        dec mp_seg_1 = player_mp
        if mp_seg_1 > temp1 then mp_seg_1 = 0
        dec temp1 = mp_seg_1
        dec mp_seg_2 = mp_seg_1 - 8
        if mp_seg_2 > temp1 then mp_seg_2 = 0
        dec temp1 = mp_seg_2
        dec mp_seg_3 = mp_seg_2 - 8
        if mp_seg_3 > temp1 then mp_seg_3 = 0
        dec temp1 = mp_seg_3
        dec mp_seg_4 = mp_seg_3 - 8
        if mp_seg_4 > temp1 then mp_seg_4 = 0
        dec temp1 = mp_seg_4
        dec mp_seg_5 = mp_seg_4 - 8
        if mp_seg_5 > temp1 then mp_seg_5 = 0
        dec temp1 = mp_seg_5
        dec mp_seg_6 = mp_seg_5 - 8
        if mp_seg_6 > temp1 then mp_seg_6 = 0
        if mp_seg_6 > 8 then mp_seg_6 = 8
        if mp_seg_5 > 8 then mp_seg_5 = 8
        if mp_seg_4 > 8 then mp_seg_4 = 8
        if mp_seg_3 > 8 then mp_seg_3 = 8
        if mp_seg_2 > 8 then mp_seg_2 = 8
        if mp_seg_1 > 8 then mp_seg_1 = 8
        return

test_spell_cost
        if mp_change < player_mp then return
        ; routines can test if mp_change is 0 after calling this subroutine
        mp_change = 0
        return

increase_hp
        temp_hp = temp_hp + hp_change
        return

decrease_hp
        temp_hp = temp_hp - hp_change
        return

;==============================================================================
; SUBROUTINE: FIND NEW OBJECT
;------------------------------------------------------------------------------
; Iterates through all 16 object slots and sets the index variable to a 0 slot
;==============================================================================
find_new_object
        asm
        ldx #0
        stx no_empty_slot
new_obj_loop
        lda object_type,x
        beq new_obj_found
        inx
        cpx #MAX_MAP_OBJECTS
        bne new_obj_loop
        ; no empty obj slot found, routines can test if this is non-zero
        stx no_empty_slot
        rts
new_obj_found
        stx index
        rts
end

clear_palettes
        BACKGRND = $00
        P0C1 = $00 : P0C2 = $00 : P0C3 = $00
        P1C1 = $00 : P1C2 = $00 : P1C3 = $00
        P2C1 = $00 : P2C2 = $00 : P2C3 = $00
        P3C1 = $00 : P3C2 = $00 : P3C3 = $00
        P4C1 = $00 : P4C2 = $00 : P4C3 = $00
        P5C1 = $00 : P5C2 = $00 : P5C3 = $00
        P6C1 = $00 : P6C2 = $00 : P6C3 = $00
        P7C1 = $00 : P7C2 = $00 : P7C3 = $00
        return
        
;==============================================================================
; SUBROUTINE: READ CONTROLLER
;------------------------------------------------------------------------------
; Adapted from mksmith's post on AtariAge forums
; https://tinyurl.com/mv9srrhj
;==============================================================================
read_controller
        ; clear but don't touch debounce state
        controller_state = controller_state & %00000001
        controller_button_state = controller_button_state & %00000001

read_joystick
        if !joy0any  then read_buttons
        if joy0left  then controller_left_bit1{1} = 1
        if joy0right then controller_right_bit2{2} = 1
        if joy0up    then controller_up_bit3{3} = 1
        if joy0down  then controller_down_bit4{4} = 1

read_buttons
        if joy0fire1 then controller_button1_press_bit1{1} = 1
        if joy0fire0 then controller_button2_press_bit4{4} = 1

        if controller_button1_press_bit1{1} then controller_button1_counter = controller_button1_counter + 1
        if controller_button2_press_bit4{4} then controller_button2_counter = controller_button2_counter + 1

held_buttons
        if controller_button1_counter > BUTTON_HOLD_FRAMES then controller_button1_hold_bit3{3} = 1
        if controller_button2_counter > BUTTON_HOLD_FRAMES then controller_button2_hold_bit6{6} = 1

; omitting tap check, currently unneeded

clear_button_counters
        if !controller_button1_press_bit1 then controller_button1_counter = 0
        if !controller_button2_press_bit4 then controller_button2_counter = 0

clear_debounce
        if controller_state = %00000001 then controller_button_debounce_bit0{0} = 0
        if controller_button_debounce_bit0 = %00000001 then controller_button_debounce_bit0 = 0

read_controller_done
        return

main
        drawscreen
        animation_timer = animation_timer + 1
        if animation_timer > ANIM_TIME then animation_timer = 0
        if game_state = STATE_TITLE then title_handler
        if game_state = STATE_FIELD then field_handler
        if game_state = STATE_MENU  then menu_handler
        goto main

topscreenroutine
        WSYNC=1
        BACKGRND=bg_color
        if game_state = STATE_TITLE then set_title_top_pal
        return

set_title_top_pal
        P0C1 = $80 : P0C2 = $0F : P0C3 = $90
        P4C1 = $80 : P4C2 = $0F : P4C3 = $08
        return

bottomscreenroutine
        WSYNC=1
        BACKGRND=$00
        if game_state = STATE_TITLE then set_title_bottom_pal
        flash_color = $00
        if player_state = STATE_CHANT && animation_timer > ANIM_TIME / 2 then flash_color = CHANT_COLOR
        BACKGRND = flash_color
        P4C1     = flash_color
        P5C1     = flash_color
        P6C1     = flash_color
        P7C1     = flash_color
        ; Johanna's hair
        if game_state = STATE_FIELD then P1C1 = HAIR_COLOR
        if player_state = STATE_CHANT && animation_timer > ANIM_TIME / 2 then P1C1 = CHANT_COLOR
        return

set_title_bottom_pal
        P0C1 = $80 : P0C2 = $0F : P0C3 = $90
        P4C1 = $00 : P4C2 = $02 : P4C3 = $03
        return