;------------------------------------------------------------------------------
; 7800BASIC INITIALIZATION
;------------------------------------------------------------------------------
        set romsize 128kRAM
        set pokeysupport on
        set screenheight 224
        set doublewide on
        set collisionwrap off
        set pauseroutine off
;        set multibutton on
;        set multibuttonpause on

        const debug_hud = 0
        const debug_time = 0

;------------------------------------------------------------------------------
; GAME STATES
;------------------------------------------------------------------------------
        const STATE_TITLE = 0
        const STATE_FIELD = 1
        const STATE_MENU  = 2
        
        const ANIM_TIME = 16
        const INVULN_FRAMES = 60

;------------------------------------------------------------------------------
; MOVEMENT CONSTANTS
;------------------------------------------------------------------------------
        const DIR_UP    = 1
        const DIR_DOWN  = 2
        const DIR_LEFT  = 3
        const DIR_RIGHT = 4

        const EXIT_NONE  = 0
        const EXIT_NORTH = 1
        const EXIT_SOUTH = 2
        const EXIT_EAST  = 3
        const EXIT_WEST  = 4

        const BUTTON_HOLD_FRAMES = 15

;------------------------------------------------------------------------------
; PLAYER DATA
;------------------------------------------------------------------------------
        const PLAYER_HEIGHT = 16
        const PLAYER_WIDTH  = 12

        const SWORD_FRAMES = 4
        const SWORD_OFFSET_DOWN  = 15
        const SWORD_OFFSET_UP    = -16
        const SWORD_OFFSET_LEFT  = -12
        const SWORD_OFFSET_RIGHT = 12
        
        const SHIELD_FRAMES = 4
        const SHIELD_OFFSET_X = 8
        const SHIELD_OFFSET_Y = 7

        const STATE_STAND       = 0
        const STATE_MOVING      = 1
        const STATE_ATTACK      = 3
        const STATE_CHANT_START = 4
        const STATE_CHANT       = 5
        const STATE_KNOCKBACK   = 2

        const FRAME_UP    = 2
        const FRAME_DOWN  = 0
        const FRAME_LEFT  = 4
        const FRAME_RIGHT = 6
        const FRAME_ATK_D = 8
        const FRAME_ATK_U = 9
        const FRAME_ATK_L = 10
        const FRAME_ATK_R = 11

        const ATTACK_FRAMES = 8
        const CHANT_START_TIME = 12

;------------------------------------------------------------------------------
; SHARED PALETTES
;------------------------------------------------------------------------------
        const PAL_DKPURP = $60
        const PAL_LTPURP = $76
        const PAL_WHITE  = $0F
        const PAL_DKBRWN = $10
        const PAL_LTBRWN = $23
        const PAL_SKIN   = $3B
        const PAL_DKRED  = $30
        const PAL_LTRED  = $45
        const PAL_GOLD   = $19
        const PAL_DKBLUE = $91
        const PAL_LTBLUE = $A3
        const PAL_COPPER = $D5


        const HAIR_COLOR = PAL_DKBRWN
        const CHANT_COLOR = $60
        const BAR_NORMAL_COLOR = $76
        const BAR_FLASH_COLOR = $79

;------------------------------------------------------------------------------
; MAP DATA
;------------------------------------------------------------------------------
        const TILE_HEIGHT = 16
        const TILE_WIDTH  = 8

        const T_TITLE  = 0
        const T_FOREST = 1
        const T_CASTLE = 2
        const T_RIVER  = 3
        const T_HILLS  = 4

        const ROOMS_PER_ROW = 7
        const MAX_MAP_OBJECTS = 12
        const MAX_OBJECTS = 15

;==============================================================================
; OBJECT DATA
;==============================================================================0
        const TYPE_TORCH    =  1
        const TYPE_WOLF     =  2
        const TYPE_SLIME    =  6
        const TYPE_MSLIME   =  7
        const TYPE_RAVEN    =  8
        const TYPE_SPAWNER  = 128
        const TYPE_FIREBALL = 129
        const TYPE_COIN     = 200
        const TYPE_PRISM    = 201
        const TYPE_FOOD     = 202

;------------------------------------------------------------------------------
; MENU DATA
;------------------------------------------------------------------------------
        const MENU_MAIN   = 0
        const MENU_ITEMS  = 1
        const MENU_MAGIC  = 2
        const MENU_EQUIP  = 3
        const MENU_RELICS = 4
        const MENU_SETUP  = 5
        const MENU_MAIN_MAX_OPTIONS = 3 ; setup menu cut (for now)

;------------------------------------------------------------------------------
; SYSTEM VARIABLES
;------------------------------------------------------------------------------
        dim temp_hp_sign = temp1        ; tracks underflow during subtraction

        autodim init a z
        autodim byte index
        autodim byte game_state
        autodim byte pointer
        autodim byte pointer_hi
        autodim byte Xposition
        autodim byte Yposition
        autodim byte Xdestination
        autodim byte Ydestination
        autodim byte Xdirection
        autodim byte Ydirection
        autodim 8.8  Xvelocity
        autodim 8.8  Yvelocity
        autodim 8.8  move_speed
        autodim 8.8  vel_cap
        autodim 8.8  friction
        autodim byte temp_hp
        autodim byte hp_change
        autodim byte bg_color
        autodim byte animation_timer
        autodim byte retract_counter
        autodim byte action_button

;------------------------------------------------------------------------------
; PLAYER
;------------------------------------------------------------------------------
        autodim init var0 var99
        autodim byte player_Xpos
        autodim byte player_Ypos
        autodim 8.8  player_Xvel
        autodim 8.8  player_Yvel
        autodim 8.8  player_vel_cap
        autodim 8.8  player_friction
        autodim byte player_Xdir
        autodim byte player_Ydir
        autodim byte player_facing      ; facing is separate from direction for knockback purposes
        autodim byte player_state
        autodim byte player_frame
        autodim byte player_flags
        autodim byte player_timer
        autodim byte player_hp
        autodim byte player_max_hp
        autodim byte player_mp
        autodim byte player_max_mp
        autodim byte player_level
        dim player_exp = score1
        autodim byte player_str
        autodim byte player_atk ; str + wpn atk
        autodim byte player_damage
        autodim byte player_atk_elem
        autodim byte player_def
        autodim byte player_def_elem
        autodim 8.8  player_speed
        autodim byte player_sword
        autodim byte player_shield
        autodim byte player_armor
        autodim byte player_charm
        autodim byte player_status
        autodim byte sword_pal
        autodim byte sword_Xpos
        autodim byte sword_Ypos
        autodim byte sword_frame
        autodim byte sword_width
        autodim byte sword_height
        autodim byte shield_pal
        autodim byte shield_Xpos
        autodim byte shield_Ypos
        autodim byte shield_frame
        autodim byte hp_seg_1
        autodim byte hp_seg_2
        autodim byte hp_seg_3
        autodim byte hp_seg_4
        autodim byte hp_seg_5
        autodim byte hp_seg_6
        autodim byte mp_seg_1
        autodim byte mp_seg_2
        autodim byte mp_seg_3
        autodim byte mp_seg_4
        autodim byte mp_seg_5
        autodim byte mp_seg_6
        autodim byte mp_change
        autodim byte chant_timer
        autodim byte flash_color
        autodim byte player_exiting_chant
        autodim byte sword_hit
        autodim byte mtarget
        autodim byte magic_Xpos
        autodim byte magic_Ypos

;------------------------------------------------------------------------------
; MOVING OBJECT ARRAYS
;------------------------------------------------------------------------------
        autodim init $2200 $23FF
        autodim byte object_type 16
        autodim byte object_Xpos 16
        autodim byte object_Ypos 16
        autodim 8.8  object_Xvel 16
        autodim 8.8  object_Yvel 16
        autodim byte object_Xdir 16
        autodim byte object_Ydir 16
        autodim byte object_frame 16
        autodim byte object_action 16
        autodim 8.8  object_speed 16
        autodim 8.8  object_vel_cap 16
        autodim 8.8  object_friction 16
        autodim byte object_hp 16
        autodim byte object_damage 16
        autodim byte object_contact 16
        autodim byte object_flags 16
        autodim byte object_timer 16

        autodim init $2400 $24FF
        autodim byte reload_map
        autodim byte save_objects
        autodim byte map_height
        autodim byte map_width
        autodim byte peekX
        autodim byte peekY
        autodim byte move_tile_1
        autodim byte move_tile_2
        autodim byte animation_frame
        autodim byte frame
        autodim byte flags
        autodim byte obj_index
        autodim byte drop_rate
        autodim byte no_empty_slot
        autodim byte torch_reblock

        ; MENUS
        autodim byte action_debounce
        autodim byte menu_debounce
        autodim byte select_debounce
        autodim byte pause_debounce
        autodim byte left_debounce
        autodim byte right_debounce
        autodim byte up_debounce
        autodim byte down_debounce
        autodim byte menu
        autodim byte menu_change
        autodim byte menu_selection
        autodim byte prev_menu_selection
        autodim byte menu_columns
        autodim byte menu_rows
        autodim byte menu_cursor_X
        autodim byte menu_cursor_Y
        autodim byte m_inv_index
        autodim byte m_inv_scroll
        autodim byte m_inv_slot
        autodim byte m_sword_pal1
        autodim byte m_sword_pal2
        autodim byte m_shield_pal1
        autodim byte m_shield_pal2
        autodim byte m_armor_pal1
        autodim byte m_armor_pal2
        autodim byte m_charm_pal1
        autodim byte m_charm_pal2
        autodim byte m_inv0_pal1
        autodim byte m_inv0_pal2
        autodim byte m_inv1_pal1
        autodim byte m_inv1_pal2
        autodim byte m_inv2_pal1
        autodim byte m_inv2_pal2
        autodim byte m_inv3_pal1
        autodim byte m_inv3_pal2
        autodim byte equip_inv_col
        autodim byte equip_inv_sel
        autodim byte equip_inv_X
        autodim byte equip_inv_Y

        ; ROOM HEADER
        autodim byte room
        autodim byte tileset
        autodim byte exit_dir
        autodim byte music
        autodim byte walkable
        autodim byte floatable
        autodim byte walkable_1
        autodim byte floatable_1
        autodim byte walkable_2
        autodim byte floatable_2
        autodim byte walk_test
        autodim byte walk_index
        autodim byte room_index

        autodim init $2500 $25FF
        const INPUT_BUFFER_MAX = 7      ; array starts at 0
        autodim byte input_buffer 8
        autodim byte input_buffer_index
        autodim byte chant_index
        autodim byte chant_input
        ; possible to start a chant on index 0 so need another variable        
        autodim byte chant_new_input
        autodim byte m_sword_inv  16
        autodim byte m_shield_inv 16
        autodim byte m_armor_inv  16
        autodim byte m_charm_inv  16
        autodim byte m_inv_item_0
        autodim byte m_inv_item_1
        autodim byte m_inv_item_2
        autodim byte m_inv_item_3
        autodim byte m_inv_item_4

        dim current_map = $2600

        player_Xpos = 24
        player_Ypos = 60

        player_speed = 1.0
        player_friction = player_speed
        player_vel_cap = 5.0

        dec player_max_hp = $48
        dec player_hp = $48

        dec player_mp = $48
        dec player_max_mp = $48

        dec hp_seg_1 = 8
        dec hp_seg_2 = 8
        dec hp_seg_3 = 8
        dec hp_seg_4 = 8
        dec hp_seg_5 = 8
        dec hp_seg_6 = 8
        dec mp_seg_1 = 8
        dec mp_seg_2 = 8
        dec mp_seg_3 = 8
        dec mp_seg_4 = 8
        dec mp_seg_5 = 8
        dec mp_seg_6 = 8

        sword_pal = 2
        shield_pal = 2

;==============================================================================
; BANK 1
;------------------------------------------------------------------------------
; 7800basic initialization, title sequence code and graphics
;------------------------------------------------------------------------------
;==============================================================================
        incgraphic gfx/font.png        320B 2 0 1 0 0
        incgraphic gfx/title/logo.png  320B 1 2 3 1 4
        incgraphic gfx/title/trees.png 320B 0 3 0 0 0
        incgraphic gfx/title/moon.png  320B 0 3 2 2 4
        incmapfile tiled/title_blackforest.tmx
        game_state = STATE_TITLE

title_init
        gosub clear_palettes
        displaymode 320B
        bg_color = $71
        clearscreen
        characterset logo
        plotmapfile tiled/title_blackforest.tmx title_blackforest 0 0 40 14
        savescreen

title_handler
        restorescreen
        savescreen
        adjustvisible 0 4
;        if animation_frame then plotchars 'Push Button 1 or 2' 0 96 10
        ; TODO: Handle, well, everything
        if joy0fire0 then action_button = 0 : goto title_new_game
        if joy0fire1 then action_button = 1 : goto title_new_game
        goto main

title_new_game
        reload_map = 1
        room_index = 17
        tileset = T_FOREST
        game_state = STATE_FIELD
        
        goto main

set_title_top_pal
        P0C1 = $80 : P0C2 = $0F : P0C3 = $90
        P4C1 = $80 : P4C2 = $0F : P4C3 = $08
        return

set_title_bottom_pal
        P0C1 = $80 : P0C2 = $0F : P0C3 = $90
        P4C1 = $00 : P4C2 = $02 : P4C3 = $03
        return

;==============================================================================
; BANK 2
;------------------------------------------------------------------------------
; Contains forest tileset graphics, maps, and enemy AI
;==============================================================================
        bank 2
        incgraphic gfx/tiles/forest_trees.png 160A 1 0 2 3 4
        incgraphic gfx/tiles/forest_rocks.png 160A 1 0 2 3 5
        incgraphic gfx/tiles/forest_water.png 160A 1 2 0 3 6
        incgraphic gfx/tiles/forest_map.png 160A 0 2 1 3
        incgraphic gfx/forest/hud.png 160A 0 3 1 2
        incgraphic gfx/forest/hud2.png 160A 0 3 1 2
        incgraphic gfx/sprites/wolf0.png 160A 0 2 3 1
        incgraphic gfx/sprites/wolf1.png 160A 0 2 3 1
        incgraphic gfx/sprites/wolf2.png 160A 0 2 3 1
        incgraphic gfx/sprites/wolf3.png 160A 0 2 3 1
        incgraphic gfx/sprites/slime0.png 160A 0 2 3 1
        incgraphic gfx/sprites/slime1.png 160A 0 2 3 1
        incgraphic gfx/sprites/minislime0.png 160A 0 2 3 1
        incgraphic gfx/sprites/minislime1.png 160A 0 2 3 1
        incgraphic gfx/sprites/raven0.png 160A 0 1 3 2
        incgraphic gfx/sprites/raven1.png 160A 0 1 3 2
        incgraphic gfx/sprites/raven2.png 160A 0 1 3 2
        incgraphic gfx/sprites/raven3.png 160A 0 1 3 2
        incgraphic gfx/sprites/raven4.png 160A 0 1 3 2
        incgraphic gfx/sprites/raven5.png 160A 0 1 3 2

        incmapfile tiled/forest.tmx
        incmapfile tiled/forest_room_1.tmx
        incmapfile tiled/forest_room_2.tmx
        incmapfile tiled/forest_room_3.tmx
        incmapfile tiled/forest_room_4.tmx
        incmapfile tiled/forest_room_5.tmx
        incmapfile tiled/forest_room_6.tmx
        incmapfile tiled/forest_room_7.tmx
        incmapfile tiled/forest_room_8.tmx
        incmapfile tiled/forest_room_9.tmx
        incmapfile tiled/forest_room_10.tmx
        incmapfile tiled/forest_room_11.tmx

load_forest
        ; forest_palettes
        bg_color = $11                          ; brown
        P0C1 = PAL_DKPURP : P0C2 = PAL_LTPURP : P0C3 = PAL_WHITE   ; magic HUD, torches
        P1C1 = PAL_DKBRWN : P1C2 = PAL_LTBRWN : P1C3 = PAL_SKIN    ; Johanna
        P2C1 = PAL_DKRED  : P2C2 = PAL_LTRED  : P2C3 = PAL_GOLD    ; HP HUD, red equipment
        P3C1 = PAL_DKBLUE : P3C2 = PAL_LTBLUE : P3C3 = PAL_COPPER  ; blue/green equipment
        P4C1 = $00 : P4C2 = $C0 : P4C3 = $C3    ; greens used by trees and slimes
        P5C1 = $00 : P5C2 = $03 : P5C3 = $06    ; grays used by rocks and wolves
        P6C1 = $00 : P6C2 = $A1 : P6C3 = $06    ; blue and gray used by water
        P7C1 = $00 : P7C2 = $24 : P7C3 = $5B    ; currently unused, light browns?

        characterset forest_trees
        room = forest_rooms[room_index]
        if room = 1 then pointer = forest_room_1_obj_lo : pointer_hi = forest_room_1_obj_hi : goto plot_forest_room_1
        if room = 2 then pointer = forest_room_2_obj_lo : pointer_hi = forest_room_2_obj_hi : goto plot_forest_room_2
        if room = 3 then pointer = forest_room_3_obj_lo : pointer_hi = forest_room_3_obj_hi : goto plot_forest_room_3
        if room = 4 then pointer = forest_room_4_obj_lo : pointer_hi = forest_room_4_obj_hi : goto plot_forest_room_4
        if room = 5 then pointer = forest_room_5_obj_lo : pointer_hi = forest_room_5_obj_hi : goto plot_forest_room_5
        if room = 6 then pointer = forest_room_6_obj_lo : pointer_hi = forest_room_6_obj_hi : goto plot_forest_room_6
        if room = 7 then pointer = forest_room_7_obj_lo : pointer_hi = forest_room_7_obj_hi : goto plot_forest_room_7
        if room = 8 then pointer = forest_room_8_obj_lo : pointer_hi = forest_room_8_obj_hi : goto plot_forest_room_8
        if room = 9 then pointer = forest_room_9_obj_lo : pointer_hi = forest_room_9_obj_hi : goto plot_forest_room_9
        if room = 10 then pointer = forest_room_10_obj_lo : pointer_hi = forest_room_10_obj_hi : goto plot_forest_room_10
        if room = 11 then pointer = forest_room_11_obj_lo : pointer_hi = forest_room_11_obj_hi : goto plot_forest_room_11

; room 1 is the default and uses a "crossroads" setup in case the player gets out of bounds somehow
plot_forest_room_1
        plotmapfile tiled/forest_room_1.tmx forest_room_1 0 0 20 14
        memcpy current_map forest_room_1 280
        return

        data forest_room_1_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end


plot_forest_room_2
        plotmapfile tiled/forest_room_2.tmx forest_room_2 0 0 20 14
        memcpy current_map forest_room_2 280
        return

        data forest_room_2_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

plot_forest_room_3
        plotmapfile tiled/forest_room_3.tmx forest_room_3 0 0 20 14
        memcpy current_map forest_room_3 280
        return

        data forest_room_3_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

plot_forest_room_4
        plotmapfile tiled/forest_room_4.tmx forest_room_4 0 0 20 14
        memcpy current_map forest_room_4 280
        return

        data forest_room_4_obj
        TYPE_RAVEN, $54, $79,  $02, $2A, $30,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

plot_forest_room_5
        plotmapfile tiled/forest_room_5.tmx forest_room_5 0 0 20 14
        memcpy current_map forest_room_5 280
        return

        data forest_room_5_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

plot_forest_room_6
        plotmapfile tiled/forest_room_6.tmx forest_room_6 0 0 20 14
        memcpy current_map forest_room_6 280
        return

        data forest_room_6_obj
        TYPE_WOLF, $30, $30,
        TYPE_TORCH, $69, $20,
        TYPE_TORCH, $39, $20,
        TYPE_TORCH, $5E, $AF,
        TYPE_TORCH, $42, $AF,
        TYPE_WOLF, $70, $30,
        TYPE_SLIME, $40, $67,
        TYPE_SLIME, $80, $90,
        $00, $90, $88,
        $00, $40, $70,
        $00, $30, $20,
        $00, $80, $40,
        $00, $b0, $c0,
        $00, $77, $55,
        $00, $44, $22,
        $00, $33, $66,
end

plot_forest_room_7
        plotmapfile tiled/forest_room_7.tmx forest_room_7 0 0 20 14
        memcpy current_map forest_room_7 280
        return

        data forest_room_7_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

plot_forest_room_8
        plotmapfile tiled/forest_room_8.tmx forest_room_8 0 0 20 14
        memcpy current_map forest_room_8 280
        return

        data forest_room_8_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

plot_forest_room_9
        plotmapfile tiled/forest_room_9.tmx forest_room_9 0 0 20 14
        memcpy current_map forest_room_9 280
        return

        data forest_room_9_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

plot_forest_room_10
        plotmapfile tiled/forest_room_10.tmx forest_room_10 0 0 20 14
        memcpy current_map forest_room_10 280
        return

        data forest_room_10_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

plot_forest_room_11
        plotmapfile tiled/forest_room_11.tmx forest_room_11 0 0 20 14
        memcpy current_map forest_room_11 280
        return

        data forest_room_11_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

        data forest_rooms
        00, 00,  8, 07, 06, 00, 00,
        00,  9, 10, 04, 05, 11, 00,
        00, 00, 00, 03, 00, 00, 00,
        00, 00, 00, 02, 00, 00, 00,
        00, 00, 00, 01, 00, 00, 00,
        00, 00, 00, 00, 00, 00, 00,
        00, 00, 00, 00, 00, 00, 00
end

test_walkable_forest
        asm
        ldx #0
tw_loop lda forest_walkable_tiles,x
        cmp move_tile_1
        bne twtile2
        pha
        lda #1
        sta walkable_1
        pla
twtile2 cmp move_tile_2
        bne tw_next
        lda #1
        sta walkable_2
tw_next inx
        cpx #forest_walkable_tiles_length
        bne tw_loop
        lda walkable_1
        beq tw_done
        lda walkable_2
        beq tw_done
        sta walkable
tw_done
        lda flags
        and #%00010000
        bne tf_done

test_floatable_forest
        ldx #0
tf_loop   lda forest_floatable_tiles,x
        cmp move_tile_1
        bne tftile2
        pha
        lda #1
        sta floatable_1
        pla
tftile2 cmp move_tile_2
        bne tf_next
        lda #1
        sta floatable_2
tf_next inx
        cpx #forest_floatable_tiles_length
        bne tf_loop
        lda floatable_1
        beq tf_done
        lda floatable_2
        beq tf_done
        sta floatable
tf_done jmp .walkable_return
end
;        for walk_index = 0 to forest_walkable_tiles_length
;        walk_test = forest_walkable_tiles[walk_index]
;        if walk_test = move_tile_1 then walkable_1 = 1
;        if walk_test = move_tile_2 then walkable_2 = 1
;        next
;        if !walkable_1 then walkable_return
;        if !walkable_2 then walkable_return
;        walkable = 1
;        goto walkable_return

        data forest_walkable_tiles
        $00, $02, $04, $0E, $12, $14, $16, $18, $1A, $1C, $1E, $20
end

        data forest_floatable_tiles
        $22, $24, $2A, $2C, $30, $32, $34, $36, $38, $3A, $3C, $3E, $40, $42, $44
end

torch_tile_block_forest
        ; block with a floatable tile so projectiles can hit torch
        pokechar current_map peekX peekY 20 14 forest_floatable_tiles
        return

torch_tile_unblock_forest
        ; the poked tile doesn't affect visuals since those are plotted from ROM
        pokechar current_map peekX peekY 20 14 forest_walkable_tiles
        return

;==============================================================================
; WOLF AI
;------------------------------------------------------------------------------
; Wolves wait for the player to get close (WOLF_CHASE_DIST), then give chase
;==============================================================================
wolf_ai
        const WOLF_CHASE_DIST = 32
        ; Once wolves start chasing, they don't stop
        if flags{7} then wolf_chase

        ; Test player distance to wolf
        temp1 = Xposition - player_Xpos
        if temp1 < WOLF_CHASE_DIST then wolf_chase
        temp1 = Yposition - player_Ypos
        if temp1 < (WOLF_CHASE_DIST * 2) then wolf_chase

wolf_anim
        ; Wolves flip left or right facing depending on player position
        frame = 0
        if Xposition <= player_Xpos then frame = frame + 2
        if animation_frame then frame = frame + 1
        return

wolf_chase
        flags{7} = 1
        gosub get_player_pos
        gosub go_to_destination
        goto wolf_anim

obj_wolf_stats
; TODO: Make this implementation suck less
        const WOLF_SPEED_HI = 1
        const WOLF_SPEED_LO = 0
        const WOLF_HP = 2
        const WOLF_VEL_CAP_HI = 2
        const WOLF_VEL_CAP_LO = 0
        const WOLF_FRICTION_HI = 1
        const WOLF_FRICTION_LO = 0
        const WOLF_DAMAGE = 1
        const WOLF_CONTACT = 1
        const WOLF_DROP_RATE = 64

        object_hp[obj_index] = WOLF_HP
        object_contact[obj_index] = WOLF_CONTACT
        object_vel_cap_hi[obj_index] = WOLF_VEL_CAP_HI
        object_vel_cap_lo[obj_index] = WOLF_VEL_CAP_LO
        object_damage[obj_index] = WOLF_DAMAGE
        object_friction_hi[obj_index] = WOLF_FRICTION_HI
        object_friction_lo[obj_index] = WOLF_FRICTION_LO
        object_speed_hi[obj_index] = WOLF_SPEED_HI
        object_speed_lo[obj_index] = WOLF_SPEED_LO
        object_flags[obj_index] = 0
        goto obj_next_stats

;==============================================================================
; SLIME AI
;------------------------------------------------------------------------------
; A Slime draws near!
; Command?
;==============================================================================
slime_ai
        gosub get_player_pos
        gosub go_to_destination
        return

obj_slime_stats
        const SLIME_DROP_RATE = 128
        const SLIME_HP = 4
        const MSLIME_HP = SLIME_HP / 2
        const SLIME_CONTACT = 4
        const SLIME_VEL_CAP_HI = 1
        const SLIME_VEL_CAP_LO = 0
        const SLIME_DAMAGE = 4
        const SLIME_FRICTION_HI = 1
        const SLIME_FRICTION_LO = 0
        const SLIME_SPEED_HI = 0
        const SLIME_SPEED_LO = 50
        object_hp[obj_index] = SLIME_HP
        object_contact[obj_index] = SLIME_CONTACT
        object_vel_cap_hi[obj_index] = SLIME_VEL_CAP_HI
        object_vel_cap_lo[obj_index] = SLIME_VEL_CAP_LO
        object_damage[obj_index] = SLIME_DAMAGE
        object_friction_hi[obj_index] = SLIME_FRICTION_HI
        object_friction_lo[obj_index] = SLIME_FRICTION_LO
        object_speed_hi[obj_index] = SLIME_SPEED_HI
        object_speed_lo[obj_index] = SLIME_SPEED_LO
        object_flags[obj_index] = 0
        goto obj_next_stats

split_slime
        ; replace slime mobj with mini slime
        object_type[index] = TYPE_MSLIME
        object_hp[index] = MSLIME_HP
        temp1 = object_Xpos[index]
        temp2 = object_Ypos[index]
        ; mini slime is moved to the left of the parent slime's pos
        object_Xpos[index] = object_Xpos[index] - 1
        gosub find_new_object
        ; if no slots, the slime just becomes a single mini slime
        if no_empty_slot then object_Xpos[index] = temp1 : cc_next
        ; initialize the new mini slime object
        object_type[index] = TYPE_MSLIME
        object_hp[index] = MSLIME_HP
        object_contact[index] = SLIME_CONTACT
        object_vel_cap_hi[index] = SLIME_VEL_CAP_HI
        object_vel_cap_lo[index] = SLIME_VEL_CAP_LO
        object_damage[index] = SLIME_DAMAGE
        object_friction_hi[index] = SLIME_FRICTION_HI
        object_friction_lo[index] = SLIME_FRICTION_LO
        object_speed_hi[index] = SLIME_SPEED_HI
        object_speed_lo[index] = SLIME_SPEED_LO
        ; mini slime spawns to the right of the parent slime's pos
        object_Xpos[index] = temp1 + 9
        object_Ypos[index] = temp2
        goto cc_next

;==============================================================================
; RAVEN AI
;------------------------------------------------------------------------------
; Flies without testing walkability and perches on trees
;==============================================================================
raven_ai
        if debug_time = 1 then BACKGRND = $A0
        flags{2} = 1
        temp1 = 0
        temp2 = 0
        ; flags{7} = not perched
        if flags{7} then goto raven_change_pos
        frame = 0
        Xvelocity = 0.0
        Yvelocity = 0.0

test_dist_to_player
        if Xposition > player_Xpos then wake_raven_right
        if Xposition < player_Xpos then wake_raven_left
        if Yposition > player_Ypos then wake_raven_down
        if Yposition < player_Ypos then wake_raven_up
        ; raven and player occupy same space, handle this

wake_raven_right
        temp1 = Xposition - player_Xpos
        if temp1 < RAVEN_CHASE_DIST then raven_change_pos
        goto raven_return

wake_raven_left
        temp1 = Xposition + player_Xpos
        if temp1 < RAVEN_CHASE_DIST then raven_change_pos
        goto raven_return

wake_raven_up
        temp2 = Yposition + player_Ypos
        if temp2 < RAVEN_CHASE_DIST then raven_change_pos
        goto raven_return

wake_raven_down
        temp2 = Yposition - player_Ypos
        if temp2 < RAVEN_CHASE_DIST then raven_change_pos
        goto raven_return


raven_change_pos
        flags{7} = 1
        frame = 1
        if animation_frame then frame = frame + 2
        if !object_timer[index] then object_timer[index] = RAVEN_FLIGHT_TIME
        if flags{3} then raven_move
        if rand > 128 then gosub swoop_Y : raven_move
        gosub swoop_X
raven_move
        gosub go_to_destination

raven_perch
        temp1 = object_timer[index]
        object_timer[index] = object_timer[index] - 1
        if temp1 < object_timer[index] then object_timer[index] = 0
        if object_timer[index] > 0 then raven_return
        gosub test_walkable
        if !walkable then flags{7} = 0

raven_return
        if Xposition >= player_Xpos then frame = frame + 1
        if debug_time = 1 then BACKGRND = bg_color
        return

obj_raven_stats
        const RAVEN_CHASE_DIST = 50
        const RAVEN_FLIGHT_TIME = 10
        const RAVEN_DROP_RATE = 128
        const RAVEN_HP = 4
        const RAVEN_CONTACT = 4
        const RAVEN_VEL_CAP_HI = 2
        const RAVEN_VEL_CAP_LO = 0
        const RAVEN_DAMAGE = 4
        const RAVEN_FRICTION_HI = 0
        const RAVEN_FRICTION_LO = 0
        const RAVEN_SPEED_HI = 1
        const RAVEN_SPEED_LO = 0
        object_hp[obj_index] = RAVEN_HP
        object_contact[obj_index] = RAVEN_CONTACT
        object_vel_cap_hi[obj_index] = RAVEN_VEL_CAP_HI
        object_vel_cap_lo[obj_index] = RAVEN_VEL_CAP_LO
        object_damage[obj_index] = RAVEN_DAMAGE
        object_friction_hi[obj_index] = RAVEN_FRICTION_HI
        object_friction_lo[obj_index] = RAVEN_FRICTION_LO
        object_speed_hi[obj_index] = RAVEN_SPEED_HI
        object_speed_lo[obj_index] = RAVEN_SPEED_LO
        object_flags[obj_index] = 0
        goto obj_next_stats

plot_wolf
        PLOTSPRITE wolf0 5 Xposition Yposition frame
        goto plot_next

plot_slime
        PLOTSPRITE slime0 4 Xposition Yposition animation_frame
        goto plot_next

plot_minislime
        PLOTSPRITE minislime0 4 Xposition Yposition animation_frame
        goto plot_next

plot_raven
        PLOTSPRITE raven0 5 Xposition Yposition frame
        goto plot_next


;==============================================================================
; BANK 3
;------------------------------------------------------------------------------
; Menu graphics and code
;==============================================================================
        bank 3

        incgraphic gfx/menu/menu_digits.png 320B 0 2
        incgraphic gfx/menu/menu_font.png 320A 1 0
        incgraphic gfx/menu/menu_arrows.png 320A 1 0
        incgraphic gfx/menu/menu_bar0.png 320B 0 2
        incgraphic gfx/menu/menu_bar1.png 320B 0 3 2
        incgraphic gfx/menu/menu_bar2.png 320B 0 3 2
        incgraphic gfx/menu/menu_bar3.png 320B 0 3 2
        incgraphic gfx/menu/menu_bar4.png 320B 0 3 2
        incgraphic gfx/menu/menu_bar5.png 320B 0 3 2
        incgraphic gfx/menu/menu_bar6.png 320B 0 3 2
        incgraphic gfx/menu/menu_bar7.png 320B 0 3 2
        incgraphic gfx/menu/menu_bar8.png 320B 0 3 2
        incgraphic gfx/menu/menu_bar9.png 320B 0 2
        incgraphic gfx/menu/menu_cursor0.png 320A 0 1
        incgraphic gfx/menu/menu_sword0.png 320B 2 0 1 3
        incgraphic gfx/menu/menu_sword1.png 320B 2 0 1 3
        incgraphic gfx/menu/menu_sword2.png 320B 2 0 1 3
        incgraphic gfx/menu/menu_sword3.png 320B 2 0 1 3
        incgraphic gfx/menu/menu_sword4.png 320B 2 0 1 3
        incgraphic gfx/menu/menu_shield0.png 320B 0 2 3 1
        incgraphic gfx/menu/menu_shield1.png 320B 0 2 3 1
        incgraphic gfx/menu/menu_shield2.png 320B 0 2 3 1
        incgraphic gfx/menu/menu_shield3.png 320B 0 2 3 1
        incgraphic gfx/menu/menu_shield4.png 320B 0 2 3 1
        incgraphic gfx/menu/menu_armor0.png 320B 0 2 3 1
        incgraphic gfx/menu/menu_armor1.png 320B 0 2 3 1
        incgraphic gfx/menu/menu_armor2.png 320B 0 2 3 1
        incgraphic gfx/menu/menu_armor3.png 320B 0 2 3 1
        incgraphic gfx/menu/menu_armor4.png 320B 0 2 3 1
        incgraphic gfx/menu/menu_charm0.png 320B 0 2 1 3
        incgraphic gfx/menu/menu_charm1.png 320B 0 2 1 3
        incgraphic gfx/menu/menu_charm2.png 320B 0 2 1 3
        incgraphic gfx/menu/menu_charm3.png 320B 0 2 1 3
        incgraphic gfx/menu/menu_charm4.png 320B 0 2 1 3
        incgraphic gfx/menu/menu_map.png 320A

menu_init
        ; TODO: Remove these once tests are done
        player_sword = 1
        player_shield = 1
        player_armor = 1
        player_charm = 1
        m_sword_inv[0] = 4
        m_sword_inv[1] = 1
        m_sword_inv[2] = 3
        m_sword_inv[3] = 2
        m_shield_inv[0] = 1
        m_shield_inv[1] = 2
        m_shield_inv[2] = 3
        m_shield_inv[3] = 4
        m_armor_inv[0] = 1
        m_armor_inv[1] = 2
        m_armor_inv[2] = 3
        m_armor_inv[3] = 4
        m_charm_inv[0] = 1
        m_charm_inv[1] = 2
        m_charm_inv[2] = 3
        m_charm_inv[3] = 4
        ; TODO: Load colors based on inventory items
        m_sword_pal1 = $1E
        m_sword_pal2 = $44
        m_inv0_pal1 = $07
        m_inv0_pal2 = $04
        m_shield_pal1 = $F3
        m_shield_pal2 = $F5
        m_inv1_pal1 = $77
        m_inv1_pal1 = $04
        m_armor_pal1 = $25
        m_armor_pal2 = $27
        m_inv2_pal1 = $FB
        m_inv2_pal2 = $FF
        m_charm_pal1 = $AA
        m_charm_pal2 = $0F
        m_inv3_pal1 = $36
        m_inv3_pal2 = $33
        game_state = STATE_MENU
        clearscreen
        displaymode 320B
        drawwait
        P0C2 = $10
        P4C2 = $10
        menu_change = 1

menu_handler
        if menu = MENU_MAIN then goto plot_main_menu
        if menu = MENU_ITEMS then goto plot_items_menu
        if menu = MENU_MAGIC then goto plot_magic_menu
        if menu = MENU_EQUIP then goto plot_equip_menu
        if menu = MENU_RELICS then goto plot_relics_menu

plot_main_menu
        P0C3 = PAL_LTPURP
        P4C3 = PAL_LTRED
        if !menu_change then goto main_menu_updater
        gosub disable_double_wide_mode
        clearscreen
        gosub plot_menu_border
        characterset menu_font
        alphachars '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ,.!?/-:`@&[$#]{}(_*)'
        plotchars 'Portrait' 0 16 1 singlewide
        plotchars 'Johanna' 0 64 0 singlewide
        plotchars 'HP' 0 72 1 singlewide
        plotchars 'MP' 0 72 2 singlewide
        plotchars 'The map gets plotted here' 0 28 7 singlewide
        plotchars 'Items  Spells  Equipment  Relics' 0 16 12 singlewide
        savescreen
        menu_cursor_X = MENU_MAIN_ITEMS_X
        menu_cursor_Y = MENU_MAIN_ITEMS_Y
        menu_change = 0

main_menu_updater
        restorescreen
        plotsprite menu_bar9 4  88 16
        plotsprite menu_bar0 4  96 16 hp_seg_1
        plotsprite menu_bar0 4 104 16 hp_seg_2
        plotsprite menu_bar0 4 112 16 hp_seg_3
        plotsprite menu_bar0 4 120 16 hp_seg_4
        plotsprite menu_bar0 4 128 16 hp_seg_5
        plotsprite menu_bar0 4 136 16 hp_seg_6
        plotsprite menu_bar9 0  88 32
        plotsprite menu_bar0 0  96 32 mp_seg_1
        plotsprite menu_bar0 0 104 32 mp_seg_2
        plotsprite menu_bar0 0 112 32 mp_seg_3
        plotsprite menu_bar0 0 120 32 mp_seg_4
        plotsprite menu_bar0 0 128 32 mp_seg_5
        plotsprite menu_bar0 0 136 32 mp_seg_6
        plotsprite menu_cursor0 0 menu_cursor_X menu_cursor_Y

main_menu_controls
        if !menu_debounce && joy0fire0 && action_button = 1 then close_menu
        if !menu_debounce && joy0fire1 && action_button = 0 then close_menu
        if !pause_debounce && switchpause then close_menu
        if !action_debounce && joy0fire0 && action_button = 0 then open_submenu
        if !action_debounce && joy0fire1 && action_button = 1 then open_submenu
        if right_debounce > MENU_TAP_FRAMES then gosub menu_selection_right
        if !right_debounce && joy0right then gosub menu_selection_right
        if menu_selection > MENU_MAIN_MAX_OPTIONS then menu_selection = 0 : goto menu_main_dirs_done
        if left_debounce > MENU_TAP_FRAMES then gosub menu_selection_left
        if !left_debounce && joy0left then gosub menu_selection_left
        if menu_selection > MENU_MAIN_MAX_OPTIONS then menu_selection = MENU_MAIN_MAX_OPTIONS
menu_main_dirs_done
        if menu_selection = 0 then menu_cursor_X = MENU_MAIN_ITEMS_X
        if menu_selection = 1 then menu_cursor_X = MENU_MAIN_MAGIC_X
        if menu_selection = 2 then menu_cursor_X = MENU_MAIN_EQUIP_X
        if menu_selection = 3 then menu_cursor_X = MENU_MAIN_RELICS_X
        goto main

open_submenu
        action_debounce = 1
        menu_change = 1
        if menu_selection = 0 then goto plot_items_menu
        if menu_selection = 1 then goto plot_magic_menu
        if menu_selection = 2 then goto plot_equip_menu
        if menu_selection = 3 then goto plot_relics_menu
        goto main

plot_items_menu
        menu = MENU_ITEMS
        if !menu_change then goto items_menu_updater
        clearscreen
        gosub plot_menu_border
        menu_change = 0
        plotchars 'Items' 0 64 0 singlewide
        savescreen

items_menu_updater
        restorescreen

items_menu_controls
        if !menu_debounce && joy0fire0 && action_button = 1 then open_main_menu
        if !menu_debounce && joy0fire1 && action_button = 0 then open_main_menu
        ; Pause is a quickie way of getting back to the action
        if !pause_debounce && switchpause then close_menu
        if !action_debounce && joy0fire0 then open_main_menu
        if !action_debounce && joy0fire1 then open_main_menu
        goto main

plot_magic_menu
        menu = MENU_MAGIC
        if !menu_change then goto magic_menu_updater
        clearscreen
;        gosub disable_double_wide_mode
        gosub plot_menu_border
        plotchars 'Spells Tome' 0 60 0 singlewide
        plotchars 'Fireball' 0 16 1 singlewide
        plotchars 'Windslash' 0 16 3 singlewide
        plotchars 'Forward' 0 24 11 singlewide
        plotchars 'Backward' 0 80 11 singlewide
        plotchars 'Clockwise' 0 24 12 singlewide
        plotchars 'Counterclockwise' 0 80 12 singlewide
        ; TODO: Show different directions on different frames?
        characterset menu_arrows
        alphachars '7894 6123'
        ; Fireball
        plotchars '646' 0 24 2 singlewide
        ; Windslash
        plotchars '632' 0 24 4 singlewide
        ; Legend
        plotchars '6' 0 16 11 singlewide
        plotchars '4' 0 72 11 singlewide
        plotchars '2' 0 16 12 singlewide
        plotchars '8' 0 72 12 singlewide
        savescreen
        menu_change = 0

magic_menu_updater
        restorescreen

magic_menu_controls
        ; Either joystick button can go back to the main menu
        ; Maybe have an Exit "button" always highlighted to signify this?
        if !menu_debounce && joy0fire0 && action_button = 1 then open_main_menu
        if !menu_debounce && joy0fire1 && action_button = 0 then open_main_menu
        ; Pause is a quickie way of getting back to the action
        if !pause_debounce && switchpause then close_menu
        if !action_debounce && joy0fire0 then open_main_menu
        if !action_debounce && joy0fire1 then open_main_menu
        goto main

plot_equip_menu
        ; turn on Kangaroo mode so palette color 1 is more manageable
        sCTRL{2} = 1 : CTRL = sCTRL
        menu = MENU_EQUIP
        if !menu_change then goto equip_menu_updater
        clearscreen
        menu_change = 0
        menu_selection = 0
        menu_columns = 1        ; technically 2 but code handles each menu pane separately
        gosub plot_menu_border
        characterset menu_font
        alphachars '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ,.!?/-:`@&[$#]{}(_*)'
        plotchars 'Johanna' 0 16 1 singlewide
        plotchars 'Attack  0  Defense  0' 0 60 1 singlewide
        plotchars '------------------------------------' 0 8 2 singlewide
        plotchars 'Inventory' 0 24 3 singlewide
        plotchars 'Equipped'  0 96 3 singlewide
        plotchars 'Weapon'    0 80 4 singlewide
        plotchars 'Shield'    0 80 6 singlewide
        plotchars 'Armor'     0 80 8 singlewide
        plotchars 'Talisman'  0 80 10 singlewide
        plotchars 'Exit'      0 128 12 singlewide
        savescreen

equip_menu_updater
        restorescreen

equip_menu_controls
        ; Pause is a quickie way of getting back to the action
        if !pause_debounce && switchpause then close_menu
        if equip_inv_col then equip_menu_inv_controls
        equip_inv_sel = 0
        if !menu_debounce && joy0fire0 && action_button = 1 then open_main_menu
        if !menu_debounce && joy0fire1 && action_button = 0 then open_main_menu
        if !action_debounce && joy0fire0 && action_button = 0 then equip_menu_change_to_inv
        if !action_debounce && joy0fire1 && action_button = 1 then equip_menu_change_to_inv
        if up_debounce > MENU_TAP_FRAMES then gosub menu_selection_up
        if !up_debounce && joy0up then gosub menu_selection_up
        if menu_selection > MENU_EQUIP_MAX_OPTIONS then menu_selection = MENU_EQUIP_MAX_OPTIONS : goto equip_menu_dirs_done
        if down_debounce > MENU_TAP_FRAMES then gosub menu_selection_down
        if !down_debounce && joy0down then gosub menu_selection_down
        if menu_selection > MENU_EQUIP_MAX_OPTIONS then menu_selection = 0
        goto equip_menu_dirs_done

        const MENU_EQUIP_MAX_OPTIONS = 4
        const MENU_EQUIP_EQUIPPED_X = 76
        const MENU_EQUIP_SWORD_Y    = 64
        const MENU_EQUIP_SHIELD_Y   = 96
        const MENU_EQUIP_ARMOR_Y    = 128
        const MENU_EQUIP_CHARM_Y    = 160
        const MENU_EQUIP_INV_X      = 12
        const MENU_EQUIP_INV0_Y    = 80
        const MENU_EQUIP_INV1_Y    = 112
        const MENU_EQUIP_INV2_Y    = 142
        const MENU_EQUIP_INV3_Y    = 176
        const MENU_EQUIP_EXIT_X     = 124
        const MENU_EQUIP_EXIT_Y     = 192

equip_menu_return_from_inv
        menu_debounce = 1
        equip_inv_col = 0
        equip_inv_sel = 0
        goto equip_menu_dirs_done

equip_menu_inv_controls
        if !menu_debounce && joy0fire0 && action_button = 1 then equip_menu_return_from_inv
        if !menu_debounce && joy0fire1 && action_button = 0 then equip_menu_return_from_inv
        if !action_debounce && joy0fire0 && action_button = 0 then equip_item
        if !action_debounce && joy0fire1 && action_button = 1 then equip_item
        if up_debounce > MENU_TAP_FRAMES then gosub equip_inv_sel_up
        if !up_debounce && joy0up then gosub equip_inv_sel_up
        if down_debounce > MENU_TAP_FRAMES then gosub equip_inv_sel_down
        if !down_debounce && joy0down then gosub equip_inv_sel_down

equip_menu_dirs_done
        menu_cursor_X = MENU_EQUIP_EQUIPPED_X
        if menu_selection = 0 then menu_cursor_Y = MENU_EQUIP_SWORD_Y : goto equip_menu_sword_inv
        if menu_selection = 1 then menu_cursor_Y = MENU_EQUIP_SHIELD_Y : goto equip_menu_shield_inv
        if menu_selection = 2 then menu_cursor_Y = MENU_EQUIP_ARMOR_Y : goto equip_menu_armor_inv
        if menu_selection = 3 then menu_cursor_Y = MENU_EQUIP_CHARM_Y : goto equip_menu_charm_inv
        if menu_selection = 4 then menu_cursor_X = MENU_EQUIP_EXIT_X : menu_cursor_Y = MENU_EQUIP_EXIT_Y
        ; continue showing the inventory of the previously selected option
        if prev_menu_selection = 0 then goto equip_menu_sword_inv
        goto equip_menu_charm_inv

equip_menu_sword_inv
        m_inv_index = 1 + m_inv_scroll
        for m_inv_slot = 0 to 3
        m_inv_item_0[m_inv_slot] = m_sword_inv[m_inv_index]
        m_inv_index = m_inv_index + 1
menu_sword_next 
        next

        ; TODO: LUT for item icons
        plotsprite menu_sword0 4 16 80 m_inv_item_0
        plotmap sword_names 0 24 5 13 1 0 m_inv_item_0 13
        plotsprite menu_sword0 4 16 112 m_inv_item_1
        plotmap sword_names 0 24 7 13 1 0 m_inv_item_1 13
        plotsprite menu_sword0 4 16 144 m_inv_item_2
        plotmap sword_names 0 24 9 13 1 0 m_inv_item_2 13
        plotsprite menu_sword0 4 16 176 1 0 m_inv_item_3
        plotmap sword_names 0 24 11 13 1 0 m_inv_item_3 13
        goto equip_menu_draw_sprites

equip_menu_shield_inv
        m_inv_index = 1 + m_inv_scroll
        for m_inv_slot = 0 to 3
        m_inv_item_0[m_inv_slot] = m_shield_inv[m_inv_index]
        m_inv_index = m_inv_index + 1
menu_shield_next 
        next

        plotsprite menu_shield0 4 16 80 m_inv_item_0
        plotmap shield_names 0 24 5 13 1 0 m_inv_item_0 13
        plotsprite menu_shield0 4 16 112 m_inv_item_1
        plotmap shield_names 0 24 7 13 1 0 m_inv_item_2 13
        plotsprite menu_shield0 4 16 144 m_inv_item_3
        plotmap shield_names 0 24 9 13 1 0 m_inv_item_3 13
        plotsprite menu_shield0 4 16 176 1 0 m_inv_item_4
        plotmap shield_names 0 24 11 13 1 0 m_inv_item_4 13
        goto equip_menu_draw_sprites

equip_menu_armor_inv
        m_inv_index = 1 + m_inv_scroll
        for m_inv_slot = 0 to 3
        m_inv_item_0[m_inv_slot] = m_armor_inv[m_inv_index]
        m_inv_index = m_inv_index + 1
menu_armor_next 
        next

        plotsprite menu_armor0 4 16 80  m_inv_item_0
        plotmap armor_names 0 24 5 13 1 0  m_inv_item_0 13
        plotsprite menu_armor0 4 16 112  m_inv_item_1
        plotmap armor_names 0 24 7 13 1 0  m_inv_item_1 13
        plotsprite menu_armor0 4 16 144  m_inv_item_2
        plotmap armor_names 0 24 9 13 1 0  m_inv_item_2 13
        plotsprite menu_armor0 4 16 176 1 0  m_inv_item_3
        plotmap armor_names 0 24 11 13 1 0  m_inv_item_3 13
        goto equip_menu_draw_sprites

equip_menu_charm_inv
        m_inv_index = 1 + m_inv_scroll
        for m_inv_slot = 0 to 3
        m_inv_item_0[m_inv_slot] = m_charm_inv[m_inv_index]
        m_inv_index = m_inv_index + 1
menu_charm_next 
        next

        plotsprite menu_charm0 4 16 80  m_inv_item_0
        plotmap charm_names 0 24 5 13 1 0  m_inv_item_0 13
        plotsprite menu_charm0 4 16 112  m_inv_item_1
        plotmap charm_names 0 24 7 13 1 0  m_inv_item_1 13
        plotsprite menu_charm0 4 16 144  m_inv_item_2
        plotmap charm_names 0 24 9 13 1 0  m_inv_item_2 13
        plotsprite menu_charm0 4 16 176 1 0  m_inv_item_3
        plotmap charm_names 0 24 11 13 1 0  m_inv_item_3 13
        goto equip_menu_draw_sprites

equip_menu_draw_sprites
        ; draw the player's equipment based on variable offsets
        plotsprite menu_sword0 0 84 80 player_sword
        plotmap sword_names 0 92 5 13 1 0 player_sword 13
        plotsprite menu_shield0 0 84 112 player_shield
        plotmap shield_names 0 92 7 13 1 0 player_shield 13
        plotsprite menu_armor0 0 84 144 player_armor
        plotmap armor_names 0 92 9 13 1 0 player_armor 13
        plotsprite menu_charm0 0 84 176 1 0 player_charm
        plotmap charm_names 0 92 11 13 1 0 player_charm 13
        if equip_inv_col then equip_menu_inv_cursor
        plotsprite menu_cursor0 0 menu_cursor_X menu_cursor_Y
        goto main

equip_menu_inv_cursor
        ; blink the equipped column cursor
        if animation_frame then plotsprite menu_cursor0 0 menu_cursor_X menu_cursor_Y
        plotsprite menu_cursor0 0 equip_inv_X equip_inv_Y
        goto main

equip_menu_change_to_inv
        action_debounce = 1
        if menu_selection = MENU_EQUIP_MAX_OPTIONS then open_main_menu
        equip_inv_col = 1
        equip_inv_X = MENU_EQUIP_INV_X
        equip_inv_Y = MENU_EQUIP_INV0_Y
        goto equip_menu_dirs_done

equip_item
        action_debounce = 1
        equip_inv_col = 0
        m_inv_scroll = 0
        if menu_selection = 0 then equip_sword
        if menu_selection = 1 then equip_shield
        if menu_selection = 2 then equip_armor
equip_charm
        player_charm = equip_inv_sel
        goto equip_menu_dirs_done

equip_sword
        player_sword = equip_inv_sel
        goto equip_menu_dirs_done

equip_shield
        player_shield = equip_inv_sel
        goto equip_menu_dirs_done

equip_armor
        player_armor = equip_inv_sel
        goto equip_menu_dirs_done

equip_menu_colors
        P0C1 = m_sword_pal1
        P0C3 = m_sword_pal2
        P4C1 = m_inv0_pal1
        P4C3 = m_inv0_pal2
        for index = 0 to 96
        WSYNC = 1
        next
        ; palettes used for inv 1 and shield
        P0C1 = m_shield_pal1
        P0C3 = m_shield_pal2
        P4C1 = m_inv1_pal1
        P4C3 = m_inv1_pal2
        for index = 0 to 32
        WSYNC = 1
        next
        ; palettes used for inv 2 and armor
        P0C1 = m_armor_pal1
        P0C3 = m_armor_pal2
        P4C1 = m_inv2_pal1
        P4C3 = m_inv2_pal2
        for index = 0 to 32
        WSYNC = 1
        next
        ; palettes used for inv 3 and charm
        P0C1 = m_charm_pal1
        P0C3 = m_charm_pal2
        P4C1 = m_inv3_pal1
        P4C3 = m_inv3_pal2
        return

plot_relics_menu
        menu = MENU_RELICS
        if !menu_change then goto relics_menu_updater
        clearscreen
        gosub plot_menu_border
        menu_change = 0
        plotchars 'Relics' 0 64 0 singlewide
        savescreen

relics_menu_updater
        restorescreen

relics_menu_controls
        if !menu_debounce && joy0fire0 && action_button = 1 then open_main_menu
        if !menu_debounce && joy0fire1 && action_button = 0 then open_main_menu
        ; Pause is a quickie way of getting back to the action
        if !pause_debounce && switchpause then close_menu
        if !action_debounce && joy0fire0 then open_main_menu
        if !action_debounce && joy0fire1 then open_main_menu
        goto main

        const MENU_MAIN_ITEMS_X = 12
        const MENU_MAIN_ITEMS_Y = 192
        const MENU_MAIN_MAGIC_X = 40
        const MENU_MAIN_EQUIP_X = 72
        const MENU_MAIN_RELICS_X = 116
        const MENU_TAP_FRAMES = 4

menu_selection_right
        prev_menu_selection = menu_selection
        menu_selection = menu_selection + 1 : right_debounce = 1
        return

menu_selection_left
        prev_menu_selection = menu_selection
        menu_selection = menu_selection - 1 : left_debounce  = 1
        return

menu_selection_down
        prev_menu_selection = menu_selection
        menu_selection = menu_selection + menu_columns : down_debounce = 1
        return

menu_selection_up
        prev_menu_selection = menu_selection
        menu_selection = menu_selection - menu_columns : up_debounce = 1
        return

equip_inv_sel_down
        equip_inv_sel = equip_inv_sel + 1 : down_debounce = 1
        if equip_inv_sel > 3 then m_inv_scroll = m_inv_scroll + 1 : return
        equip_inv_Y = equip_inv_Y + 32
        return

equip_inv_sel_up
        if equip_inv_sel = 0 then return
        equip_inv_sel = equip_inv_sel - 1 : up_debounce = 1
        if m_inv_scroll = 0 then return
        if equip_inv_sel > 0 then m_inv_scroll = m_inv_scroll - 1 : return
        equip_inv_Y = equip_inv_Y - 32
        return

open_main_menu
        action_debounce = 1
        menu_debounce = 1
        menu_change = 1
        menu = MENU_MAIN
        goto main

close_menu
        gosub enable_double_wide_mode
        gosub clear_palettes
        game_state = STATE_FIELD
        asm
        lda #1
        sta reload_map
        sta save_objects
        sta menu_debounce
        sta pause_debounce
        sta torch_reblock
end
        goto main ; shared palettes are now included in each tileset


        dmahole 0
plot_menu_border
        ; TODO: Automate this drawing?
        characterset menu_font
        alphachars '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ,.!?/-:`@&[$#]{}(_*)'
        plotchars '&[$#$$$#$#$$#$$$#$$#$#$$$#$#$$$$#$$#$$]&' 0 0 0 singlewide
        plotchars '&{' 0   0 1 singlewide
        plotchars '}&' 0 152 1 singlewide
        plotchars '&{' 0   0 2 singlewide
        plotchars '}&' 0 152 2 singlewide
        plotchars '&{' 0   0 3 singlewide
        plotchars '}&' 0 152 3 singlewide
        plotchars '&{' 0   0 4 singlewide
        plotchars '}&' 0 152 4 singlewide
        plotchars '&{' 0   0 5 singlewide
        plotchars '}&' 0 152 5 singlewide
        plotchars '&{' 0   0 6 singlewide
        plotchars '}&' 0 152 6 singlewide
        plotchars '&{' 0   0 7 singlewide
        plotchars '}&' 0 152 7 singlewide
        plotchars '&{' 0   0 8 singlewide
        plotchars '}&' 0 152 8 singlewide
        plotchars '&{' 0   0 9 singlewide
        plotchars '}&' 0 152 9 singlewide
        plotchars '&{' 0   0 10 singlewide
        plotchars '}&' 0 152 10 singlewide
        plotchars '&{' 0   0 11 singlewide
        plotchars '}&' 0 152 11 singlewide
        plotchars '&{' 0   0 12 singlewide
        plotchars '}&' 0 152 12 singlewide
        plotchars '&(__*__*_*__*__*___*_*__*___*_*_*___*_)&' 0   0 13 singlewide
        return

        alphadata sword_names menu_font singlewide
        '             '
        'Rapier       '
        'Longsword    '
        'Broadsword   '
        'Estoc        '
        'Firebrand    '
        'Sword No. 6  '
        'Sword No. 7  '
        'Sword No. 8  '
        'Sword No. 9  '
        'Sword No. 10 '
        'Sword No. 11 '
        'Sword No. 12 '
        'Sword No. 13 '
        'Sword No. 14 '
        'Sword No. 15 '
end

        alphadata shield_names menu_font singlewide
        '             '
        'Buckler      '
        'Cross Shield '
        'Kite Shield  '
        'Mirror Shield'
        'Shield No. 5 '
        'Shield No. 6 '
        'Shield No. 7 '
        'Shield No. 8 '
        'Shield No. 9 '
        'Shield No. 10'
        'Shield No. 11'
        'Shield No. 12'
        'Shield No. 13'
        'Shield No. 14'
        'Shield No. 15'
end

        alphadata armor_names menu_font singlewide
        '             '
        'Bronze Plate '
        'Steel Plate  '
        'Silver Plate '
        'Maiden Armor '
        'Armor No. 5  '
        'Armor No. 6  '
        'Armor No. 7  '
        'Armor No. 8  '
        'Armor No. 9  '
        'Armor No. 10 '
        'Armor No. 11 '
        'Armor No. 12 '
        'Armor No. 13 '
        'Armor No. 14 '
        'Armor No. 15 '
end

        alphadata charm_names menu_font singlewide
        '             '
        'Pendant      '
        'Charm        '
        'Locket       '
        'Coral Ring   '
        'Charm No. 5  '
        'Charm No. 6  '
        'Charm No. 7  '
        'Charm No. 8  '
        'Charm No. 9  '
        'Charm No. 10 '
        'Charm No. 11 '
        'Charm No. 12 '
        'Charm No. 13 '
        'Charm No. 14 '
        'Charm No. 15 '
end

enable_double_wide_mode
        sCTRL{4} = 1 : CTRL = sCTRL
        return

disable_double_wide_mode
        sCTRL{4} = 0 : CTRL = sCTRL
        return

set_menu_top_pal
        WSYNC = 1 : BACKGRND = $2D
        if menu = MENU_EQUIP then equip_menu_colors
        return

        data sfx_poof2
        $10,$10,$00 ; version, priority, frames per chunk
        $0a,$08,$04 ; first chunk of freq,channel,volume
        $12,$08,$06
        $09,$08,$08
        $11,$08,$08
        $08,$08,$0a
        $10,$08,$0a
        $07,$08,$0a
        $0F,$08,$0a
        $06,$08,$08
        $0E,$08,$06
        $05,$08,$04
        $0D,$08,$02
        $00,$00,$00
end

;==============================================================================
; BANK 8
;------------------------------------------------------------------------------
; Permanently loaded bank. Contains sprites and code used with every tileset
;==============================================================================
        bank 8
        incgraphic gfx/sprites/heroine0.png  160B 0 4 5 3 6 1 ; FRAME_DOWN
        incgraphic gfx/sprites/heroine1.png  160B 0 4 5 3 6 1 ; FRAME_DOWN_2
        incgraphic gfx/sprites/heroine2.png  160B 0 4 5 6 3   ; FRAME_UP
        incgraphic gfx/sprites/heroine3.png  160B 0 4 5 6 3   ; FRAME_UP_2
        incgraphic gfx/sprites/heroine4.png  160B 0 4 5 6 3 1 ; FRAME_LEFT
        incgraphic gfx/sprites/heroine5.png  160B 0 4 5 6 3 1 ; FRAME_LEFT_2
        incgraphic gfx/sprites/heroine6.png  160B 0 4 5 3 6 1 ; FRAME_RIGHT
        incgraphic gfx/sprites/heroine7.png  160B 0 4 5 3 6 1 ; FRAME_RIGHT_2
        incgraphic gfx/sprites/heroine8.png  160B 0 4 5 3 6 1 ; FRAME_ATK_D
        incgraphic gfx/sprites/heroine9.png  160B 0 4 6 5 3   ; FRAME_ATK_U
        incgraphic gfx/sprites/heroine10.png 160B 0 4 5 6 3 1 ; FRAME_ATK_L
        incgraphic gfx/sprites/heroine11.png 160B 0 4 5 3 6 1 ; FRAME_ATK_R
        incgraphic gfx/sprites/link.png      160B 0 4 5 6 3 1 ; FRAME_CHANT (bugged if heroine12.png is used?)
        incgraphic gfx/sprites/sword0.png 160A 0 1 3
        incgraphic gfx/sprites/sword1.png 160A 0 3 1
        incgraphic gfx/sprites/sword2.png 160A 0 1 3
        incgraphic gfx/sprites/sword3.png 160A 0 1 3
        incgraphic gfx/sprites/shield.png 160A 0 2 1
        incgraphic gfx/sprites/torch0.png 160B 0 1 2 3 6 5 4
        incgraphic gfx/sprites/torch1.png 160B 0 1 2 3 5 6 4
        incgraphic gfx/sprites/hp.png 160B 0 3 7 8 1 2
        incgraphic gfx/sprites/mp.png 160A 0 3 1
        incgraphic gfx/sprites/bar0.png 160A 0 1
        incgraphic gfx/sprites/bar1.png 160A 0 2 1
        incgraphic gfx/sprites/bar2.png 160A 0 2 1
        incgraphic gfx/sprites/bar3.png 160A 0 2 1
        incgraphic gfx/sprites/bar4.png 160A 0 2 1
        incgraphic gfx/sprites/bar5.png 160A 0 2 1
        incgraphic gfx/sprites/bar6.png 160A 0 2 1
        incgraphic gfx/sprites/bar7.png 160A 0 2 1
        incgraphic gfx/sprites/bar8.png 160A 0 2 1
        incgraphic gfx/sprites/coin.png 160A 0 3 2
        incgraphic gfx/sprites/prism.png 160A 0 3 2 1
        incgraphic gfx/sprites/chimkin.png 160A 0 3 1 2
        incgraphic gfx/sprites/fireball0.png 160A
        incgraphic gfx/sprites/fireball1.png 160A
        incgraphic gfx/sprites/fireball2.png 160A
        incgraphic gfx/sprites/fireball3.png 160A
        incgraphic gfx/sprites/fireball4.png 160A

;==============================================================================
; LOAD OBJECTS
;------------------------------------------------------------------------------
; Fills all 16 object slots with type and position data from ROM,
; then interates through each type to set object properties
; Utilizes pointers so multiple maps can reuse the same object data if desired
;==============================================================================
load_objects
        temp1 = 0
        for obj_index = 0 to MAX_OBJECTS
        object_type[obj_index] = pointer[[temp1]]
        temp1 = temp1 + 1
        object_Xpos[obj_index] = pointer[[temp1]]
        temp1 = temp1 + 1
        object_Ypos[obj_index] = pointer[[temp1]]
        temp1 = temp1 + 1
        next
        for obj_index = 0 to MAX_MAP_OBJECTS
        if !object_type[obj_index] then next_obj_stats
        if object_type[obj_index] = TYPE_WOLF then obj_wolf_stats
        if object_type[obj_index] = TYPE_TORCH then obj_torch_stats
        if object_type[obj_index] = TYPE_SLIME then obj_slime_stats
        if object_type[obj_index] = TYPE_MSLIME then obj_slime_stats : object_hp[obj_index] = MSLIME_HP
        if object_type[obj_index] = TYPE_RAVEN then obj_raven_stats


obj_next_stats
        next
        return

obj_torch_stats
        object_hp[obj_index] = 1
        object_contact[obj_index] = 0
        object_vel_cap_hi[obj_index] = 0
        object_vel_cap_lo[obj_index] = 0
        object_damage[obj_index] = 0
        object_friction_hi[obj_index] = 0
        object_friction_lo[obj_index] = 0
        object_speed_hi[obj_index] = 0
        object_speed_lo[obj_index] = 0
        object_flags[obj_index] = 0
        goto obj_next_stats

load_map
        clearscreen
        displaymode 160A
        adjustvisible 0 14
        if tileset = T_FOREST then loadrombank 2 : gosub load_forest
        savescreen
        if !save_objects then gosub load_objects
        asm
        lda #0
        sta reload_map
        sta save_objects
end
        if exit_dir = EXIT_SOUTH then player_Ypos = 16  : player_Ydir = DIR_DOWN
        if exit_dir = EXIT_NORTH then player_Ypos = 204 : player_Ydir = DIR_UP
        if exit_dir = EXIT_EAST  then player_Xpos = 148 : player_Xdir = DIR_LEFT
        if exit_dir = EXIT_WEST  then player_Xpos = 16  : player_Xdir = DIR_RIGHT
        exit_dir = EXIT_NONE

field_handler
        if reload_map = 1 then goto load_map
        goto player_handler
player_handler_done
        gosub object_handler
        ; set by close menu, needed to make torches block movement after menu access
        torch_reblock = 0
        gosub check_collisions

        restorescreen
        if debug_time then BACKGRND = $06
        ; Iterates through all objects and determined which sprites need to be plotted by type
        for index = 0 to 15
        if !object_type[index] then goto plot_next
        if object_type[index] = TYPE_SPAWNER then plot_next
        Xposition = object_Xpos[index] : Yposition = object_Ypos[index] : frame = object_frame[index]
        if object_type[index] = TYPE_WOLF then plot_wolf
        if object_type[index] = TYPE_TORCH then plot_torch
        if object_type[index] = TYPE_COIN then plot_coin
        if object_type[index] = TYPE_PRISM then plot_prism
        if object_type[index] = TYPE_SLIME then plot_slime
        if object_type[index] = TYPE_MSLIME then plot_minislime
        if object_type[index] = TYPE_RAVEN then plot_raven
        if object_type[index] = TYPE_FOOD then plot_food
        if object_type[index] = TYPE_FIREBALL then plot_fireball
plot_next
        next
        ; Plot the player, their shield, and sword if attacking
        if player_state = STATE_CHANT then plotsprite link 0 player_Xpos player_Ypos 0 : goto plot_hud
        if player_state = STATE_ATTACK then plotsprite sword0 sword_pal sword_Xpos sword_Ypos sword_frame
        plotsprite heroine0 0 player_Xpos player_Ypos player_frame
        ; TODO: Multiple shield frames depending on direction/state
        plotsprite shield shield_pal shield_Xpos shield_Ypos shield_frame
        if debug_time then BACKGRND = bg_color
plot_hud
        gosub draw_hud

play_sounds
        ; can safely load another ROM bank after screen has been drawn
        ; but might change this to playing from RAM to reduce lag
        loadrombank 3
        if sword_hit then playsfx sfx_poof2
        loadrombank 2
        goto main

plot_torch
        PLOTSPRITE torch0 0 Xposition Yposition animation_frame
        goto plot_next

plot_coin
        plotsprite coin 3 Xposition Yposition 0
        goto plot_next

plot_prism
        plotsprite prism 0 Xposition Yposition 0
        goto plot_next

plot_food
        plotsprite chimkin 1 Xposition Yposition 0
        goto plot_next

plot_fireball
        plotsprite fireball0 2 Xposition Yposition frame
        goto plot_next


;==============================================================================
; DRAW HUD
;------------------------------------------------------------------------------
; Draws the player's HP and MP bar in zones 1-2 using sprites.
; Bars must be plotted in separate zones or there isn't enough DMA time
;==============================================================================
draw_hud
        plotsprite  hp   0  8  0       ; HP is 160B
        plotsprite  bar0 2 24  0 hp_seg_1
        PLOTSPRITE4 bar0 2 32  0 hp_seg_2
        PLOTSPRITE4 bar0 2 40  0 hp_seg_3
        PLOTSPRITE4 bar0 2 48  0 hp_seg_4
        PLOTSPRITE4 bar0 2 56  0 hp_seg_5
        PLOTSPRITE4 bar0 2 64  0 hp_seg_6
        plotsprite  mp   0  8 16        ; Need to use plotsprite here to avoid rendering error on MP bar
        PLOTSPRITE4 bar0 0 24 16 mp_seg_1
        PLOTSPRITE4 bar0 0 32 16 mp_seg_2
        PLOTSPRITE4 bar0 0 40 16 mp_seg_3
        PLOTSPRITE4 bar0 0 48 16 mp_seg_4
        PLOTSPRITE4 bar0 0 56 16 mp_seg_5
        PLOTSPRITE4 bar0 0 64 16 mp_seg_6
        if debug_hud = 0 then return
        ; plotvalue hud 0 player_hp 2 72 0
        ; plotvalue hud 0 player_mp 2 72 1
        plotvalue hud 0 player_Xpos 4 32 12
        plotvalue hud2 0 move_tile_1 4 32 13
        ; plotvalue hud 0 room_index 2 32 13
        ; plotvalue hud 0 room 2 48 13
        plotvalue hud 0 input_buffer 16 16 13
        ; plotvalue hud 0 chant_input 2 8 13
        ; plotvalue hud 0 retract_counter 2 64 13
        return

open_menu
        gosub clear_palettes
        ; TODO: Should previously opened submenu be remembered?
        menu = MENU_MAIN
        loadrombank 3
        menu_debounce = 1
        pause_debounce = 1
        goto menu_init

followplayer
        if Xposition > player_Xpos then Xvelocity = Xvelocity + move_speed : Xdirection = DIR_LEFT
        if Xposition < player_Xpos then Xvelocity = Xvelocity + move_speed : Xdirection = DIR_RIGHT
        if Yposition > player_Ypos then Yvelocity = Yvelocity + move_speed : Ydirection = DIR_UP
        if Yposition < player_Ypos then Yvelocity = Yvelocity + move_speed : Ydirection = DIR_DOWN
        return

get_player_pos
        Xdestination = player_Xpos : Ydestination = player_Ypos
        return

get_player_dir
        Xdirection = player_Xdir
        Ydirection = player_Ydir
        return

go_to_destination
        if Xposition > Xdestination then Xvelocity = Xvelocity + move_speed : Xdirection = DIR_LEFT
        if Xposition < Xdestination then Xvelocity = Xvelocity + move_speed : Xdirection = DIR_RIGHT
        if Yposition > Ydestination then Yvelocity = Yvelocity + move_speed : Ydirection = DIR_UP
        if Yposition < Ydestination then Yvelocity = Yvelocity + move_speed : Ydirection = DIR_DOWN
        if Xposition = Xdestination then flags{3} = 0
        if Yposition = Ydestination then flags{3} = 0
        return

swoop_X
        return

swoop_Y
        return

object_handler
        for index = 0 to 15
        if !object_type[index] then object_done    ; 0 = no object
        if object_type[index] = TYPE_COIN then object_done      ;  coins, prisms are static
        if object_type[index] = TYPE_PRISM then object_done
        if object_type[index] = TYPE_FOOD then object_done
        if object_type[index] = TYPE_SPAWNER then spawn_object
        if object_type[index] = TYPE_TORCH then torch_tile_block
        gosub copy_object_props 
        gosub decelerate_object
        if object_type[index] = TYPE_WOLF then gosub wolf_ai
        if object_type[index] = TYPE_SLIME then gosub slime_ai
        if object_type[index] = TYPE_MSLIME then gosub slime_ai
        if object_type[index] = TYPE_RAVEN then gosub raven_ai
        if object_type[index] = TYPE_FIREBALL then gosub fireball_ai
        gosub move_object
        gosub restore_object_props
object_done
        next
        return

;==============================================================================
; FIREBALL AI
;------------------------------------------------------------------------------
; Fireballs poof out of existence when velocities = 0
;==============================================================================
        const FIREBALL_MAX_FRAMES = 4
fireball_ai
        if Xvelocity then fireball_animate
        if Yvelocity then fireball_animate
        object_timer[index] = ANIM_TIME
        object_timer[index] = object_timer[index] - 1
        if object_timer[index] then fireball_done
        frame = frame + 1
        if object_frame[index] < FIREBALL_MAX_FRAMES then return
        object_type[index] = 0
        return
fireball_animate
        frame = 0
        if animation_frame then frame = 1
fireball_done
        return


torch_tile_block
        ; flags are used to track if the tile has already been blocked
        ; however, this fails when the map reloads after the menu is opened
        if torch_reblock then goto torch_tile_block_get_pos
        if object_flags[index] then object_done
torch_tile_block_get_pos
        gosub get_torch_pos
        if tileset = T_FOREST then gosub torch_tile_block_forest
        object_flags[index] = 1
        goto object_done

spawn_object
        ; index is still set by object_handler
        if object_flags[index] = TYPE_TORCH then spawns_torch
        drop_rate = 0
        if object_flags[index] = TYPE_WOLF then drop_rate = WOLF_DROP_RATE
        if object_flags[index] = TYPE_SLIME then drop_rate = SLIME_DROP_RATE

        if rand > drop_rate then spawn_nothing

        if object_flags[index] = TYPE_WOLF then spawns_wolf
        if object_flags[index] = TYPE_SLIME then spawns_slime
        goto object_done

spawns_slime
        ; TODO: Unique drops

spawns_wolf
        ; TODO: Unique wolf item drops
spawns_torch
        if player_hp = player_max_hp then torch_mp_check
        if rand > 128 then _spawn_food
torch_mp_check
        if player_mp = player_max_mp then _spawn_coin
        goto _spawn_mana

_spawn_food
        object_type[index] = TYPE_FOOD
        object_hp[index] = 1
        goto object_done

_spawn_mana
        object_type[index] = TYPE_PRISM
        object_hp[index] = 1
        goto object_done

_spawn_coin
        object_type[index] = TYPE_COIN
        object_hp[index] = 1
        goto object_done

spawn_nothing
        object_type[index] = 0
        goto object_done

player_handler
        dec player_damage = $1
;        gosub copy_player_props
        gosub decelerate_player
;        gosub restore_player_props

;==============================================================================
; SUBROUTINE: HANDLE INPUT FIELD
;------------------------------------------------------------------------------
; This routine handles all player input in the field
;==============================================================================
handle_input_field
        if debug_time then BACKGRND = $70

        ; player timer is set for knockback and attack timing
        if !player_timer then no_player_timer
        player_timer = player_timer - 1
        if player_state = STATE_KNOCKBACK then test_joy_done
        if player_state = STATE_ATTACK then test_joy_done

no_player_timer
        player_flags{0} = 0     ; clear invulnerability flag

;------------------------------------------------------------------------------
        ; handles chanting and sword retracting. Zero if not doing these
        if player_state = STATE_CHANT then chant_handler
        if player_state = STATE_ATTACK then retract_sword
        if joy0fire0 && action_button = 0 then goto player_attack
        if joy0fire1 && action_button = 1 then goto player_attack

        asm
        lda #0
        sta retract_counter
        sta chant_timer
        sta player_state        ; STATE_STAND
        sta player_exiting_chant
        sta sword_hit
end

;------------------------------------------------------------------------------

        if player_facing = DIR_UP then player_frame = FRAME_UP : goto frames_done
        if player_facing = DIR_DOWN then player_frame = FRAME_DOWN : goto frames_done
        if player_facing = DIR_LEFT then player_frame = FRAME_LEFT : goto frames_done
        player_frame = FRAME_RIGHT

frames_done
        if joy0up    then player_Ydir = DIR_UP    : player_facing = DIR_UP    : player_frame = FRAME_UP    : player_Yvel = player_Yvel + player_speed : player_state = STATE_MOVING : test_joy_done
        if joy0down  then player_Ydir = DIR_DOWN  : player_facing = DIR_DOWN  : player_frame = FRAME_DOWN  : player_Yvel = player_Yvel + player_speed : player_state = STATE_MOVING : test_joy_done
        if joy0left  then player_Xdir = DIR_LEFT  : player_facing = DIR_LEFT  : player_frame = FRAME_LEFT  : player_Xvel = player_Xvel + player_speed : player_state = STATE_MOVING : test_joy_done
        if joy0right then player_Xdir = DIR_RIGHT : player_facing = DIR_RIGHT : player_frame = FRAME_RIGHT : player_Xvel = player_Xvel + player_speed : player_state = STATE_MOVING : test_joy_done

test_joy_done
        if !menu_debounce && joy0fire0 && action_button = 1 then goto open_menu
        if !menu_debounce && joy0fire1 && action_button = 0 then goto open_menu
        if !pause_debounce && switchpause then goto open_menu
        if player_state = STATE_STAND || player_state = STATE_ATTACK then player_move_done
        gosub copy_player_props
        gosub move_object
        gosub restore_player_props

player_move_done

        shield_Xpos = player_Xpos + SHIELD_OFFSET_X
        shield_Ypos = player_Ypos + SHIELD_OFFSET_Y

input_frame_done
        if !player_Xvel && !player_Yvel && player_state <> STATE_ATTACK && player_state <> STATE_CHANT then player_state = STATE_STAND
        if animation_frame && player_state = STATE_MOVING then player_frame = player_frame + 1

check_room_boundary
        if player_Xpos < 2  then exit_dir = EXIT_EAST  : room_index = room_index - 1
        if player_Xpos > 149 then exit_dir = EXIT_WEST  : room_index = room_index + 1
        if player_Ypos < 2  then exit_dir = EXIT_NORTH : room_index = room_index - ROOMS_PER_ROW
        if player_Ypos > 204 then exit_dir = EXIT_SOUTH : room_index = room_index + ROOMS_PER_ROW
        if exit_dir then reload_map = 1
        if debug_time then BACKGRND = bg_color
        goto player_handler_done

player_attack
        sword_hit = 0
        ; player exiting chant tracks if the player cast magic to exit chant with button held
        if player_exiting_chant then test_joy_done
        if retract_counter then retract_sword
        if player_facing = DIR_DOWN then sword_Xpos = player_Xpos : sword_Ypos = player_Ypos + SWORD_OFFSET_DOWN : sword_width = 4 : sword_height = 16 : sword_frame = 0 : goto sword_done
        if player_facing = DIR_UP   then sword_Xpos = player_Xpos : sword_Ypos = player_Ypos + SWORD_OFFSET_UP   : sword_width = 4 : sword_height = 16 : sword_frame = 1 : goto sword_done
        if player_facing = DIR_LEFT then sword_Xpos = player_Xpos + SWORD_OFFSET_LEFT : sword_Ypos = player_Ypos : sword_width = 12 : sword_height = 4 :sword_frame = 3 : goto sword_done
        sword_Xpos = player_Xpos + SWORD_OFFSET_RIGHT : sword_Ypos = player_Ypos : sword_width = 12 : sword_height = 4 : sword_frame = 2
sword_done
        if player_facing = DIR_LEFT  then player_frame = FRAME_ATK_L : goto player_attack_return
        if player_facing = DIR_RIGHT then player_frame = FRAME_ATK_R : goto player_attack_return
        if player_facing = DIR_UP    then player_frame = FRAME_ATK_U : goto player_attack_return
        if player_facing = DIR_DOWN  then player_frame = FRAME_ATK_D

player_attack_return
        player_state = STATE_ATTACK
        player_timer = ATTACK_FRAMES
        goto player_handler_done

retract_sword
        if player_facing = DIR_DOWN  then sword_Ypos = sword_Ypos - 4 : retract_step_done
        if player_facing = DIR_UP    then sword_Ypos = sword_Ypos + 4 : retract_step_done
        if player_facing = DIR_LEFT  then sword_Xpos = sword_Xpos + 2 : retract_step_done
        if player_facing = DIR_RIGHT then sword_Xpos = sword_Xpos - 2

retract_step_done
        retract_counter = retract_counter + 1
        if retract_counter < 3 then test_joy_done

retract_stand
        if !joy0fire0 && action_button = 0 then player_state = STATE_STAND : goto test_joy_done
        if !joy0fire1 && action_button = 1 then player_state = STATE_STAND : goto test_joy_done
        ; retract finished and button still held - code runs into player_chant_start

player_chant_start
        if chant_timer > CHANT_START_TIME then set_state_chant
        player_state = STATE_CHANT_START
        asm
        inc chant_timer
end
        if player_facing = DIR_UP    then player_frame = FRAME_UP
        if player_facing = DIR_DOWN  then player_frame = FRAME_DOWN
        if player_facing = DIR_LEFT  then player_frame = FRAME_LEFT
        if player_facing = DIR_RIGHT then player_frame = FRAME_RIGHT
        goto test_joy_done

set_state_chant
        ; set player state to chant and facing direction to down
        ; facing down when coming out of chant just feels more natural
        player_state = STATE_CHANT
        player_facing = DIR_DOWN

chant_handler
        if debug_time = 1 then BACKGRND = $B9

        if !joy0fire0 && action_button = 0 then chant_done_no_hold
        if !joy0fire1 && action_button = 1 then chant_done_no_hold

        ; chant_new_input is set when a direction is pressed
        if chant_new_input then chant_input_test_release

        ; parse the most recent directional entered and test for combos
        if input_buffer[chant_index] = DIR_UP    then chant_spells_up
        if input_buffer[chant_index] = DIR_DOWN  then chant_spells_down
        if input_buffer[chant_index] = DIR_LEFT  then chant_spells_left
        if input_buffer[chant_index] = DIR_RIGHT then chant_spells_right

chant_test_dirs
        if joy0left  then chant_input = DIR_LEFT  : chant_new_input = 1
        if joy0right then chant_input = DIR_RIGHT : chant_new_input = 1
        if joy0up    then chant_input = DIR_UP    : chant_new_input = 1
        if joy0down  then chant_input = DIR_DOWN  : chant_new_input = 1
        goto test_joy_done

; Require a release of a single direction (TODO: 8dir?) before buffering input
chant_input_test_release
        if joy0up    then test_joy_done
        if joy0down  then test_joy_done
        if joy0left  then test_joy_done
        if joy0right then test_joy_done
        ; TODO: Test for holds? Long times between inputs?

chant_buffer_input
        input_buffer[input_buffer_index] = chant_input
        ; chant_index is always updated to input buffer index but is its own
        ; variable so that it can be manipulated by the parsing routines
        ; without losing the input buffer index for the next frame
        chant_index = input_buffer_index
        input_buffer_index = input_buffer_index + 1
        if input_buffer_index > INPUT_BUFFER_MAX then input_buffer_index = 0
        chant_new_input = 0
        goto test_joy_done

; all chant tests seach for button combos "backwards" from the most recent input
chant_spells_up
        chant_index = chant_index - 1
        ; chant index will underflow to 255, set to 7
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] = DIR_DOWN then parse_fireball_up
        goto chant_test_dirs

chant_spells_down
        chant_index = chant_index - 1
        ; chant index will underflow to 255, set to 7
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] = DIR_UP then parse_fireball_down
        goto chant_test_dirs

chant_spells_left
        chant_index = chant_index - 1
        ; chant index will underflow to 255, set to 7
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] = DIR_RIGHT then parse_fireball_left
        goto chant_test_dirs

chant_spells_right
        chant_index = chant_index - 1
        ; chant index will underflow to 255, set to 7
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] = DIR_LEFT then parse_fireball_right
        goto chant_test_dirs

parse_fireball_up
        chant_index = chant_index - 1
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] <> DIR_UP then chant_test_dirs
        player_facing = DIR_UP : player_frame = FRAME_UP
        goto cast_fireball

parse_fireball_down
        chant_index = chant_index - 1
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] <> DIR_DOWN then chant_test_dirs
        player_frame = FRAME_DOWN
        goto cast_fireball

parse_fireball_left
        chant_index = chant_index - 1
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] <> DIR_LEFT then chant_test_dirs
        player_facing = DIR_LEFT : player_frame = FRAME_LEFT
        goto cast_fireball

parse_fireball_right
        chant_index = chant_index - 1
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] <> DIR_RIGHT then chant_test_dirs
        player_facing = DIR_RIGHT : player_frame = FRAME_RIGHT
        goto cast_fireball

chant_done
        player_exiting_chant = 1
chant_done_no_hold
        asm
        lda #0
        sta player_state        ; STATE_STAND
        sta chant_timer
        sta chant_input
        sta input_buffer_index
        sta chant_new_input
        ldx #8
clear_input_buffer
        dex
        sta input_buffer,x
        bne clear_input_buffer
end
        gosub decrease_player_mp
        goto test_joy_done

cast_fireball
        asm
        lda #1
        sta mp_change
        jsr .test_spell_cost
        bne .load_fireball_data
        jmp .test_joy_done ; allow player to try a different input
.load_fireball_data
        ldx #14
        lda #TYPE_FIREBALL
        sta object_type,x
        lda #2
        sta object_vel_cap_hi,x
        lda #0
        sta object_vel_cap_lo,x
        lda #2
        sta object_damage,x
        lda #%00010000
        sta object_flags,x
        lda player_facing
        cmp #DIR_UP
        beq cast_fireball_up
        cmp #DIR_DOWN
        beq cast_fireball_down
        cmp #DIR_LEFT
        beq cast_fireball_left
cast_fireball_right
        sta object_Xdir,x
        lda player_Xpos
        clc
        adc #14
        sta object_Xpos,x
        lda player_Ypos
        sta object_Ypos,x
        lda #1
        sta object_Xvel_hi,x
        lda #0
        sta object_Xvel_lo,x
        sta object_Yvel_hi,x
        sta object_Yvel_lo,x
        jmp .chant_done
cast_fireball_up
        sta object_Ydir,x
        lda player_Xpos
        clc
        adc #2
        sta object_Xpos,x
        lda player_Ypos
        sec
        sbc #10
        sta object_Ypos,x
        lda #0
        sta object_Xvel_hi,x
        sta object_Xvel_lo,x
        sta object_Yvel_lo,x
        lda #1
        sta object_Yvel_hi,x
        jmp .chant_done
cast_fireball_down
        sta object_Ydir,x
        lda player_Xpos
        clc
        adc #2
        sta object_Xpos,x
        lda player_Ypos
        clc
        adc #10
        sta object_Ypos,x
        lda #0
        sta object_Xvel_hi,x
        sta object_Xvel_lo,x
        sta object_Yvel_lo,x
        lda #1
        sta object_Yvel_hi,x
        jmp .chant_done
cast_fireball_left
        sta object_Xdir,x
        lda player_Xpos
        sec
        sbc #8
        sta object_Xpos,x
        lda player_Ypos
        sta object_Ypos,x
        lda #1
        sta object_Xvel_hi,x
        lda #0
        sta object_Xvel_lo,x
        sta object_Yvel_hi,x
        sta object_Yvel_lo,x
        jmp .chant_done
end

decelerate_player
        asm
        lda player_Xvel
        beq decel_pY
        pha
        sec
        sbc player_friction_hi
        sta player_Xvel_hi
        pla
        cmp player_Xvel_hi
        bcs decel_pY
        lda #0
        sta player_Xvel_lo
        sta player_Xvel_hi

decel_pY
        lda player_Yvel_hi
        beq decel_preturn
        pha
        sec
        sbc player_friction_hi
        sta player_Yvel_hi
        pla
        cmp player_Yvel_hi
        bcs decel_return
        lda #0
        sta player_Yvel_lo
        sta player_Yvel_hi

decel_preturn
        rts
end

decelerate_object
        asm
        ldx index
        lda object_friction,x
        beq decel_return
        lda object_Xvel,x
        beq decel_Y
        pha
        sec
        sbc object_friction_hi,x
        sta object_Xvel_hi,x
        pla
        cmp object_Xvel_hi,x
        bcs decel_Y
        lda #0
        sta object_Xvel_lo,x
        sta object_Xvel_hi,x

decel_Y
        lda object_Yvel_hi,x
        beq decel_return
        pha
        sec
        sbc object_friction_hi,x
        sta object_Yvel_hi,x
        pla
        cmp object_Yvel_hi,x
        bcs decel_return
        lda #0
        sta object_Yvel_lo,x
        sta object_Yvel_hi,x

decel_return
        rts
end

;==============================================================================
; SUBROUTINE: MOVE_OBJECT
;------------------------------------------------------------------------------
; Moves an object based on the non-fractional component of their velocities.
; Tests against an array of walkable tiles for current tileset before moving.
;
; All move test labels add 8 to Yposistion to allow objects to overlap
; unwalkable tiles that are above them. Objects are assumed to be 12x16
; and magic numbers are used throughout the code to improve the feel of
; player collisions with map tiles at the expense of other sprite proportions
;==============================================================================
move_object
        if debug_time then BACKGRND = $96

        ; Cap the object's velocity TODO: separate X/Y cap?
        if Xvelocity > vel_cap then Xvelocity = vel_cap
        if Yvelocity > vel_cap then Yvelocity = vel_cap

        ; Current direction(s) are determined by player input or AI logic
        if Ydirection = DIR_UP    then gosub move_test_up
        if Ydirection = DIR_DOWN  then gosub move_test_down
        if Xdirection = DIR_LEFT  then gosub move_test_left
        if Xdirection = DIR_RIGHT then gosub move_test_right
        goto move_return

move_test_up
        if flags{2} then move_up
        asm
        lda Xposition
        clc
        adc #2
        lsr
        lsr
        lsr
        sta peekX
        lda Yposition
        clc
        adc #8
        sec
        sbc Yvelocity_hi
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_1 = peekchar (current_map, peekX, peekY, 20, 14)
;        peekX = (Xposition + 8) / TILE_WIDTH
        asm
        lda Xposition
        clc
        adc #8
        lsr
        lsr
        lsr
        sta peekX
end
        move_tile_2 = peekchar (current_map, peekX, peekY, 20, 14)
        gosub test_walkable
        if !flags{4} then test_walkable_up
        if floatable then move_up
test_walkable_up
        if !walkable then Yvelocity = 0 : return
move_up
        Yposition = Yposition - Yvelocity_hi
        if Yposition > 224 then move_down
        return

move_test_down
        if flags{2} then move_down
        ;peekX = (Xposition + 2) / TILE_WIDTH
        ;peekY = ((Yposition + Yvelocity_hi) + 15) / TILE_HEIGHT
        asm
        lda Xposition
        clc
        adc #2
        lsr
        lsr
        lsr
        sta peekX
        lda Yposition
        clc
        adc #15
        clc
        adc Yvelocity_hi
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_1 = peekchar (current_map, peekX, peekY, 20, 14)
        ;peekX = (Xposition + 8) / TILE_WIDTH
        asm
        lda Xposition
        clc
        adc #8
        lsr
        lsr
        lsr
        sta peekX
end
        move_tile_2 = peekchar (current_map, peekX, peekY, 20, 14)
        gosub test_walkable
        if !flags{4} then test_walkable_down
        if floatable then move_down
test_walkable_down
        if !walkable then Yvelocity = 0 : return
move_down
        Yposition = Yposition + Yvelocity_hi
        if Yposition > 224 then move_up
        return

move_test_left
        if flags{2} then move_left
;        peekX = ((Xposition + 2) - Xvelocity_hi) / TILE_WIDTH
        ; Add 8 to Y position to allow object to overlap solid tiles above it slightly
;        peekY = (Yposition + 8) / TILE_HEIGHT
        asm
        lda Xposition
        clc
        adc #2
        sec
        sbc Xvelocity_hi
        lsr
        lsr
        lsr
        sta peekX
        lda Yposition
        clc
        adc #8
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_1 = peekchar (current_map, peekX, peekY, 20, 14)
;        peekY = (Yposition + 15) / TILE_HEIGHT
        asm
        lda Yposition
        clc
        adc #15
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_2 = peekchar (current_map, peekX, peekY, 20, 14)
        gosub test_walkable
        if !flags{4} then test_walkable_left
        if floatable then move_left
test_walkable_left
        if !walkable then Xvelocity = 0 : return
move_left
        Xposition = Xposition - Xvelocity_hi
        if Xposition > 160 then move_right
        return

move_test_right
        if flags{2} then move_right
;        peekX = ((Xposition + 9) + Xvelocity_hi) / TILE_WIDTH
        ; Add 8 to Y position to allow object to overlap solid tiles above it slightly
;        peekY = (Yposition + 8) / TILE_HEIGHT
        asm
        lda Xposition
        clc
        adc #9
        clc
        adc Xvelocity_hi
        lsr
        lsr
        lsr
        sta peekX
        lda Yposition
        clc
        adc #8
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_1 = peekchar (current_map, peekX, peekY, 20, 14)
;        peekY = (Yposition + 15) / TILE_HEIGHT
        asm
        lda Yposition
        clc
        adc #15
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_2 = peekchar (current_map, peekX, peekY, 20, 14)
        gosub test_walkable
        if !flags{4} then test_walkable_right
        if floatable then move_right
test_walkable_right
        if !walkable then Xvelocity = 0 : return
move_right
        Xposition = Xposition + Xvelocity_hi
        if Xposition > 160 then move_left
        return
        
move_return
        if debug_time then BACKGRND = bg_color
        return

test_walkable
        ; start by assuming the tile isn't walkable (fewer tests)
        asm
        lda #0
        sta walkable
        sta walkable_1
        sta walkable_2
end
        if tileset = T_FOREST then test_walkable_forest
walkable_return
        return

check_collisions
        if debug_time = 1 then BACKGRND = $95
        for index = 0 to 15
        if !object_type[index] then cc_next
        Xposition = object_Xpos[index]
        Yposition = object_Ypos[index]
        ; TODO: include all pickups in a range of type values
        if object_type[index] = TYPE_COIN then cc_pickup
        if object_type[index] = TYPE_PRISM then cc_pickup
        if object_type[index] = TYPE_FOOD then cc_pickup
        if object_type[index] = TYPE_FIREBALL then magic_collision
        if player_state <> STATE_ATTACK then cc_player_contact
        gosub sword_collision
        if !object_hp[index] then kill_object
cc_player_contact
        ; need to test torches here so the sword can still damage them
        ; but they don't knock the player back on contact
        if object_type[index] = TYPE_TORCH then cc_next
        hp_change = object_contact[index]
        gosub player_knockback
cc_next
        if debug_time = 1 then BACKGRND = bg_color
        next
cc_return
        return

cc_pickup
        if Xposition > player_Xpos && Xposition < (player_Xpos + 12) && Yposition > player_Ypos && Yposition < (player_Ypos + 16) then pickup_item
        goto cc_next

pickup_item
        if object_type[index] = TYPE_FOOD then hp_change = $10 : gosub increase_player_hp : kill_object
        if object_type[index] = TYPE_PRISM then mp_change = $10 : gosub increase_player_mp
        ; runs into kill_object

kill_object
        ; TODO: Death animation
        if object_type[index] <> TYPE_TORCH then change_to_spawner
        ; torches make their tile walkable
        gosub kill_torch
change_to_spawner
        if object_type[index] = TYPE_SLIME && animation_frame then goto split_slime
        ; switch the object's flags to its old type and its type to a spwaner
        object_flags[index] = object_type[index]
        object_type[index] = TYPE_SPAWNER
        goto cc_next

sword_collision
        if !boxcollision (sword_Xpos, sword_Ypos, sword_width, sword_height, Xposition, Yposition, 12, 16) then return
        sword_hit = 1
sword_damage
        ; TODO: Much better damage calculations
        temp_hp = object_hp[index]
        hp_change = player_damage
        gosub decrease_hp
        object_hp[index] = temp_hp
        return

magic_collision
        inline magic_collision.asm

kill_torch
        gosub get_torch_pos
        if tileset = T_FOREST then gosub torch_tile_unblock_forest
        return

player_knockback
        if player_flags{0} then return  ; player is invulnerable, bypass collision check to save cycles
        if !boxcollision (player_Xpos, player_Ypos, PLAYER_WIDTH, PLAYER_HEIGHT, Xposition, Yposition, 12, 16) then return
;        if Yposition <= player_Ypos then player_Yvel = 10.0 : player_Ydir = DIR_DOWN  : player_frame = FRAME_UP    : goto pc_damage
;        if Yposition >= player_Ypos then player_Yvel = 10.0 : player_Ydir = DIR_UP    : player_frame = FRAME_DOWN  : goto pc_damage
;        if Xposition >= player_Xpos then player_Xvel = 5.0 : player_Xdir = DIR_LEFT  : player_frame = FRAME_RIGHT : goto pc_damage
;        if Xposition <= player_Xpos then player_Xvel = 5.0 : player_Xdir = DIR_RIGHT : player_frame = FRAME_LEFT
pc_damage
        ; avoid a tail call with goto
        player_flags{0} = 1
        player_state = STATE_KNOCKBACK
        player_timer = INVULN_FRAMES
        goto damage_player_hp

; takes a torch's X & Y position and determines the map tile under it, stores in peekX & Y
get_torch_pos
        asm
        ldx index
        lda object_Xpos,x
        clc
        adc #4          ; forces X calculation onto correct map tile
        lsr
        lsr
        lsr
        sta peekX
        lda object_Ypos,x
        clc
        adc #8          ; forces Y calculation onto correct map tile
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        return

; copies player movement variables to be manipulated by movement subroutines
copy_player_props
        asm
        lda player_Xpos
        sta Xposition
        lda player_Xdir
        sta Xdirection
        lda player_Xvel_lo
        sta Xvelocity_lo
        lda player_Xvel_hi
        sta Xvelocity_hi
        lda player_Ypos
        sta Yposition
        lda player_Ydir
        sta Ydirection
        lda player_Yvel_lo
        sta Yvelocity_lo
        lda player_Yvel_hi
        sta Yvelocity_hi
        lda player_vel_cap
        sta vel_cap
        lda player_friction
        sta friction
        rts
end

; restores movement variables from subroutines back to player
restore_player_props
        asm
        lda Xposition
        sta player_Xpos
        lda Xvelocity_lo
        sta player_Xvel_lo
        lda Xvelocity_hi
        sta player_Xvel_hi
        lda Yposition
        sta player_Ypos
        lda Yvelocity_lo
        sta player_Yvel_lo
        lda Yvelocity_hi
        sta player_Yvel_hi
        rts
end

copy_object_props
        asm
        ldx index
        lda object_Xpos,x
        sta Xposition
        lda object_Xdir,x
        sta Xdirection
        lda object_Xvel_lo,x
        sta Xvelocity_lo
        lda object_Xvel_hi,x
        sta Xvelocity_hi
        lda object_Ypos,x
        sta Yposition
        lda object_Ydir,x
        sta Ydirection
        lda object_Yvel_lo,x
        sta Yvelocity_lo
        lda object_Yvel_hi,x
        sta Yvelocity_hi
        lda object_speed_lo,x
        sta move_speed_lo
        lda object_speed_hi,x
        sta move_speed_hi
        lda object_vel_cap_lo,x
        sta vel_cap_lo
        lda object_vel_cap_hi,x
        sta vel_cap_hi
        lda object_friction_lo,x
        sta friction_lo
        lda object_friction_hi,x
        sta friction_hi
        lda object_frame,x
        sta frame
        lda object_flags,x
        sta flags
        rts
end

restore_object_props
        asm
        ldx index
        lda Xposition
        sta object_Xpos,x
        lda Xvelocity_lo
        sta object_Xvel_lo,x
        lda Xvelocity_hi
        sta object_Xvel_hi,x
        lda Yposition
        sta object_Ypos,x
        lda Yvelocity_lo
        sta object_Yvel_lo,x
        lda Yvelocity_hi
        sta object_Yvel_hi,x
        lda frame
        sta object_frame,x
        lda flags
        sta object_flags,x
        lda #0
        sta flags
        rts
end

increase_player_hp
        dec player_hp = player_hp + hp_change
        if player_hp > player_max_hp then player_hp = player_max_hp
        hp_change = 0
        goto update_hp_bar


damage_player_hp
        ; TODO: This currently can't scale, only works with max HP 48...
        dec temp1 = player_hp        ; temp1 used to detect underflow
        dec player_hp = player_hp - hp_change
        if player_hp > temp1 then player_hp = 0

update_hp_bar
        dec temp1 = player_hp
        dec hp_seg_1 = player_hp
        if hp_seg_1 > temp1 then hp_seg_1 = 0
        dec temp1 = hp_seg_1
        dec hp_seg_2 = hp_seg_1 - 8
        if hp_seg_2 > temp1 then hp_seg_2 = 0
        dec temp1 = hp_seg_2
        dec hp_seg_3 = hp_seg_2 - 8
        if hp_seg_3 > temp1 then hp_seg_3 = 0
        dec temp1 = hp_seg_3
        dec hp_seg_4 = hp_seg_3 - 8
        if hp_seg_4 > temp1 then hp_seg_4 = 0
        dec temp1 = hp_seg_4
        dec hp_seg_5 = hp_seg_4 - 8
        if hp_seg_5 > temp1 then hp_seg_5 = 0
        dec temp1 = hp_seg_5
        dec hp_seg_6 = hp_seg_5 - 8
        if hp_seg_6 > temp1 then hp_seg_6 = 0
        if hp_seg_6 > 8 then hp_seg_6 = 8
        if hp_seg_5 > 8 then hp_seg_5 = 8
        if hp_seg_4 > 8 then hp_seg_4 = 8
        if hp_seg_3 > 8 then hp_seg_3 = 8
        if hp_seg_2 > 8 then hp_seg_2 = 8
        if hp_seg_1 > 8 then hp_seg_1 = 8
        return

increase_player_mp
        dec player_mp = player_mp + mp_change
        if player_mp > player_max_mp then player_mp = player_max_mp
        goto update_mp_bar

decrease_player_mp
        ; TODO: This currently can't scale, only works with max HP 48...
        dec temp1 = player_mp        ; temp1 used to detect underflow
        dec player_mp = player_mp - mp_change
        if player_mp > temp1 then player_mp = 0

update_mp_bar
        mp_change = 0
        dec temp1 = player_mp
        dec mp_seg_1 = player_mp
        if mp_seg_1 > temp1 then mp_seg_1 = 0
        dec temp1 = mp_seg_1
        dec mp_seg_2 = mp_seg_1 - 8
        if mp_seg_2 > temp1 then mp_seg_2 = 0
        dec temp1 = mp_seg_2
        dec mp_seg_3 = mp_seg_2 - 8
        if mp_seg_3 > temp1 then mp_seg_3 = 0
        dec temp1 = mp_seg_3
        dec mp_seg_4 = mp_seg_3 - 8
        if mp_seg_4 > temp1 then mp_seg_4 = 0
        dec temp1 = mp_seg_4
        dec mp_seg_5 = mp_seg_4 - 8
        if mp_seg_5 > temp1 then mp_seg_5 = 0
        dec temp1 = mp_seg_5
        dec mp_seg_6 = mp_seg_5 - 8
        if mp_seg_6 > temp1 then mp_seg_6 = 0
        if mp_seg_6 > 8 then mp_seg_6 = 8
        if mp_seg_5 > 8 then mp_seg_5 = 8
        if mp_seg_4 > 8 then mp_seg_4 = 8
        if mp_seg_3 > 8 then mp_seg_3 = 8
        if mp_seg_2 > 8 then mp_seg_2 = 8
        if mp_seg_1 > 8 then mp_seg_1 = 8
        return

test_spell_cost
        if mp_change < player_mp then return
        ; routines can test if mp_change is 0 after calling this subroutine
        mp_change = 0
        return

increase_hp
        temp_hp = temp_hp + hp_change
        return

decrease_hp
        temp_hp = temp_hp - hp_change
        return

;==============================================================================
; SUBROUTINE: FIND NEW OBJECT
;------------------------------------------------------------------------------
; Iterates through all 16 object slots and sets the index variable to a 0 slot
;==============================================================================
find_new_object
        asm
        ldx #0
        stx no_empty_slot
new_obj_loop
        lda object_type,x
        beq new_obj_found
        inx
        cpx #MAX_MAP_OBJECTS
        bne new_obj_loop
        ; no empty obj slot found, routines can test if this is non-zero
        stx no_empty_slot
        rts
new_obj_found
        stx index
        rts
end

clear_palettes
        BACKGRND = $00
        P0C1 = $00 : P0C2 = $00 : P0C3 = $00
        P1C1 = $00 : P1C2 = $00 : P1C3 = $00
        P2C1 = $00 : P2C2 = $00 : P2C3 = $00
        P3C1 = $00 : P3C2 = $00 : P3C3 = $00
        P4C1 = $00 : P4C2 = $00 : P4C3 = $00
        P5C1 = $00 : P5C2 = $00 : P5C3 = $00
        P6C1 = $00 : P6C2 = $00 : P6C3 = $00
        P7C1 = $00 : P7C2 = $00 : P7C3 = $00
        return

main
        drawscreen
        if switchreset then reboot
        if !switchselect then select_debounce = 0
        if !switchpause then pause_debounce = 0
        if !joy0fire0 && action_button = 0 then action_debounce = 0
        if !joy0fire0 && action_button = 1 then menu_debounce = 0
        if !joy0fire1 && action_button = 1 then action_debounce = 0
        if !joy0fire1 && action_button = 0 then menu_debounce = 0
        if !joy0left then left_debounce = 0
        if !joy0right then right_debounce = 0
        if !joy0up then up_debounce = 0
        if !joy0down then down_debounce = 0
        ; menu code prevents these from overflowing
        if joy0left then left_debounce = left_debounce + 1
        if joy0right then right_debounce = right_debounce + 1 
        if joy0up then up_debounce = up_debounce + 1
        if joy0down then down_debounce = down_debounce + 1
        if select_debounce then goto main_animation_timer
        if switchselect then gosub swap_action_button
main_animation_timer
        animation_timer = animation_timer + 1
        if animation_timer > ANIM_TIME then animation_timer = 0
        ; Currently only two frames of animation supported. Needs to be changed if more than 2
        animation_frame = 0
        if animation_timer > (ANIM_TIME / 2) then animation_frame = 1
        if game_state = STATE_TITLE then title_handler
        if game_state = STATE_FIELD then field_handler
        if game_state = STATE_MENU  then menu_handler
        goto main

swap_action_button
        select_debounce = 1
        ; if the player is actively using the action button, don't swap
        ; (shouldn't happen often since it's a console switch)
        if player_state >= STATE_ATTACK then return
        if action_button then action_button = 0 : return
        action_button = 1 : return

topscreenroutine
        WSYNC=1
        if game_state = STATE_MENU then set_menu_top_pal
        BACKGRND=bg_color
        if game_state = STATE_TITLE then set_title_top_pal
        return

bottomscreenroutine
        WSYNC=1
        if game_state = STATE_MENU then BACKGRND = $10 : return
        BACKGRND=$00
        if game_state = STATE_TITLE then set_title_bottom_pal
        flash_color = $00
        if player_state = STATE_CHANT && animation_timer > ANIM_TIME / 2 then flash_color = CHANT_COLOR
        BACKGRND = flash_color
        P4C1     = flash_color
        P5C1     = flash_color
        P6C1     = flash_color
        P7C1     = flash_color
        ; Johanna's hair
        if game_state = STATE_FIELD then P1C1 = HAIR_COLOR
        if player_state = STATE_CHANT && animation_timer > ANIM_TIME / 2 then P1C1 = CHANT_COLOR
        return