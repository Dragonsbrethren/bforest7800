;------------------------------------------------------------------------------
; 7800BASIC INITIALIZATION
;------------------------------------------------------------------------------
        set romsize 144k
        set pokeysupport $450
        set screenheight 224
        set doublewide on
        set collisionwrap off
        set pauseroutine off
        set trackersupport rmt
        set hssupport $0355
;        set multibutton on
;        set multibuttonpause on

        const debug_hud = 0
        const debug_time = 0

;------------------------------------------------------------------------------
; GAME STATES
;------------------------------------------------------------------------------
        const STATE_TITLE = 0
        const STATE_FIELD = 1
        const STATE_MENU  = 2
        
        const ANIM_TIME = 16
        const INVULN_FRAMES = 4

;------------------------------------------------------------------------------
; MOVEMENT CONSTANTS
;------------------------------------------------------------------------------
        const DIR_UP    = 1
        const DIR_DOWN  = 2
        const DIR_LEFT  = 3
        const DIR_RIGHT = 4

        const EXIT_NONE  = 0
        const EXIT_NORTH = 1
        const EXIT_SOUTH = 2
        const EXIT_EAST  = 3
        const EXIT_WEST  = 4

        const BUTTON_HOLD_FRAMES = 15

;------------------------------------------------------------------------------
; PLAYER DATA
;------------------------------------------------------------------------------
        const PLAYER_HEIGHT = 16
        const PLAYER_WIDTH  = 12

        const SWORD_FRAMES = 4
        const SWORD_OFFSET_DOWN  = 15
        const SWORD_OFFSET_UP    = -16
        const SWORD_OFFSET_LEFT  = -12
        const SWORD_OFFSET_RIGHT = 12
        
        const SHIELD_FRAMES = 4
        const SHIELD_OFFSET_X = 8
        const SHIELD_OFFSET_Y = 7

        const STATE_STAND       = 0
        const STATE_MOVING      = 1
        const STATE_ATTACK      = 4
        const STATE_CHANT_START = 5
        const STATE_CHANT       = 6
        const STATE_KNOCKBACK   = 2
        const STATE_HOP         = 3
        const STATE_DEATH       = 7

        const FRAME_UP    = 2
        const FRAME_DOWN  = 0
        const FRAME_LEFT  = 4
        const FRAME_RIGHT = 6
        const FRAME_ATK_D = 8
        const FRAME_ATK_U = 9
        const FRAME_ATK_L = 10
        const FRAME_ATK_R = 11
        const FRAME_CHANT = 12
        const FRAME_DEATH = 13

        const ATTACK_FRAMES = 8
        const CHANT_START_TIME = 12

;------------------------------------------------------------------------------
; SHARED PALETTES
;------------------------------------------------------------------------------
        const PAL_DKPURP = $60
        const PAL_LTPURP = $76
        const PAL_WHITE  = $0F
        const PAL_DKBRWN = $10
        const PAL_LTBRWN = $23
        const PAL_SKIN   = $3B
        const PAL_DKRED  = $30
        const PAL_LTRED  = $45
        const PAL_GOLD   = $19
        const PAL_DKBLUE = $91
        const PAL_LTBLUE = $A3
        const PAL_COPPER = $D5


        const HAIR_COLOR = PAL_DKBRWN
        const CHANT_COLOR = $60
        const BAR_NORMAL_COLOR = $76
        const BAR_FLASH_COLOR = $79

;------------------------------------------------------------------------------
; MAP DATA
;------------------------------------------------------------------------------
        const TILE_HEIGHT = 16
        const TILE_WIDTH  = 8

        const T_TITLE  = 0
        const T_FOREST = 1
        const T_CASTLE = 2
        const T_RIVER  = 3
        const T_HILLS  = 4

        const ROOMS_PER_ROW = 7
        const MAX_MAP_OBJECTS = 12
        const MAX_OBJECTS = 15

;==============================================================================
; OBJECT DATA
;==============================================================================0
        const TYPE_TORCH    =   1
        const TYPE_WOLF     =   2
        const TYPE_SLIME    =   6
        const TYPE_MSLIME   =   7
        const TYPE_RAVEN    =   8
        const TYPE_PRIEST   =   9
        const TYPE_SKELETON =  10
        const TYPE_RSLIME   =  11
        const TYPE_MRSLIME  =  12       ; Mr. Slime lol
        const TYPE_SPAWNER  = 128
        const TYPE_SKELSWORD = 129
        const TYPE_DARKSPARK = 140
        const TYPE_FIREBALL = 150
        const TYPE_BLOOD    = 196
        const TYPE_COIN     = 197
        const TYPE_PRISM    = 198
        const TYPE_FOOD     = 199
        const TYPE_ITEM1    = 200
        const TYPE_ITEM2    = 201
        const TYPE_ITEM3    = 202
        const TYPE_ITEM4    = 203
        const TYPE_ITEM5    = 204
        const TYPE_ITEM6    = 205
        const TYPE_ITEM7    = 206
        const TYPE_ITEM8    = 207
        const TYPE_ITEM9    = 208
        const TYPE_ITEM10   = 209
        const TYPE_SWORD1   = 210
        const TYPE_SWORD2   = 211
        const TYPE_SWORD3   = 212
        const TYPE_SWORD4   = 213
        const TYPE_SWORD5   = 214
        const TYPE_SWORD6   = 215
        const TYPE_SWORD7   = 216
        const TYPE_SWORD8   = 217
        const TYPE_SWORD9   = 218
        const TYPE_SWORD10  = 219
        const TYPE_SHIELD1  = 220
        const TYPE_SHIELD2  = 221
        const TYPE_SHIELD3  = 222
        const TYPE_SHIELD4  = 223
        const TYPE_SHIELD5  = 224
        const TYPE_SHIELD6  = 225
        const TYPE_SHIELD7  = 226
        const TYPE_SHIELD8  = 227
        const TYPE_SHIELD9  = 228
        const TYPE_SHIELD10 = 229
        const TYPE_ARMOR1   = 230
        const TYPE_ARMOR2   = 231
        const TYPE_ARMOR3   = 232
        const TYPE_ARMOR4   = 233
        const TYPE_ARMOR5   = 234
        const TYPE_ARMOR6   = 235
        const TYPE_ARMOR7   = 236
        const TYPE_ARMOR8   = 237
        const TYPE_ARMOR9   = 238
        const TYPE_ARMOR10  = 239
        const TYPE_CHARM1   = 240
        const TYPE_CHARM2   = 241
        const TYPE_CHARM3   = 242
        const TYPE_CHARM4   = 243
        const TYPE_CHARM5   = 244
        const TYPE_CHARM6   = 245
        const TYPE_CHARM7   = 246
        const TYPE_CHARM8   = 247
        const TYPE_CHARM9   = 248
        const TYPE_CHARM10  = 249

;------------------------------------------------------------------------------
; MENU DATA
;------------------------------------------------------------------------------
        const MENU_MAIN   = 0
        const MENU_ITEMS  = 1
        const MENU_MAGIC  = 2
        const MENU_EQUIP  = 3
        const MENU_RELICS = 4
        const MENU_PASSWORD = 5
        const MENU_GAMEOVER = 6
        const MENU_MAIN_MAX_OPTIONS = 3 ; setup menu cut (for now)
        const CHAR_SPACE = 62 ; used in plotvaluesw 0-9 + A-Z + a-z

;------------------------------------------------------------------------------
; SYSTEM VARIABLES
;------------------------------------------------------------------------------
        dim temp_hp_sign = temp1        ; tracks underflow during subtraction
        dim valueX       = temp4
        dim valueY       = temp5
        dim value_ptr_lo = temp7
        dim value_ptr_hi = temp8

        autodim init a z
        autodim byte index
        autodim byte game_state
        autodim byte pointer
        autodim byte pointer_hi
        autodim byte Xposition
        autodim byte Yposition
        autodim byte Xdestination
        autodim byte Ydestination
        autodim byte Xdirection
        autodim byte Ydirection
        autodim 8.8  Xvelocity
        autodim 8.8  Yvelocity
        autodim 8.8  move_speed
        autodim 8.8  vel_cap
        autodim 8.8  friction
        autodim byte temp_hp
        autodim byte hp_change
        autodim byte bg_color
        autodim byte animation_timer
        autodim byte retract_counter
        autodim byte action_button

;------------------------------------------------------------------------------
; PLAYER
;------------------------------------------------------------------------------
        autodim init var0 var99

        ; player is now treated as object 0, so these are just aliases
        dim player_Xpos         = object_Xpos
        dim player_Ypos         = object_Ypos
        dim player_Xvel_hi      = object_Xvel_hi
        dim player_Xvel_lo      = object_Xvel_lo
        dim player_Xvel         = player_Xvel_hi
        dim player_Yvel_hi      = object_Yvel_hi
        dim player_Yvel_lo      = object_Yvel_lo
        dim player_Yvel         = player_Yvel_hi
        dim player_vel_cap_hi   = object_vel_cap_hi
        dim player_vel_cap_lo   = object_vel_cap_lo
        dim player_vel_cap      = player_vel_cap_hi
        dim player_friction_hi  = object_friction_hi
        dim player_friction_lo  = object_friction_lo
        dim player_friction     = player_friction_hi
        dim player_Xdir         = object_Xdir
        dim player_Ydir         = object_Ydir
        dim player_facing       = object_facing
        dim player_frame        = object_frame
        dim player_state        = object_state
        dim player_flags        = object_flags
        dim player_timer        = object_timer
        dim player_dest         = object_dest
        dim player_hop_dir      = object_hop_dir
        dim player_hp           = object_hp

        autodim byte player_max_hp
        autodim byte player_mp
        autodim byte player_max_mp
        autodim byte player_level
        dim player_exp = score1
        autodim byte player_str
        autodim byte player_atk ; str + wpn atk
        autodim byte player_damage
        autodim byte player_atk_elem
        autodim byte player_def
        autodim byte player_def_elem
        autodim byte player_wisdom
        autodim 8.8  player_speed
        autodim byte player_sword
        autodim byte player_shield
        autodim byte player_armor
        autodim byte player_charm
        autodim byte player_status
        autodim byte sword_pal
        autodim byte sword_Xpos
        autodim byte sword_Ypos
        autodim byte sword_frame
        autodim byte sword_width
        autodim byte sword_height
        autodim byte shield_pal
        autodim byte shield_Xpos
        autodim byte shield_Ypos
        autodim byte shield_frame
        autodim byte hp_seg_1
        autodim byte hp_seg_2
        autodim byte hp_seg_3
        autodim byte hp_seg_4
        autodim byte hp_seg_5
        autodim byte hp_seg_6
        autodim byte mp_seg_1
        autodim byte mp_seg_2
        autodim byte mp_seg_3
        autodim byte mp_seg_4
        autodim byte mp_seg_5
        autodim byte mp_seg_6
        autodim byte mp_change
        autodim byte chant_timer
        autodim byte flash_color
        autodim byte player_exiting_chant
        autodim byte sword_hit

;------------------------------------------------------------------------------
; MISC movement vars
;------------------------------------------------------------------------------
        autodim byte mtarget
        autodim byte magic_Xpos
        autodim byte magic_Ypos
        autodim byte hop_dest
        autodim byte timer
        autodim byte hop_dir

;------------------------------------------------------------------------------
; MOVING OBJECT ARRAYS
;------------------------------------------------------------------------------
        autodim init $2200 $23FF
        autodim byte object_type 16
        autodim byte object_Xpos 16
        autodim byte object_Ypos 16
        autodim 8.8  object_Xvel 16
        autodim 8.8  object_Yvel 16
        autodim byte object_Xdir 16
        autodim byte object_Ydir 16
        autodim byte object_facing 16
        autodim byte object_frame 16
        autodim byte object_state 16
        autodim 8.8  object_speed 16
        autodim 8.8  object_vel_cap 16
        autodim 8.8  object_friction 16
        autodim byte object_hp 16
        autodim byte object_damage 16
        autodim byte object_elem_atk 16
        autodim byte object_def 16
        autodim byte object_mdef 16
        autodim byte object_elem_def 16
        autodim byte object_parent 16
        autodim byte object_flags 16
        autodim byte object_timer 16
        autodim byte object_dest 16
        autodim byte object_hop_dir 16

        autodim init $2400 $24FF
        autodim byte reload_map
        autodim byte save_objects
        autodim byte map_height
        autodim byte map_width
        autodim byte peekX
        autodim byte peekY
        autodim byte move_tile_1
        autodim byte move_tile_2
        autodim byte animation_frame
        autodim byte frame
        autodim byte flags
        autodim byte obj_index
        autodim byte drop_rate
        autodim byte no_empty_slot
        autodim byte torch_reblock
        autodim byte spawn_index
        autodim byte frame_index

        ; MENUS
        autodim byte action_debounce
        autodim byte menu_debounce
        autodim byte select_debounce
        autodim byte pause_debounce
        autodim byte left_debounce
        autodim byte right_debounce
        autodim byte up_debounce
        autodim byte down_debounce
        autodim byte menu
        autodim byte menu_change
        autodim byte menu_selection
        autodim byte prev_menu_selection
        autodim byte menu_max
        autodim byte menu_columns
        autodim byte menu_rows
        autodim byte menu_cursor_X
        autodim byte menu_cursor_Y
        autodim byte m_palette
        autodim byte m_spriteX
        autodim byte m_spriteY
        autodim byte m_textX
        autodim byte m_textY
        autodim byte m_inv_index
        autodim byte m_inv_scroll
        autodim byte m_inv_slot
        autodim byte m_sword_pal1
        autodim byte m_sword_pal2
        autodim byte m_shield_pal1
        autodim byte m_shield_pal2
        autodim byte m_armor_pal1
        autodim byte m_armor_pal2
        autodim byte m_charm_pal1
        autodim byte m_charm_pal2
        autodim byte m_inv0_pal1
        autodim byte m_inv1_pal1
        autodim byte m_inv2_pal1
        autodim byte m_inv3_pal1
        autodim byte m_inv0_pal2
        autodim byte m_inv1_pal2
        autodim byte m_inv2_pal2
        autodim byte m_inv3_pal2
        autodim byte equip_inv_col
        autodim byte equip_inv_sel
        autodim byte equip_inv_X
        autodim byte equip_inv_Y
        autodim byte item_name
        autodim byte using_item
        autodim byte m_desc

        ; ROOM HEADER
        autodim byte first_load
        autodim byte room
        autodim byte tileset
        autodim byte exit_dir
        autodim byte music
        autodim byte walkable
        autodim byte ledge
        autodim byte floatable
        autodim byte walkable_1
        autodim byte ledge_1
        autodim byte floatable_1
        autodim byte walkable_2
        autodim byte ledge_2
        autodim byte floatable_2
        autodim byte walk_test
        autodim byte walk_index
        autodim byte room_index
        autodim byte save_room_index
        autodim byte in_save_room
        autodim byte ledge_dir
        autodim byte window_zone

        autodim init $2500 $25FF
        const INPUT_BUFFER_MAX = 7      ; array starts at 0
        autodim byte input_buffer 8
        autodim byte input_buffer_index
        autodim byte chant_index
        autodim byte chant_input
        ; possible to start a chant on index 0 so need another variable        
        autodim byte chant_new_input
        autodim byte m_item_bits_1
        autodim byte m_item_bits_2
        autodim byte m_spell_bits_1
        autodim byte m_spell_bits_2
        autodim byte m_sword_bits_1
        autodim byte m_sword_bits_2
        autodim byte m_shield_bits_1
        autodim byte m_shield_bits_2
        autodim byte m_armor_bits_1
        autodim byte m_armor_bits_2
        autodim byte m_charm_bits_1
        autodim byte m_charm_bits_2
        autodim byte m_item_inv   11
        autodim byte m_sword_inv  11
        autodim byte m_shield_inv 11
        autodim byte m_armor_inv  11
        autodim byte m_charm_inv  11
        autodim byte m_inv_item_0
        autodim byte m_inv_item_1
        autodim byte m_inv_item_2
        autodim byte m_inv_item_3
        autodim byte m_inv_item_4
        autodim byte m_sword_max

        autodim byte menu_map_room 98
        autodim byte menu_map_index
        autodim byte menu_map_index_2
        autodim byte menu_map_Xpos
        autodim byte menu_map_Ypos

        ; PASSWORD ARRAY
        dim pw_index0  = pw_tileset
        autodim byte pw_tileset
        autodim byte pw_saveroom
        autodim byte pw_sword
        autodim byte pw_shield
        autodim byte pw_armor
        autodim byte pw_charm
        dim pw_index6  = pw_inventory_1
        autodim byte pw_inventory_1
        autodim byte pw_inventory_2
        autodim byte pw_spells_1
        autodim byte pw_spells_2
        autodim byte pw_swords_1
        autodim byte pw_swords_2
        dim pw_index12 = pw_shields_1
        autodim byte pw_shields_1
        autodim byte pw_shields_2
        autodim byte pw_armor_1
        autodim byte pw_armor_2
        autodim byte pw_charms_1
        autodim byte pw_charms_2
        dim pw_index18 = pw_relics_1
        autodim byte pw_relics_1
        autodim byte pw_relics_2
        autodim byte pw_index20
        autodim byte pw_index21
        autodim byte pw_index22
        autodim byte pw_checksum
        autodim byte pw_index
        autodim byte pw_buffer 24
        autodim byte pw_error
        autodim byte pw_success
        autodim byte fade_count


        dim current_map = $2600

        dim RMTRAM = $2720

;==============================================================================
; BANK 1
;------------------------------------------------------------------------------
; 7800basic initialization, title sequence code and graphics
;------------------------------------------------------------------------------
;==============================================================================
        incgraphic gfx/title/font.png  320B 2 0 1 0 0
        incgraphic gfx/title/logo.png  320B 1 2 3 1 4
        incgraphic gfx/title/trees.png 320B 0 3 0 0 0
        incgraphic gfx/title/moon.png  320B 0 3 2 2 4
        incgraphic gfx/menu/menu_cursor0.png 320A 0 1
        incmapfile tiled/title_blackforest.tmx
title_init
        game_state = STATE_TITLE
        gosub clear_palettes
        menu_cursor_X = 60
        asm
        lda #1
        sta menu_columns
        sta menu_max
        sta action_debounce
        sta menu_debounce
end
        displaymode 320B
        bg_color = $71
        clearscreen
        characterset logo
        plotmapfile tiled/title_blackforest.tmx title_blackforest 0 0 40 10
        alphachars '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz @-'
        characterset font
        plotchars '@2024-2025 CHRIS WIESE' 0 36 12
        savescreen

title_handler
        restorescreen
        adjustvisible 0 4
        ; menu_change is set by title_flash, need to get 1 button input from player before drawing menu
        if !menu_change then title_flash

title_controls
        if !action_debounce && joy0fire0 && action_button = 0 then title_selection
        if !action_debounce && joy0fire1 && action_button = 1 then title_selection
        if up_debounce >= MENU_TAP_FRAMES then gosub menu_selection_up bank3
        if !up_debounce && joy0up then gosub menu_selection_up bank3
        if down_debounce >= MENU_TAP_FRAMES then gosub menu_selection_down bank3
        if !down_debounce && joy0down then gosub menu_selection_down bank3
        if menu_selection then menu_cursor_Y = 176 : goto title_menu
        menu_cursor_Y = 160

title_menu
        plotsprite menu_cursor0 0 menu_cursor_X menu_cursor_Y
        plotchars 'New Game' 0 64 10
        plotchars 'Continue' 0 64 11        
        goto main

title_selection
        if menu_selection then title_continue
        goto title_new_game

title_flash
        ; Whether the player pushes 1 or 2 determine's the game's default action button
        if joy0fire0 then action_button = 0 : menu_change = 1 : action_debounce = 1
        if joy0fire1 then action_button = 1 : menu_change = 1 : action_debounce = 1
        if animation_frame then plotchars 'Push Button 1 or 2' 0 44 10 17
        goto main

title_continue
        pw_index = 0
        ; password starts as all dashes
        for index = 0 to 23
        pw_index0[index] = 81
        next
        loadmemory pw_index0-pw_index
        game_state = STATE_MENU
        menu = MENU_PASSWORD
        asm
        lda #1
        sta action_debounce
        sta menu_debounce
        sta pause_debounce
end
        goto menu_init bank3

title_new_game
        tileset = T_CASTLE
        player_sword = 1
        player_shield = 0
        player_armor = 1
        player_charm = 0
        m_item_bits_1 = %00000000
        m_item_bits_2 = %00000000
        m_sword_bits_1 = %00011111
        m_sword_bits_2 = %00011111
        m_shield_bits_1 = %00010000
        m_shield_bits_2 = 0
        m_armor_bits_1 = %00011101
        m_armor_bits_2 = 0
        m_charm_bits_1 = 0
        m_charm_bits_2 = 0
        for index = 0 to 97
        menu_map_room[index] = 0
        next

init_field
        ; code shared by new game and continue options
        game_state = STATE_FIELD
        reload_map = 1
        first_load = 1
        player_state = STATE_STAND
        player_speed = 1.0
        player_friction = player_speed
        player_vel_cap = 5.0
        dec player_max_hp = $48
        dec player_hp = $48
        dec player_mp = $48
        dec player_max_mp = $48
        dec hp_seg_1 = 8
        dec hp_seg_2 = 8
        dec hp_seg_3 = 8
        dec hp_seg_4 = 8
        dec hp_seg_5 = 8
        dec hp_seg_6 = 8
        dec mp_seg_1 = 8
        dec mp_seg_2 = 8
        dec mp_seg_3 = 8
        dec mp_seg_4 = 8
        dec mp_seg_5 = 8
        dec mp_seg_6 = 8
        sword_pal = 2
        shield_pal = 2
        gosub encode_password
        gosub update_player_stats bank3
        goto main

set_title_top_pal
        BACKGRND = bg_color
        P0C1 = $80 : P0C2 = $0F : P0C3 = $90
        P4C1 = $80 : P4C2 = $0F : P4C3 = $08
        return

set_title_bottom_pal
        P0C1 = $80 : P0C2 = $0F : P0C3 = $90
        P4C1 = $00 : P4C2 = $02 : P4C3 = $03
        return

kill_player
        player_frame = FRAME_DEATH
        if !fade_count then fade_count = 60
        goto cc_next

death_fade
        ; TODO: Slowly fade the palette to black here
        fade_count = fade_count - 1
        if !fade_count then password_display
        goto player_handler_done

save_room_handler
        gosub encode_password
password_display
        menu = MENU_GAMEOVER
        menu_debounce = 1
        pause_debounce = 1
        action_debounce = 1
        goto menu_init bank3

encode_password
        asm
        lda tileset
        sta pw_tileset
        lda save_room_index
        sta pw_saveroom
        lda player_sword
        sta pw_sword
        lda player_shield
        sta pw_shield
        lda player_armor
        sta pw_armor
        lda player_charm
        sta pw_charm
        lda m_item_bits_1
        sta pw_inventory_1
        lda m_item_bits_2
        sta pw_inventory_2
        lda #0
        sta pw_spells_1
        sta pw_spells_2
        lda m_sword_bits_1
        sta pw_swords_1
        lda m_sword_bits_2
        sta pw_swords_2
        lda m_shield_bits_1
        sta pw_shields_1
        lda m_shield_bits_2
        sta pw_shields_2
        lda m_armor_bits_1
        sta pw_armor_1
        lda m_armor_bits_2
        sta pw_armor_2
        lda m_charm_bits_1
        sta pw_charms_1
        lda m_charm_bits_2
        sta pw_charms_2
        lda #0
        sta pw_relics_1
        sta pw_relics_2
        sta pw_index20
        sta pw_index21
        sta pw_index22
        jsr .calculate_pw_checksum
        sta pw_checksum

encode_font_offset
        lda pw_index0,x
        clc
        adc #PW_0
        sta pw_index0,x
        inx
        cpx #24
        bne encode_font_offset
        lda #24
        sta pw_index
end
        savememory pw_index0-pw_index
        return

decode_password
        asm
        ldx #0
decode_font_offset
        lda pw_index0,x
        sec
        sbc #PW_0
        sta pw_index0,x
        inx
        cpx #24
        bne decode_font_offset

        jsr .calculate_pw_checksum
        cmp pw_checksum
        beq write_to_gamestate
        jsr encode_font_offset         ; reencode the font for display if the password fails
        lda #$E0
        sta pw_error
        rts

write_to_gamestate
        lda pw_tileset
        sta tileset
        lda pw_saveroom
        sta save_room_index
        ; TODO: handle determining map screen to start on from save room index
        lda pw_sword
        sta player_sword
        lda pw_shield
        sta player_shield
        lda pw_armor
        sta player_armor
        lda pw_charm
        sta player_charm
        lda pw_inventory_1
        sta m_item_bits_1
        lda pw_inventory_2
        sta m_item_bits_2
        lda pw_swords_1
        sta m_sword_bits_1
        lda pw_swords_2
        sta m_sword_bits_2
        lda pw_shields_1
        sta m_shield_bits_1
        lda pw_shields_2
        sta m_shield_bits_2
        lda pw_armor_1
        sta m_armor_bits_1
        lda pw_armor_2
        sta m_armor_bits_2
        lda pw_charms_1
        sta m_charm_bits_1
        lda pw_charms_2
        sta m_charm_bits_2
        lda #1
        sta pw_success
        rts
end

calculate_pw_checksum
        asm
        lda pw_tileset
        clc
        adc pw_saveroom
        adc pw_sword
        adc pw_shield
        adc pw_armor
        adc pw_charm
        adc pw_inventory_1
        adc pw_inventory_2
        adc pw_spells_1
        adc pw_spells_2
        adc pw_swords_1
        adc pw_swords_2
        adc pw_shields_1
        adc pw_shields_2
        adc pw_armor_1
        adc pw_armor_2
        adc pw_charms_1
        adc pw_charms_2
        adc pw_relics_1
        adc pw_relics_2
        adc pw_index20
        adc pw_index21
        adc pw_index22
        and #$1F
        rts
end

password_to_buffer
        asm
        ldx #24
pw_buffer_loop
        lda pw_index0,x
        sta pw_buffer,x
        dex
        bne pw_buffer_loop
        lda pw_index0
        sta pw_buffer
        rts
end

buffer_to_password
        asm
        ldx #24
buffer_pw_loop
        lda pw_buffer,x
        sta pw_index0,x
        dex
        bne buffer_pw_loop
        lda pw_buffer
        sta pw_index0
        rts
end

plot_gameover
        menu = MENU_GAMEOVER
        if !menu_change then goto gameover_updater
        clearscreen
        gosub disable_double_wide_mode
        gosub plot_menu_border
        menu_change = 0
        menu_selection = 0
        menu_columns = 1
        characterset menu_font
        alphachars '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz -!&[$#]{}(_*)'
        if in_save_room then plotchars 'Password' 0 64 2 singlewide : goto gameover_options
        plotchars 'GAME  OVER' 0 60 2 singlewide
gameover_options
        plotchars 'Continue' 0 60 9 singlewide
        plotchars 'Quit' 0 60 10 singlewide
        savescreen

gameover_updater
        restorescreen
        gosub plot_password
        plotsprite menu_cursor0 0 menu_cursor_X menu_cursor_Y

gameover_controls
        if !action_debounce && joy0fire0 && action_button = 0 then gameover_input
        if !action_debounce && joy0fire1 && action_button = 1 then gameover_input

        if up_debounce >= MENU_TAP_FRAMES then gosub menu_selection_up
        if !up_debounce && joy0up then gosub menu_selection_up
        if down_debounce >= MENU_TAP_FRAMES then gosub menu_selection_down
        if !down_debounce && joy0down then gosub menu_selection_down
        if menu_selection > 1 then menu_selection = 0
        menu_cursor_X = 56
        if !menu_selection then menu_cursor_Y = 144 : goto main
        menu_cursor_Y = 160
        goto main

gameover_input
        if menu_selection then menu_selection = 0 : menu_change = 1 : goto title_init
        gosub decode_password
        in_save_room = 0
        goto title_continue

plot_relics_menu
plot_password_menu
        ; turn on Kangaroo mode so "Password Error prints over saved screen"
        sCTRL{2} = 1 : CTRL = sCTRL
        menu = MENU_PASSWORD
        if !menu_change then goto password_menu_updater
        clearscreen
        gosub disable_double_wide_mode
        gosub calc_inv_array
        ; gosub encode_password
        gosub password_to_buffer
        gosub plot_menu_border
        menu_change = 0
        menu_selection = 0
        menu_max = 40
        menu_columns = 13
        plotchars 'Enter Password' 0 52 2 singlewide
        plotchars '0 1 2 3 4 5 6 7 8 9 Erase' 0 28 9 singlewide
        plotchars 'A B C D E F G H I J K L M' 0 28 10 singlewide
        plotchars 'N O P Q R S T U V W X Y Z' 0 28 11 singlewide
        plotchars 'Confirm  Exit'             0 84 12 singlewide
        savescreen

password_menu_updater
        restorescreen
        gosub plot_password
        plotsprite menu_cursor0 0 menu_cursor_X menu_cursor_Y
        ; $E0 is a checksum error code set by the decode subroutine
        if !pw_error then goto password_menu_controls
        plotchars 'Password Error' 0 52 2 singlewide
        ; used to detect if cursor is moved after displaying error
        prev_menu_selection = menu_selection

password_menu_controls
        if !menu_debounce && joy0fire0 && action_button = 1 then pw_backspace
        if !menu_debounce && joy0fire1 && action_button = 0 then pw_backspace
        ; Pause is a quickie way of getting back to the action
        if !pause_debounce && switchpause then gosub buffer_to_password : goto close_menu
        if !action_debounce && joy0fire0 && action_button = 0 then encode_sel_to_pw
        if !action_debounce && joy0fire1 && action_button = 1 then encode_sel_to_pw
        gosub menu_dirs

password_menu_dirs_done
        ; set by decode password subroutine
        if pw_success = 1 then goto init_field
        ; clear the Password Error message if the cursor was moved
        if menu_selection <> prev_menu_selection then pw_error = 0
        ; Handles the Erase option spanning multiple columns
        if menu_selection > 39 then menu_selection = 40
        if menu_selection = 11 then menu_selection = 10
        if menu_selection = 12 then menu_selection = 10
        if menu_selection < 13 then menu_cursor_X = 24 + (menu_selection * 8) : goto password_menu_cursor_Y
        if menu_selection < 26 then menu_cursor_X = 24 + ((menu_selection - 13) * 8) : goto password_menu_cursor_Y
        menu_cursor_X = 24 + ((menu_selection - 26) * 8)
password_menu_cursor_Y
        menu_cursor_Y = 144
        if menu_selection > 12 then menu_cursor_Y = 160
        if menu_selection > 25 then menu_cursor_Y = 176
        if menu_selection = 39 then menu_cursor_X = 80 : menu_cursor_Y = MENU_EQUIP_EXIT_Y
        if menu_selection = 40 then menu_cursor_X = 116 : menu_cursor_Y = MENU_EQUIP_EXIT_Y
        goto main


        ; these are offsets added to the menu selection to get proper font characters
        const PW_0 = 18
        const PW_A = 15
encode_sel_to_pw
        pw_error = 0
        action_debounce = 1
        temp1 = PW_0
        if menu_selection > 10 then temp1 = PW_A        ; "Erase" spans 3 colums, font offset needs to change
        if menu_selection = 10 then pw_backspace                        ; Erase
        if menu_selection = 39 then gosub decode_password : goto main   ; Confirm
        if menu_selection = 40 then menu_selection = 0 : menu_change = 1 : goto title_init                             ; Exit
        pw_index0[pw_index] = menu_selection + temp1
        pw_index = pw_index + 1
        if pw_index > 24 then pw_index = 24
        goto password_menu_dirs_done

pw_backspace
        pw_error = 0
        menu_debounce = 1
        if pw_index > 24 then pw_index = 24
        pw_index = pw_index - 1
        pw_index0[pw_index] = 81
        if pw_index > 23 then pw_index = 0
        goto main

plot_password
        plotchars pw_index0 0 52 3 6 singlewide
        plotchars pw_index6 0 84 3 6 singlewide
        plotchars pw_index12 0 52 4 6 singlewide
        plotchars pw_index18 0 84 4 6 singlewide
        return

        data inv_bits
        %00000001, %00000010, %00000100, %00001000, %00010000
end

prep_inv_bits
        if temp1 > 5 then prep_bits_2
        temp1 = inv_bits[temp1]
        temp2 = 0
        return
prep_bits_2
        temp1 = temp1 - 5
        temp2 = inv_bits[temp1]
        temp1 = 0
        return

pickup_item
        temp1 = temp1 - 200
        gosub prep_inv_bits
add_item
        m_item_bits_1 = m_item_bits_1 | temp1
        m_item_bits_2 = m_item_bits_2 | temp2
        goto kill_object

pickup_sword
        temp1 = temp1 - 210
        gosub prep_inv_bits
add_sword
        m_sword_bits_1 = m_sword_bits_1 | temp1
        m_sword_bits_2 = m_sword_bits_2 | temp2
        goto kill_object

pickup_shield
        temp1 = temp1 - 220
        gosub prep_inv_bits
add_shield
        m_shield_bits_1 = m_shield_bits_1 | temp1
        m_shield_bits_2 = m_shield_bits_2 | temp2
        goto kill_object

pickup_armor
        temp1 = temp1 - 230
        gosub prep_inv_bits
add_armor
        m_armor_bits_1 = m_armor_bits_1 | temp1
        m_armor_bits_2 = m_armor_bits_2 | temp2
        goto kill_object

pickup_charm
        temp1 = temp1 - 240
        gosub prep_inv_bits
add_charm
        m_charm_bits_1 = m_charm_bits_1 | temp1
        m_charm_bits_2 = m_charm_bits_2 | temp2
        goto kill_object

check_item_bits
        if object_type[index] = TYPE_ITEM1 && m_item_bits_1{0} then object_type[index] = TYPE_FOOD
        if object_type[index] = TYPE_ITEM2 && m_item_bits_1{1} then object_type[index] = TYPE_FOOD
        if object_type[index] = TYPE_ITEM3 && m_item_bits_1{2} then object_type[index] = TYPE_FOOD
        if object_type[index] = TYPE_ITEM4 && m_item_bits_1{3} then object_type[index] = TYPE_PRISM
        if object_type[index] = TYPE_ITEM5 && m_item_bits_1{4} then object_type[index] = TYPE_PRISM
        if object_type[index] = TYPE_ITEM6 && m_item_bits_2{0} then object_type[index] = TYPE_FOOD
        if object_type[index] = TYPE_ITEM7 && m_item_bits_2{1} then object_type[index] = TYPE_FOOD
        if object_type[index] = TYPE_ITEM8 && m_item_bits_2{2} then object_type[index] = TYPE_FOOD
        if object_type[index] = TYPE_ITEM9 && m_item_bits_2{3} then object_type[index] = TYPE_FOOD
        if object_type[index] = TYPE_ITEM10 && m_item_bits_2{4} then object_type[index] = TYPE_FOOD

check_sword_bits
        if object_type[index] = TYPE_SWORD1 && m_sword_bits_1{0} then object_type[index] = 0
        if object_type[index] = TYPE_SWORD2 && m_sword_bits_1{1} then object_type[index] = 0
        if object_type[index] = TYPE_SWORD3 && m_sword_bits_1{2} then object_type[index] = 0 
        if object_type[index] = TYPE_SWORD4 && m_sword_bits_1{3} then object_type[index] = 0 
        if object_type[index] = TYPE_SWORD5 && m_sword_bits_1{4} then object_type[index] = 0 
        if object_type[index] = TYPE_SWORD6 && m_sword_bits_2{0} then object_type[index] = 0 
        if object_type[index] = TYPE_SWORD7 && m_sword_bits_2{1} then object_type[index] = 0 
        if object_type[index] = TYPE_SWORD8 && m_sword_bits_2{2} then object_type[index] = 0 
        if object_type[index] = TYPE_SWORD9 && m_sword_bits_2{3} then object_type[index] = 0 
        if object_type[index] = TYPE_SWORD10 && m_sword_bits_2{4} then object_type[index] = 0 
        goto object_done

check_shield_bits
        if object_type[index] = TYPE_SHIELD1 && m_shield_bits_1{0} then object_type[index] = 0
        if object_type[index] = TYPE_SHIELD2 && m_shield_bits_1{1} then object_type[index] = 0
        if object_type[index] = TYPE_SHIELD3 && m_shield_bits_1{2} then object_type[index] = 0 
        if object_type[index] = TYPE_SHIELD4 && m_shield_bits_1{3} then object_type[index] = 0 
        if object_type[index] = TYPE_SHIELD5 && m_shield_bits_1{4} then object_type[index] = 0 
        if object_type[index] = TYPE_SHIELD6 && m_shield_bits_2{0} then object_type[index] = 0 
        if object_type[index] = TYPE_SHIELD7 && m_shield_bits_2{1} then object_type[index] = 0 
        if object_type[index] = TYPE_SHIELD8 && m_shield_bits_2{2} then object_type[index] = 0 
        if object_type[index] = TYPE_SHIELD9 && m_shield_bits_2{3} then object_type[index] = 0 
        if object_type[index] = TYPE_SHIELD10 && m_shield_bits_2{4} then object_type[index] = 0 
        goto object_done

check_armor_bits
        if object_type[index] = TYPE_ARMOR1 && m_armor_bits_1{0} then object_type[index] = 0
        if object_type[index] = TYPE_ARMOR2 && m_armor_bits_1{1} then object_type[index] = 0
        if object_type[index] = TYPE_ARMOR3 && m_armor_bits_1{2} then object_type[index] = 0 
        if object_type[index] = TYPE_ARMOR4 && m_armor_bits_1{3} then object_type[index] = 0 
        if object_type[index] = TYPE_ARMOR5 && m_armor_bits_1{4} then object_type[index] = 0 
        if object_type[index] = TYPE_ARMOR6 && m_armor_bits_2{0} then object_type[index] = 0 
        if object_type[index] = TYPE_ARMOR7 && m_armor_bits_2{1} then object_type[index] = 0 
        if object_type[index] = TYPE_ARMOR8 && m_armor_bits_2{2} then object_type[index] = 0 
        if object_type[index] = TYPE_ARMOR9 && m_armor_bits_2{3} then object_type[index] = 0 
        if object_type[index] = TYPE_ARMOR10 && m_armor_bits_2{4} then object_type[index] = 0 
        goto object_done

check_charm_bits
        if object_type[index] = TYPE_CHARM1 && m_charm_bits_1{0} then object_type[index] = 0
        if object_type[index] = TYPE_CHARM2 && m_charm_bits_1{1} then object_type[index] = 0
        if object_type[index] = TYPE_CHARM3 && m_charm_bits_1{2} then object_type[index] = 0 
        if object_type[index] = TYPE_CHARM4 && m_charm_bits_1{3} then object_type[index] = 0 
        if object_type[index] = TYPE_CHARM5 && m_charm_bits_1{4} then object_type[index] = 0 
        if object_type[index] = TYPE_CHARM6 && m_charm_bits_2{0} then object_type[index] = 0 
        if object_type[index] = TYPE_CHARM7 && m_charm_bits_2{1} then object_type[index] = 0 
        if object_type[index] = TYPE_CHARM8 && m_charm_bits_2{2} then object_type[index] = 0 
        if object_type[index] = TYPE_CHARM9 && m_charm_bits_2{3} then object_type[index] = 0 
        if object_type[index] = TYPE_CHARM10 && m_charm_bits_2{4} then object_type[index] = 0 
        goto object_done

magic_collision
        inline magic_collision.asm

        const FIREBALL_SPEED_HI = 2
        const FIREBALL_SPEED_LO = 0
        const FIREBALL_DAMAGE = 2
        const FIREBALL_MP_COST = 8

cast_fireball
        asm
        lda #FIREBALL_MP_COST
        sta mp_change
        jsr .test_spell_cost
        bne .load_fireball_index
        jmp .test_joy_done ; allow player to try a different input
.load_fireball_index
        ldx #14
        ldy #0  ; player index
load_fireball_data
        lda #TYPE_FIREBALL
        sta object_type,x
        lda #FIREBALL_SPEED_HI
        sta object_vel_cap_hi,x
        sta object_speed_hi,x
        lda #FIREBALL_SPEED_LO
        sta object_vel_cap_lo,x
        sta object_speed_lo,x
        lda #FIREBALL_DAMAGE
        sta object_damage,x
        lda #%00010000
        sta object_flags,x
set_cast_direction
        lda player_facing,y
        cmp #DIR_UP
        beq cast_fireball_up
        cmp #DIR_DOWN
        beq cast_fireball_down
        cmp #DIR_LEFT
        bne cast_fireball_right
        jmp cast_fireball_left
cast_fireball_right
        sta object_Xdir,x
        lda player_Xpos,y
        clc
        adc #14
        sta object_Xpos,x
        lda player_Ypos,y
        sta object_Ypos,x
        lda object_speed_hi,x
        sta object_Xvel_hi,x
        lda object_speed_lo,x
        sta object_Xvel_lo,x
        lda #0
        sta object_Yvel_hi,x
        sta object_Yvel_lo,x
        rts
cast_fireball_up
        sta object_Ydir,x
        lda player_Xpos,y
        clc
        adc #2
        sta object_Xpos,x
        lda player_Ypos,y
        sec
        sbc #10
        sta object_Ypos,x
        lda #0
        sta object_Xvel_hi,x
        sta object_Xvel_lo,x
        lda object_speed_lo,x
        sta object_Yvel_lo,x
        lda object_speed_hi,x
        sta object_Yvel_hi,x
        rts
cast_fireball_down
        sta object_Ydir,x
        lda player_Xpos,y
        clc
        adc #2
        sta object_Xpos,x
        lda player_Ypos,y
        clc
        adc #10
        sta object_Ypos,x
        lda #0
        sta object_Xvel_hi,x
        sta object_Xvel_lo,x
        lda object_speed_lo,x
        sta object_Yvel_lo,x
        lda object_speed_hi,x
        sta object_Yvel_hi,x
        rts
cast_fireball_left
        sta object_Xdir,x
        lda player_Xpos,y
        sec
        sbc #8
        sta object_Xpos,x
        lda player_Ypos,y
        sta object_Ypos,x
        lda object_speed_hi,x
        sta object_Xvel_hi,x
        lda object_speed_lo,x
        sta object_Xvel_lo,x
        lda #0
        sta object_Yvel_hi,x
        sta object_Yvel_lo,x
        rts
end

main
        drawscreen
        if switchreset then reboot
        if !switchselect then select_debounce = 0
        if !switchpause then pause_debounce = 0
        if !joy0fire0 && action_button = 0 then action_debounce = 0
        if !joy0fire0 && action_button = 1 then menu_debounce = 0
        if !joy0fire1 && action_button = 1 then action_debounce = 0
        if !joy0fire1 && action_button = 0 then menu_debounce = 0
        if !joy0left then left_debounce = 0
        if !joy0right then right_debounce = 0
        if !joy0up then up_debounce = 0
        if !joy0down then down_debounce = 0
        ; menu code prevents these from overflowing
        if joy0left then left_debounce = left_debounce + 1
        if joy0right then right_debounce = right_debounce + 1 
        if joy0up then up_debounce = up_debounce + 1
        if joy0down then down_debounce = down_debounce + 1
        if select_debounce then goto main_animation_timer
        if switchselect then gosub swap_action_button
main_animation_timer
        animation_timer = animation_timer + 1
        if animation_timer > ANIM_TIME then animation_timer = 0
        ; Currently only two frames of animation supported. Needs to be changed if more than 2
        animation_frame = 0
        if animation_timer > (ANIM_TIME / 2) then animation_frame = 1
        if game_state = STATE_TITLE then title_handler
        if game_state = STATE_FIELD then field_handler
        if game_state = STATE_MENU  then menu_handler
        goto main

swap_action_button
        select_debounce = 1
        ; if the player is actively using the action button, don't swap
        ; (shouldn't happen often since it's a console switch)
        if player_state >= STATE_ATTACK then return
        if action_button then action_button = 0 : return
        action_button = 1 : return

topscreenroutine
        WSYNC=1
        if game_state = STATE_MENU then set_menu_top_pal
        WSYNC=1
        if tileset = T_FOREST then BACKGRND=bg_color
        if game_state = STATE_TITLE then set_title_top_pal
        return

bottomscreenroutine
        if game_state = STATE_MENU then BACKGRND = $10 : return
        BACKGRND=$00
        if game_state = STATE_TITLE then set_title_bottom_pal
        flash_color = $00
        if player_state = STATE_CHANT && animation_timer > ANIM_TIME / 2 then flash_color = CHANT_COLOR
        BACKGRND = flash_color
        if tileset = T_FOREST then forest_flash
hair_flash
        ; Johanna's hair
        if game_state = STATE_FIELD then P1C1 = HAIR_COLOR
        if player_state = STATE_CHANT && animation_timer > ANIM_TIME / 2 then P1C1 = CHANT_COLOR
        return

forest_flash
        P4C1     = flash_color
        P5C1     = flash_color
        P6C1     = flash_color
        P7C1     = flash_color
        goto hair_flash

clear_palettes
        BACKGRND = $00
        P0C1 = $00 : P0C2 = $00 : P0C3 = $00
        P1C1 = $00 : P1C2 = $00 : P1C3 = $00
        P2C1 = $00 : P2C2 = $00 : P2C3 = $00
        P3C1 = $00 : P3C2 = $00 : P3C3 = $00
        P4C1 = $00 : P4C2 = $00 : P4C3 = $00
        P5C1 = $00 : P5C2 = $00 : P5C3 = $00
        P6C1 = $00 : P6C2 = $00 : P6C3 = $00
        P7C1 = $00 : P7C2 = $00 : P7C3 = $00
        return

        data f_sword_pals
        0, 2, 1, 1, 0, 2, 2, 2, 2, 2, 2
end

        data f_shield_pals
        0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0
end

        data sfx_poof2
        $10,$10,$00 ; version, priority, frames per chunk
        $0a,$08,$04 ; first chunk of freq,channel,volume
        $12,$08,$06
        $09,$08,$08
        $11,$08,$08
        $08,$08,$0a
        $10,$08,$0a
        $07,$08,$0a
        $0F,$08,$0a
        $06,$08,$08
        $0E,$08,$06
        $05,$08,$04
        $0D,$08,$02
        $00,$00,$00
end

        data sfx_strum
        $10,$10,$00 ; version, priority, frames per chunk
        $0c,$0c,$09 ; first chunk of freq,channel,volume
        $0c,$0c,$0f
        $0c,$0c,$0f
        $0c,$0c,$0f
        $0c,$0c,$0f
        $1e,$04,$0f
        $1e,$04,$0e
        $07,$0c,$0f
        $07,$0c,$0f
        $07,$0c,$0b
        $1e,$04,$0b
        $07,$0c,$0c
        $0c,$0c,$09
        $07,$0c,$07
        $07,$0c,$06
        $07,$0c,$05
        $07,$0c,$04
        $07,$0c,$04
        $07,$0c,$03
        $07,$0c,$03
        $07,$0c,$02
        $07,$0c,$02
        $07,$0c,$01
        $07,$0c,$01
        $00,$00,$00
end

        data sfx_bump
        $10,$10,$00 ; version, priority, frames per chunk
        $0b,$0f,$00 ; first chunk of freq,channel,volume
        $0c,$06,$0b
        $0a,$06,$0f
        $0b,$06,$0f
        $0a,$06,$0e
        $15,$0f,$0d
        $0e,$06,$0c
        $0d,$06,$0b
        $19,$0f,$0a
        $16,$0f,$09
        $19,$0f,$08
        $10,$06,$07
        $0d,$0c,$06
        $19,$0c,$05
        $1c,$0c,$04
        $1e,$0c,$03
        $06,$06,$02
        $06,$06,$01
        $00,$00,$00
end

        data sfx_nonobounce
        $10,$10,$01 ; version, priority, frames per chunk
        $0f,$0c,$04
        $00,$0e,$08
        $10,$0c,$08
        $02,$06,$06
        $10,$0c,$06
        $02,$06,$06
        $00,$0e,$08
        $10,$0c,$08
        $02,$06,$08
        $0f,$0c,$06
        $10,$0c,$06
        $02,$06,$06
        $10,$0c,$06
        $0f,$0c,$04
        $10,$0c,$04
        $0f,$0c,$04
        $00,$0e,$04
        $10,$0c,$04
        $10,$0c,$02
        0,0,0
end

        inline pokeysound.asm
        inline hiscore.asm

;==============================================================================
; BANK 2
;------------------------------------------------------------------------------
; Contains forest tileset graphics, maps, and enemy AI
;==============================================================================
        bank 2
        incgraphic gfx/tiles/forest_trees.png 160A 1 0 2 3 4
        incgraphic gfx/tiles/forest_rocks.png 160A 1 0 2 3 5
        incgraphic gfx/tiles/forest_water.png 160A 1 2 0 3 6
        incgraphic gfx/tiles/forest_ledges.png 160A 1 0 2 3 7
        incgraphic gfx/tiles/forest_map.png 160A 0 2 1 3
        incgraphic gfx/forest/hud.png 160A 0 3 1 2
        incgraphic gfx/forest/hud2.png 160A 0 3 1 2
        incgraphic gfx/sprites/wolf0.png 160A 0 2 3 1
        incgraphic gfx/sprites/wolf1.png 160A 0 2 3 1
        incgraphic gfx/sprites/wolf2.png 160A 0 2 3 1
        incgraphic gfx/sprites/wolf3.png 160A 0 2 3 1
        incgraphic gfx/sprites/slime0.png 160A 0 2 3 1
        incgraphic gfx/sprites/slime1.png 160A 0 2 3 1
        incgraphic gfx/sprites/minislime0.png 160A 0 2 3 1
        incgraphic gfx/sprites/minislime1.png 160A 0 2 3 1
        incgraphic gfx/sprites/raven0.png 160A 0 1 3 2
        incgraphic gfx/sprites/raven1.png 160A 0 1 3 2
        incgraphic gfx/sprites/raven2.png 160A 0 1 3 2
        incgraphic gfx/sprites/raven3.png 160A 0 1 3 2
        incgraphic gfx/sprites/raven4.png 160A 0 1 3 2
        incgraphic gfx/sprites/raven5.png 160A 0 1 3 2

        incmapfile tiled/forest.tmx
        incmapfile tiled/forest_room_1.tmx
        incmapfile tiled/forest_room_2.tmx
        incmapfile tiled/forest_room_3.tmx
        incmapfile tiled/forest_room_4.tmx
        incmapfile tiled/forest_room_5.tmx
        incmapfile tiled/forest_room_6.tmx
        incmapfile tiled/forest_room_7.tmx
        incmapfile tiled/forest_room_8.tmx
        incmapfile tiled/forest_room_9.tmx
        incmapfile tiled/forest_room_10.tmx
        incmapfile tiled/forest_room_11.tmx
        incmapfile tiled/forest_room_12.tmx

load_forest
        if !first_load then forest_pals
        first_load = 0
        if save_room_index = 1 then forest_save_1

; Initial player location on game start
        room_index = 17
        menu_map_Xpos = 78
        menu_map_Ypos = 96
        player_Xpos = 24
        player_Ypos = 60
        player_facing = DIR_DOWN
        goto forest_pals

forest_save_1
        room_index = 12
        menu_map_Xpos = 94
        menu_map_Ypos = 80
        player_Xpos = 24
        player_Ypos = 60
        player_facing = DIR_DOWN

forest_pals
        bg_color = $11                          ; brown
        P0C1 = PAL_DKPURP : P0C2 = PAL_LTPURP : P0C3 = PAL_WHITE   ; magic HUD, torches
        P1C1 = PAL_DKBRWN : P1C2 = PAL_LTBRWN : P1C3 = PAL_SKIN    ; Johanna
        P2C1 = PAL_DKRED  : P2C2 = PAL_LTRED  : P2C3 = PAL_GOLD    ; HP HUD, red equipment
        P3C1 = PAL_DKBLUE : P3C2 = PAL_LTBLUE : P3C3 = PAL_COPPER  ; blue/green equipment
        P4C1 = $00 : P4C2 = $C0 : P4C3 = $C3    ; greens used by trees and slimes
        P5C1 = $00 : P5C2 = $03 : P5C3 = $06    ; grays used by rocks and wolves
        P6C1 = $00 : P6C2 = $A1 : P6C3 = $06    ; blue and gray used by water
        P7C1 = $00 : P7C2 = $10 : P7C3 = $12    ; ledges, dark and light browns

        characterset forest_trees
        room = forest_rooms[room_index]
        if room = 1 then pointer = forest_room_1_obj_lo : pointer_hi = forest_room_1_obj_hi : goto plot_forest_room_1
        if room = 2 then pointer = forest_room_2_obj_lo : pointer_hi = forest_room_2_obj_hi : goto plot_forest_room_2
        if room = 3 then pointer = forest_room_3_obj_lo : pointer_hi = forest_room_3_obj_hi : goto plot_forest_room_3
        if room = 4 then pointer = forest_room_4_obj_lo : pointer_hi = forest_room_4_obj_hi : goto plot_forest_room_4
        if room = 5 then pointer = forest_room_5_obj_lo : pointer_hi = forest_room_5_obj_hi : goto plot_forest_room_5
        if room = 6 then pointer = forest_room_6_obj_lo : pointer_hi = forest_room_6_obj_hi : goto plot_forest_room_6
        if room = 7 then pointer = forest_room_7_obj_lo : pointer_hi = forest_room_7_obj_hi : goto plot_forest_room_7
        if room = 8 then pointer = forest_room_8_obj_lo : pointer_hi = forest_room_8_obj_hi : goto plot_forest_room_8
        if room = 9 then pointer = forest_room_9_obj_lo : pointer_hi = forest_room_9_obj_hi : goto plot_forest_room_9
        if room = 10 then pointer = forest_room_10_obj_lo : pointer_hi = forest_room_10_obj_hi : goto plot_forest_room_10
        if room = 11 then pointer = forest_room_11_obj_lo : pointer_hi = forest_room_11_obj_hi : goto plot_forest_room_11
        if room = 12 then pointer = forest_room_12_obj_lo : pointer_hi = forest_room_12_obj_hi : goto plot_forest_room_12

; room 1 is the default and uses a "crossroads" setup in case the player gets out of bounds somehow
plot_forest_room_1
        menu_map_index = room_index * 2
        menu_map_room[menu_map_index] = 2
        menu_map_index = menu_map_index + 1
        menu_map_room[menu_map_index] = 3
        plotmapfile tiled/forest_room_1.tmx forest_room_1 0 0 20 14
        memcpy current_map forest_room_1 280
        return

        data forest_room_1_obj
        $00
end


plot_forest_room_2
        menu_map_index = room_index * 2
        menu_map_room[menu_map_index] = $08
        menu_map_index = menu_map_index + 1
        menu_map_room[menu_map_index] = $09
        plotmapfile tiled/forest_room_2.tmx forest_room_2 0 0 20 14
        memcpy current_map forest_room_2 280
        return

        data forest_room_2_obj
        TYPE_TORCH, $28, $9D,  TYPE_TORCH, $6F, $9D,  TYPE_RAVEN, $1E, $28,  TYPE_SLIME, $51, $58,
        $00
end

plot_forest_room_3
        pw_success = 0
        menu_map_index = room_index * 2
        menu_map_room[menu_map_index] = $0E
        menu_map_index = menu_map_index + 1
        menu_map_room[menu_map_index] = $09
        plotmapfile tiled/forest_room_3.tmx forest_room_3 0 0 20 14
        memcpy current_map forest_room_3 280
        return

        data forest_room_3_obj
        TYPE_ITEM1, $4E, $3D,  $00
end

plot_forest_room_4
        menu_map_index = room_index * 2
        menu_map_room[menu_map_index] = 2
        menu_map_index = menu_map_index + 1
        menu_map_room[menu_map_index] = 3
        plotmapfile tiled/forest_room_4.tmx forest_room_4 0 0 20 14
        memcpy current_map forest_room_4 280
        return

        data forest_room_4_obj
        TYPE_WOLF, $54, $79,  TYPE_TORCH, $2A, $30,  $00
end

plot_forest_room_5
        menu_map_index = room_index * 2
        menu_map_room[menu_map_index] = 2
        menu_map_index = menu_map_index + 1
        menu_map_room[menu_map_index] = $0B
        plotmapfile tiled/forest_room_5.tmx forest_room_5 0 0 20 14
        memcpy current_map forest_room_5 280
        return

        data forest_room_5_obj
        TYPE_TORCH, $38, $30,  TYPE_TORCH, $68, $30,  TYPE_WOLF, $49, $63,  $00
end

plot_forest_room_6
        menu_map_index = room_index * 2
        menu_map_room[menu_map_index] = 6
        menu_map_index = menu_map_index + 1
        menu_map_room[menu_map_index] = $0D
        plotmapfile tiled/forest_room_6.tmx forest_room_6 0 0 20 14
        memcpy current_map forest_room_6 280
        return

        data forest_room_6_obj
        TYPE_WOLF, $30, $30,
        $00, $69, $20,
        $00, $39, $20,
        TYPE_TORCH, $5E, $AF,
        TYPE_TORCH, $42, $AF,
        TYPE_WOLF, $6B, $51,
        TYPE_SLIME, $40, $67,
        TYPE_SLIME, $80, $90,
        $00, $90, $88,
        $00, $40, $70,
        $00, $30, $20,
        $00, $80, $40,
        $00, $b0, $c0,
        $00, $77, $55,
        $00, $44, $22,
        $00, $33, $66,
end

plot_forest_room_7
        menu_map_index = room_index * 2
        menu_map_room[menu_map_index] = 6
        menu_map_index = menu_map_index + 1
        menu_map_room[menu_map_index] = 7
        plotmapfile tiled/forest_room_7.tmx forest_room_7 0 0 20 14
        memcpy current_map forest_room_7 280
        return

        data forest_room_7_obj
        TYPE_SLIME, $45, $7F,  TYPE_SLIME, $36, $A0,  $00
end

plot_forest_room_8
        menu_map_index = room_index * 2
        menu_map_room[menu_map_index] = $10
        menu_map_index = menu_map_index + 1
        menu_map_room[menu_map_index] = 5
        plotmapfile tiled/forest_room_8.tmx forest_room_8 0 0 20 14
        memcpy current_map forest_room_8 280
        return

        data forest_room_8_obj
        TYPE_RAVEN, $26, $28,  TYPE_RAVEN, $1E, $90,  $00
end

plot_forest_room_9
        menu_map_index = room_index * 2
        menu_map_room[menu_map_index] = 4
        menu_map_index = menu_map_index + 1
        menu_map_room[menu_map_index] = 5
        plotmapfile tiled/forest_room_9.tmx forest_room_9 0 0 20 14
        memcpy current_map forest_room_9 280
        return

        data forest_room_9_obj
        $00
end

plot_forest_room_10
        menu_map_index = room_index * 2
        menu_map_room[menu_map_index] = 2
        menu_map_index = menu_map_index + 1
        menu_map_room[menu_map_index] = 3
        plotmapfile tiled/forest_room_10.tmx forest_room_10 0 0 20 14
        memcpy current_map forest_room_10 280
        return

        data forest_room_10_obj
        $00
end

plot_forest_room_11
        if !pw_success then in_save_room = 1
        pw_success = 0
        save_room_index = 1
        menu_map_index = room_index * 2
        menu_map_room[menu_map_index] = $0C
        menu_map_index = menu_map_index + 1
        menu_map_room[menu_map_index] = $0D
        plotmapfile tiled/forest_room_11.tmx forest_room_11 0 0 20 14
        memcpy current_map forest_room_11 280
        return

        data forest_room_11_obj
        $00
end

plot_forest_room_12
        menu_map_index = room_index * 2
        menu_map_room[menu_map_index] = $08
        menu_map_index = menu_map_index + 1
        menu_map_room[menu_map_index] = $0F
        plotmapfile tiled/forest_room_12.tmx forest_room_12 0 0 20 14
        memcpy current_map forest_room_12 280
        return

        data forest_room_12_obj
        $00
end

        data forest_rooms
        00, 00,  8, 07, 06, 00, 00,
        00, 10,  9, 04, 05, 11, 00,
        00, 00, 00, 03, 02, 12, 00,
        00, 00, 00, 01, 00, 00, 00,
        00, 00, 00, 00, 00, 00, 00,
        00, 00, 00, 00, 00, 00, 00,
        00, 00, 00, 00, 00, 00, 00
end

        dmahole 0
test_walkable_forest
        asm
        ldx #0
tw_loop lda forest_walkable_tiles,x
        cmp move_tile_1
        bne twtile2
        pha
        lda #1
        sta walkable_1
        pla
twtile2 cmp move_tile_2
        bne tw_next
        lda #1
        sta walkable_2
        ; optimization: bypass the rest of the array if both tiles walkable
        ;   further optimization possible by sorting arrays by tile frequency
        lda walkable_1
        bne tw_walkable
tw_next inx
        cpx #forest_walkable_tiles_length
        bne tw_loop
        lda walkable_1
        beq tw_done
        lda walkable_2
        beq tw_done
tw_walkable
        sta walkable
        jmp .walkable_return
tw_done
        lda ledge_dir   ; if ledge_dir isn't set, bypass ledge check
        beq tf_flags
test_ledge_forest
        ldy #0
        cmp #DIR_LEFT
        bne tlright
        lda #<forest_ledge_tiles_left
        sta pointer
        lda #>forest_ledge_tiles_left
        sta pointer_hi
        jmp tl_loop
tlright cmp #DIR_RIGHT
        bne tldown
        lda #<forest_ledge_tiles_right
        sta pointer
        lda #>forest_ledge_tiles_right
        sta pointer_hi
        jmp tl_loop
tldown  cmp #DIR_DOWN
        bne tl_done
        lda #<forest_ledge_tiles_down
        sta pointer
        lda #>forest_ledge_tiles_down
        sta pointer_hi
tl_loop lda (pointer),y
        cmp move_tile_1
        bne tltile2
        pha
        lda #1
        sta ledge_1
        pla
tltile2 cmp move_tile_2
        bne tl_next
        lda #1
        sta ledge_2
        ; optimization: bypass the rest of the array if both tiles walkable
        ;   further optimization possible by sorting arrays by tile frequency
        lda ledge_1
        bne tl_ledge
tl_next iny
        cpy #forest_ledge_tiles_down_length     ; HACK - all ledge arrays currently same length...
        bne tl_loop
        lda ledge_1
        beq tl_done
        lda ledge_2
        beq tl_done
tl_ledge
        sta ledge
        lda #0
tl_done sta ledge_dir   ; A = 0 if branched from tl_next
tf_flags
        lda flags
        and #%00010000
        bne tf_done
        ; ledges are always floatable tiles
        lda ledge
        bne tf_floatable

test_floatable_forest
        ldx #0
tf_loop lda forest_floatable_tiles,x
        cmp move_tile_1
        bne tftile2
        pha
        lda #1
        sta floatable_1
        pla
tftile2 cmp move_tile_2
        bne tf_next
        lda #1
        sta floatable_2
        lda floatable_1
        bne tf_floatable
tf_next inx
        cpx #forest_floatable_tiles_length
        bne tf_loop
        lda floatable_1
        beq tf_done
        lda floatable_2
        beq tf_done
tf_floatable
        sta floatable
tf_done jmp .walkable_return
end
;        for walk_index = 0 to forest_walkable_tiles_length
;        walk_test = forest_walkable_tiles[walk_index]
;        if walk_test = move_tile_1 then walkable_1 = 1
;        if walk_test = move_tile_2 then walkable_2 = 1
;        next
;        if !walkable_1 then walkable_return
;        if !walkable_2 then walkable_return
;        walkable = 1
;        goto walkable_return

        data forest_walkable_tiles
        $00, $02, $04, $0E, $12, $14, $16, $18, $1A, $1C, $1E, $20
end

        data forest_ledge_tiles_down
        $22, $24, $26
end

        data forest_ledge_tiles_left
        $32, $34, $36
end

        data forest_ledge_tiles_right
        $2C, $2E, $30
end

        data forest_floatable_tiles
        $2A, $24, $26, $22, $2C, $2E, $30, $32, $34, $36, $38, $3A, $3C, $3E, $40, $42, $44, $46, $48
end

torch_tile_block_forest
        ; block with a floatable tile so projectiles can hit torch
        pokechar current_map peekX peekY 20 14 forest_floatable_tiles
        return

torch_tile_unblock_forest
        ; the poked tile doesn't affect visuals since those are plotted from ROM
        pokechar current_map peekX peekY 20 14 forest_walkable_tiles
        return

;==============================================================================
; WOLF AI
;------------------------------------------------------------------------------
; Wolves wait for the player to get close (WOLF_CHASE_DIST), then give chase
;==============================================================================
wolf_ai
        const WOLF_CHASE_DIST = 32
        ; Once wolves start chasing, they don't stop
        if flags{7} then wolf_chase

        ; Test player distance to wolf
        temp1 = Xposition - player_Xpos
        if temp1 < WOLF_CHASE_DIST then wolf_chase
        temp1 = Yposition - player_Ypos
        if temp1 < (WOLF_CHASE_DIST * 2) then wolf_chase

wolf_anim
        ; Wolves flip left or right facing depending on player position
        frame = 0
        if Xposition <= player_Xpos then frame = frame + 2
        if animation_frame then frame = frame + 1
        return

wolf_chase
        flags{7} = 1
        gosub get_player_pos
        gosub go_to_destination
        goto wolf_anim

obj_wolf_stats
; TODO: Make this implementation suck less
        const WOLF_SPEED_HI = 1
        const WOLF_SPEED_LO = 0
        const WOLF_HP = 2
        const WOLF_VEL_CAP_HI = 1
        const WOLF_VEL_CAP_LO = 0
        const WOLF_FRICTION_HI = 1
        const WOLF_FRICTION_LO = 0
        const WOLF_DAMAGE = 1
        const WOLF_DEF = 0
        const WOLF_MDEF = 2
        const WOLF_DROP_RATE = 64

        object_hp[obj_index] = WOLF_HP
        object_vel_cap_hi[obj_index] = WOLF_VEL_CAP_HI
        object_vel_cap_lo[obj_index] = WOLF_VEL_CAP_LO
        object_damage[obj_index] = WOLF_DAMAGE
        object_def[obj_index] = WOLF_DEF
        object_mdef[obj_index] = WOLF_MDEF
        object_friction_hi[obj_index] = WOLF_FRICTION_HI
        object_friction_lo[obj_index] = WOLF_FRICTION_LO
        object_speed_hi[obj_index] = WOLF_SPEED_HI
        object_speed_lo[obj_index] = WOLF_SPEED_LO
        object_flags[obj_index] = 0
        goto obj_next_stats

;==============================================================================
; SLIME AI
;------------------------------------------------------------------------------
; A Slime draws near!
; Command?
;==============================================================================
slime_ai
        ; slimes have no physical defense on their squished frame
        if !animation_frame then temp1 = SLIME_DEF : goto slime_chase
        ; this will allow them to split into mini-slimes
        temp1 = 0
slime_chase
        object_def[index] = temp1
        gosub get_player_pos
        gosub go_to_destination
        return

obj_slime_stats
        const SLIME_DROP_RATE = 128
        const SLIME_HP = 4
        const MSLIME_HP = SLIME_HP / 2
        const SLIME_VEL_CAP_HI = 1
        const SLIME_VEL_CAP_LO = 0
        const SLIME_DAMAGE = 4
        const SLIME_DEF = 255
        const SLIME_MDEF = 0
        const MSLIME_DEF = 0
        const MSLIME_MDEF = 0
        const SLIME_FRICTION_HI = 1
        const SLIME_FRICTION_LO = 0
        const SLIME_SPEED_HI = 0
        const SLIME_SPEED_LO = 5
        object_hp[obj_index] = SLIME_HP
        object_vel_cap_hi[obj_index] = SLIME_VEL_CAP_HI
        object_vel_cap_lo[obj_index] = SLIME_VEL_CAP_LO
        object_damage[obj_index] = SLIME_DAMAGE
        object_def[obj_index] = SLIME_DEF
        object_mdef[obj_index] = SLIME_MDEF
        object_friction_hi[obj_index] = SLIME_FRICTION_HI
        object_friction_lo[obj_index] = SLIME_FRICTION_LO
        object_speed_hi[obj_index] = SLIME_SPEED_HI
        object_speed_lo[obj_index] = SLIME_SPEED_LO
        object_flags[obj_index] = 0
        goto obj_next_stats

split_slime
        ; replace slime mobj with mini slime
        object_type[index] = TYPE_MSLIME
        object_hp[index] = MSLIME_HP
        object_def[index] = MSLIME_DEF
        temp1 = object_Xpos[index]
        temp2 = object_Ypos[index]
        ; mini slime is moved to the left of the parent slime's pos
        object_Xpos[index] = object_Xpos[index] - 1
        gosub find_new_object
        index = spawn_index
        ; if no slots, the slime just becomes a single mini slime
        if no_empty_slot then object_Xpos[index] = temp1 : cc_next
        ; initialize the new mini slime object
        object_type[index] = TYPE_MSLIME
        object_hp[index] = MSLIME_HP
        object_vel_cap_hi[index] = SLIME_VEL_CAP_HI
        object_vel_cap_lo[index] = SLIME_VEL_CAP_LO
        object_damage[index] = SLIME_DAMAGE
        object_def[index] = MSLIME_DEF
        object_mdef[index] = MSLIME_MDEF
        object_friction_hi[index] = SLIME_FRICTION_HI
        object_friction_lo[index] = SLIME_FRICTION_LO
        object_speed_hi[index] = SLIME_SPEED_HI
        object_speed_lo[index] = SLIME_SPEED_LO
        ; mini slime spawns to the right of the parent slime's pos
        object_Xpos[index] = temp1 + 9
        object_Ypos[index] = temp2
        goto cc_next

;==============================================================================
; RAVEN AI
;------------------------------------------------------------------------------
; Flies without testing walkability and perches on trees
;==============================================================================
raven_ai
        if debug_time = 1 then BACKGRND = $A0
        flags{2} = 1
        temp1 = 0
        temp2 = 0
        ; flags{7} = not perched
        if flags{7} then goto raven_change_pos
        frame = 0
        Xvelocity = 0.0
        Yvelocity = 0.0

test_dist_to_player
        if Xposition > player_Xpos then wake_raven_right
        if Xposition < player_Xpos then wake_raven_left
        if Yposition > player_Ypos then wake_raven_down
        if Yposition < player_Ypos then wake_raven_up
        ; raven and player occupy same space, handle this

wake_raven_right
        temp1 = Xposition - player_Xpos
        if temp1 < RAVEN_CHASE_DIST then raven_change_pos
        goto raven_return

wake_raven_left
        temp1 = Xposition + player_Xpos
        if temp1 < RAVEN_CHASE_DIST then raven_change_pos
        goto raven_return

wake_raven_up
        temp2 = Yposition + player_Ypos
        if temp2 < RAVEN_CHASE_DIST then raven_change_pos
        goto raven_return

wake_raven_down
        temp2 = Yposition - player_Ypos
        if temp2 < RAVEN_CHASE_DIST then raven_change_pos
        goto raven_return


raven_change_pos
        flags{7} = 1
        frame = 1
        if animation_frame then frame = frame + 2
        if !object_timer[index] then object_timer[index] = RAVEN_FLIGHT_TIME
        if flags{3} then raven_move
        if rand > 128 then gosub swoop_Y : raven_move
        gosub swoop_X
raven_move
        gosub go_to_destination

raven_perch
        temp1 = object_timer[index]
        object_timer[index] = object_timer[index] - 1
        if temp1 < object_timer[index] then object_timer[index] = 0
        if object_timer[index] > 0 then raven_return
        gosub test_walkable
        if !walkable then flags{7} = 0

raven_return
        if Xposition >= player_Xpos then frame = frame + 1
        if debug_time = 1 then BACKGRND = bg_color
        return

obj_raven_stats
        const RAVEN_CHASE_DIST = 50
        const RAVEN_FLIGHT_TIME = 10
        const RAVEN_DROP_RATE = 128
        const RAVEN_HP = 4
        const RAVEN_VEL_CAP_HI = 2
        const RAVEN_VEL_CAP_LO = 0
        const RAVEN_DAMAGE = 4
        const RAVEN_FRICTION_HI = 0
        const RAVEN_FRICTION_LO = 0
        const RAVEN_SPEED_HI = 1
        const RAVEN_SPEED_LO = 0
        const RAVEN_DEF = 0
        const RAVEN_MDEF = 0
        object_hp[obj_index] = RAVEN_HP
        object_vel_cap_hi[obj_index] = RAVEN_VEL_CAP_HI
        object_vel_cap_lo[obj_index] = RAVEN_VEL_CAP_LO
        object_damage[obj_index] = RAVEN_DAMAGE
        object_def[obj_index] = RAVEN_DEF
        object_mdef[obj_index] = RAVEN_MDEF
        object_friction_hi[obj_index] = RAVEN_FRICTION_HI
        object_friction_lo[obj_index] = RAVEN_FRICTION_LO
        object_speed_hi[obj_index] = RAVEN_SPEED_HI
        object_speed_lo[obj_index] = RAVEN_SPEED_LO
        object_flags[obj_index] = 0
        goto obj_next_stats

plot_wolf
        PLOTSPRITE wolf0 5 Xposition Yposition frame
        goto plot_next

plot_slime
        PLOTSPRITE slime0 4 Xposition Yposition animation_frame
        goto plot_next

plot_minislime
        PLOTSPRITE minislime0 4 Xposition Yposition animation_frame
        goto plot_next

plot_raven
        PLOTSPRITE raven0 5 Xposition Yposition frame
        goto plot_next


;==============================================================================
; BANK 3
;------------------------------------------------------------------------------
; Menu graphics and code
;==============================================================================
        bank 3

        incgraphic gfx/menu/menu_map.png 320A
        incgraphic gfx/menu/menu_font.png 320A 1 0
        incgraphic gfx/menu/menu_arrows.png 320A 1 0
        incgraphic gfx/menu/menu_bar0.png 320B 0 2
        incgraphic gfx/menu/menu_bar1.png 320B 0 3 2
        incgraphic gfx/menu/menu_bar2.png 320B 0 3 2
        incgraphic gfx/menu/menu_bar3.png 320B 0 3 2
        incgraphic gfx/menu/menu_bar4.png 320B 0 3 2
        incgraphic gfx/menu/menu_bar5.png 320B 0 3 2
        incgraphic gfx/menu/menu_bar6.png 320B 0 3 2
        incgraphic gfx/menu/menu_bar7.png 320B 0 3 2
        incgraphic gfx/menu/menu_bar8.png 320B 0 3 2
        incgraphic gfx/menu/menu_bar9.png 320B 0 2
        incgraphic gfx/menu/menu_pin.png 320B 0 3 2
        incgraphic gfx/menu/menu_s.png 320A
        incgraphic gfx/menu/menu_sword0.png 320B 2 0 3 1
        incgraphic gfx/menu/menu_sword1.png 320B 2 0 3 1
        incgraphic gfx/menu/menu_sword2.png 320B 2 0 3 1
        incgraphic gfx/menu/menu_sword3.png 320B 2 0 3 1
        incgraphic gfx/menu/menu_sword4.png 320B 2 0 3 1
        incgraphic gfx/menu/menu_shield0.png 320B 0 2 3 1
        incgraphic gfx/menu/menu_shield1.png 320B 0 2 3 1
        incgraphic gfx/menu/menu_shield2.png 320B 0 2 3 1
        incgraphic gfx/menu/menu_shield3.png 320B 0 2 3 1
        incgraphic gfx/menu/menu_shield4.png 320B 0 2 3 1
        incgraphic gfx/menu/menu_armor0.png 320B 0 2 3 1
        incgraphic gfx/menu/menu_armor1.png 320B 0 2 3 1
        incgraphic gfx/menu/menu_armor2.png 320B 0 2 3 1
        incgraphic gfx/menu/menu_armor3.png 320B 0 2 3 1
        incgraphic gfx/menu/menu_charm0.png 320B 0 2 1 3
        incgraphic gfx/menu/menu_charm1.png 320B 0 2 1 3
        incgraphic gfx/menu/menu_charm2.png 320B 0 2 1 3
        incgraphic gfx/menu/menu_charm3.png 320B 0 2 1 3
        incgraphic gfx/menu/menu_charm4.png 320B 0 2 1 3
        incgraphic gfx/menu/menu_potion0.png 320B 0 2 1 3
        incgraphic gfx/menu/menu_potion1.png 320B 0 2 1 3
        incgraphic gfx/menu/menu_potion2.png 320B 0 2 1 3

menu_init
        ; For some reason, removing this causes compilation to fail...
        temp1 = 0
        game_state = STATE_MENU
        clearscreen
        displaymode 320B
        adjustvisible 0 14
        drawwait
        P0C2 = $10
        P4C2 = $10
        menu_change = 1

menu_handler
        if menu = MENU_GAMEOVER then goto plot_gameover
        if menu = MENU_ITEMS then goto plot_items_menu
        if menu = MENU_MAGIC then goto plot_magic_menu
        if menu = MENU_EQUIP then goto plot_equip_menu
        if menu = MENU_RELICS then goto plot_relics_menu
        if menu = MENU_PASSWORD then goto plot_password_menu

plot_main_menu
        P0C3 = PAL_LTPURP
        P4C3 = PAL_LTRED
        if !menu_change then goto main_menu_updater
        gosub disable_double_wide_mode
        clearscreen
        gosub plot_menu_border
        characterset menu_font
        alphachars '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz -!&[$#]{}(_*)'
        gosub plot_menu_hud

        plotchars 'Items  Spells  Equipment  Relics' 0 16 12 singlewide
        gosub gen_forest_map
        savescreen
        menu_cursor_X = MENU_MAIN_ITEMS_X
        menu_cursor_Y = MENU_MAIN_ITEMS_Y
        menu_change = 0
        menu_columns = 0        ; prevent up/down from doing anything
        menu_max = 3

main_menu_updater
        restorescreen
        gosub plot_menu_bars
        plotsprite menu_cursor0 0 menu_cursor_X menu_cursor_Y
        plotsprite menu_pin 0 menu_map_Xpos menu_map_Ypos

main_menu_controls
        if !menu_debounce && joy0fire0 && action_button = 1 then close_menu
        if !menu_debounce && joy0fire1 && action_button = 0 then close_menu
        if !pause_debounce && switchpause then close_menu
        if !action_debounce && joy0fire0 && action_button = 0 then open_submenu
        if !action_debounce && joy0fire1 && action_button = 1 then open_submenu
        gosub menu_dirs
menu_main_dirs_done
        if menu_selection = 0 then menu_cursor_X = MENU_MAIN_ITEMS_X
        if menu_selection = 1 then menu_cursor_X = MENU_MAIN_MAGIC_X
        if menu_selection = 2 then menu_cursor_X = MENU_MAIN_EQUIP_X
        if menu_selection = 3 then menu_cursor_X = MENU_MAIN_RELICS_X
        goto main

open_submenu
        action_debounce = 1
        menu_change = 1
        if menu_selection = 0 then goto plot_items_menu
        if menu_selection = 1 then goto plot_magic_menu
        if menu_selection = 2 then goto plot_equip_menu
        ; if menu_selection = 3 then goto plot_relics_menu
        goto main

plot_items_menu
        sCTRL{2} = 1 : CTRL = sCTRL
        menu = MENU_ITEMS
        if !menu_change then goto items_menu_updater
        clearscreen
        gosub plot_menu_border
        menu_change = 0
        menu_columns = 2
        menu_max = 9    ; bit of a hack for the exit option
        gosub plot_menu_hud
        plotchars '------------------------------------' 0 8 3 singlewide
        plotchars 'Exit' 0 128 12 singlewide
        savescreen

items_menu_updater
        restorescreen
        gosub calc_inv_array
        gosub plot_menu_bars

items_palettes
        ; reuses palette variables from equip menu
        temp1 = m_item_inv[0]
        m_inv0_pal1 = pal_items1[temp1]
        m_inv0_pal2 = pal_items2[temp1]
        temp1 = m_item_inv[1]
        m_sword_pal1 = pal_items1[temp1]
        m_sword_pal2 = pal_items2[temp1]
        temp1 = m_item_inv[2]
        m_inv1_pal1 = pal_items1[temp1]
        m_inv1_pal2 = pal_items2[temp1]
        temp1 = m_item_inv[3]
        m_shield_pal1 = pal_items1[temp1]
        m_shield_pal2 = pal_items2[temp1]
        temp1 = m_item_inv[4]
        m_inv2_pal1 = pal_items1[temp1]
        m_inv2_pal2 = pal_items2[temp1]
        temp1 = m_item_inv[5]
        m_armor_pal1 = pal_items1[temp1]
        m_armor_pal2 = pal_items2[temp1]
        temp1 = m_item_inv[6]
        m_inv3_pal1 = pal_items1[temp1]
        m_inv3_pal2 = pal_items2[temp1]
        temp1 = m_item_inv[7]
        m_charm_pal1 = pal_items1[temp1]
        m_charm_pal2 = pal_items2[temp1]
        
        ; plot the inventory
        m_spriteX = 16
        m_spriteY = 80
        m_textX = 24
        m_textY = 5
        m_palette = 4
        ; reuse obj_index here because index is used by menu coloring code and breaks item list
        for obj_index = 0 to 7
        item_name = m_item_inv[obj_index]
        if !item_name then items_left
        plotsprite menu_potion0 m_palette m_spriteX m_spriteY
        plotmap item_names m_palette m_textX m_textY 11 1 0 item_name 11
items_left
        if m_spriteX = 16 then m_palette = 0 : m_spriteX = 84 : m_textX = 92 : goto items_right
        m_palette = 4
        m_spriteX = 16 : m_textX = 24
        m_spriteY = m_spriteY + 32
        m_textY = m_textY + 2
items_right
        next

        ; bypass item description if on Exit
        if menu_selection >= 8 then item_cursor_Y
        temp1 = m_item_inv[menu_selection]
        m_desc = m_desc_set[temp1]
        plotmap item_desc 0 28 12 18 1 0 m_desc 18

item_cursor_Y
        if menu_selection = 0 || menu_selection = 1 then menu_cursor_Y = 80 : goto item_cursor_X
        if menu_selection = 2 || menu_selection = 3 then menu_cursor_Y = 80 + 32 : goto item_cursor_X
        if menu_selection = 4 || menu_selection = 5 then menu_cursor_Y = 80 + 64 : goto item_cursor_X
        if menu_selection = 6 || menu_selection = 7 then menu_cursor_Y = 80 + 96 : goto item_cursor_X
        menu_cursor_Y = MENU_EQUIP_EXIT_Y

item_cursor_X
        ; kludge - makes up from the exit option go into right column instead of left
        if menu_selection = 8 then menu_selection = 9
        if menu_selection = 9 then menu_cursor_X = MENU_EQUIP_EXIT_X : goto item_cursor_set
        if menu_selection = 1 || menu_selection = 3 then menu_cursor_X = 80 : goto item_cursor_set
        if menu_selection = 5 || menu_selection = 7 then menu_cursor_X = 80 : goto item_cursor_set
        menu_cursor_X = 12

item_cursor_set
        plotsprite menu_cursor0 0 menu_cursor_X menu_cursor_Y


items_menu_controls
        if !menu_debounce && joy0fire0 && action_button = 1 then open_main_menu
        if !menu_debounce && joy0fire1 && action_button = 0 then open_main_menu
        ; Pause is a quickie way of getting back to the action
        if !pause_debounce && switchpause then close_menu
        if !action_debounce && joy0fire0 && action_button = 0 then use_item
        if !action_debounce && joy0fire1 && action_button = 1 then use_item
        if using_item then use_item
        gosub menu_dirs
        goto main

        const ITEMS_HP_X = 80
        const ITEMS_HP_Y = 32

        const HP_CHANGE_POTION = $20
        const HP_CHANGE_HIPOTION = $30
        const HP_CHANGE_XPOTION = $48
        const MP_CHANGE_ETHER = $10
        const MP_CHANGE_XETHER = $48
use_item
        action_debounce = 1
        if menu_selection = 9 then open_main_menu
        using_item = m_item_inv[menu_selection]
        ; TODO: Prevent item use if full HP/MP or normal status
        if using_item = 1 then m_item_bits_1{0} = 0 : hp_change = HP_CHANGE_POTION : goto use_potion
        if using_item = 2 then m_item_bits_1{1} = 0 : hp_change = HP_CHANGE_HIPOTION : goto use_potion
        if using_item = 3 then m_item_bits_1{2} = 0 : hp_change = HP_CHANGE_XPOTION : goto use_potion
        if using_item = 4 then m_item_bits_1{3} = 0 : mp_change = MP_CHANGE_ETHER : goto use_ether
        if using_item = 5 then m_item_bits_1{4} = 0 : mp_change = MP_CHANGE_XETHER : goto use_ether
        if using_item = 6 then m_item_bits_2{0} = 0 : hp_change = HP_CHANGE_XPOTION : mp_change = MP_CHANGE_XETHER : goto use_elixir
        if using_item = 7 then m_item_bits_2{1} = 0 : goto use_antidote
        if using_item = 8 then m_item_bits_2{2} = 0 : goto use_uncurse

use_potion
        gosub increase_player_hp
        goto use_item_done

use_elixir
        gosub increase_player_hp

use_ether
        gosub increase_player_mp
        goto use_item_done

use_antidote
use_uncurse

use_item_done
        using_item = 0
        goto main

plot_magic_menu
        menu = MENU_MAGIC
        if !menu_change then goto magic_menu_updater
        clearscreen
;        gosub disable_double_wide_mode
        gosub plot_menu_border
        plotchars 'Spells Tome' 0 60 1 singlewide
        plotchars 'Fireball' 0 16 2 singlewide
        plotchars 'Forward' 0 24 11 singlewide
        plotchars 'Backward' 0 80 11 singlewide
        plotchars 'Clockwise' 0 24 12 singlewide
        plotchars 'Counterclockwise' 0 80 12 singlewide
        ; TODO: Show different directions on different frames?
        characterset menu_arrows
        alphachars '7894 6123'
        ; Fireball
        plotchars '646' 0 24 3 singlewide
        ; Legend
        plotchars '6' 0 16 11 singlewide
        plotchars '4' 0 72 11 singlewide
        plotchars '2' 0 16 12 singlewide
        plotchars '8' 0 72 12 singlewide
        savescreen
        menu_change = 0

magic_menu_updater
        restorescreen

magic_menu_controls
        ; Either joystick button can go back to the main menu
        ; Maybe have an Exit "button" always highlighted to signify this?
        if !menu_debounce && joy0fire0 && action_button = 1 then open_main_menu
        if !menu_debounce && joy0fire1 && action_button = 0 then open_main_menu
        ; Pause is a quickie way of getting back to the action
        if !pause_debounce && switchpause then close_menu
        if !action_debounce && joy0fire0 then open_main_menu
        if !action_debounce && joy0fire1 then open_main_menu
        goto main

plot_equip_menu
        ; turn on Kangaroo mode so palette color 1 is more manageable
        sCTRL{2} = 1 : CTRL = sCTRL
        menu = MENU_EQUIP
        gosub calc_inv_array
        if !menu_change then goto equip_menu_updater
        clearscreen
        menu_change = 0
        menu_selection = 0
        menu_columns = 1        ; technically 2 but code handles each menu pane separately
        menu_max = 4
        gosub plot_menu_border
        characterset menu_font
        alphachars '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz -!&[$#]{}(_*)'
        plotchars 'Attack     Defense     Wisdom' 0 16 1 singlewide
        plotchars '------------------------------------' 0 8 2 singlewide
        plotchars 'Inventory' 0 24 3 singlewide
        plotchars 'Equipped'  0 96 3 singlewide
        plotchars 'Weapon'    0 80 4 singlewide
        plotchars 'Shield'    0 80 6 singlewide
        plotchars 'Body'     0 80 8 singlewide
        plotchars 'Talisman'  0 80 10 singlewide
        plotchars 'Exit'      0 128 12 singlewide
        savescreen
        goto update_player_stats

equip_menu_updater
        restorescreen

equip_menu_controls
        ; Pause is a quickie way of getting back to the action
        if !pause_debounce && switchpause then close_menu
        if equip_inv_col then equip_menu_inv_controls
        equip_inv_sel = 0
        if !menu_debounce && joy0fire0 && action_button = 1 then open_main_menu
        if !menu_debounce && joy0fire1 && action_button = 0 then open_main_menu
        if !action_debounce && joy0fire0 && action_button = 0 then equip_menu_change_to_inv
        if !action_debounce && joy0fire1 && action_button = 1 then equip_menu_change_to_inv
        gosub menu_dirs
        if menu_selection > MENU_EQUIP_MAX_OPTIONS then menu_selection = MENU_EQUIP_MAX_OPTIONS : goto equip_menu_dirs_done
        if menu_selection > MENU_EQUIP_MAX_OPTIONS then menu_selection = 0
        goto equip_menu_dirs_done

        const MENU_EQUIP_MAX_OPTIONS = 4
        const MENU_EQUIP_EQUIPPED_X = 76
        const MENU_EQUIP_SWORD_Y    = 64
        const MENU_EQUIP_SHIELD_Y   = 96
        const MENU_EQUIP_ARMOR_Y    = 128
        const MENU_EQUIP_CHARM_Y    = 160
        const MENU_EQUIP_INV_X      = 12
        const MENU_EQUIP_INV0_Y    = 80
        const MENU_EQUIP_INV1_Y    = 112
        const MENU_EQUIP_INV2_Y    = 142
        const MENU_EQUIP_INV3_Y    = 176
        const MENU_EQUIP_EXIT_X     = 124
        const MENU_EQUIP_EXIT_Y     = 192

equip_menu_return_from_inv
        menu_debounce = 1
        equip_inv_col = 0
        equip_inv_sel = 0
        m_inv_scroll = 0
        goto equip_menu_dirs_done

equip_menu_inv_controls
        if !menu_debounce && joy0fire0 && action_button = 1 then equip_menu_return_from_inv
        if !menu_debounce && joy0fire1 && action_button = 0 then equip_menu_return_from_inv
        if !action_debounce && joy0fire0 && action_button = 0 then equip_item
        if !action_debounce && joy0fire1 && action_button = 1 then equip_item
        if up_debounce >= MENU_TAP_FRAMES then gosub equip_inv_sel_up
        if !up_debounce && joy0up then gosub equip_inv_sel_up
        if down_debounce >= MENU_TAP_FRAMES then gosub equip_inv_sel_down
        if !down_debounce && joy0down then gosub equip_inv_sel_down

equip_menu_dirs_done
        menu_cursor_X = MENU_EQUIP_EQUIPPED_X
        if menu_selection = 0 then menu_cursor_Y = MENU_EQUIP_SWORD_Y : goto equip_menu_sword_inv
        if menu_selection = 1 then menu_cursor_Y = MENU_EQUIP_SHIELD_Y : goto equip_menu_shield_inv
        if menu_selection = 2 then menu_cursor_Y = MENU_EQUIP_ARMOR_Y : goto equip_menu_armor_inv
        if menu_selection = 3 then menu_cursor_Y = MENU_EQUIP_CHARM_Y : goto equip_menu_charm_inv
        if menu_selection = 4 then menu_cursor_X = MENU_EQUIP_EXIT_X : menu_cursor_Y = MENU_EQUIP_EXIT_Y
        ; continue showing the inventory of the previously selected option
        if prev_menu_selection = 3 then goto equip_menu_charm_inv

equip_menu_sword_inv
        m_inv_index = m_inv_scroll
        for m_inv_slot = 0 to 3
        temp1 = m_sword_inv[m_inv_index]
        m_inv_item_0[m_inv_slot] = temp1
        m_inv0_pal1[m_inv_slot] = pal_swords1[temp1]
        m_inv0_pal2[m_inv_slot] = pal_swords2[temp1]
        m_inv_index = m_inv_index + 1
menu_sword_next 
        next

        ; TODO: LUT for item icons
plot_inv_sword_0
        if !m_inv_item_0 then plot_inv_sword_1
        plotsprite menu_sword0 4 16 80 m_inv_item_0
        plotmap sword_names 0 24 5 13 1 0 m_inv_item_0 13
plot_inv_sword_1
        if !m_inv_item_1 then plot_inv_sword_2
        plotsprite menu_sword0 4 16 112 m_inv_item_1
        plotmap sword_names 0 24 7 13 1 0 m_inv_item_1 13
plot_inv_sword_2
        if !m_inv_item_2 then plot_inv_sword_3
        plotsprite menu_sword0 4 16 144 m_inv_item_2
        plotmap sword_names 0 24 9 13 1 0 m_inv_item_2 13
plot_inv_sword_3
        if !m_inv_item_3 then plot_inv_sword_done
        plotsprite menu_sword0 4 16 176 1 0 m_inv_item_3
        plotmap sword_names 0 24 11 13 1 0 m_inv_item_3 13
plot_inv_sword_done
        goto equip_menu_draw_sprites

equip_menu_shield_inv
        m_inv_index = m_inv_scroll
        for m_inv_slot = 0 to 3
        temp1 = m_shield_inv[m_inv_index]
        m_inv_item_0[m_inv_slot] = temp1
        m_inv0_pal1[m_inv_slot] = pal_shields1[temp1]
        m_inv0_pal2[m_inv_slot] = pal_shields2[temp1]
        m_inv_index = m_inv_index + 1
menu_shield_next 
        next

plot_inv_shield_0
        if !m_inv_item_0 then plot_inv_shield_1
        plotsprite menu_shield0 4 16 80 m_inv_item_0
        plotmap shield_names 0 24 5 13 1 0 m_inv_item_0 13
plot_inv_shield_1
        if !m_inv_item_1 then plot_inv_shield_2
        plotsprite menu_shield0 4 16 112 m_inv_item_1
        plotmap shield_names 0 24 7 13 1 0 m_inv_item_1 13
plot_inv_shield_2
        if !m_inv_item_2 then plot_inv_shield_3
        plotsprite menu_shield0 4 16 144 m_inv_item_2
        plotmap shield_names 0 24 9 13 1 0 m_inv_item_2 13
plot_inv_shield_3
        if !m_inv_item_3 then plot_inv_shield_done
        plotsprite menu_shield0 4 16 176 1 0 m_inv_item_3
        plotmap shield_names 0 24 11 13 1 0 m_inv_item_3 13
plot_inv_shield_done
        goto equip_menu_draw_sprites

equip_menu_armor_inv
        m_inv_index = m_inv_scroll
        for m_inv_slot = 0 to 3
        temp1 = m_armor_inv[m_inv_index]
        m_inv_item_0[m_inv_slot] = temp1
        m_inv0_pal1[m_inv_slot] = pal_armor1[temp1]
        m_inv0_pal2[m_inv_slot] = pal_armor2[temp1]
        m_inv_index = m_inv_index + 1
menu_armor_next 
        next

plot_inv_armor_0
        plotsprite menu_armor0 4 16 80  m_inv_item_0
        plotmap armor_names 0 24 5 13 1 0  m_inv_item_0 13
plot_inv_armor_1
        plotsprite menu_armor0 4 16 112  m_inv_item_1
        plotmap armor_names 0 24 7 13 1 0  m_inv_item_1 13
plot_inv_armor_2
        plotsprite menu_armor0 4 16 144  m_inv_item_2
        plotmap armor_names 0 24 9 13 1 0  m_inv_item_2 13
plot_inv_armor_3
        plotsprite menu_armor0 4 16 176 1 0  m_inv_item_3
        plotmap armor_names 0 24 11 13 1 0  m_inv_item_3 13
plot_inv_armor_done
        goto equip_menu_draw_sprites

equip_menu_charm_inv
        m_inv_index = m_inv_scroll
        for m_inv_slot = 0 to 3
        temp1 = m_charm_inv[m_inv_index]
        m_inv_item_0[m_inv_slot] = temp1
        m_inv0_pal1[m_inv_slot] = pal_charms1[temp1]
        m_inv0_pal2[m_inv_slot] = pal_charms2[temp1]
        m_inv_index = m_inv_index + 1
menu_charm_next 
        next

        plotsprite menu_charm0 4 16 80  m_inv_item_0
        plotmap charm_names 0 24 5 13 1 0  m_inv_item_0 13
        plotsprite menu_charm0 4 16 112  m_inv_item_1
        plotmap charm_names 0 24 7 13 1 0  m_inv_item_1 13
        plotsprite menu_charm0 4 16 144  m_inv_item_2
        plotmap charm_names 0 24 9 13 1 0  m_inv_item_2 13
        plotsprite menu_charm0 4 16 176 1 0  m_inv_item_3
        plotmap charm_names 0 24 11 13 1 0  m_inv_item_3 13
        goto equip_menu_draw_sprites

equip_menu_draw_sprites
        ; This block of code has gotten pretty messy!
        ; It tests each equipment slot to see if it is a non-zero value,
        ; then plots a sprite and a character map for that value.
        ; If it IS zero, no name is drawn, except in the case of weapon
        if player_sword then goto equip_menu_draw_sword
        plotmap unarmed_name 0 92 5 13 1 0 0
        goto equip_menu_test_shield
equip_menu_draw_sword
        plotsprite menu_sword0 0 84 80 player_sword
        plotmap sword_names 0 92 5 13 1 0 player_sword 13
equip_menu_test_shield
        if player_shield then goto equip_menu_draw_shield
        goto equip_menu_test_armor
equip_menu_draw_shield
        plotsprite menu_shield0 0 84 112 player_shield
        plotmap shield_names 0 92 7 13 1 0 player_shield 13
equip_menu_test_armor
        if player_armor then goto equip_menu_draw_armor
        goto equip_menu_test_charm
equip_menu_draw_armor
        plotsprite menu_armor0 0 84 144 player_armor
        plotmap armor_names 0 92 9 13 1 0 player_armor 13
equip_menu_test_charm
        if player_charm then goto equip_menu_draw_charm
        goto equip_menu_draw_atk
equip_menu_draw_charm
        plotsprite menu_charm0 0 84 176 1 0 player_charm
        plotmap charm_names 0 92 11 13 1 0 player_charm 13
equip_menu_draw_atk
        ; plotvalue menu_font 0 player_atk 2 88 1
        asm
        lda	#44
        sta	valueX
        lda	#1
        sta	valueY
        lda	#<player_atk
        sta	value_ptr_lo
        lda	#>player_atk
        sta	value_ptr_hi
        jsr	plotvaluesw
        ; plotvalue menu_font 0 player_def 2 136 1
        lda	#92
        sta	valueX
        lda	#1
        sta	valueY
        lda	#<player_def
        sta	value_ptr_lo
        lda	#>player_def
        sta	value_ptr_hi
        jsr	plotvaluesw
        ; Wisdom
        lda	#136
        sta	valueX
        lda	#1
        sta	valueY
        lda	#<player_wisdom
        sta	value_ptr_lo
        lda	#>player_wisdom
        sta	value_ptr_hi
        jsr	plotvaluesw
end
        if equip_inv_col then equip_menu_inv_cursor
        plotsprite menu_cursor0 0 menu_cursor_X menu_cursor_Y
        goto main

equip_menu_inv_cursor
        ; blink the equipped column cursor
        if animation_frame then plotsprite menu_cursor0 0 menu_cursor_X menu_cursor_Y
        plotsprite menu_cursor0 0 equip_inv_X equip_inv_Y
        goto main

equip_menu_change_to_inv
        action_debounce = 1
        if menu_selection = MENU_EQUIP_MAX_OPTIONS then open_main_menu
        equip_inv_col = 1
        equip_inv_X = MENU_EQUIP_INV_X
        equip_inv_Y = MENU_EQUIP_INV0_Y
        goto equip_menu_dirs_done

equip_item
        action_debounce = 1
        equip_inv_col = 0
        m_inv_scroll = 0
        if menu_selection = 0 then equip_sword
        if menu_selection = 1 then equip_shield
        if menu_selection = 2 then equip_armor
equip_charm
        player_charm = m_charm_inv[equip_inv_sel]
        goto update_player_stats

equip_sword
        player_sword = m_sword_inv[equip_inv_sel]
        sword_pal = f_sword_pals[player_sword]
        goto update_player_stats

equip_shield
        player_shield = m_shield_inv[equip_inv_sel]
        shield_pal = f_shield_pals[player_shield]
        goto update_player_stats

equip_armor
        player_armor = m_armor_inv[equip_inv_sel]

update_player_stats
        ; good place to throw in the equipment palette update
update_equipment_pals
        asm
        ldx player_sword
        lda pal_swords1,x
        sta m_sword_pal1
        lda pal_swords2,x
        sta m_sword_pal2
        ldx player_shield
        lda pal_shields1,x
        sta m_shield_pal1
        lda pal_shields2,x
        sta m_shield_pal2
        ldx player_armor
        lda pal_armor1,x
        sta m_armor_pal1
        lda pal_armor2,x
        sta m_armor_pal2
        ldx player_charm
        lda pal_charms1,x
        sta m_charm_pal1
        lda pal_charms2,x
        sta m_charm_pal2
end
        ; currently this just reads from an array for each type of equipment,
        ; swords only do attack, shields/armor only defense, and charms both
        dec player_atk = sword_atk[player_sword]
        dec player_atk = player_atk + player_str
        dec player_def = shield_def[player_shield]
        dec temp1 = player_def 
        dec player_def = armor_def[player_armor] + temp1
        temp1 = player_charm * 2
        dec player_atk = player_atk + charm_stats[temp1]
        temp1 = (player_charm + 1) * 2
        dec player_def = player_def + charm_stats[temp1]
        goto equip_menu_dirs_done

equip_menu_colors
        P0C3 = PAL_LTPURP
        P4C3 = PAL_LTRED
        for index = 0 to 64
        WSYNC = 1
        next 
        P0C1 = m_sword_pal1
        P0C3 = m_sword_pal2
        P4C1 = m_inv0_pal1
        P4C3 = m_inv0_pal2
        for index = 0 to 32
        WSYNC = 1
        next
        ; palettes used for inv 1 and shield
        P0C1 = m_shield_pal1
        P0C3 = m_shield_pal2
        P4C1 = m_inv1_pal1
        P4C3 = m_inv1_pal2
        for index = 0 to 32
        WSYNC = 1
        next
        ; palettes used for inv 2 and armor
        P0C1 = m_armor_pal1
        P0C3 = m_armor_pal2
        P4C1 = m_inv2_pal1
        P4C3 = m_inv2_pal2
        for index = 0 to 32
        WSYNC = 1
        next
        ; palettes used for inv 3 and charm
        P0C1 = m_charm_pal1
        P0C3 = m_charm_pal2
        P4C1 = m_inv3_pal1
        P4C3 = m_inv3_pal2
        return

        const MENU_MAIN_ITEMS_X = 12
        const MENU_MAIN_ITEMS_Y = 192
        const MENU_MAIN_MAGIC_X = 40
        const MENU_MAIN_EQUIP_X = 72
        const MENU_MAIN_RELICS_X = 116
        const MENU_TAP_FRAMES = 4

menu_dirs
        if right_debounce >= MENU_TAP_FRAMES then gosub menu_selection_right
        if !right_debounce && joy0right then gosub menu_selection_right
        if left_debounce >= MENU_TAP_FRAMES then gosub menu_selection_left
        if !left_debounce && joy0left then gosub menu_selection_left
        if up_debounce >= MENU_TAP_FRAMES then gosub menu_selection_up
        if !up_debounce && joy0up then gosub menu_selection_up
        if down_debounce >= MENU_TAP_FRAMES then gosub menu_selection_down
        if !down_debounce && joy0down then gosub menu_selection_down
        return

menu_selection_right
        prev_menu_selection = menu_selection
        menu_selection = menu_selection + 1 : right_debounce = 1
        ; wrap menu selection back to zero
        if menu_selection > menu_max then menu_selection = 0
        return

menu_selection_left
        prev_menu_selection = menu_selection
        menu_selection = menu_selection - 1 : left_debounce  = 1
        ; selection underflow, wrap to last option
        if menu_selection > menu_max then menu_selection = menu_max
        return

menu_selection_down
        prev_menu_selection = menu_selection
        menu_selection = menu_selection + menu_columns : down_debounce = 1
        ; wrap menu selection back to zero
        if menu_selection > menu_max then menu_selection = 0
        return

menu_selection_up
        prev_menu_selection = menu_selection
        menu_selection = menu_selection - menu_columns : up_debounce = 1
        ; selection underflow, wrap to last option
        if menu_selection > menu_max then menu_selection = menu_max
        return

        dmahole 0
equip_inv_sel_down
        ; TODO: Inventory management and variable that sets the cap to the current number of items
        if equip_inv_sel > 10 then equip_inv_sel = 10 : return
        equip_inv_sel = equip_inv_sel + 1 : down_debounce = 1
        if equip_inv_Y = MENU_EQUIP_INV3_Y then equip_inv_down_no_Y
        equip_inv_Y = equip_inv_Y + 32
        return
equip_inv_down_no_Y
        m_inv_scroll = m_inv_scroll + 1
        return

equip_inv_sel_up
        if equip_inv_sel = 0 then up_debounce = 1 : return
        equip_inv_sel = equip_inv_sel - 1 : up_debounce = 1
        if equip_inv_Y = MENU_EQUIP_INV0_Y then equip_inv_up_no_Y
        equip_inv_Y = equip_inv_Y - 32
        return
equip_inv_up_no_Y
        m_inv_scroll = m_inv_scroll - 1
        return

open_main_menu
        ; turn off Kangaroo mode for position pin sprite
        sCTRL{2} = 0 : CTRL = sCTRL
        action_debounce = 1
        menu_debounce = 1
        menu_change = 1
        menu = MENU_MAIN
        menu_selection = 0
        goto main

close_menu
        gosub enable_double_wide_mode
        gosub clear_palettes
        game_state = STATE_FIELD
        asm
        lda #1
        sta reload_map
        sta save_objects
        sta menu_debounce
        sta pause_debounce
        sta torch_reblock
end
        goto main ; shared palettes are now included in each tileset

gen_forest_map
        ; TODO: Test which rooms have been entered
        alphachars '0123456789ABCDEF'
        characterset menu_map
        plotmap menu_map_room 0 52 4 14 7
        characterset menu_font
        if tileset = T_FOREST then gen_forest_s
        if tileset = T_CASTLE then gen_castle_s

gen_forest_s
        if save_room_index{0} then plotsprite menu_s 0 94 80
        return

gen_castle_s
        if save_room_index{0} then plotsprite menu_s 0 86 96
        return

calc_inv_array
        ; zero the inventory arrays to prevent duplication
        for index = 0 to 55
        m_item_inv[index] = 0
        next
        ; populate arrays based on equipment bits
        ; TODO: Optimize for ROM space, this is quick and dirty...
        if m_item_bits_1{0} then m_item_inv[1] = 1
        if m_item_bits_1{1} then m_item_inv[2] = 2
        if m_item_bits_1{2} then m_item_inv[3] = 3
        if m_item_bits_1{3} then m_item_inv[4] = 4
        if m_item_bits_1{4} then m_item_inv[5] = 5
        if m_item_bits_2{0} then m_item_inv[6] = 6
        if m_item_bits_2{1} then m_item_inv[7] = 7
        if m_item_bits_2{2} then m_item_inv[8] = 8
        if m_item_bits_2{3} then m_item_inv[9] = 9
        if m_item_bits_2{4} then m_item_inv[10] = 10
        if m_sword_bits_1{0} then m_sword_inv[1] = 1
        if m_sword_bits_1{1} then m_sword_inv[2] = 2
        if m_sword_bits_1{2} then m_sword_inv[3] = 3
        if m_sword_bits_1{3} then m_sword_inv[4] = 4
        if m_sword_bits_1{4} then m_sword_inv[5] = 5
        if m_sword_bits_2{0} then m_sword_inv[6] = 6
        if m_sword_bits_2{1} then m_sword_inv[7] = 7
        if m_sword_bits_2{2} then m_sword_inv[8] = 8
        if m_sword_bits_2{3} then m_sword_inv[9] = 9
        if m_sword_bits_2{4} then m_sword_inv[10] = 10
        if m_shield_bits_1{0} then m_shield_inv[1] = 1
        if m_shield_bits_1{1} then m_shield_inv[2] = 2
        if m_shield_bits_1{2} then m_shield_inv[3] = 3
        if m_shield_bits_1{3} then m_shield_inv[4] = 4
        if m_shield_bits_1{4} then m_shield_inv[5] = 5
        if m_shield_bits_2{0} then m_shield_inv[6] = 6
        if m_shield_bits_2{1} then m_shield_inv[7] = 7
        if m_shield_bits_2{2} then m_shield_inv[8] = 8
        if m_shield_bits_2{3} then m_shield_inv[9] = 9
        if m_shield_bits_2{4} then m_shield_inv[10] = 10
        if m_armor_bits_1{0} then m_armor_inv[1] = 1
        if m_armor_bits_1{1} then m_armor_inv[2] = 2
        if m_armor_bits_1{2} then m_armor_inv[3] = 3
        if m_armor_bits_1{3} then m_armor_inv[4] = 4
        if m_armor_bits_1{4} then m_armor_inv[5] = 5
        if m_armor_bits_2{0} then m_armor_inv[6] = 6
        if m_armor_bits_2{1} then m_armor_inv[7] = 7
        if m_armor_bits_2{2} then m_armor_inv[8] = 8
        if m_armor_bits_2{3} then m_armor_inv[9] = 9
        if m_armor_bits_2{4} then m_armor_inv[10] = 10
        if m_charm_bits_1{0} then m_charm_inv[1] = 1
        if m_charm_bits_1{1} then m_charm_inv[2] = 2
        if m_charm_bits_1{2} then m_charm_inv[3] = 3
        if m_charm_bits_1{3} then m_charm_inv[4] = 4
        if m_charm_bits_1{4} then m_charm_inv[5] = 5
        if m_charm_bits_2{0} then m_charm_inv[6] = 6
        if m_charm_bits_2{1} then m_charm_inv[7] = 7
        if m_charm_bits_2{2} then m_charm_inv[8] = 8
        if m_charm_bits_2{3} then m_charm_inv[9] = 9
        if m_charm_bits_2{4} then m_charm_inv[10] = 10

        const m_item_inv_lo = #<m_item_inv
        const m_item_inv_hi = #>m_item_inv
        const m_sword_inv_lo = #<m_sword_inv
        const m_sword_inv_hi = #>m_sword_inv
        const m_shield_inv_lo = #<m_shield_inv
        const m_shield_inv_hi = #>m_shield_inv
        const m_armor_inv_lo = #<m_armor_inv
        const m_armor_inv_hi = #>m_armor_inv
        const m_charm_inv_lo = #<m_charm_inv
        const m_charm_inv_hi = #>m_charm_inv

        ; inventory-by-inventory, remove zeros
        pointer = m_item_inv_lo
        pointer_hi = m_item_inv_hi
        gosub remove_inv_zeros
        pointer = m_sword_inv_lo
        pointer_hi = m_sword_inv_hi
        gosub remove_inv_zeros
        pointer = m_shield_inv_lo
        pointer_hi = m_shield_inv_hi
        gosub remove_inv_zeros
        pointer = m_armor_inv_lo
        pointer_hi = m_armor_inv_hi
        gosub remove_inv_zeros
        pointer = m_charm_inv_lo
        pointer_hi = m_charm_inv_hi
        ; riz_return pulls double duty as the return for calc_inv_array

remove_inv_zeros
        ; reads thru the inv array and removes any empty slots
        temp1 = 0
        for index = 1 to 10
        if !pointer[[index]] then riz_next
        pointer[[temp1]] = pointer[[index]]
        temp1 = temp1 + 1
riz_next
        next
        ; pad remaining inventory slots with zero
        for index = temp1 to 10
        pointer[[index]] = 0
        next
riz_return
        return

plot_menu_hud
        characterset menu_font
        alphachars '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz -!&[$#]{}(_*)'
        plotchars 'Johanna' 0 20 1 singlewide
        plotchars 'HP' 0 72 1 singlewide
        plotchars 'MP' 0 72 2 singlewide
        return

plot_menu_bars
        gosub update_hp_bar
        gosub update_mp_bar
        plotsprite menu_bar9 4  80 16
        plotsprite menu_bar0 4  88 16 hp_seg_1
        plotsprite menu_bar0 4  96 16 hp_seg_2
        plotsprite menu_bar0 4 104 16 hp_seg_3
        plotsprite menu_bar0 4 112 16 hp_seg_4
        plotsprite menu_bar0 4 120 16 hp_seg_5
        plotsprite menu_bar0 4 128 16 hp_seg_6
        plotsprite menu_bar9 0  80 32
        plotsprite menu_bar0 0  88 32 mp_seg_1
        plotsprite menu_bar0 0  96 32 mp_seg_2
        plotsprite menu_bar0 0 104 32 mp_seg_3
        plotsprite menu_bar0 0 112 32 mp_seg_4
        plotsprite menu_bar0 0 120 32 mp_seg_5
        plotsprite menu_bar0 0 128 32 mp_seg_6
        return

plot_menu_border
        ; TODO: Automate this drawing?
        characterset menu_font
        alphachars '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz -!&[$#]{}(_*)'
        plotchars '&[$#$$$#$#$$#$$$#$$#$#$$$#$#$$$$#$$#$$]&' 0 0 0 singlewide
        plotchars '&{' 0   0 1 singlewide
        plotchars '}&' 0 152 1 singlewide
        plotchars '&{' 0   0 2 singlewide
        plotchars '}&' 0 152 2 singlewide
        plotchars '&{' 0   0 3 singlewide
        plotchars '}&' 0 152 3 singlewide
        plotchars '&{' 0   0 4 singlewide
        plotchars '}&' 0 152 4 singlewide
        plotchars '&{' 0   0 5 singlewide
        plotchars '}&' 0 152 5 singlewide
        plotchars '&{' 0   0 6 singlewide
        plotchars '}&' 0 152 6 singlewide
        plotchars '&{' 0   0 7 singlewide
        plotchars '}&' 0 152 7 singlewide
        plotchars '&{' 0   0 8 singlewide
        plotchars '}&' 0 152 8 singlewide
        plotchars '&{' 0   0 9 singlewide
        plotchars '}&' 0 152 9 singlewide
        plotchars '&{' 0   0 10 singlewide
        plotchars '}&' 0 152 10 singlewide
        plotchars '&{' 0   0 11 singlewide
        plotchars '}&' 0 152 11 singlewide
        plotchars '&{' 0   0 12 singlewide
        plotchars '}&' 0 152 12 singlewide
        plotchars '&(__*__*_*__*__*___*_*__*___*_*_*___*_)&' 0   0 13 singlewide
        return

        alphadata item_names menu_font singlewide
        '           '
        'Potion     '
        'High Potion'
        'Max Potion '
        'Ether      '
        'High Ether '
        'Elixir     '
        'Antidote   '
        'Uncurse    '
        'Soft       '
        'Life Apple '
end

        ; Item description assigments
        data m_desc_set
        0, 1, 1, 1, 2, 2, 3, 4, 5, 6, 7
end

        alphadata item_desc menu_font singlewide
        '                  '
        'Restores HP       '
        'Restores MP       '
        'Restores HP and MP'
        'Cures Poison      '
        'Cures Curse       '
        'Cures Stone       '
        'Familiar Revives  '
end

        alphadata sword_names menu_font singlewide
        '             '
        'Rapier       '
        'Longsword    '
        'Broadsword   '
        'Estoc        '
        'Firebrand    '
        'Sword Num 6  '
        'Sword Num 7  '
        'Sword Num 8  '
        'Sword Num 9  '
        'Sword Num 10 '
end

        alphadata shield_names menu_font singlewide
        '             '
        'Buckler      '
        'Cross Shield '
        'Kite Shield  '
        'Mirror Shield'
        'Shield Num 5 '
        'Shield Num 6 '
        'Shield Num 7 '
        'Shield Num 8 '
        'Shield Num 9 '
        'Shield Num 10'
end

        alphadata armor_names menu_font singlewide
        '             '
        'Leather Armor'
        'Bronze Plate '
        'Steel Plate  '
        'Silver Plate '
        'Maiden Armor '
        'Armor Num 6  '
        'Armor Num 7  '
        'Armor Num 8  '
        'Armor Num 9  '
        'Armor Num 10 '
end

        alphadata charm_names menu_font singlewide
        '             '
        'Pendant      '
        'Charm        '
        'Locket       '
        'Coral Ring   '
        'Charm Num 5  '
        'Charm Num 6  '
        'Charm Num 7  '
        'Charm Num 8  '
        'Charm Num 9  '
        'Charm Num 10 '
end

        ; used when attacking without a weapon
        alphadata unarmed_name menu_font singlewide
        'Unarmed      '
end

        data pal_items1
        $00, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $0F, $34
end

        data pal_items2
        $00, $83, $84, $85, $74, $75, $97, $45, $06, $1C, $27
end

        data pal_swords1
        $00, $44, $12, $02, $02, $34
end
        data pal_swords2
        $00, $FE, $24, $05, $51, $36
end

        data pal_shields1
        $00, $44
end
        data pal_shields2
        $00, $FE
end

        data pal_armor1
        $00, $12, $F2
end
        data pal_armor2
        $00, $24, $F4
end

        data pal_charms1
        $00, $44
end
        data pal_charms2
        $00, $FE
end

        data sword_atk
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16
end

        data shield_def
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16
end

        data armor_def
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16
end

        data charm_stats
        0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16
end

enable_double_wide_mode
        sCTRL{4} = 1 : CTRL = sCTRL
        return

disable_double_wide_mode
        sCTRL{4} = 0 : CTRL = sCTRL
        return

        inline plotvaluesw.asm

set_menu_top_pal
        WSYNC = 1 : BACKGRND = $2D
        if menu = MENU_ITEMS || menu = MENU_EQUIP then equip_menu_colors
        return

;==============================================================================
; BANK 4
;------------------------------------------------------------------------------
; Cathedral graphics, maps, AI
;==============================================================================
        bank 4
        incgraphic gfx/tiles/castle_stone.png  160A 1 0 2 3 4
        incgraphic gfx/tiles/castle_tile.png  160A 1 0 2 3 6
        incgraphic gfx/tiles/castle_carpet.png  160A 1 0 2 3 7
        incgraphic gfx/tiles/castle_tables.png 160A 1 0 2 3 5
        incgraphic gfx/tiles/castle_hud.png 160A 0 3 1 2
        incgraphic gfx/sprites/blood.png 160A 0 1
        incgraphic gfx/sprites/darkspark0.png 160A 0 2 1 3
        incgraphic gfx/sprites/darkspark1.png 160A 2 0 1 3
        incgraphic gfx/sprites/darkspark2.png 160A 1 0
        incgraphic gfx/sprites/priest0.png 160A 0 2 1 3
        incgraphic gfx/sprites/priest1.png 160A 0 2 1 3
        incgraphic gfx/sprites/priest2.png 160A 0 1 2
        incgraphic gfx/sprites/priest3.png 160A 0 1 2
        incgraphic gfx/sprites/priest4.png 160A 0 2 1 3
        incgraphic gfx/sprites/priest5.png 160A 0 2 1 3
        incgraphic gfx/sprites/priest6.png 160A 0 2 1 3
        incgraphic gfx/sprites/priest7.png 160A 0 2 1 3
        incgraphic gfx/sprites/priest8.png 160A 0 2 1 3
        incgraphic gfx/sprites/priest9.png 160A 0 1 2 3
        incgraphic gfx/sprites/priest10.png 160A 0 2 1 3
        incgraphic gfx/sprites/priest11.png 160A 0 2 1 3
        incgraphic gfx/sprites/skeleton0.png 160A 0 3 1 2
        incgraphic gfx/sprites/skeleton1.png 160A 0 3 1 2
        incgraphic gfx/sprites/skeleton2.png 160A 0 3 1 2
        incgraphic gfx/sprites/skeleton3.png 160A 0 3 1 2
        incgraphic gfx/sprites/skeleton4.png 160A 0 3 1 2
        incgraphic gfx/sprites/skeleton5.png 160A 0 3 1 2
        incgraphic gfx/sprites/skeleton6.png 160A 0 3 1 2
        incgraphic gfx/sprites/skeleton7.png 160A 0 3 1 2
        incgraphic gfx/sprites/skeleton8.png 160A 0 3 1 2
        incgraphic gfx/sprites/skeleton9.png 160A 0 3 1 2
        incgraphic gfx/sprites/skeleton10.png 160A 0 3 1 2
        incgraphic gfx/sprites/skeleton11.png 160A 0 3 1 2
        incgraphic gfx/sprites/c_slime0.png 160A 0 3 1 2
        incgraphic gfx/sprites/c_slime1.png 160A 0 3 1 2
        incgraphic gfx/sprites/c_minislime0.png 160A 0 3 1 2
        incgraphic gfx/sprites/c_minislime1.png 160A 0 3 1 2

        incmapfile tiled/castle_room_8.tmx
        incmapfile tiled/castle_room_9.tmx
        incmapfile tiled/castle_room_10.tmx
        incmapfile tiled/castle_room_11.tmx
        incmapfile tiled/castle_room_12.tmx
        incmapfile tiled/castle_room_13.tmx
        incmapfile tiled/castle_room_14.tmx
        incmapfile tiled/castle_room_15.tmx
        incmapfile tiled/castle_room_16.tmx
        incmapfile tiled/castle_room_17.tmx 
        incmapfile tiled/castle_room_18.tmx
        incmapfile tiled/castle_room_19.tmx
        incmapfile tiled/castle_room_20.tmx
        incmapfile tiled/castle_room_21.tmx
        incmapfile tiled/castle_room_22.tmx
        incmapfile tiled/castle_room_23.tmx
        incmapfile tiled/castle_room_24.tmx
        incmapfile tiled/castle_room_25.tmx
        incmapfile tiled/castle_room_1.tmx
        incmapfile tiled/castle_room_2.tmx
        incmapfile tiled/castle_room_3.tmx
        incmapfile tiled/castle_room_4.tmx
        incmapfile tiled/castle_room_5.tmx
        incmapfile tiled/castle_room_6.tmx
        incmapfile tiled/castle_room_7.tmx

        const plot_castle_room_0_lo = #<.plot_castle_room_0
        const plot_castle_room_0_hi = #>.plot_castle_room_0
        const plot_castle_room_1_lo = #<.plot_castle_room_1
        const plot_castle_room_1_hi = #>.plot_castle_room_1
        const plot_castle_room_2_lo = #<.plot_castle_room_2
        const plot_castle_room_2_hi = #>.plot_castle_room_2
        const plot_castle_room_3_lo = #<.plot_castle_room_3
        const plot_castle_room_3_hi = #>.plot_castle_room_3
        const plot_castle_room_4_lo = #<.plot_castle_room_4
        const plot_castle_room_4_hi = #>.plot_castle_room_4
        const plot_castle_room_5_lo = #<.plot_castle_room_5
        const plot_castle_room_5_hi = #>.plot_castle_room_5
        const plot_castle_room_6_lo = #<.plot_castle_room_6
        const plot_castle_room_6_hi = #>.plot_castle_room_6
        const plot_castle_room_7_lo = #<.plot_castle_room_7
        const plot_castle_room_7_hi = #>.plot_castle_room_7
        const plot_castle_room_8_lo = #<.plot_castle_room_8
        const plot_castle_room_8_hi = #>.plot_castle_room_8
        const plot_castle_room_9_lo = #<.plot_castle_room_9
        const plot_castle_room_9_hi = #>.plot_castle_room_9
        const plot_castle_room_10_lo = #<.plot_castle_room_10
        const plot_castle_room_10_hi = #>.plot_castle_room_10
        const plot_castle_room_11_lo = #<.plot_castle_room_11
        const plot_castle_room_11_hi = #>.plot_castle_room_11
        const plot_castle_room_12_lo = #<.plot_castle_room_12
        const plot_castle_room_12_hi = #>.plot_castle_room_12
        const plot_castle_room_13_lo = #<.plot_castle_room_13
        const plot_castle_room_13_hi = #>.plot_castle_room_13
        const plot_castle_room_14_lo = #<.plot_castle_room_14
        const plot_castle_room_14_hi = #>.plot_castle_room_14
        const plot_castle_room_15_lo = #<.plot_castle_room_15
        const plot_castle_room_15_hi = #>.plot_castle_room_15
        const plot_castle_room_16_lo = #<.plot_castle_room_16
        const plot_castle_room_16_hi = #>.plot_castle_room_16
        const plot_castle_room_17_lo = #<.plot_castle_room_17
        const plot_castle_room_17_hi = #>.plot_castle_room_17
        const plot_castle_room_18_lo = #<.plot_castle_room_18
        const plot_castle_room_18_hi = #>.plot_castle_room_18
        const plot_castle_room_19_lo = #<.plot_castle_room_19
        const plot_castle_room_19_hi = #>.plot_castle_room_19
        const plot_castle_room_20_lo = #<.plot_castle_room_20
        const plot_castle_room_20_hi = #>.plot_castle_room_20
        const plot_castle_room_21_lo = #<.plot_castle_room_21
        const plot_castle_room_21_hi = #>.plot_castle_room_21
        const plot_castle_room_22_lo = #<.plot_castle_room_22
        const plot_castle_room_22_hi = #>.plot_castle_room_22
        const plot_castle_room_23_lo = #<.plot_castle_room_23
        const plot_castle_room_23_hi = #>.plot_castle_room_23
        const plot_castle_room_24_lo = #<.plot_castle_room_24
        const plot_castle_room_24_hi = #>.plot_castle_room_24
        const plot_castle_room_25_lo = #<.plot_castle_room_25
        const plot_castle_room_25_hi = #>.plot_castle_room_25

        data castle_map_lo
        plot_castle_room_0_lo,
        plot_castle_room_1_lo, plot_castle_room_2_lo, plot_castle_room_3_lo, plot_castle_room_4_lo, plot_castle_room_5_lo,
        plot_castle_room_6_lo, plot_castle_room_7_lo, plot_castle_room_8_lo, plot_castle_room_9_lo, plot_castle_room_10_lo,
        plot_castle_room_11_lo, plot_castle_room_12_lo, plot_castle_room_13_lo, plot_castle_room_14_lo, plot_castle_room_15_lo,
        plot_castle_room_16_lo, plot_castle_room_17_lo, plot_castle_room_18_lo, plot_castle_room_19_lo, plot_castle_room_20_lo,
        plot_castle_room_21_lo, plot_castle_room_22_lo, plot_castle_room_23_lo, plot_castle_room_24_lo, plot_castle_room_25_lo
end

        data castle_map_hi
        plot_castle_room_0_hi,
        plot_castle_room_1_hi, plot_castle_room_2_hi, plot_castle_room_3_hi, plot_castle_room_4_hi, plot_castle_room_5_hi,
        plot_castle_room_6_hi, plot_castle_room_7_hi, plot_castle_room_8_hi, plot_castle_room_9_hi, plot_castle_room_10_hi,
        plot_castle_room_11_hi, plot_castle_room_12_hi, plot_castle_room_13_hi, plot_castle_room_14_hi, plot_castle_room_15_hi,
        plot_castle_room_16_hi, plot_castle_room_17_hi, plot_castle_room_18_hi, plot_castle_room_19_hi, plot_castle_room_20_hi,
        plot_castle_room_21_hi, plot_castle_room_22_hi, plot_castle_room_23_hi, plot_castle_room_24_hi, plot_castle_room_25_hi
end

        data castle_obj_lo
        castle_room_0_obj_lo,
        castle_room_1_obj_lo, castle_room_2_obj_lo, castle_room_3_obj_lo, castle_room_4_obj_lo, castle_room_5_obj_lo,
        castle_room_6_obj_lo, castle_room_7_obj_lo, castle_room_8_obj_lo, castle_room_9_obj_lo, castle_room_10_obj_lo,
        castle_room_11_obj_lo, castle_room_12_obj_lo, castle_room_13_obj_lo, castle_room_14_obj_lo, castle_room_15_obj_lo,
        castle_room_16_obj_lo, castle_room_17_obj_lo, castle_room_18_obj_lo, castle_room_19_obj_lo, castle_room_20_obj_lo,
        castle_room_21_obj_lo, castle_room_22_obj_lo, castle_room_23_obj_lo, castle_room_24_obj_lo, castle_room_25_obj_lo
end

        data castle_obj_hi
        castle_room_0_obj_hi,
        castle_room_1_obj_hi, castle_room_2_obj_hi, castle_room_3_obj_hi, castle_room_4_obj_hi, castle_room_5_obj_hi,
        castle_room_6_obj_hi, castle_room_7_obj_hi, castle_room_8_obj_hi, castle_room_9_obj_hi, castle_room_10_obj_hi,
        castle_room_11_obj_hi, castle_room_12_obj_hi, castle_room_13_obj_hi, castle_room_14_obj_hi, castle_room_15_obj_hi,
        castle_room_16_obj_hi, castle_room_17_obj_hi, castle_room_18_obj_hi, castle_room_19_obj_hi, castle_room_20_obj_hi,
        castle_room_21_obj_hi, castle_room_22_obj_hi, castle_room_23_obj_hi, castle_room_24_obj_hi, castle_room_25_obj_hi
end

load_castle
        if !first_load then castle_pals
        first_load = 0
        if save_room_index = 1 then castle_save_1

        room_index = 44
        menu_map_Xpos = 70
        menu_map_Ypos = 160
        player_Xpos = 24
        player_Ypos = 60
        player_facing = DIR_UP
        goto castle_pals

castle_save_1
        room_index = 18
        menu_map_Xpos = 86
        menu_map_Ypos = 96
        player_Xpos = 24
        player_Ypos = 60
        player_facing = DIR_DOWN

castle_pals
        bg_color = $00                                             ; black
        P0C1 = PAL_DKPURP : P0C2 = PAL_LTPURP : P0C3 = PAL_WHITE   ; magic HUD, torches
        P1C1 = PAL_DKBRWN : P1C2 = PAL_LTBRWN : P1C3 = PAL_SKIN    ; Johanna
        P2C1 = PAL_DKRED  : P2C2 = PAL_LTRED  : P2C3 = PAL_GOLD    ; HP HUD, red equipment
        P3C1 = PAL_DKBLUE : P3C2 = PAL_LTBLUE : P3C3 = PAL_COPPER  ; blue/green equipment
        P4C1 = $90 : P4C2 = $02 : P4C3 = $04    ; walls
        P5C1 = $00 : P5C2 = $33 : P5C3 = $0F    ; skeletons
        P6C1 = $A2 : P6C2 = $A0 : P6C3 = $A1    ; blue-green tiles
        P7C1 = $43 : P7C2 = $40 : P7C3 = $41    ; maroon carpets

        characterset castle_stone
        asm
        ldx room_index
        lda castle_rooms,x
        tax
        lda castle_map_lo,x
        sta temp1               ; temp1 + 2 used for indirect jmp
        lda castle_map_hi,x
        sta temp2
        lda castle_obj_lo,x
        sta pointer
        lda castle_obj_hi,x
        sta pointer_hi
        lda room_index
        asl
        sta menu_map_index
        clc
        adc #1
        sta menu_map_index_2
        jmp (temp1)
end

castle_gold_pal
        P5C1 = $40 : P5C2 = $23 : P5C3 = $27    ; golds, browns

castle_maroon_pal
        ; override tile colors with maroons for carpeted stairs
        P6C1 = $42 : P6C2 = $40 : P6C3 = $40
        return

plot_castle_room_0
plot_castle_room_1
        menu_map_room[menu_map_index] = 2
        menu_map_room[menu_map_index_2] = 3
        memcpy current_map castle_room_1 280
        plotmapfile tiled/castle_room_1.tmx castle_room_1 0 0 20 14
plot_castle_bank5_return
        return

        data castle_room_0_obj
        $00
end

        data castle_room_1_obj
        TYPE_TORCH, $40, $B0,  TYPE_TORCH, $56, $B0,  TYPE_TORCH, $40, $20,  TYPE_TORCH, $56, $20,
        TYPE_SKELETON, $4A, $30,  $00
end

plot_castle_room_2
        menu_map_room[menu_map_index] = 10
        menu_map_room[menu_map_index_2] = 11
        plotmapfile tiled/castle_room_2.tmx castle_room_2 0 0 20 14
        memcpy current_map castle_room_2 280
        return

        data castle_room_2_obj
        $00
end
        dmahole 0

plot_castle_room_3
        menu_map_room[menu_map_index] = 4
        menu_map_room[menu_map_index_2] = 5
        plotmapfile tiled/castle_room_3.tmx castle_room_3 0 0 20 14
        memcpy current_map castle_room_3 280
        return

        data castle_room_3_obj
        $00
end

plot_castle_room_4
        menu_map_room[menu_map_index] = 8
        menu_map_room[menu_map_index_2] = 15
        plotmapfile tiled/castle_room_4.tmx castle_room_4 0 0 20 14
        memcpy current_map castle_room_4 280
        return

        data castle_room_4_obj
        $00
end

plot_castle_room_5
        menu_map_room[menu_map_index] = 10
        menu_map_room[menu_map_index_2] = 11
        plotmapfile tiled/castle_room_5.tmx castle_room_5 0 0 20 14
        memcpy current_map castle_room_5 280
        return

        data castle_room_5_obj
        TYPE_RSLIME, $68, $40, TYPE_RSLIME, $80, $40, TYPE_BLOOD, $80, $20, $00
end

plot_castle_room_6
        menu_map_room[menu_map_index] = 10
        menu_map_room[menu_map_index_2] = 3
        memcpy current_map castle_room_6 280
        plotmapfile tiled/castle_room_6.tmx current_map 0 0 20 14
        return

        data castle_room_6_obj
        $00
end

plot_castle_room_7
        menu_map_room[menu_map_index] = 4
        menu_map_room[menu_map_index_2] = 5
        plotmapfile tiled/castle_room_7.tmx castle_room_7 0 0 20 14
        memcpy current_map castle_room_7 280
        return

        data castle_room_7_obj
        $00
end


plot_castle_room_8
        goto load_castle_room_8

        data castle_room_8_obj
        $00
end

plot_castle_room_9
        goto load_castle_room_9 bank5

        data castle_room_9_obj
        $00
end

plot_castle_room_10
        goto load_castle_room_10 bank5

        data castle_room_10_obj
        $00
end

plot_castle_room_11
        goto load_castle_room_11 bank5

        data castle_room_11_obj
        $00
end

plot_castle_room_12
        goto load_castle_room_12 bank5

        data castle_room_12_obj
        TYPE_PRIEST, $58, $20,  $00
end

plot_castle_room_13
        goto load_castle_room_13 bank5

        data castle_room_13_obj
        TYPE_TORCH, $10, $20,
        TYPE_TORCH, $88, $20,
        TYPE_TORCH, $38, $40,
        TYPE_TORCH, $60, $40,
        TYPE_PRIEST, $50, $26,
        $00
end

plot_castle_room_14
        goto load_castle_room_14 bank5

        data castle_room_14_obj
        $00
end

plot_castle_room_15
        goto load_castle_room_15 bank5

        data castle_room_15_obj
        $00
end

plot_castle_room_16
        goto load_castle_room_16 bank5

        data castle_room_16_obj
        $00
end

plot_castle_room_17
        goto load_castle_room_17 bank5

        data castle_room_17_obj
        TYPE_TORCH, $18, $70, TYPE_TORCH, $80, $70, $00
end

plot_castle_room_18
        goto load_castle_room_18 bank5

        data castle_room_18_obj
        $00
end

plot_castle_room_19
        goto load_castle_room_19 bank5

        data castle_room_19_obj
        $00
end

plot_castle_room_20
        goto load_castle_room_20 bank5

        data castle_room_20_obj
        $00
end

plot_castle_room_21
        goto load_castle_room_21 bank5

        data castle_room_21_obj
        $00
end

plot_castle_room_22
        goto load_castle_room_22 bank5

        data castle_room_22_obj
        $00
end

plot_castle_room_23
        goto load_castle_room_23 bank5

        data castle_room_23_obj
        $00
end

plot_castle_room_24
        goto load_castle_room_24 bank5

        data castle_room_24_obj
        $00
end

plot_castle_room_25
        goto load_castle_room_25 bank5

        data castle_room_25_obj
        $00
end

        data castle_rooms
        00, 00, 00, 00, 00, 00, 00,
        24, 25, 00, 00, 00, 00, 00,
        23, 00, 16, 00, 14, 00, 00,
        19, 18, 13, 17, 11, 00, 00,
        21, 22, 12, 00, 06,  7,  8,
        20, 00, 02, 00, 05, 00,  9,
        15, 03, 01, 03, 04, 00, 10
end

test_walkable_castle
        asm
        ldx #0
twc_loop lda castle_walkable_tiles,x
        cmp move_tile_1
        bne twctile2
        pha
        lda #1
        sta walkable_1
        pla
twctile2 cmp move_tile_2
        bne twc_next
        lda #1
        sta walkable_2
        ; optimization: bypass the rest of the array if both tiles walkable
        ;   further optimization possible by sorting arrays by tile frequency
        lda walkable_1
        bne twc_walkable
twc_next inx
        cpx #castle_walkable_tiles_length
        bne twc_loop
        lda walkable_1
        beq twc_done
        lda walkable_2
        beq twc_done
twc_walkable
        sta walkable
        jmp .walkable_return
twc_done
tfc_flags
        lda flags
        and #%00010000
        bne tfc_done

test_floatable_castle
        ldx #0
tfc_loop lda castle_floatable_tiles,x
        cmp move_tile_1
        bne tfctile2
        pha
        lda #1
        sta floatable_1
        pla
tfctile2 cmp move_tile_2
        bne tfc_next
        lda #1
        sta floatable_2
        lda floatable_1
        bne tfc_floatable
tfc_next inx
        cpx #castle_floatable_tiles_length
        bne tfc_loop
        lda floatable_1
        beq tfc_done
        lda floatable_2
        beq tfc_done
tfc_floatable
        sta floatable
tfc_done jmp .walkable_return
end

        data castle_walkable_tiles
        $10, $16, $18, $1A, $1C, $1E, $20, $22, $24, $26, $28, $2A, $2C, $2E,
        $30, $32, $34, $36, $38, $3A, $3C, $3E, $40, $42, $44, $46, $48, $4A
end

        data castle_floatable_tiles
        $4C, $4E, $50, $52, $54, $56, $58
end

torch_tile_block_castle
        ; block with a floatable tile so projectiles can hit torch
        pokechar current_map peekX peekY 20 14 castle_floatable_tiles
        return

torch_tile_unblock_castle
        ; the poked tile doesn't affect visuals since those are plotted from ROM
        pokechar current_map peekX peekY 20 14 castle_walkable_tiles
        return

;==============================================================================
; PRIEST & SKELETON AI
;------------------------------------------------------------------------------
; Walks slowly until aligned with player, then casts dark spark or sword attack
;==============================================================================
priest_ai
        if flags{6} then goto priest_cast_2
priest_dir
        if timer then goto priest_walk
        timer = 20
        temp1 = rand
        if temp1 > 128 then priest_vert

priest_horiz
        if Xposition >= player_Xpos then priest_left

priest_right
        object_facing[index] = DIR_RIGHT
        Xdirection = DIR_RIGHT
        Ydirection = 0
        goto priest_walk

priest_left
        object_facing[index] = DIR_LEFT
        Xdirection = DIR_LEFT
        Ydirection = 0
        goto priest_walk

priest_vert
        if Yposition < player_Ypos then priest_down

priest_up
        object_facing[index] = DIR_UP
        Xdirection = 0
        Ydirection = DIR_UP
        goto priest_walk

priest_down
        object_facing[index] = DIR_DOWN
        Xdirection = 0
        Ydirection = DIR_DOWN

priest_walk
        timer = timer - 1
        if Xdirection = DIR_LEFT then priest_walk_x
        if Xdirection = DIR_RIGHT then priest_walk_x
        if Ydirection = DIR_UP then priest_walk_y
        if Ydirection = DIR_DOWN then priest_walk_y
        
priest_walk_x
        if object_type[index] <> TYPE_PRIEST then skel_melee_x
priest_test_horz
        gosub priest_box
        if temp4 < player_Ypos && temp5 >= temp6 then goto priest_cast_horiz
priest_walk_x_2
        Xvelocity = Xvelocity + move_speed : Yvelocity = 0
        goto priest_walk_anim

priest_walk_y
        if object_type[index] <> TYPE_PRIEST then skel_melee_y
priest_test_vert
        gosub priest_box
        if temp1 < player_Xpos && temp2 >= temp3 then goto priest_cast_vert
priest_walk_y_2
        Yvelocity = Yvelocity + move_speed : Xvelocity = 0

priest_walk_anim
        if Ydirection = DIR_DOWN then frame = 0
        if Ydirection = DIR_UP then frame = 2
        if Xdirection = DIR_LEFT then frame = 4
        if Xdirection = DIR_RIGHT then frame = 6
        if animation_frame then frame = frame + 1
        goto priest_return

skel_melee_x
        gosub test_melee
        if !temp6 then goto priest_walk_x_2

priest_cast_horiz
        object_facing[index] = DIR_LEFT
        if Xposition < player_Xpos then object_facing[index] = DIR_RIGHT
        goto priest_cast

skel_melee_y
        gosub test_melee
        if !temp6 then goto priest_walk_y_2

priest_cast_vert
        object_facing[index] = DIR_UP
        if Yposition < player_Ypos then object_facing[index] = DIR_DOWN

        ; prep the priest/skeleton object for spawning their attacks
priest_cast
        const PRIEST_CAST_FRAMES = 20
        gosub find_new_object
        if no_empty_slot then priest_return
        ; set the spawned object slot's parent to the index of this object
        object_parent[spawn_index] = index
        flags{6} = 1
        frame_index = object_facing[index]
        frame = priest_cast_frames[frame_index]
        asm
        lda #0
        sta Xvelocity_hi
        sta Xvelocity_lo
        sta Yvelocity_hi
        sta Yvelocity_lo
end
        timer = PRIEST_CAST_FRAMES

priest_cast_2
        if object_type[index] = TYPE_SKELETON then goto skel_sword
        timer = timer - 1
        if timer then goto priest_return

        ; todo: roll off into its own spawn projectile subroutine
        const DARKSPARK_SPEED_HI = 2
        const DARKSPARK_SPEED_LO = 0
        const DARKSPARK_DAMAGE = 6
        playsfx sfx_nonobounce

load_darkspark
        asm
        ldx spawn_index
        ldy index
        lda #TYPE_DARKSPARK
        sta object_type,x
        lda #DARKSPARK_SPEED_HI
        sta object_vel_cap_hi,x
        sta object_speed_hi,x
        lda #DARKSPARK_SPEED_LO
        sta object_vel_cap_lo,x
        sta object_speed_lo,x
        lda #DARKSPARK_DAMAGE
        sta object_damage,x
        jsr set_cast_direction
end
        flags{6} = 0

priest_return
        return


priest_box
        temp1 = Xposition - 2
        temp2 = Xposition + 14
        temp3 = player_Xpos + 12
        temp4 = Yposition - 4
        temp5 = Yposition + 20
        temp6 = player_Ypos + 16
        return

        data priest_cast_frames
        0, 9, 8, 10, 11
end

        const SKELSWORD_DAMAGE = 10

skel_sword
        if flags{7} then priest_return
        asm
        jsr .position_sword
        ldx spawn_index
        ldy index
        lda #TYPE_SKELSWORD
        sta object_type,x
        lda #0
        sta object_flags,x
        sta object_vel_cap_hi,x
        sta object_speed_hi,x
        sta object_vel_cap_lo,x
        sta object_speed_lo,x
        lda #SKELSWORD_DAMAGE
        sta object_damage,x
        sta object_hp,x ; dummy stat but needed for damage code
        lda temp1
        sta object_Xpos,x
        lda temp2
        sta object_Ypos,x
        lda temp5
        sta object_frame,x
        lda object_facing,y
        sta object_facing,x
        lda #1
        sta object_timer,x
end
        flags{7} = 1
        goto priest_return

        const RETRACT_FRAMES = 4

;==============================================================================
; SKELSWORD AI
;------------------------------------------------------------------------------
; Exists for ATTACK_FRAMES duration, then kills itself
;==============================================================================
skelsword_ai
        temp1 = object_parent[index]
        ; if Skeleton has died, remove sword instantly
        if !object_type[temp1] then ss_kill
        timer = timer - 1
        if flags{7} then ss_retract_2
        if timer then return
        if flags{6} then ss_retract
        timer = ATTACK_FRAMES
        flags{6} = 1
        return

ss_retract
        timer = RETRACT_FRAMES
        flags{7} = 1

ss_retract_2
        if !timer then ss_kill
        return  ; bypass retract code until object priority handling is added
        if object_facing[index] = DIR_DOWN  then Yposition = Yposition - 4 : return
        if object_facing[index] = DIR_UP    then Yposition = Yposition + 4 : return
        if object_facing[index] = DIR_LEFT  then Xposition = Xposition + 2 : return
        Xposition = Xposition - 2 : return

ss_kill
        asm
        lda #0
        ldx temp1
        ldy index
        ; unset flags 6 and 7 on parent skeleton
        sta object_flags,x
        sta object_type,y
        rts
end

obj_priest_stats
        object_hp[obj_index] = 5
        object_vel_cap_hi[obj_index] = 1
        object_vel_cap_lo[obj_index] = 0
        object_damage[obj_index] = 4
        object_def[obj_index] = 0
        object_mdef[obj_index] = 2
        object_friction_hi[obj_index] = 1
        object_friction_lo[obj_index] = 0
        object_speed_hi[obj_index] = 0
        object_speed_lo[obj_index] = 20
        object_flags[obj_index] = 0
        goto obj_next_stats

obj_skel_stats
        object_hp[obj_index] = 5
        object_vel_cap_hi[obj_index] = 1
        object_vel_cap_lo[obj_index] = 0
        object_damage[obj_index] = 4
        object_def[obj_index] = 0
        object_mdef[obj_index] = 2
        object_friction_hi[obj_index] = 1
        object_friction_lo[obj_index] = 0
        object_speed_hi[obj_index] = 0
        object_speed_lo[obj_index] = 20
        object_flags[obj_index] = 0
        goto obj_next_stats

;==============================================================================
; RED SLIME AI
;------------------------------------------------------------------------------
; A Red Slime draws near!
; Command?
;==============================================================================
redslime_ai
        ; slimes have no physical defense on their squished frame
        if !animation_frame then temp1 = RSLIME_DEF : goto rslime_chase
        ; this will allow them to split into mini-slimes
        temp1 = 0
rslime_chase
        object_def[index] = temp1
        gosub get_player_pos
        gosub go_to_destination
        return

obj_redslime_stats
        const RSLIME_DROP_RATE = 128
        const RSLIME_HP = 4
        const MRSLIME_HP = RSLIME_HP / 2
        const RSLIME_VEL_CAP_HI = 1
        const RSLIME_VEL_CAP_LO = 0
        const RSLIME_DAMAGE = 8
        const RSLIME_DEF = 255
        const RSLIME_MDEF = 0
        const MRSLIME_DEF = 0
        const MRSLIME_MDEF = 0
        const RSLIME_FRICTION_HI = 1
        const RSLIME_FRICTION_LO = 0
        const RSLIME_SPEED_HI = 0
        const RSLIME_SPEED_LO = 5
        object_hp[obj_index] = RSLIME_HP
        object_vel_cap_hi[obj_index] = RSLIME_VEL_CAP_HI
        object_vel_cap_lo[obj_index] = RSLIME_VEL_CAP_LO
        object_damage[obj_index] = RSLIME_DAMAGE
        object_def[obj_index] = RSLIME_DEF
        object_mdef[obj_index] = RSLIME_MDEF
        object_friction_hi[obj_index] = RSLIME_FRICTION_HI
        object_friction_lo[obj_index] = RSLIME_FRICTION_LO
        object_speed_hi[obj_index] = RSLIME_SPEED_HI
        object_speed_lo[obj_index] = RSLIME_SPEED_LO
        object_flags[obj_index] = 0
        goto obj_next_stats

split_rslime
        ; replace slime mobj with mini slime
        object_type[index] = TYPE_MRSLIME
        object_hp[index] = MRSLIME_HP
        object_def[index] = MRSLIME_DEF
        temp1 = object_Xpos[index]
        temp2 = object_Ypos[index]
        ; mini slime is moved to the left of the parent slime's pos
        object_Xpos[index] = object_Xpos[index] - 1
        gosub find_new_object
        index = spawn_index
        ; if no slots, the slime just becomes a single mini slime
        if no_empty_slot then object_Xpos[index] = temp1 : cc_next
        ; initialize the new mini slime object
        object_type[index] = TYPE_MRSLIME
        object_hp[index] = MRSLIME_HP
        object_vel_cap_hi[index] = RSLIME_VEL_CAP_HI
        object_vel_cap_lo[index] = RSLIME_VEL_CAP_LO
        object_damage[index] = RSLIME_DAMAGE
        object_def[index] = MRSLIME_DEF
        object_mdef[index] = MRSLIME_MDEF
        object_friction_hi[index] = RSLIME_FRICTION_HI
        object_friction_lo[index] = RSLIME_FRICTION_LO
        object_speed_hi[index] = RSLIME_SPEED_HI
        object_speed_lo[index] = RSLIME_SPEED_LO
        ; mini slime spawns to the right of the parent slime's pos
        object_Xpos[index] = temp1 + 9
        object_Ypos[index] = temp2
        goto cc_next

plot_priest
        plotsprite priest0 1 Xposition Yposition frame
        goto plot_next

plot_darkspark
        plotsprite darkspark0 0 Xposition Yposition frame
        goto plot_next

plot_skeleton
        plotsprite skeleton0 5 Xposition Yposition frame
        goto plot_next

plot_skelsword
        plotsprite sword0 0 Xposition Yposition frame
        goto plot_next

plot_rslime
        PLOTSPRITE c_slime0 7 Xposition Yposition animation_frame
        goto plot_next

plot_mrslime
        PLOTSPRITE c_minislime0 7 Xposition Yposition animation_frame
        goto plot_next

plot_blood
        plotsprite blood 2 Xposition Yposition 0
        goto plot_next

;==============================================================================
; BANK 5
;------------------------------------------------------------------------------
; Cathedral graphics, maps, AI
;==============================================================================
        bank 5
        incgraphic gfx/tiles/castle_stone.png  160A 1 0 2 3 4
        incgraphic gfx/tiles/castle_tile.png  160A 1 0 2 3 6
        incgraphic gfx/tiles/castle_carpet.png  160A 1 0 2 3 7
        incgraphic gfx/tiles/castle_tables.png 160A 1 0 2 3 5
        incgraphic gfx/tiles/castle_hud.png 160A 0 3 1 2
        incgraphic gfx/sprites/blood.png 160A 0 1
        incgraphic gfx/sprites/darkspark0.png 160A 0 2 1 3
        incgraphic gfx/sprites/darkspark1.png 160A 2 0 1 3
        incgraphic gfx/sprites/darkspark2.png 160A 1 0
        incgraphic gfx/sprites/priest0.png 160A 0 2 1 3
        incgraphic gfx/sprites/priest1.png 160A 0 2 1 3
        incgraphic gfx/sprites/priest2.png 160A 0 1 2
        incgraphic gfx/sprites/priest3.png 160A 0 1 2
        incgraphic gfx/sprites/priest4.png 160A 0 2 1 3
        incgraphic gfx/sprites/priest5.png 160A 0 2 1 3
        incgraphic gfx/sprites/priest6.png 160A 0 2 1 3
        incgraphic gfx/sprites/priest7.png 160A 0 2 1 3
        incgraphic gfx/sprites/priest8.png 160A 0 2 1 3
        incgraphic gfx/sprites/priest9.png 160A 0 1 2 3
        incgraphic gfx/sprites/priest10.png 160A 0 2 1 3
        incgraphic gfx/sprites/priest11.png 160A 0 2 1 3
        incgraphic gfx/sprites/skeleton0.png 160A 0 3 1 2
        incgraphic gfx/sprites/skeleton1.png 160A 0 3 1 2
        incgraphic gfx/sprites/skeleton2.png 160A 0 3 1 2
        incgraphic gfx/sprites/skeleton3.png 160A 0 3 1 2
        incgraphic gfx/sprites/skeleton4.png 160A 0 3 1 2
        incgraphic gfx/sprites/skeleton5.png 160A 0 3 1 2
        incgraphic gfx/sprites/skeleton6.png 160A 0 3 1 2
        incgraphic gfx/sprites/skeleton7.png 160A 0 3 1 2
        incgraphic gfx/sprites/skeleton8.png 160A 0 3 1 2
        incgraphic gfx/sprites/skeleton9.png 160A 0 3 1 2
        incgraphic gfx/sprites/skeleton10.png 160A 0 3 1 2
        incgraphic gfx/sprites/skeleton11.png 160A 0 3 1 2
        incgraphic gfx/sprites/c_slime0.png 160A 0 2 1 3
        incgraphic gfx/sprites/c_slime1.png 160A 0 2 1 3
        incgraphic gfx/sprites/c_minislime0.png 160A 0 2 1 3
        incgraphic gfx/sprites/c_minislime1.png 160A 0 2 1 3

        incmapfile tiled/castle_room_8.tmx
        incmapfile tiled/castle_room_9.tmx
        incmapfile tiled/castle_room_10.tmx
        incmapfile tiled/castle_room_11.tmx
        incmapfile tiled/castle_room_12.tmx
        incmapfile tiled/castle_room_13.tmx
        incmapfile tiled/castle_room_14.tmx
        incmapfile tiled/castle_room_15.tmx
        incmapfile tiled/castle_room_16.tmx
        incmapfile tiled/castle_room_17.tmx 
        incmapfile tiled/castle_room_18.tmx
        incmapfile tiled/castle_room_19.tmx
        incmapfile tiled/castle_room_20.tmx
        incmapfile tiled/castle_room_21.tmx
        incmapfile tiled/castle_room_22.tmx
        incmapfile tiled/castle_room_23.tmx
        incmapfile tiled/castle_room_24.tmx
        incmapfile tiled/castle_room_25.tmx

load_castle_room_8
        menu_map_room[menu_map_index] = 6
        menu_map_room[menu_map_index_2] = 13
        plotmapfile tiled/castle_room_8.tmx castle_room_8 0 0 20 14
        memcpy current_map castle_room_8 280
        goto plot_castle_bank5_return bank4

load_castle_room_9
        menu_map_room[menu_map_index] = 10
        menu_map_room[menu_map_index_2] = 11
        plotmapfile tiled/castle_room_9.tmx castle_room_9 0 0 20 14
        memcpy current_map castle_room_9 280
        goto plot_castle_bank5_return bank4

load_castle_room_10
        menu_map_room[menu_map_index] = 10
        menu_map_room[menu_map_index_2] = 11
        plotmapfile tiled/castle_room_10.tmx castle_room_10 0 0 20 14
        memcpy current_map castle_room_10 280
        goto plot_castle_bank5_return bank4

load_castle_room_11
        menu_map_room[menu_map_index] = 2
        menu_map_room[menu_map_index_2] = 11
        plotmapfile tiled/castle_room_11.tmx castle_room_11 0 0 20 14
        memcpy current_map castle_room_11 280
        goto plot_castle_bank5_return bank4

load_castle_room_12
        menu_map_room[menu_map_index] = 10
        menu_map_room[menu_map_index_2] = 11
        plotmapfile tiled/castle_room_12.tmx castle_room_12 0 0 20 14
        memcpy current_map castle_room_12 280
        goto castle_gold_pal bank4

load_castle_room_13
        menu_map_room[menu_map_index] = 6
        menu_map_room[menu_map_index_2] = 7
        plotmapfile tiled/castle_room_13.tmx castle_room_13 0 0 20 14
        memcpy current_map castle_room_13 280
        goto castle_gold_pal bank4

load_castle_room_14
        if !pw_success then in_save_room = 1
        pw_success = 0
        save_room_index = 1
        menu_map_room[menu_map_index] = 12
        menu_map_room[menu_map_index_2] = 13
        plotmapfile tiled/castle_room_14.tmx castle_room_14 0 0 20 14
        memcpy current_map castle_room_14 280
        goto castle_gold_pal bank4

load_castle_room_15
        menu_map_room[menu_map_index] = 14
        menu_map_room[menu_map_index_2] = 9
        plotmapfile tiled/castle_room_15.tmx castle_room_15 0 0 20 14
        memcpy current_map castle_room_15 280
        goto plot_castle_bank5_return bank4

        dmahole 0

load_castle_room_16
        menu_map_room[menu_map_index] = 12
        menu_map_room[menu_map_index_2] = 13
        plotmapfile tiled/castle_room_16.tmx castle_room_16 0 0 20 14
        memcpy current_map castle_room_16 280
        goto plot_castle_bank5_return bank4

load_castle_room_17
        menu_map_room[menu_map_index] = 4
        menu_map_room[menu_map_index_2] = 5
        plotmapfile tiled/castle_room_17.tmx castle_room_17 0 0 20 14
        memcpy current_map castle_room_17 280
        goto plot_castle_bank5_return bank4

load_castle_room_18
        menu_map_room[menu_map_index] = 4
        menu_map_room[menu_map_index_2] = 5
        plotmapfile tiled/castle_room_18.tmx castle_room_18 0 0 20 14
        memcpy current_map castle_room_18 280
        goto plot_castle_bank5_return bank4

load_castle_room_19
        menu_map_room[menu_map_index] = 10
        menu_map_room[menu_map_index_2] = 3
        plotmapfile tiled/castle_room_19.tmx castle_room_19 0 0 20 14
        memcpy current_map castle_room_19 280
        goto plot_castle_bank5_return bank4

load_castle_room_20
        menu_map_room[menu_map_index] = 10
        menu_map_room[menu_map_index_2] = 11
        plotmapfile tiled/castle_room_20.tmx castle_room_20 0 0 20 14
        memcpy current_map castle_room_20 280
        goto plot_castle_bank5_return bank4

load_castle_room_21
        menu_map_room[menu_map_index] = 10
        menu_map_room[menu_map_index_2] = 11
        plotmapfile tiled/castle_room_21.tmx castle_room_21 0 0 20 14
        memcpy current_map castle_room_21 280
        ; secret passage!
        pokechar current_map 14 6 20 14 $10
        pokechar current_map 14 7 20 14 $10
        goto plot_castle_bank5_return bank4

load_castle_room_22
        menu_map_room[menu_map_index] = 8
        menu_map_room[menu_map_index_2] = 15
        plotmapfile tiled/castle_room_22.tmx castle_room_22 0 0 20 14
        memcpy current_map castle_room_22 280
        goto plot_castle_bank5_return bank4

load_castle_room_23
        menu_map_room[menu_map_index] = 10
        menu_map_room[menu_map_index_2] = 11
        plotmapfile tiled/castle_room_23.tmx castle_room_23 0 0 20 14
        memcpy current_map castle_room_23 280
        goto plot_castle_bank5_return bank4

load_castle_room_24
        menu_map_room[menu_map_index] = 12
        menu_map_room[menu_map_index_2] = 7
        plotmapfile tiled/castle_room_24.tmx castle_room_24 0 0 20 14
        memcpy current_map castle_room_24 280
        goto plot_castle_bank5_return bank4

load_castle_room_25
        menu_map_room[menu_map_index] = 4
        menu_map_room[menu_map_index_2] = 17
        plotmapfile tiled/castle_room_25.tmx castle_room_25 0 0 20 14
        memcpy current_map castle_room_25 280
        goto plot_castle_bank5_return bank4

;==============================================================================
; BANK 9
;------------------------------------------------------------------------------
; Permanently loaded bank. Contains sprites and code used with every tileset
;==============================================================================
        bank 9
        incgraphic gfx/sprites/heroine0.png  160B 0 4 5 3 6 1 ; FRAME_DOWN
        incgraphic gfx/sprites/heroine1.png  160B 0 4 5 3 6 1 ; FRAME_DOWN_2
        incgraphic gfx/sprites/heroine2.png  160B 0 4 5 6 3   ; FRAME_UP
        incgraphic gfx/sprites/heroine3.png  160B 0 4 5 6 3   ; FRAME_UP_2
        incgraphic gfx/sprites/heroine4.png  160B 0 4 5 6 3 1 ; FRAME_LEFT
        incgraphic gfx/sprites/heroine5.png  160B 0 4 5 6 3 1 ; FRAME_LEFT_2
        incgraphic gfx/sprites/heroine6.png  160B 0 4 5 3 6 1 ; FRAME_RIGHT
        incgraphic gfx/sprites/heroine7.png  160B 0 4 5 3 6 1 ; FRAME_RIGHT_2
        incgraphic gfx/sprites/heroine8.png  160B 0 4 5 3 6 1 ; FRAME_ATK_D
        incgraphic gfx/sprites/heroine9.png  160B 0 4 6 5 3   ; FRAME_ATK_U
        incgraphic gfx/sprites/heroine10.png 160B 0 4 5 6 3 1 ; FRAME_ATK_L
        incgraphic gfx/sprites/heroine11.png 160B 0 4 5 3 6 1 ; FRAME_ATK_R
        incgraphic gfx/sprites/link.png      160B 0 4 5 6 3 1 ; FRAME_CHANT (bugged if heroine12.png is used?)
        incgraphic gfx/sprites/heroine13.png 160B 0 4 5 3 6
        incgraphic gfx/sprites/sword0.png 160A 0 1 3
        incgraphic gfx/sprites/sword1.png 160A 0 3 1
        incgraphic gfx/sprites/sword2.png 160A 0 1 3
        incgraphic gfx/sprites/sword3.png 160A 0 1 3
        incgraphic gfx/sprites/shield.png 160A 0 2 1
        incgraphic gfx/sprites/torch0.png 160B 0 1 2 3 6 5 4
        incgraphic gfx/sprites/torch1.png 160B 0 1 2 3 5 6 4
        incgraphic gfx/sprites/torch2.png 160B 0 1 2 3 6 4 5
        incgraphic gfx/sprites/torch3.png 160B 0 1 2 6 4 5
        incgraphic gfx/sprites/hp.png 160B 0 3 7 8 1 2
        incgraphic gfx/sprites/mp.png 160A 0 3 1
        incgraphic gfx/sprites/bar0.png 160A 0 1
        incgraphic gfx/sprites/bar1.png 160A 0 2 1
        incgraphic gfx/sprites/bar2.png 160A 0 2 1
        incgraphic gfx/sprites/bar3.png 160A 0 2 1
        incgraphic gfx/sprites/bar4.png 160A 0 2 1
        incgraphic gfx/sprites/bar5.png 160A 0 2 1
        incgraphic gfx/sprites/bar6.png 160A 0 2 1
        incgraphic gfx/sprites/bar7.png 160A 0 2 1
        incgraphic gfx/sprites/bar8.png 160A 0 2 1
        incgraphic gfx/sprites/coin.png 160A 0 3 2
        incgraphic gfx/sprites/prism.png 160A 0 3 2 1
        incgraphic gfx/sprites/chimkin.png 160A 0 3 1 2
        incgraphic gfx/sprites/fireball0.png 160A
        incgraphic gfx/sprites/fireball1.png 160A
        incgraphic gfx/sprites/fireball2.png 160A
        incgraphic gfx/sprites/fireball3.png 160A
        incgraphic gfx/sprites/fireball4.png 160A
        incgraphic gfx/sprites/potion0.png 160A 0 2 3 1
        incgraphic gfx/sprites/armor0.png 160A 0 2 1

;==============================================================================
; LOAD OBJECTS
;------------------------------------------------------------------------------
; Fills all 16 object slots with type and position data from ROM,
; then interates through each type to set object properties
; Utilizes pointers so multiple maps can reuse the same object data if desired
;==============================================================================
load_objects
        temp1 = 0
        for obj_index = 1 to MAX_OBJECTS
        object_type[obj_index] = pointer[[temp1]]
        if !object_type[obj_index] then pad_objects
        temp1 = temp1 + 1
        object_Xpos[obj_index] = pointer[[temp1]]
        temp1 = temp1 + 1
        object_Ypos[obj_index] = pointer[[temp1]]
        temp1 = temp1 + 1
        next
        ; TODO: pointer table for stats as well
pad_objects
        for index = obj_index to MAX_OBJECTS
        object_type[index] = 0
        next
        for obj_index = 1 to MAX_MAP_OBJECTS
        if !object_type[obj_index] then next_obj_stats
        if object_type[obj_index] = TYPE_WOLF then obj_wolf_stats
        if object_type[obj_index] = TYPE_TORCH then obj_torch_stats
        if object_type[obj_index] = TYPE_SLIME then obj_slime_stats
        if object_type[obj_index] = TYPE_MSLIME then obj_slime_stats : object_hp[obj_index] = MSLIME_HP : object_def[obj_index] = MSLIME_DEF
        if object_type[obj_index] = TYPE_RSLIME then obj_redslime_stats
        if object_type[obj_index] = TYPE_MRSLIME then obj_redslime_stats : object_hp[obj_index] = MRSLIME_HP : object_def[obj_index] = MRSLIME_DEF
        if object_type[obj_index] = TYPE_RAVEN then obj_raven_stats
        if object_type[obj_index] = TYPE_PRIEST then obj_priest_stats
        if object_type[obj_index] = TYPE_SKELETON then obj_skel_stats


obj_next_stats
        next
        return

obj_torch_stats
        object_hp[obj_index] = 1
        object_vel_cap_hi[obj_index] = 0
        object_vel_cap_lo[obj_index] = 0
        object_damage[obj_index] = 0
        object_friction_hi[obj_index] = 0
        object_friction_lo[obj_index] = 0
        object_speed_hi[obj_index] = 0
        object_speed_lo[obj_index] = 0
        object_flags[obj_index] = 0
        goto obj_next_stats

load_map
        clearscreen
        displaymode 160A
        adjustvisible 0 14
        if tileset = T_FOREST then gosub load_forest bank2
        if tileset = T_CASTLE then gosub load_castle bank4
        savescreen
        if !save_objects then gosub load_objects
        asm
        lda #0
        sta reload_map
        sta save_objects
end
        if exit_dir = EXIT_SOUTH then player_Ypos = 16  : player_Ydir = DIR_DOWN
        if exit_dir = EXIT_NORTH then player_Ypos = 204 : player_Ydir = DIR_UP
        if exit_dir = EXIT_EAST  then player_Xpos = 148 : player_Xdir = DIR_LEFT
        if exit_dir = EXIT_WEST  then player_Xpos = 8  : player_Xdir = DIR_RIGHT
        exit_dir = EXIT_NONE

field_handler
        if reload_map = 1 then goto load_map
        goto player_handler
player_handler_done
        gosub object_handler
        ; set by close menu, needed to make torches block movement after menu access
        torch_reblock = 0
        gosub check_collisions

        restorescreen
        if debug_time then BACKGRND = $06
        ; Iterates through all objects and determines which sprites need to be plotted by type
        for index = 1 to 15
        if !object_type[index] then goto plot_next
        if object_type[index] = TYPE_SPAWNER then plot_next
        Xposition = object_Xpos[index] : Yposition = object_Ypos[index] : frame = object_frame[index]
        if object_type[index] = TYPE_WOLF then plot_wolf
        if object_type[index] = TYPE_TORCH then plot_torch
        if object_type[index] = TYPE_COIN then plot_coin
        if object_type[index] = TYPE_PRISM then plot_prism
        if object_type[index] = TYPE_SLIME then plot_slime
        if object_type[index] = TYPE_MSLIME then plot_minislime
        if object_type[index] = TYPE_RSLIME then plot_rslime
        if object_type[index] = TYPE_MRSLIME then plot_mrslime
        if object_type[index] = TYPE_RAVEN then plot_raven
        if object_type[index] = TYPE_PRIEST then plot_priest
        if object_type[index] = TYPE_SKELETON then plot_skeleton
        if object_type[index] = TYPE_FOOD then plot_food
        if object_type[index] = TYPE_ITEM1 then plot_item1
        if object_type[index] = TYPE_ARMOR2 then plot_armor2
        if object_type[index] = TYPE_FIREBALL then plot_fireball
        if object_type[index] = TYPE_DARKSPARK then plot_darkspark
        if object_type[index] = TYPE_SKELSWORD then plot_skelsword
        if object_type[index] = TYPE_BLOOD then plot_blood
plot_next
        next
        ; Plot the player, their shield, and sword if attacking
        if player_state = STATE_CHANT then plotsprite link 0 player_Xpos player_Ypos 0 : goto plot_hud
        if player_state = STATE_ATTACK then plotsprite sword0 sword_pal sword_Xpos sword_Ypos sword_frame
        plotsprite heroine0 0 player_Xpos player_Ypos player_frame
        if player_state = STATE_DEATH then goto plot_hud
        ; TODO: Multiple shield frames depending on direction/state
        if player_shield then plotsprite shield shield_pal shield_Xpos shield_Ypos shield_frame
        if debug_time then BACKGRND = bg_color
plot_hud
        gosub draw_hud
        if debug_hud then gosub plot_debug_hud
        goto main

plot_torch
        temp1 = animation_frame
        if tileset = T_CASTLE then temp1 = temp1 + 2
        PLOTSPRITE torch0 0 Xposition Yposition temp1
        goto plot_next

plot_coin
        plotsprite coin 3 Xposition Yposition 0
        goto plot_next

plot_prism
        plotsprite prism 0 Xposition Yposition 0
        goto plot_next

plot_food
        plotsprite chimkin 1 Xposition Yposition 0
        goto plot_next

plot_item1
        plotsprite potion0 0 Xposition Yposition 0
        goto plot_next

plot_armor2
        plotsprite armor0 2 Xposition Yposition 0
        goto plot_next

plot_fireball
        plotsprite fireball0 2 Xposition Yposition frame
        goto plot_next


;==============================================================================
; DRAW HUD
;------------------------------------------------------------------------------
; Draws the player's HP and MP bar in zones 1-2 using sprites.
; Bars must be plotted in separate zones or there isn't enough DMA time
;==============================================================================
draw_hud
        plotsprite  hp   0  8  0       ; HP is 160B
        plotsprite  bar0 2 24  0 hp_seg_1
        ; prep plot_par to draw the rest of the HP segments
        Xposition = 32
        asm
        lda #0
        sta Yposition
        sta temp1
end
        temp2 = 4
        temp3 = (2 * 32)
        gosub plot_bar
        plotsprite  mp   0  8 16        ; Need to use plotsprite here to avoid rendering error on MP bar
        ; prep plot_bar for MP bar
        Xposition = 24
        Yposition = 16
        temp1 = 5
        temp2 = 10
        temp3 = 0
        ; code runs directly into 
plot_bar
        for index = temp1 to temp2
        frame = hp_seg_2[index]
        PLOTSPRITE4 bar0 temp3 Xposition Yposition frame
        Xposition = Xposition + 8
        next
        return

plot_debug_hud
        if tileset = T_CASTLE then plot_hud_castle
        ; plotvalue hud 0 player_hp 2 72 0
        ; plotvalue hud 0 player_mp 2 72 1
        plotvalue hud 0 player_Xpos 4 32 12
        plotvalue hud2 0 move_tile_1 4 32 13
        ; plotvalue hud 0 room_index 2 32 13
        ; plotvalue hud 0 room 2 48 13
        plotvalue hud 0 input_buffer 16 16 13
        ; plotvalue hud 0 chant_input 2 8 13
        ; plotvalue hud 0 retract_counter 2 64 13
        return

plot_hud_castle
        plotvalue castle_hud 0 player_Xpos 2 32 12
        plotvalue castle_hud 0 player_Ypos 2 48 12
        plotvalue castle_hud 0 move_tile_1 4 32 13
        return

open_menu
        gosub clear_palettes
        ; TODO: Should previously opened submenu be remembered?
        menu = MENU_MAIN
        menu_debounce = 1
        pause_debounce = 1
        goto menu_init bank3

followplayer
        if Xposition > player_Xpos then Xvelocity = Xvelocity + move_speed : Xdirection = DIR_LEFT
        if Xposition < player_Xpos then Xvelocity = Xvelocity + move_speed : Xdirection = DIR_RIGHT
        if Yposition > player_Ypos then Yvelocity = Yvelocity + move_speed : Ydirection = DIR_UP
        if Yposition < player_Ypos then Yvelocity = Yvelocity + move_speed : Ydirection = DIR_DOWN
        return

get_player_pos
        Xdestination = player_Xpos : Ydestination = player_Ypos
        return

get_player_dir
        Xdirection = player_Xdir
        Ydirection = player_Ydir
        return

go_to_destination
        if Xposition > Xdestination then Xvelocity = Xvelocity + move_speed : Xdirection = DIR_LEFT
        if Xposition < Xdestination then Xvelocity = Xvelocity + move_speed : Xdirection = DIR_RIGHT
        if Yposition > Ydestination then Yvelocity = Yvelocity + move_speed : Ydirection = DIR_UP
        if Yposition < Ydestination then Yvelocity = Yvelocity + move_speed : Ydirection = DIR_DOWN
        if Xposition = Xdestination then flags{3} = 0
        if Yposition = Ydestination then flags{3} = 0
        return

swoop_X
        return

swoop_Y
        return

;==============================================================================
; TEST MELEE
;------------------------------------------------------------------------------
; Can object hit player with melee attack?
; ** temp1: object X to left of player
; ** temp2: object X to right of player
; ** temp3: incremented on each successful melee range check
; ** temp4: object Y above player
; ** temp5: object Y below player
; ** temp6: if set, player within melee range
;==============================================================================
test_melee
        temp6 = 0
        if object_facing[index] = DIR_UP then melee_up
        if object_facing[index] = DIR_DOWN then melee_down
        if object_facing[index] = DIR_LEFT then melee_left
melee_right
        temp1 = Xposition
        temp2 = Xposition + 16
        temp4 = Yposition - 8
        temp5 = Yposition + 16
        goto melee_range

melee_up
        temp1 = Xposition - 4
        temp2 = Xposition + 8
        temp4 = Yposition
        temp5 = Yposition - 24
        goto melee_range

melee_down
        temp1 = Xposition - 4
        temp2 = Xposition + 8
        temp4 = Yposition + 24
        temp5 = Yposition
        goto melee_range

melee_left
        temp1 = Xposition - 16
        temp2 = Xposition
        temp4 = Yposition - 8
        temp5 = Yposition + 16

melee_range
        if player_Xpos >= temp1 && player_Xpos < temp2 then temp3 = 1
        if player_Ypos >= temp4 && player_Ypos < temp5 then temp3 = temp3 + 1
        if temp3 > 1 then temp6 = 1
        return

;==============================================================================
; POSITION SWORD
;------------------------------------------------------------------------------
; Same as player code (can probably be shared with some tweaks)
;-=============================================================================
position_sword
        if object_facing[index] = DIR_DOWN then pos_swd_down
        if object_facing[index] = DIR_UP then pos_swd_up
        if object_facing[index] = DIR_LEFT then pos_swd_left

pos_swd_right
        temp1 = object_Xpos[index] + SWORD_OFFSET_RIGHT
        temp2 = object_Ypos[index]
        ;temp3 = 12
        ;temp4 = 4
        temp5 = 2
        return

pos_swd_down
        temp1 = object_Xpos[index]
        temp2 = object_Ypos[index] + SWORD_OFFSET_DOWN
        ;temp3 = 4
        ;temp4 = 16
        temp5 = 0
        return

pos_swd_up
        temp1 = object_Xpos[index]
        temp2 = object_Ypos[index] + SWORD_OFFSET_UP
        ;temp3 = 4
        ;temp4 = 16
        temp5 = 1
        return

pos_swd_left
        temp1 = object_Xpos[index] + SWORD_OFFSET_LEFT
        temp2 = object_Ypos[index]
        ;temp3 = 12
        ;temp4 = 4
        temp5 = 3
        return

object_handler
        for index = 1 to 15
        if !object_type[index] then object_done    ; 0 = no object
        if object_type[index] >= TYPE_CHARM1 then check_charm_bits
        if object_type[index] >= TYPE_ARMOR1 then check_armor_bits
        if object_type[index] >= TYPE_SHIELD1 then check_shield_bits
        if object_type[index] >= TYPE_SWORD1 then check_sword_bits
        if object_type[index] >= TYPE_ITEM1 then check_item_bits
        if object_type[index] >= TYPE_BLOOD then object_done      ;  coins, prisms are static
        if object_type[index] = TYPE_SPAWNER then spawn_object
        if object_type[index] = TYPE_TORCH then torch_tile_block
        gosub copy_object_props 
        if flags{5} then gosub ledge_hop : goto object_restore
        gosub decelerate_object
        if object_type[index] = TYPE_SKELSWORD then gosub skelsword_ai
        if object_type[index] = TYPE_WOLF then gosub wolf_ai
        if object_type[index] = TYPE_SLIME then gosub slime_ai
        if object_type[index] = TYPE_MSLIME then gosub slime_ai
        if object_type[index] = TYPE_RSLIME then gosub redslime_ai
        if object_type[index] = TYPE_MRSLIME then gosub redslime_ai
        if object_type[index] = TYPE_RAVEN then gosub raven_ai
        if object_type[index] = TYPE_PRIEST then gosub priest_ai
        if object_type[index] = TYPE_SKELETON then gosub priest_ai
        if object_type[index] = TYPE_FIREBALL then gosub fireball_ai
        if object_type[index] = TYPE_DARKSPARK then gosub fireball_ai
        gosub move_object
object_restore
        gosub restore_object_props
object_done
        next
        return

;==============================================================================
; FIREBALL AI
;------------------------------------------------------------------------------
; Fireballs poof out of existence when velocities = 0
;==============================================================================
        const FIREBALL_MAX_FRAMES = 4
fireball_ai
        if Xvelocity then fireball_animate
        if Yvelocity then fireball_animate
        object_type[index] = 0
        return
fireball_animate
        frame = 0
        if animation_frame then frame = 1
fireball_done
        return


torch_tile_block
        ; flags are used to track if the tile has already been blocked
        ; however, this fails when the map reloads after the menu is opened
        if torch_reblock then goto torch_tile_block_get_pos
        if object_flags[index] then object_done
torch_tile_block_get_pos
        gosub get_torch_pos
        if tileset = T_FOREST then gosub torch_tile_block_forest
        if tileset = T_CASTLE then gosub torch_tile_block_castle
        object_flags[index] = 1
        goto object_done

spawn_object
        ; index is still set by object_handler
        if object_flags[index] = TYPE_TORCH then spawns_torch
        drop_rate = 0
        if object_flags[index] = TYPE_WOLF then drop_rate = WOLF_DROP_RATE
        if object_flags[index] = TYPE_SLIME then drop_rate = SLIME_DROP_RATE

        if rand > drop_rate then spawn_nothing

        if object_flags[index] = TYPE_WOLF then spawns_wolf
        if object_flags[index] = TYPE_SLIME then spawns_slime
        goto object_done

spawns_slime
        object_type[index] = TYPE_ITEM1
        object_hp[index] = 1
        goto object_done

spawns_wolf
        ; TODO: Unique wolf item drops
spawns_torch
        if player_hp = player_max_hp then torch_mp_check
        if rand > 128 then _spawn_food
torch_mp_check
        if player_mp = player_max_mp then _spawn_coin
        goto _spawn_mana

_spawn_food
        object_type[index] = TYPE_FOOD
        object_hp[index] = 1
        goto object_done

_spawn_mana
        object_type[index] = TYPE_PRISM
        object_hp[index] = 1
        goto object_done

_spawn_coin
        object_type[index] = TYPE_COIN
        object_hp[index] = 1
        goto object_done

spawn_nothing
        object_type[index] = 0
        goto object_done

player_handler
        ; TODO: saving cutscene
        if in_save_room then goto save_room_handler
        if player_state = STATE_DEATH then goto death_fade
;        gosub copy_player_props
        index = 0 : gosub decelerate_player
;        gosub restore_player_props

;==============================================================================
; SUBROUTINE: HANDLE INPUT FIELD
;------------------------------------------------------------------------------
; This routine handles all player input in the field
;==============================================================================
handle_input_field
        if !player_flags{5} then player_no_hop
        index = 0
        gosub copy_player_props
        gosub ledge_hop
        gosub restore_player_props
        goto test_joy_done
player_no_hop
        ; player timer is set for knockback and attack timing
        if !player_timer then no_player_timer
        player_timer = player_timer - 1
        if player_state = STATE_ATTACK then test_joy_done
        if player_flags{0} then player_test_state

no_player_timer
        player_flags{0} = 0     ; clear invulnerability flag

;------------------------------------------------------------------------------
        ; handles chanting and sword retracting. Zero if not doing these
player_test_state
        if player_state = STATE_CHANT then chant_handler
        if player_state = STATE_ATTACK then retract_sword
        if joy0fire0 && action_button = 0 then goto player_attack
        if joy0fire1 && action_button = 1 then goto player_attack

        asm
        lda #0
        sta retract_counter
        sta chant_timer
        sta player_state        ; STATE_STAND
        sta player_exiting_chant
        sta sword_hit
end

;------------------------------------------------------------------------------

        if player_facing = DIR_UP then player_frame = FRAME_UP : goto frames_done
        if player_facing = DIR_DOWN then player_frame = FRAME_DOWN : goto frames_done
        if player_facing = DIR_LEFT then player_frame = FRAME_LEFT : goto frames_done
        player_frame = FRAME_RIGHT

frames_done
        if joy0up    then player_Ydir = DIR_UP    : player_facing = DIR_UP    : player_frame = FRAME_UP    : player_Yvel = player_Yvel + player_speed : player_state = STATE_MOVING : test_joy_done
        if joy0down  then player_Ydir = DIR_DOWN  : player_facing = DIR_DOWN  : player_frame = FRAME_DOWN  : player_Yvel = player_Yvel + player_speed : player_state = STATE_MOVING : test_joy_done
        if joy0left  then player_Xdir = DIR_LEFT  : player_facing = DIR_LEFT  : player_frame = FRAME_LEFT  : player_Xvel = player_Xvel + player_speed : player_state = STATE_MOVING : test_joy_done
        if joy0right then player_Xdir = DIR_RIGHT : player_facing = DIR_RIGHT : player_frame = FRAME_RIGHT : player_Xvel = player_Xvel + player_speed : player_state = STATE_MOVING : test_joy_done

test_joy_done
        if !menu_debounce && joy0fire0 && action_button = 1 then goto open_menu
        if !menu_debounce && joy0fire1 && action_button = 0 then goto open_menu
        if !pause_debounce && switchpause then goto open_menu
        if player_state = STATE_STAND || player_state = STATE_ATTACK then player_move_done
        if player_flags{5} then player_move_done
        index = 0 : gosub copy_player_props
        gosub move_object
        gosub restore_player_props

player_move_done

        shield_Xpos = player_Xpos + SHIELD_OFFSET_X
        shield_Ypos = player_Ypos + SHIELD_OFFSET_Y

input_frame_done
        if !player_Xvel && !player_Yvel && player_state <> STATE_ATTACK && player_state <> STATE_CHANT then player_state = STATE_STAND
        if animation_frame && player_state = STATE_MOVING then player_frame = player_frame + 1

check_room_boundary
        if player_Xpos < 2  then exit_dir = EXIT_EAST  : room_index = room_index - 1 : menu_map_Xpos = menu_map_Xpos - 8
        if player_Xpos > 149 then exit_dir = EXIT_WEST  : room_index = room_index + 1 : menu_map_Xpos = menu_map_Xpos + 8
        if player_Ypos < 2  then exit_dir = EXIT_NORTH : room_index = room_index - ROOMS_PER_ROW : menu_map_Ypos = menu_map_Ypos - 16
        if player_Ypos > 204 then exit_dir = EXIT_SOUTH : room_index = room_index + ROOMS_PER_ROW : menu_map_Ypos = menu_map_Ypos + 16
        if exit_dir then reload_map = 1
        goto player_handler_done

player_attack
        sword_hit = 0
        ; player exiting chant tracks if the player cast magic to exit chant with button held
        if player_exiting_chant then test_joy_done
        if retract_counter then retract_sword
        if player_facing = DIR_DOWN then sword_Xpos = player_Xpos : sword_Ypos = player_Ypos + SWORD_OFFSET_DOWN : sword_width = 4 : sword_height = 16 : sword_frame = 0 : goto sword_done
        if player_facing = DIR_UP   then sword_Xpos = player_Xpos : sword_Ypos = player_Ypos + SWORD_OFFSET_UP   : sword_width = 4 : sword_height = 16 : sword_frame = 1 : goto sword_done
        if player_facing = DIR_LEFT then sword_Xpos = player_Xpos + SWORD_OFFSET_LEFT : sword_Ypos = player_Ypos : sword_width = 12 : sword_height = 4 :sword_frame = 3 : goto sword_done
        sword_Xpos = player_Xpos + SWORD_OFFSET_RIGHT : sword_Ypos = player_Ypos : sword_width = 12 : sword_height = 4 : sword_frame = 2
sword_done
        if player_facing = DIR_LEFT  then player_frame = FRAME_ATK_L : goto player_attack_return
        if player_facing = DIR_RIGHT then player_frame = FRAME_ATK_R : goto player_attack_return
        if player_facing = DIR_UP    then player_frame = FRAME_ATK_U : goto player_attack_return
        if player_facing = DIR_DOWN  then player_frame = FRAME_ATK_D

player_attack_return
        player_state = STATE_ATTACK
        player_timer = ATTACK_FRAMES
        goto player_handler_done

retract_sword
        if player_facing = DIR_DOWN  then sword_Ypos = sword_Ypos - 4 : retract_step_done
        if player_facing = DIR_UP    then sword_Ypos = sword_Ypos + 4 : retract_step_done
        if player_facing = DIR_LEFT  then sword_Xpos = sword_Xpos + 2 : retract_step_done
        if player_facing = DIR_RIGHT then sword_Xpos = sword_Xpos - 2

retract_step_done
        retract_counter = retract_counter + 1
        if retract_counter < 3 then test_joy_done

retract_stand
        if !joy0fire0 && action_button = 0 then player_state = STATE_STAND : goto test_joy_done
        if !joy0fire1 && action_button = 1 then player_state = STATE_STAND : goto test_joy_done
        ; retract finished and button still held - code runs into player_chant_start

player_chant_start
        if chant_timer > CHANT_START_TIME then set_state_chant
        player_state = STATE_CHANT_START
        asm
        inc chant_timer
end
        if player_facing = DIR_UP    then player_frame = FRAME_UP
        if player_facing = DIR_DOWN  then player_frame = FRAME_DOWN
        if player_facing = DIR_LEFT  then player_frame = FRAME_LEFT
        if player_facing = DIR_RIGHT then player_frame = FRAME_RIGHT
        goto test_joy_done

set_state_chant
        ; set player state to chant and facing direction to down
        ; facing down when coming out of chant just feels more natural
        player_state = STATE_CHANT
        player_facing = DIR_DOWN

chant_handler
        if debug_time = 1 then BACKGRND = $B9

        if !joy0fire0 && action_button = 0 then chant_done_no_hold
        if !joy0fire1 && action_button = 1 then chant_done_no_hold

        ; chant_new_input is set when a direction is pressed
        if chant_new_input then chant_input_test_release

        ; parse the most recent directional entered and test for combos
        if input_buffer[chant_index] = DIR_UP    then chant_spells_up
        if input_buffer[chant_index] = DIR_DOWN  then chant_spells_down
        if input_buffer[chant_index] = DIR_LEFT  then chant_spells_left
        if input_buffer[chant_index] = DIR_RIGHT then chant_spells_right

chant_test_dirs
        if joy0left  then chant_input = DIR_LEFT  : chant_new_input = 1
        if joy0right then chant_input = DIR_RIGHT : chant_new_input = 1
        if joy0up    then chant_input = DIR_UP    : chant_new_input = 1
        if joy0down  then chant_input = DIR_DOWN  : chant_new_input = 1
        goto test_joy_done

; Require a release of a single direction (TODO: 8dir?) before buffering input
chant_input_test_release
        if joy0up    then test_joy_done
        if joy0down  then test_joy_done
        if joy0left  then test_joy_done
        if joy0right then test_joy_done
        ; TODO: Test for holds? Long times between inputs?

chant_buffer_input
        input_buffer[input_buffer_index] = chant_input
        ; chant_index is always updated to input buffer index but is its own
        ; variable so that it can be manipulated by the parsing routines
        ; without losing the input buffer index for the next frame
        chant_index = input_buffer_index
        input_buffer_index = input_buffer_index + 1
        if input_buffer_index > INPUT_BUFFER_MAX then input_buffer_index = 0
        chant_new_input = 0
        goto test_joy_done

; all chant tests seach for button combos "backwards" from the most recent input
chant_spells_up
        chant_index = chant_index - 1
        ; chant index will underflow to 255, set to 7
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] = DIR_DOWN then parse_fireball_up
        goto chant_test_dirs

chant_spells_down
        chant_index = chant_index - 1
        ; chant index will underflow to 255, set to 7
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] = DIR_UP then parse_fireball_down
        goto chant_test_dirs

chant_spells_left
        chant_index = chant_index - 1
        ; chant index will underflow to 255, set to 7
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] = DIR_RIGHT then parse_fireball_left
        goto chant_test_dirs

chant_spells_right
        chant_index = chant_index - 1
        ; chant index will underflow to 255, set to 7
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] = DIR_LEFT then parse_fireball_right
        goto chant_test_dirs

parse_fireball_up
        chant_index = chant_index - 1
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] <> DIR_UP then chant_test_dirs
        player_facing = DIR_UP : player_frame = FRAME_UP
        gosub cast_fireball
        goto chant_done

parse_fireball_down
        chant_index = chant_index - 1
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] <> DIR_DOWN then chant_test_dirs
        player_frame = FRAME_DOWN
        gosub cast_fireball
        goto chant_done

parse_fireball_left
        chant_index = chant_index - 1
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] <> DIR_LEFT then chant_test_dirs
        player_facing = DIR_LEFT : player_frame = FRAME_LEFT
        gosub cast_fireball
        goto chant_done

parse_fireball_right
        chant_index = chant_index - 1
        if chant_index > INPUT_BUFFER_MAX then chant_index = INPUT_BUFFER_MAX
        if input_buffer[chant_index] <> DIR_RIGHT then chant_test_dirs
        player_facing = DIR_RIGHT : player_frame = FRAME_RIGHT
        gosub cast_fireball
        goto chant_done ; because I know I'll cause a bug adding code later...

chant_done
        player_exiting_chant = 1
chant_done_no_hold
        asm
        lda #0
        sta player_state        ; STATE_STAND
        sta chant_timer
        sta chant_input
        sta input_buffer_index
        sta chant_new_input
        ldx #8
clear_input_buffer
        dex
        sta input_buffer,x
        bne clear_input_buffer
end
        gosub decrease_player_mp
        goto test_joy_done

decelerate_player
decelerate_object
        asm
        ldx index
        lda object_friction,x
        beq decel_return
        lda object_Xvel,x
        beq decel_Y
        pha
        sec
        sbc object_friction_hi,x
        sta object_Xvel_hi,x
        pla
        cmp object_Xvel_hi,x
        bcs decel_Y
        lda #0
        sta object_Xvel_lo,x
        sta object_Xvel_hi,x

decel_Y
        lda object_Yvel_hi,x
        beq decel_return
        pha
        sec
        sbc object_friction_hi,x
        sta object_Yvel_hi,x
        pla
        cmp object_Yvel_hi,x
        bcs decel_return
        lda #0
        sta object_Yvel_lo,x
        sta object_Yvel_hi,x

decel_return
        rts
end

;==============================================================================
; SUBROUTINE: MOVE_OBJECT
;------------------------------------------------------------------------------
; Moves an object based on the non-fractional component of their velocities.
; Tests against an array of walkable tiles for current tileset before moving.
;
; All move test labels add 8 to Yposistion to allow objects to overlap
; unwalkable tiles that are above them. Objects are assumed to be 12x16
; and magic numbers are used throughout the code to improve the feel of
; player collisions with map tiles at the expense of other sprite proportions
;==============================================================================
move_object
        if debug_time then BACKGRND = $96

        ; Cap the object's velocity TODO: separate X/Y cap?
        if Xvelocity > vel_cap then Xvelocity = vel_cap
        if Yvelocity > vel_cap then Yvelocity = vel_cap

        ; Current direction(s) are determined by player input or AI logic
        ; optimization: bypass direction checks if no velocity
        if !Yvelocity then move_object_X
        if Ydirection = DIR_UP    then gosub move_test_up
        if Ydirection = DIR_DOWN  then gosub move_test_down
move_object_X
        if !Xvelocity then move_object_done
        if Xdirection = DIR_LEFT  then gosub move_test_left
        if Xdirection = DIR_RIGHT then gosub move_test_right
move_object_done
        goto move_return

move_test_up
        if flags{2} then move_up
        asm
        lda Xposition
        clc
        adc #2
        lsr
        lsr
        lsr
        sta peekX
        lda Yposition
        clc
        adc #8
        sec
        sbc Yvelocity_hi
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_1 = peekchar (current_map, peekX, peekY, 20, 14)
;        peekX = (Xposition + 8) / TILE_WIDTH
        asm
        lda Xposition
        clc
        adc #8
        lsr
        lsr
        lsr
        sta peekX
end
        move_tile_2 = peekchar (current_map, peekX, peekY, 20, 14)
        gosub test_walkable
        if !flags{4} then test_walkable_up
        if floatable then move_up
test_walkable_up
        if !walkable then Yvelocity = 0 : return
move_up
        Yposition = Yposition - Yvelocity_hi
        if Yposition > 224 then object_type[index] = 0
        return

move_test_down
        if flags{2} then move_down
        ;peekX = (Xposition + 2) / TILE_WIDTH
        ;peekY = ((Yposition + Yvelocity_hi) + 15) / TILE_HEIGHT
        asm
        lda Xposition
        clc
        adc #2
        lsr
        lsr
        lsr
        sta peekX
        lda Yposition
        clc
        adc #15
        clc
        adc Yvelocity_hi
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_1 = peekchar (current_map, peekX, peekY, 20, 14)
        ;peekX = (Xposition + 8) / TILE_WIDTH
        asm
        lda Xposition
        clc
        adc #8
        lsr
        lsr
        lsr
        sta peekX
end
        move_tile_2 = peekchar (current_map, peekX, peekY, 20, 14)
        ledge_dir = DIR_DOWN
        gosub test_walkable
        if !flags{4} then test_walkable_down
        if floatable then move_down
test_walkable_down
        if ledge then Xdirection = 0 : flags{5} = 1
        if !walkable then Yvelocity = 0 : return
move_down
        Yposition = Yposition + Yvelocity_hi
        if Yposition > 224 then object_type[index] = 0
        return

move_test_left
        if flags{2} then move_left
;        peekX = ((Xposition + 2) - Xvelocity_hi) / TILE_WIDTH
        ; Add 8 to Y position to allow object to overlap solid tiles above it slightly
;        peekY = (Yposition + 8) / TILE_HEIGHT
        asm
        lda Xposition
        clc
        adc #2
        sec
        sbc Xvelocity_hi
        lsr
        lsr
        lsr
        sta peekX
        lda Yposition
        clc
        adc #8
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_1 = peekchar (current_map, peekX, peekY, 20, 14)
;        peekY = (Yposition + 15) / TILE_HEIGHT
        asm
        lda Yposition
        clc
        adc #15
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_2 = peekchar (current_map, peekX, peekY, 20, 14)
        ledge_dir = DIR_LEFT
        gosub test_walkable
        if !flags{4} then test_walkable_left
        if floatable then move_left
test_walkable_left
        if ledge then Xdirection = DIR_LEFT : flags{5} = 1
        if !walkable then Xvelocity = 0 : return
move_left
        Xposition = Xposition - Xvelocity_hi
        if Xposition > 160 then object_type[index] = 0
        return

move_test_right
        if flags{2} then move_right
;        peekX = ((Xposition + 9) + Xvelocity_hi) / TILE_WIDTH
        ; Add 8 to Y position to allow object to overlap solid tiles above it slightly
;        peekY = (Yposition + 8) / TILE_HEIGHT
        asm
        lda Xposition
        clc
        adc #9
        clc
        adc Xvelocity_hi
        lsr
        lsr
        lsr
        sta peekX
        lda Yposition
        clc
        adc #8
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_1 = peekchar (current_map, peekX, peekY, 20, 14)
;        peekY = (Yposition + 15) / TILE_HEIGHT
        asm
        lda Yposition
        clc
        adc #15
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_2 = peekchar (current_map, peekX, peekY, 20, 14)
        ledge_dir = DIR_RIGHT
        gosub test_walkable
        if !flags{4} then test_walkable_right
        if floatable then move_right
test_walkable_right
        if ledge then Xdirection = DIR_RIGHT : flags{5} = 1
        if !walkable then Xvelocity = 0 : return
move_right
        Xposition = Xposition + Xvelocity_hi
        if Xposition > 160 then object_type[index] = 0
        return
        
move_return
        if debug_time then BACKGRND = bg_color
        return

test_walkable
        if debug_time then BACKGRND = $1A
        ; start by assuming the tile isn't walkable (fewer tests)
        asm
        lda #0
        sta walkable
        sta walkable_1
        sta walkable_2
        sta floatable
        sta floatable_1
        sta floatable_2
        sta ledge
        sta ledge_1
        sta ledge_2
end
        if tileset = T_FOREST then goto test_walkable_forest
        if tileset = T_CASTLE then goto test_walkable_castle
walkable_return
        if debug_time then BACKGRND = bg_color
        return

check_collisions
        if debug_time = 1 then BACKGRND = $95
        for index = 0 to 15
        if !object_type[index] then cc_next
        Xposition = object_Xpos[index]
        Yposition = object_Ypos[index]
        if object_type[index] >= TYPE_COIN then cc_pickup
        if object_type[index] >= TYPE_FIREBALL then magic_collision
        if player_state <> STATE_ATTACK then cc_player_contact
        gosub sword_collision
        if !object_hp[index] then kill_object
cc_player_contact
        ; need to test torches here so the sword can still damage them
        ; but they don't knock the player back on contact
        if object_type[index] = TYPE_TORCH then cc_next
        hp_change = object_damage[index]
        gosub player_knockback
        if player_state = STATE_DEATH then goto kill_player
cc_next
        if debug_time = 1 then BACKGRND = bg_color
        next
cc_return
        return

cc_pickup
        if Xposition > player_Xpos && Xposition < (player_Xpos + 12) && Yposition > player_Ypos && Yposition < (player_Ypos + 16) then pickup_object
        goto cc_next

pickup_object
        playsfx sfx_strum
        if object_type[index] = TYPE_FOOD then hp_change = $10 : gosub increase_player_hp
        if object_type[index] = TYPE_PRISM then mp_change = $10 : gosub increase_player_mp
        if object_type[index] >= TYPE_ITEM1 then temp1 = object_type[index]
        if temp1 > TYPE_ARMOR10 then pickup_charm
        if temp1 > TYPE_SHIELD10 then pickup_armor
        if temp1 > TYPE_SWORD10 then pickup_shield
        if temp1 > TYPE_ITEM10 then pickup_sword
        if temp1 >= TYPE_ITEM1 then pickup_item

kill_object
        ; TODO: Death animation
        if object_type[index] <> TYPE_TORCH then change_to_spawner
        ; torches make their tile walkable
        gosub kill_torch
change_to_spawner
        if object_type[index] = TYPE_SLIME && animation_frame then goto split_slime
        if object_type[index] = TYPE_RSLIME && animation_frame then goto split_rslime
        ; switch the object's flags to its old type and its type to a spwaner
        object_flags[index] = object_type[index]
        object_type[index] = TYPE_SPAWNER
        goto cc_next

sword_collision
        if !boxcollision (sword_Xpos, sword_Ypos, sword_width, sword_height, Xposition, Yposition, 12, 16) then return
        playsfx sfx_poof2
sword_damage
        ; TODO: Much better damage calculations
        if object_def[index] = 255 then return
        temp_hp = object_hp[index]
        hp_change = player_atk - object_def[index]
        if hp_change > player_atk then hp_change = 1
        gosub decrease_hp
        object_hp[index] = temp_hp
        return

kill_torch
        gosub get_torch_pos
        if tileset = T_FOREST then gosub torch_tile_unblock_forest
        if tileset = T_CASTLE then gosub torch_tile_unblock_castle
        return

player_knockback
        if player_flags{0} then return  ; player is invulnerable, bypass collision check to save cycles
        if !boxcollision (player_Xpos, player_Ypos, PLAYER_WIDTH, PLAYER_HEIGHT, Xposition, Yposition, 12, 16) then return
;        if Yposition <= player_Ypos then player_Yvel = 10.0 : player_Ydir = DIR_DOWN  : player_frame = FRAME_UP    : goto pc_damage
;        if Yposition >= player_Ypos then player_Yvel = 10.0 : player_Ydir = DIR_UP    : player_frame = FRAME_DOWN  : goto pc_damage
;        if Xposition >= player_Xpos then player_Xvel = 5.0 : player_Xdir = DIR_LEFT  : player_frame = FRAME_RIGHT : goto pc_damage
;        if Xposition <= player_Xpos then player_Xvel = 5.0 : player_Xdir = DIR_RIGHT : player_frame = FRAME_LEFT

        ; projectiles are destroyed on contact
        if object_type[index] >= TYPE_DARKSPARK then object_type[index] = 0
pc_damage
        player_flags{0} = 1
        player_state = STATE_KNOCKBACK
        player_timer = INVULN_FRAMES

        ; moved damage subroutine here to avoid a goto
damage_player_hp
        ; TODO: This currently can't scale, only works with max HP 48...
        dec temp1 = player_hp        ; temp1 used to detect underflow
        dec temp2 = hp_change
        dec hp_change = hp_change - player_def
        ; don't want total immunity to damage, that's boring!
        if hp_change > temp2 then hp_change = 1
        dec player_hp = player_hp - hp_change
        if player_hp > temp1 then player_hp = 0

update_hp_bar
        dec temp1 = player_hp
        dec hp_seg_1 = player_hp
        if hp_seg_1 > temp1 then hp_seg_1 = 0
        dec temp1 = hp_seg_1
        dec hp_seg_2 = hp_seg_1 - 8
        if hp_seg_2 > temp1 then hp_seg_2 = 0
        dec temp1 = hp_seg_2
        dec hp_seg_3 = hp_seg_2 - 8
        if hp_seg_3 > temp1 then hp_seg_3 = 0
        dec temp1 = hp_seg_3
        dec hp_seg_4 = hp_seg_3 - 8
        if hp_seg_4 > temp1 then hp_seg_4 = 0
        dec temp1 = hp_seg_4
        dec hp_seg_5 = hp_seg_4 - 8
        if hp_seg_5 > temp1 then hp_seg_5 = 0
        dec temp1 = hp_seg_5
        dec hp_seg_6 = hp_seg_5 - 8
        if hp_seg_6 > temp1 then hp_seg_6 = 0
        if hp_seg_6 > 8 then hp_seg_6 = 8
        if hp_seg_5 > 8 then hp_seg_5 = 8
        if hp_seg_4 > 8 then hp_seg_4 = 8
        if hp_seg_3 > 8 then hp_seg_3 = 8
        if hp_seg_2 > 8 then hp_seg_2 = 8
        if hp_seg_1 > 8 then hp_seg_1 = 8

        if player_hp = 0 then player_state = STATE_DEATH
        return

increase_player_hp
        dec player_hp = player_hp + hp_change
        if player_hp > player_max_hp then player_hp = player_max_hp
        hp_change = 0
        goto update_hp_bar

increase_player_mp
        dec player_mp = player_mp + mp_change
        if player_mp > player_max_mp then player_mp = player_max_mp
        goto update_mp_bar

decrease_player_mp
        ; TODO: This currently can't scale, only works with max HP 48...
        dec temp1 = player_mp        ; temp1 used to detect underflow
        dec player_mp = player_mp - mp_change
        if player_mp > temp1 then player_mp = 0

update_mp_bar
        mp_change = 0
        dec temp1 = player_mp
        dec mp_seg_1 = player_mp
        if mp_seg_1 > temp1 then mp_seg_1 = 0
        dec temp1 = mp_seg_1
        dec mp_seg_2 = mp_seg_1 - 8
        if mp_seg_2 > temp1 then mp_seg_2 = 0
        dec temp1 = mp_seg_2
        dec mp_seg_3 = mp_seg_2 - 8
        if mp_seg_3 > temp1 then mp_seg_3 = 0
        dec temp1 = mp_seg_3
        dec mp_seg_4 = mp_seg_3 - 8
        if mp_seg_4 > temp1 then mp_seg_4 = 0
        dec temp1 = mp_seg_4
        dec mp_seg_5 = mp_seg_4 - 8
        if mp_seg_5 > temp1 then mp_seg_5 = 0
        dec temp1 = mp_seg_5
        dec mp_seg_6 = mp_seg_5 - 8
        if mp_seg_6 > temp1 then mp_seg_6 = 0
        if mp_seg_6 > 8 then mp_seg_6 = 8
        if mp_seg_5 > 8 then mp_seg_5 = 8
        if mp_seg_4 > 8 then mp_seg_4 = 8
        if mp_seg_3 > 8 then mp_seg_3 = 8
        if mp_seg_2 > 8 then mp_seg_2 = 8
        if mp_seg_1 > 8 then mp_seg_1 = 8
        return

test_spell_cost
        if mp_change < player_mp then return
        ; routines can test if mp_change is 0 after calling this subroutine
        mp_change = 0
        return

increase_hp
        temp_hp = temp_hp + hp_change
        return

decrease_hp
        temp_hp = temp_hp - hp_change
        return

; takes a torch's X & Y position and determines the map tile under it, stores in peekX & Y
get_torch_pos
        asm
        ldx index
        lda object_Xpos,x
        clc
        adc #4          ; forces X calculation onto correct map tile
        lsr
        lsr
        lsr
        sta peekX
        lda object_Ypos,x
        clc
        adc #8          ; forces Y calculation onto correct map tile
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        return


copy_player_props
copy_object_props
        asm
        ldx index
        lda object_Xpos,x
        sta Xposition
        lda object_Xdir,x
        sta Xdirection
        lda object_Xvel_lo,x
        sta Xvelocity_lo
        lda object_Xvel_hi,x
        sta Xvelocity_hi
        lda object_Ypos,x
        sta Yposition
        lda object_Ydir,x
        sta Ydirection
        lda object_Yvel_lo,x
        sta Yvelocity_lo
        lda object_Yvel_hi,x
        sta Yvelocity_hi
        lda object_speed_lo,x
        sta move_speed_lo
        lda object_speed_hi,x
        sta move_speed_hi
        lda object_vel_cap_lo,x
        sta vel_cap_lo
        lda object_vel_cap_hi,x
        sta vel_cap_hi
        lda object_friction_lo,x
        sta friction_lo
        lda object_friction_hi,x
        sta friction_hi
        lda object_frame,x
        sta frame
        lda object_flags,x
        sta flags
        lda object_dest,x
        sta hop_dest
        lda object_hop_dir,x
        sta hop_dir
        lda object_timer,x
        sta timer
        rts
end

restore_player_props
restore_object_props
        asm
        ldx index
        lda Xposition
        sta object_Xpos,x
        lda Xdirection
        sta object_Xdir,x
        lda Xvelocity_lo
        sta object_Xvel_lo,x
        lda Xvelocity_hi
        sta object_Xvel_hi,x
        lda Yposition
        sta object_Ypos,x
        lda Ydirection
        sta object_Ydir,x
        lda Yvelocity_lo
        sta object_Yvel_lo,x
        lda Yvelocity_hi
        sta object_Yvel_hi,x
        lda frame
        sta object_frame,x
        lda flags
        sta object_flags,x
        lda #0
        sta flags
        lda hop_dest
        sta object_dest,x
        lda hop_dir
        sta object_hop_dir,x
        lda timer
        sta object_timer,x
        rts
end

;==============================================================================
; SUBROUTINE: FIND NEW OBJECT
;------------------------------------------------------------------------------
; Iterates through all 16 object slots and sets the index variable to a 0 slot
;==============================================================================
find_new_object
        asm
        ldx #0
        stx no_empty_slot
new_obj_loop
        inx
        lda object_type,x
        beq new_obj_found
        cpx #MAX_MAP_OBJECTS
        bne new_obj_loop
        ; no empty obj slot found, routines can test if this is non-zero
        stx no_empty_slot
        rts
new_obj_found
        stx spawn_index
        rts
end

ledge_hop
        asm
        lda Xdirection
        cmp #DIR_LEFT
        beq hop_left
        cmp #DIR_RIGHT
        beq hop_right
        ; must be down
hop_down
        lda timer
        bne hop_down_up
        lda #16
        sta timer
        lda Yposition
        clc
        adc #16
        sta hop_dest
hop_down_up
        cmp #8
        bcc hop_down_down
        dec Yposition
        dec timer
        rts
hop_down_down
        inc Yposition
        lda hop_dest
        cmp Yposition
        beq hop_done
        rts

hop_left
        lda timer
        bne hop_left_up
        lda #12
        sta timer
        lda Xposition
        sec
        sbc #12
        sta hop_dest
hop_left_up
        cmp #6
        bcc hop_left_down
        dec Yposition
        dec Xposition
        dec timer
        rts
hop_left_down
        inc Yposition
        dec Xposition
        lda hop_dest
        cmp Xposition
        beq hop_done
        rts

hop_right
        lda timer
        bne hop_right_up
        lda #12
        sta timer
        lda Xposition
        clc
        adc #12
        sta hop_dest
hop_right_up
        cmp #6
        bcc hop_right_down
        dec Yposition
        inc Xposition
        dec timer
        rts
hop_right_down
        inc Yposition
        inc Xposition
        lda hop_dest
        cmp Xposition
        beq hop_done
        rts

hop_done
        lda #0
        sta flags
        sta timer
        sta hop_dest
        rts
end