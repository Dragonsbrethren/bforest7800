;------------------------------------------------------------------------------
; 7800BASIC INITIALIZATION
;------------------------------------------------------------------------------
        set romsize 128kRAM
        set pokeysupport on
        set screenheight 224
        set doublewide on
        set collisionwrap off
        set multibutton on
        set multibuttonpause on

        const debug_hud = 1
        const debug_time = 1

;------------------------------------------------------------------------------
; GAME STATES
;------------------------------------------------------------------------------
        const STATE_TITLE = 0
        const STATE_FIELD = 1
        const STATE_MENU  = 2
        
        const ANIM_TIME = 16
        const INVULN_FRAMES = 60

;------------------------------------------------------------------------------
; MOVEMENT CONSTANTS
;------------------------------------------------------------------------------
        const DIR_LEFT = 3
        const DIR_RIGHT = 2
        const DIR_UP = 1
        const DIR_DOWN = 0

        const EXIT_NONE  = 0
        const EXIT_NORTH = 1
        const EXIT_SOUTH = 2
        const EXIT_EAST  = 3
        const EXIT_WEST  = 4

;------------------------------------------------------------------------------
; PLAYER DATA
;------------------------------------------------------------------------------
        const PLAYER_HEIGHT = 16
        const PLAYER_WIDTH  = 12

        const SWORD_FRAMES = 4
        const SWORD_OFFSET_DOWN  = 15
        const SWORD_OFFSET_UP    = -16
        const SWORD_OFFSET_LEFT  = -12
        const SWORD_OFFSET_RIGHT = 12
        
        const SHIELD_FRAMES = 4
        const SHIELD_OFFSET_X = 8
        const SHIELD_OFFSET_Y = 7

        const STATE_STAND     = 0
        const STATE_MOVING    = 1
        const STATE_ATTACK    = 2
        const STATE_CHANT     = 3
        const STATE_KNOCKBACK = 4

        const FRAME_UP    = 2
        const FRAME_DOWN  = 0
        const FRAME_LEFT  = 4
        const FRAME_RIGHT = 6
        const FRAME_ATK_D = 8
        const FRAME_ATK_U = 9
        const FRAME_ATK_L = 10
        const FRAME_ATK_R = 11

;------------------------------------------------------------------------------
; MAP DATA
;------------------------------------------------------------------------------
        const TILE_HEIGHT = 16
        const TILE_WIDTH  = 8

        const T_TITLE  = 0
        const T_FOREST = 1
        const T_CASTLE = 2
        const T_RIVER  = 3
        const T_HILLS  = 4

        const ROOMS_PER_ROW = 7

;==============================================================================
; OBJECT DATA
;==============================================================================
        const TYPE_WOLF    =  1
        const TYPE_TORCH   =  2
        const TYPE_SPAWNER =  3
        const TYPE_COIN    =  4
        const TYPE_PRISM   =  5
        const TYPE_SLIME   =  6
        const TYPE_MSLIME  =  7

;------------------------------------------------------------------------------
; SYSTEM VARIABLES
;------------------------------------------------------------------------------
        dim temp_hp_sign = temp1        ; tracks underflow during subtraction

        autodim init a z
        autodim byte index
        autodim byte game_state
        autodim byte pointer
        autodim byte pointer_hi
        autodim byte Xposition
        autodim byte Yposition
        autodim byte Xdirection
        autodim byte Ydirection
        autodim 8.8  Xvelocity
        autodim 8.8  Yvelocity
        autodim 8.8  move_speed
        autodim 8.8  vel_cap
        autodim 8.8  friction
        autodim byte height
        autodim byte width
        autodim byte temp_hp
        autodim byte hp_change
        autodim byte bg_color
        autodim byte animation_timer

;------------------------------------------------------------------------------
; PLAYER
;------------------------------------------------------------------------------
        autodim init var0 var99
        autodim byte player_Xpos
        autodim byte player_Ypos
        autodim 8.8  player_Xvel
        autodim 8.8  player_Yvel
        autodim 8.8  player_vel_cap
        autodim 8.8  player_friction
        autodim byte player_Xdir
        autodim byte player_Ydir
        autodim byte player_facing      ; facing is separate from direction for knockback purposes
        autodim byte player_state
        autodim byte player_frame
        autodim byte player_flags
        autodim byte player_timer
        autodim byte player_hp
        autodim byte player_max_hp
        autodim byte player_mp
        autodim byte player_max_mp
        autodim byte player_level
        dim player_exp = score1
        autodim byte player_str
        autodim byte player_atk ; str + wpn atk
        autodim byte player_damage
        autodim byte player_atk_elem
        autodim byte player_def
        autodim byte player_def_elem
        autodim 8.8  player_speed
        autodim byte player_sword
        autodim byte player_shield
        autodim byte player_helm
        autodim byte player_armor
        autodim byte player_relic
        autodim byte player_status
        autodim byte sword_pal
        autodim byte sword_Xpos
        autodim byte sword_Ypos
        autodim byte sword_frame
        autodim byte sword_width
        autodim byte sword_height
        autodim byte shield_pal
        autodim byte shield_Xpos
        autodim byte shield_Ypos
        autodim byte shield_frame
        autodim byte hp_seg_1
        autodim byte hp_seg_2
        autodim byte hp_seg_3
        autodim byte hp_seg_4
        autodim byte hp_seg_5
        autodim byte hp_seg_6
        autodim byte mp_seg_1
        autodim byte mp_seg_2
        autodim byte mp_seg_3
        autodim byte mp_seg_4
        autodim byte mp_seg_5
        autodim byte mp_seg_6

;------------------------------------------------------------------------------
; MOVING OBJECT ARRAYS
;------------------------------------------------------------------------------
        autodim init $2200 $23FF
        autodim byte object_type 16
        autodim byte object_Xpos 16
        autodim byte object_Ypos 16
        autodim 8.8  object_Xvel 16
        autodim 8.8  object_Yvel 16
        autodim byte object_Xdir 16
        autodim byte object_Ydir 16
        autodim byte object_frame 16
        autodim byte object_action 16
        autodim 8.8  object_speed 16
        autodim 8.8  object_vel_cap 16
        autodim 8.8  object_friction 16
        autodim byte object_hp 16
        autodim byte object_damage 16
        autodim byte object_contact 16
        autodim byte object_flags 16
        autodim byte object_timer 16

        autodim init $2400 $24FF
        autodim byte reload_map
        autodim byte map_height
        autodim byte map_width
        autodim byte peekX
        autodim byte peekY
        autodim byte move_tile_1
        autodim byte move_tile_2
        autodim byte animation_frame
        autodim byte frame
        autodim byte flags
        autodim byte obj_index
        autodim byte joy0fire1_held
        autodim byte drop_rate
        autodim byte no_empty_slot

        ; ROOM HEADER
        autodim byte room
        autodim byte tileset
        autodim byte exit_dir
        autodim byte music
        autodim byte walkable
        autodim byte walkable_1
        autodim byte walkable_2
        autodim byte walk_test
        autodim byte walk_index
        autodim byte room_index

        dim current_map = $2600

        player_Xpos = 24
        player_Ypos = 60

        player_speed = 1.0
        player_friction = player_speed
        player_vel_cap = 5.0

        dec player_max_hp = $48
        dec player_hp = $48

        dec hp_seg_1 = 8
        dec hp_seg_2 = 8
        dec hp_seg_3 = 8
        dec hp_seg_4 = 8
        dec hp_seg_5 = 8
        dec hp_seg_6 = 8
        dec mp_seg_1 = 8
        dec mp_seg_2 = 8
        dec mp_seg_3 = 8
        dec mp_seg_4 = 8
        dec mp_seg_5 = 8
        dec mp_seg_6 = 8

        sword_pal = 2
        shield_pal = 2

;==============================================================================
; BANK 1
;------------------------------------------------------------------------------
; 7800basic initialization, title sequence code and graphics
;------------------------------------------------------------------------------
;==============================================================================
        incgraphic gfx/title/logo.png  320B 1 2 3 1 4
        incgraphic gfx/title/trees.png 320B 0 3 0 0 0
        incgraphic gfx/title/moon.png  320B 0 3 2 2 4
        incgraphic gfx/font.png        320A 0 2
        incmapfile tiled/title_blackforest.tmx
        game_state = STATE_TITLE

title_init
        gosub clear_palettes
        displaymode 320B
        bg_color = $71
        clearscreen
        characterset logo
        plotmapfile tiled/title_blackforest.tmx title_blackforest 0 0 40 14
        savescreen

title_handler
        restorescreen
        adjustvisible 0 4
        ; TODO: Handle, well, everything
        if !joy0fire0 || !joy0fire1 then goto main
        reload_map = 1
        room_index = 17
        tileset = T_FOREST
        game_state = STATE_FIELD

        ; shared_palettes
        P0C1 = $60 : P0C2 = $76 : P0C3 = $0F    ; purple, light purple, white -- magic HUD, torches
        P1C1 = $10 : P1C2 = $23 : P1C3 = $3B    ; dark brown, light brown, peach -- Johanna
        P2C1 = $30 : P2C2 = $45 : P2C3 = $1F    ; red, light red, gold -- HP HUD, equipment
        P3C1 = $50 : P3C2 = $55 : P3C3 = $5B    ; currently unused blues, equipment
        
        goto main

;==============================================================================
; BANK 2
;------------------------------------------------------------------------------
; Contains forest tileset graphics, maps, and enemy AI
;==============================================================================
        bank 2
        incgraphic gfx/tiles/forest_trees.png 160A 1 0 2 3 4
        incgraphic gfx/tiles/forest_rocks.png 160A 1 0 2 3 5
        incgraphic gfx/tiles/forest_water.png 160A 1 2 0 3 6
        incgraphic gfx/tiles/forest_map.png 160A 0 2 1 3
        incgraphic gfx/forest/hud.png 160A 0 3 1 2
        incgraphic gfx/forest/hud2.png 160A 0 3 1 2
        incgraphic gfx/sprites/wolf0.png 160A 0 2 3 1
        incgraphic gfx/sprites/wolf1.png 160A 0 2 3 1
        incgraphic gfx/sprites/wolf2.png 160A 0 2 3 1
        incgraphic gfx/sprites/wolf3.png 160A 0 2 3 1
        incgraphic gfx/sprites/slime0.png 160A 0 2 3 1
        incgraphic gfx/sprites/slime1.png 160A 0 2 3 1
        incgraphic gfx/sprites/minislime0.png 160A 0 2 3 1
        incgraphic gfx/sprites/minislime1.png 160A 0 2 3 1
         
        incmapfile tiled/forest.tmx
        incmapfile tiled/forest_room_1.tmx
        incmapfile tiled/forest_room_2.tmx
        incmapfile tiled/forest_room_3.tmx
        incmapfile tiled/forest_room_4.tmx
        incmapfile tiled/forest_room_5.tmx
        incmapfile tiled/forest_room_6.tmx
        incmapfile tiled/forest_room_7.tmx
        incmapfile tiled/forest_room_8.tmx
        incmapfile tiled/forest_room_9.tmx
        incmapfile tiled/forest_room_10.tmx

load_forest

        ; forest_palettes
        bg_color = $11                          ; brown
        P4C1 = $00 : P4C2 = $C0 : P4C3 = $C3    ; greens used by trees and slimes
        P5C1 = $00 : P5C2 = $03 : P5C3 = $06    ; grays used by rocks and wolves
        P6C1 = $00 : P6C2 = $A1 : P6C3 = $06    ; blue and gray used by water
        P7C1 = $00 : P7C2 = $24 : P7C3 = $5B    ; currently unused, light browns?

        characterset forest_trees
        room = forest_rooms[room_index]
        if room = 1 then pointer = forest_room_1_obj_lo : pointer_hi = forest_room_1_obj_hi : goto plot_forest_room_1
        if room = 2 then pointer = forest_room_2_obj_lo : pointer_hi = forest_room_2_obj_hi : goto plot_forest_room_2
        if room = 3 then pointer = forest_room_3_obj_lo : pointer_hi = forest_room_3_obj_hi : goto plot_forest_room_3
        if room = 4 then pointer = forest_room_4_obj_lo : pointer_hi = forest_room_4_obj_hi : goto plot_forest_room_4
        if room = 5 then pointer = forest_room_5_obj_lo : pointer_hi = forest_room_5_obj_hi : goto plot_forest_room_5
        if room = 6 then pointer = forest_room_6_obj_lo : pointer_hi = forest_room_6_obj_hi : goto plot_forest_room_6
        if room = 7 then pointer = forest_room_7_obj_lo : pointer_hi = forest_room_7_obj_hi : goto plot_forest_room_7
        if room = 8 then pointer = forest_room_8_obj_lo : pointer_hi = forest_room_8_obj_hi : goto plot_forest_room_8
        if room = 9 then pointer = forest_room_9_obj_lo : pointer_hi = forest_room_9_obj_hi : goto plot_forest_room_9
        if room = 10 then pointer = forest_room_10_obj_lo : pointer_hi = forest_room_10_obj_hi : goto plot_forest_room_10

; room 1 is the default and uses a "crossroads" setup in case the player gets out of bounds somehow
plot_forest_room_1
        plotmapfile tiled/forest_room_1.tmx forest_room_1 0 0 20 14
        memcpy current_map forest_room_1 280
        return

        data forest_room_1_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end


plot_forest_room_2
        plotmapfile tiled/forest_room_2.tmx forest_room_2 0 0 20 14
        memcpy current_map forest_room_2 280
        return

        data forest_room_2_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

plot_forest_room_3
        plotmapfile tiled/forest_room_3.tmx forest_room_3 0 0 20 14
        memcpy current_map forest_room_3 280
        return

        data forest_room_3_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  TYPE_SLIME, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

plot_forest_room_4
        plotmapfile tiled/forest_room_4.tmx forest_room_4 0 0 20 14
        memcpy current_map forest_room_4 280
        return

        data forest_room_4_obj
        TYPE_SLIME, $54, $79,  $02, $2A, $30,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

plot_forest_room_5
        plotmapfile tiled/forest_room_5.tmx forest_room_5 0 0 20 14
        memcpy current_map forest_room_5 280
        return

        data forest_room_5_obj
        TYPE_SLIME, $30, $30,
        TYPE_SLIME, $69, $20,
        TYPE_SLIME, $39, $20,
        TYPE_SLIME, $5E, $AF,
        TYPE_SLIME, $42, $AF,
        TYPE_SLIME, $70, $30,
        TYPE_SLIME, $40, $67,
        TYPE_SLIME, $80, $90,
        TYPE_SLIME, $90, $88,
        TYPE_SLIME, $40, $70,
        TYPE_SLIME, $30, $20,
        TYPE_SLIME, $80, $40,
        TYPE_SLIME, $b0, $c0,
        TYPE_SLIME, $77, $55,
        TYPE_SLIME, $44, $22,
        TYPE_SLIME, $33, $66,
end

plot_forest_room_6
        plotmapfile tiled/forest_room_6.tmx forest_room_6 0 0 20 14
        memcpy current_map forest_room_6 280
        return

        data forest_room_6_obj
        TYPE_WOLF, $30, $30,
        TYPE_TORCH, $69, $20,
        TYPE_TORCH, $39, $20,
        TYPE_TORCH, $5E, $AF,
        TYPE_TORCH, $42, $AF,
        TYPE_WOLF, $70, $30,
        TYPE_SLIME, $40, $67,
        TYPE_SLIME, $80, $90,
        $00, $90, $88,
        $00, $40, $70,
        $00, $30, $20,
        $00, $80, $40,
        $00, $b0, $c0,
        $00, $77, $55,
        $00, $44, $22,
        $00, $33, $66,
end

plot_forest_room_7
        plotmapfile tiled/forest_room_7.tmx forest_room_7 0 0 20 14
        memcpy current_map forest_room_7 280
        return

        data forest_room_7_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

plot_forest_room_8
        plotmapfile tiled/forest_room_8.tmx forest_room_8 0 0 20 14
        memcpy current_map forest_room_8 280
        return

        data forest_room_8_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

plot_forest_room_9
        plotmapfile tiled/forest_room_9.tmx forest_room_9 0 0 20 14
        memcpy current_map forest_room_9 280
        return

        data forest_room_9_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

plot_forest_room_10
        plotmapfile tiled/forest_room_10.tmx forest_room_10 0 0 20 14
        memcpy current_map forest_room_10 280
        return

        data forest_room_10_obj
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
        $00, $00, $00,  $00, $00, $00,  $00, $00, $00,  $00, $00, $00,
end

        data forest_rooms
        00, 00,  8, 07, 06, 00, 00,
        00,  9, 10, 04, 05, 00, 00,
        00, 00, 00, 03, 00, 00, 00,
        00, 00, 00, 02, 00, 00, 00,
        00, 00, 00, 01, 00, 00, 00,
        00, 00, 00, 00, 00, 00, 00,
        00, 00, 00, 00, 00, 00, 00
end

test_walkable_forest
        asm
        ldx #0
.loop   lda forest_walkable_tiles,x
        cmp move_tile_1
        bne .tile2
        pha
        lda #1
        sta walkable_1
        pla
.tile2  cmp move_tile_2
        bne .next
        lda #1
        sta walkable_2
.next   inx
        cpx #forest_walkable_tiles_length
        bne .loop
        lda walkable_1
        beq .done
        lda walkable_2
        beq .done
        lda #1
        sta walkable
.done
end
        goto walkable_return
;        for walk_index = 0 to forest_walkable_tiles_length
;        walk_test = forest_walkable_tiles[walk_index]
;        if walk_test = move_tile_1 then walkable_1 = 1
;        if walk_test = move_tile_2 then walkable_2 = 1
;        next
;        if !walkable_1 then walkable_return
;        if !walkable_2 then walkable_return
;        walkable = 1
;        goto walkable_return

        data forest_walkable_tiles
        $00, $02, $04, $0E, $12, $14, $16, $18, $1A, $1C, $1E, $20
end

;==============================================================================
; WOLF AI
;------------------------------------------------------------------------------
; Wolves wait for the player to get close (WOLF_CHASE_DIST), then give chase
;==============================================================================
wolf_ai
        const WOLF_CHASE_DIST = 32
        ; Once wolves start chasing, they don't stop
        if flags{7} then wolf_chase

        ; Test player distance to wolf
        temp1 = Xposition - player_Xpos
        if temp1 < WOLF_CHASE_DIST then wolf_chase
        temp1 = Yposition - player_Ypos
        if temp1 < (WOLF_CHASE_DIST * 2) then wolf_chase

wolf_anim
        ; Wolves flip left or right facing depending on player position
        frame = 0
        if Xposition < player_Xpos then frame = frame + 2
        if animation_frame then frame = frame + 1
        return

wolf_chase
        flags{7} = 1
        gosub followplayer
        goto wolf_anim

obj_wolf_stats
; TODO: Make this implementation suck less
        const WOLF_SPEED_HI = 1
        const WOLF_SPEED_LO = 0
        const WOLF_HP = 2
        const WOLF_VEL_CAP_HI = 2
        const WOLF_VEL_CAP_LO = 0
        const WOLF_FRICTION_HI = 1
        const WOLF_FRICTION_LO = 0
        const WOLF_DAMAGE = 1
        const WOLF_CONTACT = 1
        const WOLF_DROP_RATE = 64

        object_hp[obj_index] = WOLF_HP
        object_contact[obj_index] = WOLF_CONTACT
        object_vel_cap_hi[obj_index] = WOLF_VEL_CAP_HI
        object_vel_cap_lo[obj_index] = WOLF_VEL_CAP_LO
        object_damage[obj_index] = WOLF_DAMAGE
        object_friction_hi[obj_index] = WOLF_FRICTION_HI
        object_friction_lo[obj_index] = WOLF_FRICTION_LO
        object_speed_hi[obj_index] = WOLF_SPEED_HI
        object_speed_lo[obj_index] = WOLF_SPEED_LO
        object_flags[obj_index] = 0
        goto obj_next_stats

;==============================================================================
; SLIME AI
;------------------------------------------------------------------------------
; A Slime draws near!
; Command?
;==============================================================================
slime_ai
        gosub followplayer
        return

obj_slime_stats
        const SLIME_DROP_RATE = 128
        const SLIME_HP = 4
        const MSLIME_HP = SLIME_HP / 2
        const SLIME_CONTACT = 4
        const SLIME_VEL_CAP_HI = 1
        const SLIME_VEL_CAP_LO = 0
        const SLIME_DAMAGE = 4
        const SLIME_FRICTION_HI = 1
        const SLIME_FRICTION_LO = 0
        const SLIME_SPEED_HI = 0
        const SLIME_SPEED_LO = 50
        object_hp[obj_index] = SLIME_HP
        object_contact[obj_index] = SLIME_CONTACT
        object_vel_cap_hi[obj_index] = SLIME_VEL_CAP_HI
        object_vel_cap_lo[obj_index] = SLIME_VEL_CAP_LO
        object_damage[obj_index] = SLIME_DAMAGE
        object_friction_hi[obj_index] = SLIME_FRICTION_HI
        object_friction_lo[obj_index] = SLIME_FRICTION_LO
        object_speed_hi[obj_index] = SLIME_SPEED_HI
        object_speed_lo[obj_index] = SLIME_SPEED_LO
        object_flags[obj_index] = 0
        goto obj_next_stats

;==============================================================================
; BANK 8
;------------------------------------------------------------------------------
; Permanently loaded bank. Contains sprites and code used with every tileset
;==============================================================================
        bank 8
        incgraphic gfx/sprites/heroine0.png  160B 0 4 5 3 6 1 ; FRAME_DOWN
        incgraphic gfx/sprites/heroine1.png  160B 0 4 5 3 6 1 ; FRAME_DOWN_2
        incgraphic gfx/sprites/heroine2.png  160B 0 4 5 6 3   ; FRAME_UP
        incgraphic gfx/sprites/heroine3.png  160B 0 4 5 6 3   ; FRAME_UP_2
        incgraphic gfx/sprites/heroine4.png  160B 0 4 5 6 3 1 ; FRAME_LEFT
        incgraphic gfx/sprites/heroine5.png  160B 0 4 5 6 3 1 ; FRAME_LEFT_2
        incgraphic gfx/sprites/heroine6.png  160B 0 4 5 3 6 1 ; FRAME_RIGHT
        incgraphic gfx/sprites/heroine7.png  160B 0 4 5 3 6 1 ; FRAME_RIGHT_2
        incgraphic gfx/sprites/heroine8.png  160B 0 4 5 3 6 1 ; FRAME_ATK_D
        incgraphic gfx/sprites/heroine9.png  160B 0 4 6 5 3   ; FRAME_ATK_U
        incgraphic gfx/sprites/heroine10.png 160B 0 4 5 6 3 1 ; FRAME_ATK_L
        incgraphic gfx/sprites/heroine11.png 160B 0 4 5 3 6 1 ; FRAME_ATK_R
        incgraphic gfx/sprites/link.png      160B 0 4 5 6 3 1 ; FRAME_CHANT (bugged if heroine12.png is used?)
        incgraphic gfx/sprites/sword0.png 160A 0 1 3
        incgraphic gfx/sprites/sword1.png 160A 0 3 1
        incgraphic gfx/sprites/sword2.png 160A 0 1 3
        incgraphic gfx/sprites/sword3.png 160A 0 1 3
        incgraphic gfx/sprites/shield.png 160A 0 2 1
        incgraphic gfx/sprites/torch0.png 160B 0 1 2 3 6 5 4
        incgraphic gfx/sprites/torch1.png 160B 0 1 2 3 5 6 4
        incgraphic gfx/sprites/hp.png 160B 0 3 7 8 1 2
        incgraphic gfx/sprites/mp.png 160A 0 3 1
        incgraphic gfx/sprites/bar0.png 160A 0 1
        incgraphic gfx/sprites/bar1.png 160A 0 2 1
        incgraphic gfx/sprites/bar2.png 160A 0 2 1
        incgraphic gfx/sprites/bar3.png 160A 0 2 1
        incgraphic gfx/sprites/bar4.png 160A 0 2 1
        incgraphic gfx/sprites/bar5.png 160A 0 2 1
        incgraphic gfx/sprites/bar6.png 160A 0 2 1
        incgraphic gfx/sprites/bar7.png 160A 0 2 1
        incgraphic gfx/sprites/bar8.png 160A 0 2 1
        incgraphic gfx/sprites/coin.png 160A 0 3 2
        incgraphic gfx/sprites/prism.png 160A 0 3 2 1

;==============================================================================
; LOAD OBJECTS
;------------------------------------------------------------------------------
; Fills all 16 object slots with type and position data from ROM,
; then interates through each type to set object properties
; Utilizes pointers so multiple maps can reuse the same object data if desired
;==============================================================================
load_objects
        temp1 = 0
        for obj_index = 0 to 15
        object_type[obj_index] = pointer[[temp1]]
        temp1 = temp1 + 1
        object_Xpos[obj_index] = pointer[[temp1]]
        temp1 = temp1 + 1
        object_Ypos[obj_index] = pointer[[temp1]]
        temp1 = temp1 + 1
        next
        for obj_index = 0 to 15
        if !object_type[obj_index] then next_obj_stats
        if object_type[obj_index] = TYPE_WOLF then obj_wolf_stats
        if object_type[obj_index] = TYPE_TORCH then obj_torch_stats
        if object_type[obj_index] = TYPE_SLIME then obj_slime_stats
        if object_type[obj_index] = TYPE_MSLIME then obj_slime_stats : object_hp = MSLIME_HP


obj_next_stats
        next
        return

obj_torch_stats
        object_hp[obj_index] = 1
        object_contact[obj_index] = 0
        object_vel_cap_hi[obj_index] = 0
        object_vel_cap_lo[obj_index] = 0
        object_damage[obj_index] = 0
        object_friction_hi[obj_index] = 0
        object_friction_lo[obj_index] = 0
        object_speed_hi[obj_index] = 0
        object_speed_lo[obj_index] = 0
        object_flags[obj_index] = 0
        goto obj_next_stats

load_map
        clearscreen
        displaymode 160A
        adjustvisible 0 14
        game_state = STATE_FIELD
        if tileset = T_FOREST then loadrombank 2 : gosub load_forest
        savescreen
        gosub load_objects
        reload_map = 0
        if exit_dir = EXIT_SOUTH then player_Ypos = 16  : player_Ydir = DIR_DOWN
        if exit_dir = EXIT_NORTH then player_Ypos = 204 : player_Ydir = DIR_UP
        if exit_dir = EXIT_EAST  then player_Xpos = 148 : player_Xdir = DIR_LEFT
        if exit_dir = EXIT_WEST  then player_Xpos = 16  : player_Xdir = DIR_RIGHT
        exit_dir = EXIT_NONE

field_handler
        if reload_map = 1 then goto load_map
        gosub player_handler
        gosub object_handler
        gosub check_collisions
        player_timer = player_timer - 1 : if player_timer < 0 then player_timer = 0

        ; Currently only two frames of animation supported. Needs to be changed if more than 2
        animation_frame = 0
        if animation_timer > (ANIM_TIME / 2) then animation_frame = 1
        
        restorescreen
        if debug_time then BACKGRND = $06
        ; Iterates through all objects and determined which sprites need to be plotted by type
        for index = 0 to 15
        if !object_type[index] then goto plot_next
        if object_type[index] = TYPE_SPAWNER then plot_next
        Xposition = object_Xpos[index] : Yposition = object_Ypos[index] : frame = object_frame[index]
        if object_type[index] = TYPE_WOLF then plot_wolf
        if object_type[index] = TYPE_TORCH then plot_torch
        if object_type[index] = TYPE_COIN then plot_coin
        if object_type[index] = TYPE_PRISM then plot_prism
        if object_type[index] = TYPE_SLIME then plot_slime
        if object_type[index] = TYPE_MSLIME then plot_minislime
plot_next
        next
        ; Plot the player, their shield, and sword if attacking
        if player_state = STATE_CHANT then plotsprite link 0 player_Xpos player_Ypos 0 : goto plot_hud
        plotsprite heroine0 0 player_Xpos player_Ypos player_frame
        if player_state = STATE_ATTACK then plotsprite sword0 sword_pal sword_Xpos sword_Ypos sword_frame
        ; TODO: Multiple shield frames depending on direction/state
        plotsprite shield shield_pal shield_Xpos shield_Ypos shield_frame
        if debug_time then BACKGRND = bg_color
plot_hud
        gosub draw_hud
        goto main

plot_wolf
        PLOTSPRITE wolf0 5 Xposition Yposition frame
        goto plot_next

plot_torch
        PLOTSPRITE torch0 0 Xposition Yposition animation_frame
        goto plot_next

plot_coin
        PLOTSPRITE coin 3 Xposition Yposition 0
        goto plot_next

plot_prism
        PLOTSPRITE prism 0 Xposition Yposition 0
        goto plot_next

plot_slime
        PLOTSPRITE slime0 4 Xposition Yposition animation_frame
        goto plot_next

plot_minislime
        PLOTSPRITE minislime0 4 Xposition Yposition animation_frame
        goto plot_next


;==============================================================================
; DRAW HUD
;------------------------------------------------------------------------------
; Draws the player's HP and MP bar in zones 1-2 using sprites.
; Bars must be plotted in separate zones or there isn't enough DMA time
;==============================================================================
draw_hud
        if debug_time then BACKGRND = $43
        plotsprite  hp   0  8  0       ; HP is 160B
        plotsprite  bar0 2 24  0 hp_seg_1
        PLOTSPRITE4 bar0 2 32  0 hp_seg_2
        PLOTSPRITE4 bar0 2 40  0 hp_seg_3
        PLOTSPRITE4 bar0 2 48  0 hp_seg_4
        PLOTSPRITE4 bar0 2 56  0 hp_seg_5
        PLOTSPRITE4 bar0 2 64  0 hp_seg_6
        plotsprite  mp   0  8 16        ; Need to use plotsprite here to avoid rendering error on MP bar
        PLOTSPRITE4 bar0 0 24 16 mp_seg_1
        PLOTSPRITE4 bar0 0 32 16 mp_seg_2
        PLOTSPRITE4 bar0 0 40 16 mp_seg_3
        PLOTSPRITE4 bar0 0 48 16 mp_seg_4
        PLOTSPRITE4 bar0 0 56 16 mp_seg_5
        PLOTSPRITE4 bar0 0 64 16 mp_seg_6
        if debug_hud = 0 then return
        plotvalue hud 0 player_Xpos 4 32 12
        plotvalue hud2 0 move_tile_1 4 32 13
        plotvalue hud 0 room_index 2 32 13
        plotvalue hud 0 room 2 48 13
        if debug_time then BACKGRND = bg_color
        return

menu_handler
        goto field_handler

followplayer
        if Xposition > player_Xpos then Xvelocity = Xvelocity + move_speed : Xdirection = DIR_LEFT
        if Xposition < player_Xpos then Xvelocity = Xvelocity + move_speed : Xdirection = DIR_RIGHT
        if Yposition > player_Ypos then Yvelocity = Yvelocity + move_speed : Ydirection = DIR_UP
        if Yposition < player_Ypos then Yvelocity = Yvelocity + move_speed : Ydirection = DIR_DOWN
        return

object_handler
        for index = 0 to 15
        if !object_type[index] then object_done    ; 0 = no object
        if object_type[index] = TYPE_COIN then object_done      ;  coins, prisms are static
        if object_type[index] = TYPE_PRISM then object_done
        if object_type[index] = TYPE_SPAWNER then spawn_object
        if object_type[index] = TYPE_TORCH then torch_tile_block
        gosub copy_object_props
        gosub decelerate_object
        if object_type[index] = TYPE_WOLF then gosub wolf_ai
        if object_type[index] = TYPE_SLIME then gosub slime_ai
        if object_type[index] = TYPE_MSLIME then gosub slime_ai
        gosub move_object
        gosub restore_object_props
object_done
        if debug_time = 1 then BACKGRND = bg_color
        next
        return

torch_tile_block
        if debug_time = 1 then BACKGRND = $76
        if object_flags[index] then object_done
        gosub get_torch_pos
        pokechar current_map peekX peekY 20 14 10
        object_flags[index] = 1
        goto object_done

spawn_object
        ; index is still set by object_handler
        if object_flags[index] = TYPE_TORCH then spawns_torch
        drop_rate = 0
        if object_flags[index] = TYPE_WOLF then drop_rate = WOLF_DROP_RATE
        if object_flags[index] = TYPE_SLIME then drop_rate = SLIME_DROP_RATE

        if rand > drop_rate then spawn_nothing

        if object_flags[index] = TYPE_WOLF then spawns_wolf
        if object_flags[index] = TYPE_SLIME then spawns_slime
        goto object_done

spawns_slime
        ; TODO: Unique drops

spawns_wolf
        ; TODO: Unique wolf item drops
spawns_torch
        player_mp = 0
        dec player_max_mp = 48
        if player_mp = player_max_mp then _spawn_coin

_spawn_mana
        object_type[index] = TYPE_PRISM
        object_hp[index] = 1
        goto object_done

_spawn_coin
        object_type[index] = TYPE_COIN
        object_hp[index] = 1
        goto object_done

spawn_nothing
        object_type[index] = 0
        goto object_done

player_handler
        dec player_damage = $1
        gosub copy_player_props
        gosub decelerate_object
        gosub restore_player_props

handle_input_field
        if debug_time then BACKGRND = $70
        if !player_timer then no_player_timer
        player_timer = player_timer - 1
        if player_state = STATE_KNOCKBACK then test_joy_done
no_player_timer
        player_flags{0} = 0
        joy0fire1_held = 0
        if joy0fire0 then goto player_attack
        player_state = STATE_STAND
        if player_facing = DIR_UP then player_frame = FRAME_UP : goto frames_done
        if player_facing = DIR_DOWN then player_frame = FRAME_DOWN : goto frames_done
        if player_facing = DIR_LEFT then player_frame = FRAME_LEFT : goto frames_done
        player_frame = FRAME_RIGHT
frames_done
        if joy0up    then player_Ydir = DIR_UP    : player_facing = DIR_UP    : player_frame = FRAME_UP    : player_Yvel = player_Yvel + player_speed : player_state = STATE_MOVING : test_joy_done
        if joy0down  then player_Ydir = DIR_DOWN  : player_facing = DIR_DOWN  : player_frame = FRAME_DOWN  : player_Yvel = player_Yvel + player_speed : player_state = STATE_MOVING : test_joy_done
        if joy0left  then player_Xdir = DIR_LEFT  : player_facing = DIR_LEFT  : player_frame = FRAME_LEFT  : player_Xvel = player_Xvel + player_speed : player_state = STATE_MOVING : test_joy_done
        if joy0right then player_Xdir = DIR_RIGHT : player_facing = DIR_RIGHT : player_frame = FRAME_RIGHT : player_Xvel = player_Xvel + player_speed : player_state = STATE_MOVING : test_joy_done

test_joy_done
        if joy0fire1 then goto open_menu
        gosub copy_player_props
        gosub move_object
        gosub restore_player_props

        if player_facing = DIR_DOWN then sword_Xpos = player_Xpos : sword_Ypos = player_Ypos + SWORD_OFFSET_DOWN : sword_width = 4 : sword_height = 16 : sword_frame = 0 : goto sword_done
        if player_facing = DIR_UP   then sword_Xpos = player_Xpos : sword_Ypos = player_Ypos + SWORD_OFFSET_UP   : sword_width = 4 : sword_height = 16 : sword_frame = 1 : goto sword_done
        if player_facing = DIR_LEFT then sword_Xpos = player_Xpos + SWORD_OFFSET_LEFT : sword_Ypos = player_Ypos : sword_width = 12 : sword_height = 4 :sword_frame = 3 : goto sword_done
        sword_Xpos = player_Xpos + SWORD_OFFSET_RIGHT : sword_Ypos = player_Ypos : sword_width = 12 : sword_height = 4 : sword_frame = 2
sword_done
        shield_Xpos = player_Xpos + SHIELD_OFFSET_X
        shield_Ypos = player_Ypos + SHIELD_OFFSET_Y
input_frame_done
        if !player_Xvel && !player_Yvel && player_state <> STATE_ATTACK && player_state <> STATE_CHANT then player_state = STATE_STAND
        if animation_frame && player_state = STATE_MOVING then player_frame = player_frame + 1

check_room_boundary
        if player_Xpos < 2  then exit_dir = EXIT_EAST  : room_index = room_index - 1
        if player_Xpos > 149 then exit_dir = EXIT_WEST  : room_index = room_index + 1
        if player_Ypos < 2  then exit_dir = EXIT_NORTH : room_index = room_index - ROOMS_PER_ROW
        if player_Ypos > 204 then exit_dir = EXIT_SOUTH : room_index = room_index + ROOMS_PER_ROW
        if exit_dir then reload_map = 1
        if debug_time then BACKGRND = bg_color
        return

open_menu
        game_state = STATE_MENU
        return

player_attack
        if joy0fire1_held then player_chant
        joy0fire1_held = 1
        if player_facing = DIR_LEFT  then player_frame = FRAME_ATK_L : goto player_attack_return
        if player_facing = DIR_RIGHT then player_frame = FRAME_ATK_R : goto player_attack_return
        if player_facing = DIR_UP    then player_frame = FRAME_ATK_U : goto player_attack_return
        if player_facing = DIR_DOWN  then player_frame = FRAME_ATK_D

player_attack_return
        player_state = STATE_ATTACK
        if debug_time then BACKGRND = bg_color
        return

player_chant
        player_timer = player_timer + 1
        if player_timer > 4 then player_state = STATE_CHANT
        return

decelerate_object
        if !friction then decel_return
        if !Xvelocity then decel_Y
        temp1 = Xvelocity
        Xvelocity = Xvelocity - friction
        if temp1 < Xvelocity then Xvelocity = 0
decel_Y
        if !Yvelocity then decel_return
        temp1 = Yvelocity
        Yvelocity = Yvelocity - friction
        if temp1 < Yvelocity then Yvelocity = 0
decel_return
        return

;==============================================================================
; SUBROUTINE: MOVE_OBJECT
;------------------------------------------------------------------------------
; Moves an object based on the non-fractional component of their velocities
; Tests against an array of walkable tiles for current tileset before moving
; KISS: Moving objects are assumed to fit player sprite proportions (12x16)
; TODO: Replace bounding box magic numbers with variables based on object
;==============================================================================
move_object
        if debug_time then BACKGRND = $96

        ; Cap the object's velocity TODO: separate X/Y cap?
        if Xvelocity > vel_cap then Xvelocity = vel_cap
        if Yvelocity > vel_cap then Yvelocity = vel_cap

        ; Current direction(s) are determined by player input or AI logic
        if Ydirection = DIR_UP    then gosub move_test_up
        if Ydirection = DIR_DOWN  then gosub move_test_down
        if Xdirection = DIR_LEFT  then gosub move_test_left
        if Xdirection = DIR_RIGHT then gosub move_test_right
        goto move_return

move_test_up
;        peekX = (Xposition + 2) / TILE_WIDTH
        ; Add 8 to Y position to allow object to overlap solid tiles above it slightly
;        peekY = ((Yposition + 8) - Yvelocity_hi) / TILE_HEIGHT
        asm
        lda Xposition
        clc
        adc #2
        lsr
        lsr
        lsr
        sta peekX
        lda Yposition
        clc
        adc #8
        sec
        sbc Yvelocity_hi
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_1 = peekchar (current_map, peekX, peekY, 20, 14)
;        peekX = (Xposition + 8) / TILE_WIDTH
        asm
        lda Xposition
        clc
        adc #8
        lsr
        lsr
        lsr
        sta peekX
end
        move_tile_2 = peekchar (current_map, peekX, peekY, 20, 14)
        gosub test_walkable
        if walkable then Yposition = Yposition - Yvelocity_hi
        return

move_test_down
        ;peekX = (Xposition + 2) / TILE_WIDTH
        ;peekY = ((Yposition + Yvelocity_hi) + 15) / TILE_HEIGHT
        asm
        lda Xposition
        clc
        adc #2
        lsr
        lsr
        lsr
        sta peekX
        lda Yposition
        clc
        adc #15
        clc
        adc Yvelocity_hi
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_1 = peekchar (current_map, peekX, peekY, 20, 14)
        ;peekX = (Xposition + 8) / TILE_WIDTH
        asm
        lda Xposition
        clc
        adc #8
        lsr
        lsr
        lsr
        sta peekX
end
        move_tile_2 = peekchar (current_map, peekX, peekY, 20, 14)
        gosub test_walkable
        if walkable then Yposition = Yposition + Yvelocity_hi
        return

move_test_left
;        peekX = ((Xposition + 2) - Xvelocity_hi) / TILE_WIDTH
        ; Add 8 to Y position to allow object to overlap solid tiles above it slightly
;        peekY = (Yposition + 8) / TILE_HEIGHT
        asm
        lda Xposition
        clc
        adc #2
        sec
        sbc Xvelocity_hi
        lsr
        lsr
        lsr
        sta peekX
        lda Yposition
        clc
        adc #8
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_1 = peekchar (current_map, peekX, peekY, 20, 14)
;        peekY = (Yposition + 15) / TILE_HEIGHT
        asm
        lda Yposition
        clc
        adc #15
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_2 = peekchar (current_map, peekX, peekY, 20, 14)
        gosub test_walkable
        if walkable then Xposition = Xposition - Xvelocity_hi
        return

move_test_right
;        peekX = ((Xposition + 9) + Xvelocity_hi) / TILE_WIDTH
        ; Add 8 to Y position to allow object to overlap solid tiles above it slightly
;        peekY = (Yposition + 8) / TILE_HEIGHT
        asm
        lda Xposition
        clc
        adc #9
        clc
        adc Xvelocity_hi
        lsr
        lsr
        lsr
        sta peekX
        lda Yposition
        clc
        adc #8
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_1 = peekchar (current_map, peekX, peekY, 20, 14)
;        peekY = (Yposition + 15) / TILE_HEIGHT
        asm
        lda Yposition
        clc
        adc #15
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        move_tile_2 = peekchar (current_map, peekX, peekY, 20, 14)
        gosub test_walkable
        if walkable then Xposition = Xposition + Xvelocity_hi
        return
        
move_return
        if debug_time then BACKGRND = bg_color
        return

test_walkable
        ; start by assuming the tile isn't walkable (fewer tests)
;        walkable = 0
;        walkable_1 = 0
;        walkable_2 = 0
        asm
        lda #0
        sta walkable
        sta walkable_1
        sta walkable_2
end
        if tileset = T_FOREST then test_walkable_forest
walkable_return
        return

check_collisions
        if debug_time = 1 then BACKGRND = $95
        for index = 0 to 15
        if !object_type[index] then cc_next
        if object_type[index] = TYPE_COIN then cc_pickup
        if object_type[index] = TYPE_PRISM then cc_pickup
        gosub copy_object_props
        hp_change = player_damage
        if player_state <> STATE_ATTACK then cc_player_contact
        gosub sword_collision
        if !object_hp[index] then kill_object
cc_player_contact
        ; need to test torches here so the sword can still damage them
        ; but they don't knock the player back on contact
        if object_type[index] = TYPE_TORCH then cc_next
        hp_change = object_contact[index]
        gosub player_knockback
cc_next
        if debug_time = 1 then BACKGRND = bg_color
        next
cc_return
        return

cc_pickup
        goto cc_next

kill_object
        ; TODO: Death animation
        if object_type[index] <> TYPE_TORCH then change_to_spawner
        ; torches make their tile walkable
        if debug_time = 1 then BACKGRND = $73
        gosub get_torch_pos
        pokechar current_map peekX peekY 20 14 0
        if debug_time = 1 then BACKGRND = bg_color
change_to_spawner
        if object_type[index] = TYPE_SLIME && animation_frame then goto split_slime
        ; switch the object's flags to its old type and its type to a spwaner
        object_flags[index] = object_type[index]
        object_type[index] = TYPE_SPAWNER
        goto cc_next

split_slime
        if debug_time = 1 then BACKGRND = $B9
        ; replace slime mobj with mini slime
        object_type[index] = TYPE_MSLIME
        object_hp[index] = MSLIME_HP
        temp1 = object_Xpos[index]
        temp2 = object_Ypos[index]
        ; mini slime is moved to the left of the parent slime's pos
        object_Xpos[index] = object_Xpos[index] - 1
        gosub find_new_object
        ; if no slots, the slime just becomes a single mini slime
        if no_empty_slot then object_Xpos[index] = temp1 : cc_next
        ; initialize the new mini slime object
        object_type[index] = TYPE_MSLIME
        object_hp[index] = MSLIME_HP
        object_contact[index] = SLIME_CONTACT
        object_vel_cap_hi[index] = SLIME_VEL_CAP_HI
        object_vel_cap_lo[index] = SLIME_VEL_CAP_LO
        object_damage[index] = SLIME_DAMAGE
        object_friction_hi[index] = SLIME_FRICTION_HI
        object_friction_lo[index] = SLIME_FRICTION_LO
        object_speed_hi[index] = SLIME_SPEED_HI
        object_speed_lo[index] = SLIME_SPEED_LO
        ; mini slime spawns to the right of the parent slime's pos
        object_Xpos[index] = temp1 + 9
        object_Ypos[index] = temp2
        goto cc_next

sword_collision
        if !boxcollision (sword_Xpos, sword_Ypos, sword_width, sword_height, Xposition, Yposition, 12, 16) then return
sword_damage
        ; TODO: Much better damage calculations
        temp_hp = object_hp[index]
        hp_change = player_damage
        gosub decrease_hp
        object_hp[index] = temp_hp
        return

player_knockback
        if player_flags{0} then return  ; player is invulnerable, bypass collision check to save cycles
        if !boxcollision (player_Xpos, player_Ypos, PLAYER_WIDTH, PLAYER_HEIGHT, Xposition, Yposition, width, height) then return
        if Yposition <= player_Ypos then player_Yvel = 10.0 : player_Ydir = DIR_DOWN  : player_frame = FRAME_UP    : goto pc_damage
        if Yposition >= player_Ypos then player_Yvel = 10.0 : player_Ydir = DIR_UP    : player_frame = FRAME_DOWN  : goto pc_damage
        if Xposition >= player_Xpos then player_Xvel = 5.0 : player_Xdir = DIR_LEFT  : player_frame = FRAME_RIGHT : goto pc_damage
        if Xposition <= player_Xpos then player_Xvel = 5.0 : player_Xdir = DIR_RIGHT : player_frame = FRAME_LEFT
pc_damage
        ; avoid a tail call with goto
        player_flags{0} = 1
        player_state = STATE_KNOCKBACK
        player_timer = INVULN_FRAMES
        goto damage_player_hp

; takes a torch's X & Y position and determines the map tile under it, stores in peekX & Y
get_torch_pos
        asm
        ldx index
        lda object_Xpos,x
        clc
        adc #4          ; forces X calculation onto correct map tile
        lsr
        lsr
        lsr
        sta peekX
        lda object_Ypos,x
        clc
        adc #8          ; forces Y calculation onto correct map tile
        lsr
        lsr
        lsr
        lsr
        sta peekY
end
        return

; copies player movement variables to be manipulated by movement subroutines
copy_player_props
        if debug_time = 1 then BACKGRND = $E9
        asm
        lda player_Xpos
        sta Xposition
        lda player_Xdir
        sta Xdirection
        lda player_Xvel_lo
        sta Xvelocity_lo
        lda player_Xvel_hi
        sta Xvelocity_hi
        lda player_Ypos
        sta Yposition
        lda player_Ydir
        sta Ydirection
        lda player_Yvel_lo
        sta Yvelocity_lo
        lda player_Yvel_hi
        sta Yvelocity_hi
        lda player_vel_cap
        sta vel_cap
        lda player_friction
        sta friction
end
        if debug_time = 1 then BACKGRND = bg_color
        return
;        Xposition  = player_Xpos
;        Xdirection = player_Xdir
;        Xvelocity  = player_Xvel
;        Yposition  = player_Ypos
;        Ydirection = player_Ydir
;        Yvelocity  = player_Yvel
;        vel_cap    = player_vel_cap
;        friction   = player_friction
;        return

; restores movement variables from subroutines back to player
restore_player_props
        if debug_time = 1 then BACKGRND = $E7
        asm
        lda Xposition
        sta player_Xpos
        lda Xvelocity_lo
        sta player_Xvel_lo
        lda Xvelocity_hi
        sta player_Xvel_hi
        lda Yposition
        sta player_Ypos
        lda Yvelocity_lo
        sta player_Yvel_lo
        lda Yvelocity_hi
        sta player_Yvel_hi
end
        if debug_time = 1 then BACKGRND = bg_color
        return
;        player_Xpos = Xposition
;        player_Xvel = Xvelocity
;        player_Ypos = Yposition
;        player_Yvel = Yvelocity
;        return

copy_object_props
        if debug_time then BACKGRND = $D6
        asm
        ldx index
        lda object_Xpos,x
        sta Xposition
        lda object_Xdir,x
        sta Xdirection
        lda object_Xvel_lo,x
        sta Xvelocity_lo
        lda object_Xvel_hi,x
        sta Xvelocity_hi
        lda object_Ypos,x
        sta Yposition
        lda object_Ydir,x
        sta Ydirection
        lda object_Yvel_lo,x
        sta Yvelocity_lo
        lda object_Yvel_hi,x
        sta Yvelocity_hi
        lda object_speed_lo,x
        sta move_speed_lo
        lda object_speed_hi,x
        sta move_speed_hi
        lda object_vel_cap_lo,x
        sta vel_cap_lo
        lda object_vel_cap_hi,x
        sta vel_cap_hi
        lda object_friction_lo,x
        sta friction_lo
        lda object_friction_hi,x
        sta friction_hi
        lda object_frame,x
        sta frame
        lda object_flags,x
        sta flags
end
;        Xposition  = object_Xpos[index]
;        Xdirection = object_Xdir[index]
;        Xvelocity  = object_Xvel[index]
;        Yposition  = object_Ypos[index]
;        Ydirection = object_Ydir[index]
;        Yvelocity  = object_Yvel[index]
;        move_speed = object_speed[index]
;        vel_cap    = object_vel_cap[index]
;        friction   = object_friction[index]
;        width      = object_width[index]
;        height     = object_height[index]
;        frame      = object_frame[index]
;        flags      = object_flags[index]
        if debug_time then BACKGRND = bg_color
        asm
        rts
end

restore_object_props
        if debug_time then BACKGRND = $36
        asm
        ldx index
        lda Xposition
        sta object_Xpos,x
        lda Xvelocity_lo
        sta object_Xvel_lo,x
        lda Xvelocity_hi
        sta object_Xvel_hi,x
        lda Yposition
        sta object_Ypos,x
        lda Yvelocity_lo
        sta object_Yvel_lo,x
        lda Yvelocity_hi
        sta object_Yvel_hi,x
        lda frame
        sta object_frame,x
        lda flags
        sta object_flags,x
end
;        object_Xpos[index]  = Xposition
;        object_Xvel[index]  = Xvelocity
;        object_Ypos[index]  = Yposition
;        object_Yvel[index]  = Yvelocity
;        object_frame[index] = frame
;        object_flags[index] = flags
        if debug_time then BACKGRND = bg_color
        asm
        rts
end


damage_player_hp
        ; TODO: This currently can't scale, only works with max HP 48...
        dec temp1 = player_hp        ; temp1 used to detect underflow
        dec player_hp = player_hp - hp_change
        if player_hp > temp1 then player_hp = 0
        dec temp1 = player_hp
        dec hp_seg_1 = player_hp - 8
        if hp_seg_1 > temp1 then hp_seg_1 = 0
        dec temp1 = hp_seg_1
        dec hp_seg_2 = hp_seg_1 - 8
        if hp_seg_2 > temp1 then hp_seg_2 = 0
        dec temp1 = hp_seg_2
        dec hp_seg_3 = hp_seg_2 - 8
        if hp_seg_3 > temp1 then hp_seg_3 = 0
        dec temp1 = hp_seg_3
        dec hp_seg_4 = hp_seg_3 - 8
        if hp_seg_4 > temp1 then hp_seg_4 = 0
        dec temp1 = hp_seg_4
        dec hp_seg_5 = hp_seg_4 - 8
        if hp_seg_5 > temp1 then hp_seg_5 = 0
        dec temp1 = hp_seg_5
        dec hp_seg_6 = hp_seg_5 - 8
        if hp_seg_6 > temp1 then hp_seg_6 = 0
        if hp_seg_6 > 8 then hp_seg_6 = 8
        if hp_seg_5 > 8 then hp_seg_5 = 8
        if hp_seg_4 > 8 then hp_seg_4 = 8
        if hp_seg_3 > 8 then hp_seg_3 = 8
        if hp_seg_2 > 8 then hp_seg_2 = 8
        if hp_seg_1 > 8 then hp_seg_1 = 8
        return

increase_hp
        temp_hp = temp_hp + hp_change
        return

decrease_hp
        temp_hp = temp_hp - hp_change
        return

;==============================================================================
; SUBROUTINE: FIND NEW OBJECT
;------------------------------------------------------------------------------
; Iterates through all 16 object slots and sets the index variable to a 0 slot
;==============================================================================
find_new_object
        asm
        ldx #0
        stx no_empty_slot
new_obj_loop
        lda object_type,x
        beq new_obj_found
        inx
        cpx #15
        bne new_obj_loop
        ; no empty obj slot found, routines can test if this is non-zero
        stx no_empty_slot
        rts
new_obj_found
        stx index
        rts
end

clear_palettes
        BACKGRND = $00
        P0C1 = $00 : P0C2 = $00 : P0C3 = $00
        P1C1 = $00 : P1C2 = $00 : P1C3 = $00
        P2C1 = $00 : P2C2 = $00 : P2C3 = $00
        P3C1 = $00 : P3C2 = $00 : P3C3 = $00
        P4C1 = $00 : P4C2 = $00 : P4C3 = $00
        P5C1 = $00 : P5C2 = $00 : P5C3 = $00
        P6C1 = $00 : P6C2 = $00 : P6C3 = $00
        P7C1 = $00 : P7C2 = $00 : P7C3 = $00
        return

main
        drawscreen
        animation_timer = animation_timer + 1
        if animation_timer > ANIM_TIME then animation_timer = 0
        if game_state = STATE_TITLE then title_handler
        if game_state = STATE_FIELD then field_handler
        if game_state = STATE_MENU  then menu_handler
        goto main

topscreenroutine
        WSYNC=1
        BACKGRND=bg_color
        if game_state = STATE_TITLE then set_title_top_pal
        return

set_title_top_pal
        P0C1 = $80 : P0C2 = $0F : P0C3 = $90
        P4C1 = $80 : P4C2 = $0F : P4C3 = $08
        return

bottomscreenroutine
        WSYNC=1
        BACKGRND=$00
        if game_state = STATE_TITLE then set_title_bottom_pal
        if player_state = STATE_CHANT && animation_timer > ANIM_TIME / 2 then BACKGRND=$60
        return

set_title_bottom_pal
        P0C1 = $80 : P0C2 = $0F : P0C3 = $90
        P4C1 = $00 : P4C2 = $02 : P4C3 = $03
        return