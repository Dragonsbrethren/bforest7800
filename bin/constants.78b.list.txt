------- FILE constants.78b.asm LEVEL 1 PASS 3
      1  10000 ????						; MACRO.H
      2  10000 ????
      3  10000 ????						; Based on the 2600 macro.h file.
      4  10000 ????						; Macros irrelevant to the 7800 have been removed, and the sleep macro
      5  10000 ????						; has been adapted to give accurate results on the 7800.
      6  10000 ????
      7  10000 ????						; Version 1.0 2019/12/11 (based on the 2600 Version 1.05, 13/NOVEMBER/2003)
      8  10000 ????
      9  10000 ????						; Available macros...
     10  10000 ????						;   SLEEP n		 - sleep for n cycles
     11  10000 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     12  10000 ????
     13  10000 ????						;-------------------------------------------------------------------------------
     14  10000 ????						; SLEEP duration
     15  10000 ????						; Original author: Thomas Jentzsch
     16  10000 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     17  10000 ????						; useful for code where precise timing is required.
     18  10000 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     19  10000 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     20  10000 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     21  10000 ????
     22  10000 ????				       MAC	sleep
     23  10000 ????			    .CYCLES    SET	{1}
     24  10000 ????
     25  10000 ????				       IF	.CYCLES < 2
     26  10000 ????				       ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     27  10000 ????				       ERR
     28  10000 ????				       ENDIF
     29  10000 ????
     30  10000 ????				       IF	.CYCLES & 1
     31  10000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     32  10000 ????				       nop	$80
     33  10000 ????				       ELSE
     34  10000 ????				       bit	$80
     35  10000 ????				       ENDIF
     36  10000 ????			    .CYCLES    SET	.CYCLES - 3
     37  10000 ????				       ENDIF
     38  10000 ????
     39  10000 ????				       REPEAT	.CYCLES / 2
     40  10000 ????				       nop
     41  10000 ????				       REPEND
     42  10000 ????				       ENDM		;usage: SLEEP n (n>1)
     43  10000 ????
     44  10000 ????
     45  10000 ????						;-------------------------------------------------------------------------------
     46  10000 ????						; FRACSLEEP duration
     47  10000 ????						; Based on Thomas Jentzsch's SLEEP macro, but takes cycles*2 to allow for
     48  10000 ????						; 7800 based 0.5 cycle sleep.
     49  10000 ????
     50  10000 ????				       MAC	fracsleep
     51  10000 ????			    .CYCLES    SET	{1}
     52  10000 ????
     53  10000 ????				       IF	.CYCLES < 4
     54  10000 ????				       ECHO	"MACRO ERROR: 'FRACSLEEP': Duration must be > 4"
     55  10000 ????				       ERR
     56  10000 ????				       ENDIF
     57  10000 ????				       IF	.CYCLES = 5
     58  10000 ????				       ECHO	"MACRO ERROR: 'FRACSLEEP': Duration = 5 is impossible"
     59  10000 ????				       ERR
     60  10000 ????				       ENDIF
     61  10000 ????
     62  10000 ????				       IF	.CYCLES & 1
     63  10000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     64  10000 ????				       nop	$0	; TIA access is 3.5 cycles
     65  10000 ????				       ELSE
     66  10000 ????				       bit	$0	; TIA access is 3.5 cycles
     67  10000 ????				       ENDIF
     68  10000 ????			    .CYCLES    SET	.CYCLES - 7
     69  10000 ????				       ENDIF
     70  10000 ????
     71  10000 ????				       IF	.CYCLES & 2
     72  10000 ????				       IFNCONST	NO_ILLEGAL_OPCODES
     73  10000 ????				       nop	$80
     74  10000 ????				       ELSE
     75  10000 ????				       bit	$80
     76  10000 ????				       ENDIF
     77  10000 ????			    .CYCLES    SET	.CYCLES - 6
     78  10000 ????				       ENDIF
     79  10000 ????
     80  10000 ????				       REPEAT	.CYCLES / 4
     81  10000 ????				       nop
     82  10000 ????				       REPEND
     83  10000 ????				       ENDM		;usage: FRACSLEEP n (n>1)
     84  10000 ????
     85  10000 ????
     86  10000 ????						;-------------------------------------------------------
     87  10000 ????						; SET_POINTER
     88  10000 ????						; Original author: Manuel Rotschkar
     89  10000 ????						;
     90  10000 ????						; Sets a 2 byte RAM pointer to an absolute address.
     91  10000 ????						;
     92  10000 ????						; Usage: SET_POINTER pointer, address
     93  10000 ????						; Example: SET_POINTER SpritePTR, SpriteData
     94  10000 ????						;
     95  10000 ????						; Note: Alters the accumulator, NZ flags
     96  10000 ????						; IN 1: 2 byte RAM location reserved for pointer
     97  10000 ????						; IN 2: absolute address
     98  10000 ????
     99  10000 ????				       MAC	set_pointer
    100  10000 ????			    .POINTER   SET	{1}
    101  10000 ????			    .ADDRESS   SET	{2}
    102  10000 ????
    103  10000 ????				       LDA	#<.ADDRESS	; Get Lowbyte of Address
    104  10000 ????				       STA	.POINTER	; Store in pointer
    105  10000 ????				       LDA	#>.ADDRESS	; Get Hibyte of Address
    106  10000 ????				       STA	.POINTER+1	; Store in pointer+1
    107  10000 ????
    108  10000 ????				       ENDM
    109  10000 ????
    110  10000 ????						; EOF
    111  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
    112  10000 ????
    113  10000 ????						; 7800MACRO.H
    114  10000 ????
    115  10000 ????						;-------------------------------------------------------
    116  10000 ????						; BOXCOLLISIONCHECK
    117  10000 ????						; author: Mike Saarna
    118  10000 ????						;
    119  10000 ????						; A general bounding box collision check. compares 2 rectangles of differing size
    120  10000 ????						; and shape for overlap. Carry is set for collision detected, clear for none.
    121  10000 ????						;
    122  10000 ????						; Usage: BOXCOLLISIONCHECK x1var,y1var,w1var,h1var,x2var,y2var,w2var,h2var
    123  10000 ????						;
    124  10000 ????
    125  10000 ????				       MAC	boxcollisioncheck
    126  10000 ????			    .boxx1     SET	{1}
    127  10000 ????			    .boxy1     SET	{2}
    128  10000 ????			    .boxw1     SET	{3}
    129  10000 ????			    .boxh1     SET	{4}
    130  10000 ????			    .boxx2     SET	{5}
    131  10000 ????			    .boxy2     SET	{6}
    132  10000 ????			    .boxw2     SET	{7}
    133  10000 ????			    .boxh2     SET	{8}
    134  10000 ????
    135  10000 ????			    .DoXCollisionCheck
    136  10000 ????				       lda	.boxx1	;3
    137  10000 ????				       cmp	.boxx2	;2
    138  10000 ????				       bcs	.X1isbiggerthanX2	;2/3
    139  10000 ????			    .X2isbiggerthanX1
    140  10000 ????				       adc	#.boxw1	;2
    141  10000 ????				       cmp	.boxx2	;3
    142  10000 ????				       bcs	.DoYCollisionCheck	;3/2
    143  10000 ????				       bcc	.noboxcollision	;3
    144  10000 ????			    .X1isbiggerthanX2
    145  10000 ????				       clc		;2
    146  10000 ????				       sbc	#.boxw2	;2
    147  10000 ????				       cmp	.boxx2	;3
    148  10000 ????				       bcs	.noboxcollision	;3/2
    149  10000 ????			    .DoYCollisionCheck
    150  10000 ????				       lda	.boxy1	;3
    151  10000 ????				       cmp	.boxy2	;3
    152  10000 ????				       bcs	.Y1isbiggerthanY2	;3/2
    153  10000 ????			    .Y2isbiggerthanY1
    154  10000 ????				       adc	#.boxh1	;2
    155  10000 ????				       cmp	.boxy2	;3
    156  10000 ????				       jmp	.checkdone	;6
    157  10000 ????			    .Y1isbiggerthanY2
    158  10000 ????				       clc		;2
    159  10000 ????				       sbc	#.boxh2	;2
    160  10000 ????				       cmp	.boxy2	;3
    161  10000 ????				       bcs	.noboxcollision	;3/2
    162  10000 ????			    .boxcollision
    163  10000 ????				       sec		;2
    164  10000 ????				       .byte	$24	; hardcoded "BIT [clc opcode]", used to skip over the following clc
    165  10000 ????			    .noboxcollision
    166  10000 ????				       clc		;2
    167  10000 ????			    .checkdone
    168  10000 ????
    169  10000 ????				       ENDM
    170  10000 ????
    171  10000 ????						; QBOXCOLLISIONCHECK
    172  10000 ????						; author: unknown
    173  10000 ????						;
    174  10000 ????						; A general bounding box collision check. compares 2 rectangles of differing size
    175  10000 ????						; and shape for overlap. Carry is CLEAR for collision detected, SET for none.
    176  10000 ????						;
    177  10000 ????						; Usage: QBOXCOLLISIONCHECK x1var,y1var,w1var,h1var,x2var,y2var,w2var,h2var
    178  10000 ????						;
    179  10000 ????				       MAC	qboxcollisioncheck
    180  10000 ????			    .boxx1     SET	{1}
    181  10000 ????			    .boxy1     SET	{2}
    182  10000 ????			    .boxw1     SET	{3}
    183  10000 ????			    .boxh1     SET	{4}
    184  10000 ????			    .boxx2     SET	{5}
    185  10000 ????			    .boxy2     SET	{6}
    186  10000 ????			    .boxw2     SET	{7}
    187  10000 ????			    .boxh2     SET	{8}
    188  10000 ????
    189  10000 ????				       lda	.boxx2
    190  10000 ????				       clc
    191  10000 ????				       adc	#.boxw2
    192  10000 ????				       sbc	.boxx1
    193  10000 ????				       cmp	#.boxw1+.boxw2-1
    194  10000 ????				       bcs	.qboxcollisiondone
    195  10000 ????						;if we're here, carry is clear
    196  10000 ????				       lda	.boxy2
    197  10000 ????				       adc	#.boxh2
    198  10000 ????				       sbc	.boxy1
    199  10000 ????				       cmp	#.boxh1+.boxh2-1
    200  10000 ????			    .qboxcollisiondone
    201  10000 ????				       rol		; temp for testing - invert carry...
    202  10000 ????				       eor	#1
    203  10000 ????				       ror
    204  10000 ????				       ENDM
    205  10000 ????
    206  10000 ????
    207  10000 ????				       MAC	median3
    208  10000 ????
    209  10000 ????						; A median filter (for smoothing paddle jitter)
    210  10000 ????						;   this macro takes the current paddle value, compares it to historic
    211  10000 ????						;   values, and replaces the current paddle value with the median.
    212  10000 ????						;
    213  10000 ????						; called as:  MEDIAN3 STORAGE CURRENT
    214  10000 ????						;    where STORAGE points to 3 consecutive bytes of memory. The first 2
    215  10000 ????						;	  must be dedicated to this MEDIAN filter. The last 1 is a temp.
    216  10000 ????						;    where CURRENT is memory holding the new value you wish to compare to
    217  10000 ????						;	  the previous values, and update with the median value.
    218  10000 ????						;
    219  10000 ????						; returns: CURRENT (modified to contain median value)
    220  10000 ????						;
    221  10000 ????						; author: Mike Saarna (aka RevEng)
    222  10000 ????
    223  10000 ????			    .MedianBytes SET	{1}
    224  10000 ????			    .NewValue  SET	{2}
    225  10000 ????
    226  10000 ????				       lda	#0
    227  10000 ????				       ldy	.NewValue
    228  10000 ????				       sty	.MedianBytes+2	; put the new value in the most "recent" slot
    229  10000 ????
    230  10000 ????						; build an index from relative size comparisons between our 3 values.
    231  10000 ????				       cpy	.MedianBytes
    232  10000 ????				       rol
    233  10000 ????				       cpy	.MedianBytes+1
    234  10000 ????				       rol
    235  10000 ????				       ldy	.MedianBytes
    236  10000 ????				       cpy	.MedianBytes+1
    237  10000 ????				       rol
    238  10000 ????				       tay
    239  10000 ????
    240  10000 ????				       ldx	MedianOrderLUT,y	; convert the size-comparison index to an index to the median value
    241  10000 ????				       lda	.MedianBytes,x
    242  10000 ????				       sta	.NewValue	; we replace the new value memory with the median value
    243  10000 ????
    244  10000 ????						; then shift values from "newer" bytes to "older" bytes, leaving the
    245  10000 ????						; newest byte (.MedianBytes+2) empty for next time.
    246  10000 ????				       lda	.MedianBytes+1
    247  10000 ????				       sta	.MedianBytes
    248  10000 ????				       lda	.MedianBytes+2
    249  10000 ????				       sta	.MedianBytes+1
    250  10000 ????				       ifnconst	MedianOrderLUT
    251  10000 ????				       jmp	MedianOrderLUTend
    252  10000 ????			    MedianOrderLUT		; converts our "comparison index" to an index to the median value
    253  10000 ????				       .byte	0	; 0  B2 < B0 < B1
    254  10000 ????				       .byte	1	; 1  B2 < B1 < B0
    255  10000 ????				       .byte	2	; 2   impossible
    256  10000 ????				       .byte	2	; 3  B1 < B2 < B0
    257  10000 ????				       .byte	2	; 4  B0 < B2 < B1
    258  10000 ????				       .byte	2	; 5   impossible
    259  10000 ????				       .byte	1	; 6  B0 < B1 < B2
    260  10000 ????				       .byte	0	; 7  B1 < B0 < B2
    261  10000 ????			    MedianOrderLUTend
    262  10000 ????				       endif
    263  10000 ????				       ENDM
    264  10000 ????
    265  10000 ????				       MAC	plotsprite
    266  10000 ????
    267  10000 ????						; A macro version of the plotsprite command.
    268  10000 ????						; This trades off rom space for speed.
    269  10000 ????						; It also doesn't check if the visible screen is displayed or not.
    270  10000 ????						; It has no training wheels. It is all rusty sharp edges.
    271  10000 ????
    272  10000 ????			    .GFXLabel  SET	{1}	; constant
    273  10000 ????			    .Palette   SET	{2}	; constant/variable MACARG2CONST
    274  10000 ????			    .SpriteX   SET	{3}	; constant/variable MACARG3CONST
    275  10000 ????			    .SpriteY   SET	{4}	; constant/variable MACARG4CONST
    276  10000 ????			    .ByteOffset SET	{5}	; constant/variable MACARG5CONST
    277  10000 ????
    278  10000 ????				       if	MACARG4CONST = 0
    279  10000 ????				       lda	.SpriteY
    280  10000 ????				       else
    281  10000 ????				       lda	#.SpriteY
    282  10000 ????				       endif
    283  10000 ????
    284  10000 ????				       lsr
    285  10000 ????				       lsr
    286  10000 ????				       asr	#%11111110	; ensure carry is clear
    287  10000 ????				       if	WZONEHEIGHT = 16
    288  10000 ????				       asr	#%11111110	; ensure carry is clear
    289  10000 ????				       endif
    290  10000 ????
    291  10000 ????				       tax
    292  10000 ????
    293  10000 ????				       cpx	#WZONECOUNT
    294  10000 ????				       bcs	.PLOTSPRITEnext
    295  10000 ????						; carry is clear
    296  10000 ????
    297  10000 ????				       ifconst	VSCROLL
    298  10000 ????				       ldy	Xx3,x
    299  10000 ????				       lda	DLLMEM+11,y
    300  10000 ????				       else		; !VSCROLL
    301  10000 ????				       lda	DLPOINTL,x	; Get pointer to DL that this sprite starts in
    302  10000 ????				       endif
    303  10000 ????				       ifconst	DOUBLEBUFFER
    304  10000 ????				       adc	doublebufferdloffset
    305  10000 ????				       endif		; DOUBLEBUFFER
    306  10000 ????				       sta	dlpnt
    307  10000 ????				       ifconst	VSCROLL
    308  10000 ????				       lda	DLLMEM+10,y
    309  10000 ????				       else		; !VSCROLL
    310  10000 ????				       lda	DLPOINTH,x
    311  10000 ????				       endif		; !VSCROLL
    312  10000 ????				       ifconst	DOUBLEBUFFER
    313  10000 ????				       adc	#0
    314  10000 ????				       endif		; DOUBLEBUFFER
    315  10000 ????				       sta	dlpnt+1
    316  10000 ????
    317  10000 ????				       ldy	dlend,x	; find the next new object position in this zone
    318  10000 ????
    319  10000 ????				       ifconst	.ByteOffset
    320  10000 ????
    321  10000 ????				       if	MACARG5CONST = 1
    322  10000 ????				       lda	#.ByteOffset
    323  10000 ????				       else
    324  10000 ????				       lda	.ByteOffset
    325  10000 ????				       endif
    326  10000 ????				       ifconst	DOUBLEBUFFER
    327  10000 ????				       if	{1}_width = 1
    328  10000 ????				       clc
    329  10000 ????				       endif
    330  10000 ????				       endif
    331  10000 ????				       if	{1}_width = 2
    332  10000 ????				       asl
    333  10000 ????				       endif
    334  10000 ????				       if	{1}_width = 3
    335  10000 ????				       asl
    336  10000 ????				       if	MACARG5CONST = 1
    337  10000 ????				       adc	#.ByteOffset
    338  10000 ????				       else
    339  10000 ????				       adc	.ByteOffset
    340  10000 ????				       endif
    341  10000 ????				       endif
    342  10000 ????				       if	{1}_width = 4
    343  10000 ????				       asl
    344  10000 ????				       asl
    345  10000 ????				       endif
    346  10000 ????				       if	{1}_width = 5
    347  10000 ????				       asl
    348  10000 ????				       asl
    349  10000 ????				       if	MACARG5CONST = 1
    350  10000 ????				       adc	#.ByteOffset
    351  10000 ????				       else
    352  10000 ????				       adc	.ByteOffset
    353  10000 ????				       endif
    354  10000 ????				       endif
    355  10000 ????				       if	{1}_width = 6
    356  10000 ????				       asl
    357  10000 ????				       if	MACARG5CONST = 1
    358  10000 ????				       adc	#.ByteOffset
    359  10000 ????				       else
    360  10000 ????				       adc	.ByteOffset
    361  10000 ????				       endif
    362  10000 ????				       asl
    363  10000 ????				       endif
    364  10000 ????				       if	{1}_width = 7
    365  10000 ????				       asl
    366  10000 ????				       if	MACARG5CONST = 1
    367  10000 ????				       adc	#.ByteOffset
    368  10000 ????				       else
    369  10000 ????				       adc	.ByteOffset
    370  10000 ????				       endif
    371  10000 ????				       asl
    372  10000 ????				       if	MACARG5CONST = 1
    373  10000 ????				       adc	#.ByteOffset
    374  10000 ????				       else
    375  10000 ????				       adc	.ByteOffset
    376  10000 ????				       endif
    377  10000 ????				       endif
    378  10000 ????				       if	{1}_width = 8
    379  10000 ????				       asl
    380  10000 ????				       asl
    381  10000 ????				       asl
    382  10000 ????				       endif
    383  10000 ????				       if	{1}_width = 9
    384  10000 ????				       asl
    385  10000 ????				       asl
    386  10000 ????				       asl
    387  10000 ????				       if	MACARG5CONST = 1
    388  10000 ????				       adc	#.ByteOffset
    389  10000 ????				       else
    390  10000 ????				       adc	.ByteOffset
    391  10000 ????				       endif
    392  10000 ????				       endif
    393  10000 ????				       if	{1}_width = 10
    394  10000 ????				       asl
    395  10000 ????				       asl
    396  10000 ????				       if	MACARG5CONST = 1
    397  10000 ????				       adc	#.ByteOffset
    398  10000 ????				       else
    399  10000 ????				       adc	.ByteOffset
    400  10000 ????				       endif
    401  10000 ????				       asl
    402  10000 ????				       endif
    403  10000 ????				       if	{1}_width = 11
    404  10000 ????				       asl
    405  10000 ????				       asl
    406  10000 ????				       if	MACARG5CONST = 1
    407  10000 ????				       adc	#.ByteOffset
    408  10000 ????				       else
    409  10000 ????				       adc	.ByteOffset
    410  10000 ????				       endif
    411  10000 ????				       asl
    412  10000 ????				       if	MACARG5CONST = 1
    413  10000 ????				       adc	#.ByteOffset
    414  10000 ????				       else
    415  10000 ????				       adc	.ByteOffset
    416  10000 ????				       endif
    417  10000 ????				       endif
    418  10000 ????				       if	{1}_width = 12
    419  10000 ????				       asl
    420  10000 ????				       if	MACARG5CONST = 1
    421  10000 ????				       adc	#.ByteOffset
    422  10000 ????				       else
    423  10000 ????				       adc	.ByteOffset
    424  10000 ????				       endif
    425  10000 ????				       asl
    426  10000 ????				       asl
    427  10000 ????				       endif
    428  10000 ????				       if	{1}_width = 13
    429  10000 ????				       asl
    430  10000 ????				       if	MACARG5CONST = 1
    431  10000 ????				       adc	#.ByteOffset
    432  10000 ????				       else
    433  10000 ????				       adc	.ByteOffset
    434  10000 ????				       endif
    435  10000 ????				       asl
    436  10000 ????				       asl
    437  10000 ????				       if	MACARG5CONST = 1
    438  10000 ????				       adc	#.ByteOffset
    439  10000 ????				       else
    440  10000 ????				       adc	.ByteOffset
    441  10000 ????				       endif
    442  10000 ????
    443  10000 ????				       endif
    444  10000 ????				       if	{1}_width = 14
    445  10000 ????				       asl
    446  10000 ????				       if	MACARG5CONST = 1
    447  10000 ????				       adc	#.ByteOffset
    448  10000 ????				       else
    449  10000 ????				       adc	.ByteOffset
    450  10000 ????				       endif
    451  10000 ????				       asl
    452  10000 ????				       if	MACARG5CONST = 1
    453  10000 ????				       adc	#.ByteOffset
    454  10000 ????				       else
    455  10000 ????				       adc	.ByteOffset
    456  10000 ????				       endif
    457  10000 ????				       asl
    458  10000 ????				       endif
    459  10000 ????				       if	{1}_width = 15
    460  10000 ????				       asl
    461  10000 ????				       if	MACARG5CONST = 1
    462  10000 ????				       adc	#.ByteOffset
    463  10000 ????				       else
    464  10000 ????				       adc	.ByteOffset
    465  10000 ????				       endif
    466  10000 ????				       asl
    467  10000 ????				       if	MACARG5CONST = 1
    468  10000 ????				       adc	#.ByteOffset
    469  10000 ????				       else
    470  10000 ????				       adc	.ByteOffset
    471  10000 ????				       endif
    472  10000 ????				       asl
    473  10000 ????				       if	MACARG5CONST = 1
    474  10000 ????				       adc	#.ByteOffset
    475  10000 ????				       else
    476  10000 ????				       adc	.ByteOffset
    477  10000 ????				       endif
    478  10000 ????				       endif
    479  10000 ????				       if	{1}_width = 16
    480  10000 ????				       asl
    481  10000 ????				       asl
    482  10000 ????				       asl
    483  10000 ????				       asl
    484  10000 ????				       endif
    485  10000 ????				       adc	#<.GFXLabel	; carry is clear via previous asl or asr
    486  10000 ????				       else
    487  10000 ????				       lda	#<.GFXLabel	; carry is clear via previous asl or asr
    488  10000 ????				       endif		; .ByteOffset
    489  10000 ????				       sta	(dlpnt),y	; #1 - low byte object address
    490  10000 ????
    491  10000 ????				       iny
    492  10000 ????
    493  10000 ????				       lda	#({1}_mode | %01000000)
    494  10000 ????				       sta	(dlpnt),y	; #2 - graphics mode , indirect
    495  10000 ????
    496  10000 ????				       iny
    497  10000 ????
    498  10000 ????				       if	MACARG4CONST = 0
    499  10000 ????				       lda	.SpriteY
    500  10000 ????				       else
    501  10000 ????				       lda	#.SpriteY
    502  10000 ????				       endif
    503  10000 ????				       and	#(WZONEHEIGHT - 1)
    504  10000 ????				       cmp	#1	; clear carry if our sprite is just in this zone
    505  10000 ????				       ora	#>.GFXLabel
    506  10000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
    507  10000 ????
    508  10000 ????				       iny
    509  10000 ????
    510  10000 ????				       if	MACARG2CONST = 1
    511  10000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
    512  10000 ????				       else
    513  10000 ????				       lda	#({1}_width_twoscompliment)
    514  10000 ????				       ora	.Palette
    515  10000 ????				       endif
    516  10000 ????				       sta	(dlpnt),y	; #4 - palette|width
    517  10000 ????
    518  10000 ????				       iny
    519  10000 ????
    520  10000 ????				       if	MACARG3CONST = 1
    521  10000 ????				       lda	#.SpriteX
    522  10000 ????				       else
    523  10000 ????				       lda	.SpriteX
    524  10000 ????				       endif
    525  10000 ????				       sta	(dlpnt),y	; #5 - x object position
    526  10000 ????
    527  10000 ????				       iny
    528  10000 ????				       sty	dlend,x
    529  10000 ????
    530  10000 ????				       ifconst	ALWAYSTERMINATE
    531  10000 ????				       iny
    532  10000 ????				       lda	#0
    533  10000 ????				       sta	(dlpnt),y
    534  10000 ????				       endif
    535  10000 ????
    536  10000 ????				       bcc	.PLOTSPRITEend
    537  10000 ????
    538  10000 ????			    .PLOTSPRITEnext
    539  10000 ????				       inx		; next zone
    540  10000 ????
    541  10000 ????				       cpx	#WZONECOUNT
    542  10000 ????				       bcs	.PLOTSPRITEend
    543  10000 ????						; carry is clear
    544  10000 ????
    545  10000 ????				       ifconst	VSCROLL
    546  10000 ????				       ldy	Xx3,x
    547  10000 ????				       lda	DLLMEM+11,y
    548  10000 ????				       else		; !VSCROLL
    549  10000 ????				       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
    550  10000 ????				       endif		; !VSCROLL
    551  10000 ????				       ifconst	DOUBLEBUFFER
    552  10000 ????				       adc	doublebufferdloffset
    553  10000 ????				       endif		; DOUBLEBUFFER
    554  10000 ????				       sta	dlpnt
    555  10000 ????				       ifconst	VSCROLL
    556  10000 ????				       lda	DLLMEM+10,y
    557  10000 ????				       else		; !VSCROLL
    558  10000 ????				       lda	DLPOINTH,x
    559  10000 ????				       endif		; !VSCROLL
    560  10000 ????				       ifconst	DOUBLEBUFFER
    561  10000 ????				       adc	#0
    562  10000 ????				       endif		; DOUBLEBUFFER
    563  10000 ????				       sta	dlpnt+1
    564  10000 ????
    565  10000 ????				       ldy	dlend,x	; find the next new object position in this zone
    566  10000 ????
    567  10000 ????				       ifconst	.ByteOffset
    568  10000 ????
    569  10000 ????				       if	MACARG5CONST = 1
    570  10000 ????				       lda	#.ByteOffset
    571  10000 ????				       else
    572  10000 ????				       lda	.ByteOffset
    573  10000 ????				       endif
    574  10000 ????				       if	{1}_width = 1
    575  10000 ????				       clc
    576  10000 ????				       endif
    577  10000 ????				       if	{1}_width = 2
    578  10000 ????				       asl		; carry clear
    579  10000 ????				       endif
    580  10000 ????				       if	{1}_width = 3
    581  10000 ????				       asl		; carry clear
    582  10000 ????				       if	MACARG5CONST = 1
    583  10000 ????				       adc	#.ByteOffset
    584  10000 ????				       else
    585  10000 ????				       adc	.ByteOffset
    586  10000 ????				       endif
    587  10000 ????				       endif
    588  10000 ????				       if	{1}_width = 4
    589  10000 ????				       asl		; carry clear
    590  10000 ????				       asl
    591  10000 ????				       endif
    592  10000 ????				       if	{1}_width = 5
    593  10000 ????				       asl		; carry clear
    594  10000 ????				       asl
    595  10000 ????				       if	MACARG5CONST = 1
    596  10000 ????				       adc	#.ByteOffset
    597  10000 ????				       else
    598  10000 ????				       adc	.ByteOffset
    599  10000 ????				       endif
    600  10000 ????				       endif
    601  10000 ????				       if	{1}_width = 6
    602  10000 ????				       asl		; carry clear
    603  10000 ????				       if	MACARG5CONST = 1
    604  10000 ????				       adc	#.ByteOffset
    605  10000 ????				       else
    606  10000 ????				       adc	.ByteOffset
    607  10000 ????				       endif
    608  10000 ????				       asl
    609  10000 ????				       endif
    610  10000 ????				       if	{1}_width = 7
    611  10000 ????				       asl		; carry clear
    612  10000 ????				       if	MACARG5CONST = 1
    613  10000 ????				       adc	#.ByteOffset
    614  10000 ????				       else
    615  10000 ????				       adc	.ByteOffset
    616  10000 ????				       endif
    617  10000 ????				       asl
    618  10000 ????				       endif
    619  10000 ????				       if	{1}_width = 8
    620  10000 ????				       asl		; carry clear
    621  10000 ????				       asl
    622  10000 ????				       asl
    623  10000 ????				       endif
    624  10000 ????				       if	{1}_width = 9
    625  10000 ????				       asl		; carry clear
    626  10000 ????				       asl
    627  10000 ????				       asl
    628  10000 ????				       if	MACARG5CONST = 1
    629  10000 ????				       adc	#.ByteOffset
    630  10000 ????				       else
    631  10000 ????				       adc	.ByteOffset
    632  10000 ????				       endif
    633  10000 ????				       endif
    634  10000 ????				       if	{1}_width = 10
    635  10000 ????				       asl		; carry clear
    636  10000 ????				       asl
    637  10000 ????				       if	MACARG5CONST = 1
    638  10000 ????				       adc	#.ByteOffset
    639  10000 ????				       else
    640  10000 ????				       adc	.ByteOffset
    641  10000 ????				       endif
    642  10000 ????				       asl
    643  10000 ????				       endif
    644  10000 ????				       if	{1}_width = 11
    645  10000 ????				       asl		; carry clear
    646  10000 ????				       asl
    647  10000 ????				       if	MACARG5CONST = 1
    648  10000 ????				       adc	#.ByteOffset
    649  10000 ????				       else
    650  10000 ????				       adc	.ByteOffset
    651  10000 ????				       endif
    652  10000 ????				       asl
    653  10000 ????				       if	MACARG5CONST = 1
    654  10000 ????				       adc	#.ByteOffset
    655  10000 ????				       else
    656  10000 ????				       adc	.ByteOffset
    657  10000 ????				       endif
    658  10000 ????				       endif
    659  10000 ????				       if	{1}_width = 12
    660  10000 ????				       asl		; carry clear
    661  10000 ????				       if	MACARG5CONST = 1
    662  10000 ????				       adc	#.ByteOffset
    663  10000 ????				       else
    664  10000 ????				       adc	.ByteOffset
    665  10000 ????				       endif
    666  10000 ????				       asl
    667  10000 ????				       asl
    668  10000 ????				       endif
    669  10000 ????				       if	{1}_width = 13
    670  10000 ????				       asl		; carry clear
    671  10000 ????				       if	MACARG5CONST = 1
    672  10000 ????				       adc	#.ByteOffset
    673  10000 ????				       else
    674  10000 ????				       adc	.ByteOffset
    675  10000 ????				       endif
    676  10000 ????				       asl
    677  10000 ????				       asl
    678  10000 ????				       if	MACARG5CONST = 1
    679  10000 ????				       adc	#.ByteOffset
    680  10000 ????				       else
    681  10000 ????				       adc	.ByteOffset
    682  10000 ????				       endif
    683  10000 ????				       endif
    684  10000 ????				       if	{1}_width = 14
    685  10000 ????				       asl		; carry clear
    686  10000 ????				       if	MACARG5CONST = 1
    687  10000 ????				       adc	#.ByteOffset
    688  10000 ????				       else
    689  10000 ????				       adc	.ByteOffset
    690  10000 ????				       endif
    691  10000 ????				       asl
    692  10000 ????				       if	MACARG5CONST = 1
    693  10000 ????				       adc	#.ByteOffset
    694  10000 ????				       else
    695  10000 ????				       adc	.ByteOffset
    696  10000 ????				       endif
    697  10000 ????				       asl
    698  10000 ????				       endif
    699  10000 ????				       if	{1}_width = 15
    700  10000 ????				       asl
    701  10000 ????				       if	MACARG5CONST = 1
    702  10000 ????				       adc	#.ByteOffset
    703  10000 ????				       else
    704  10000 ????				       adc	.ByteOffset
    705  10000 ????				       endif
    706  10000 ????				       asl
    707  10000 ????				       if	MACARG5CONST = 1
    708  10000 ????				       adc	#.ByteOffset
    709  10000 ????				       else
    710  10000 ????				       adc	.ByteOffset
    711  10000 ????				       endif
    712  10000 ????				       asl
    713  10000 ????				       if	MACARG5CONST = 1
    714  10000 ????				       adc	#.ByteOffset
    715  10000 ????				       else
    716  10000 ????				       adc	.ByteOffset
    717  10000 ????				       endif
    718  10000 ????				       endif
    719  10000 ????				       if	{1}_width = 16
    720  10000 ????				       asl
    721  10000 ????				       asl
    722  10000 ????				       asl
    723  10000 ????				       asl
    724  10000 ????				       endif
    725  10000 ????				       adc	#<.GFXLabel
    726  10000 ????				       else
    727  10000 ????				       lda	#<.GFXLabel
    728  10000 ????				       endif		; .ByteOffset
    729  10000 ????
    730  10000 ????				       sta	(dlpnt),y	; #1 - low byte object address
    731  10000 ????
    732  10000 ????				       iny
    733  10000 ????
    734  10000 ????				       lda	#({1}_mode | %01000000)
    735  10000 ????				       sta	(dlpnt),y	; #2 - graphics mode , indirect
    736  10000 ????
    737  10000 ????				       iny
    738  10000 ????
    739  10000 ????				       if	MACARG4CONST = 0
    740  10000 ????				       lda	.SpriteY
    741  10000 ????				       else
    742  10000 ????				       lda	#.SpriteY
    743  10000 ????				       endif
    744  10000 ????				       and	#(WZONEHEIGHT - 1)
    745  10000 ????				       ora	#>(.GFXLabel - (WZONEHEIGHT * 256))	; start in the dma hole
    746  10000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
    747  10000 ????
    748  10000 ????				       iny
    749  10000 ????
    750  10000 ????				       if	MACARG2CONST = 1
    751  10000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
    752  10000 ????				       else
    753  10000 ????				       lda	#({1}_width_twoscompliment)
    754  10000 ????				       ora	.Palette
    755  10000 ????				       endif
    756  10000 ????				       sta	(dlpnt),y	; #4 - palette|width
    757  10000 ????
    758  10000 ????				       iny
    759  10000 ????
    760  10000 ????				       if	MACARG3CONST = 1
    761  10000 ????				       lda	#.SpriteX
    762  10000 ????				       else
    763  10000 ????				       lda	.SpriteX
    764  10000 ????				       endif
    765  10000 ????				       sta	(dlpnt),y	; #5 - x object position
    766  10000 ????
    767  10000 ????				       iny
    768  10000 ????				       sty	dlend,x
    769  10000 ????
    770  10000 ????				       ifconst	ALWAYSTERMINATE
    771  10000 ????				       iny
    772  10000 ????				       lda	#0
    773  10000 ????				       sta	(dlpnt),y
    774  10000 ????				       endif
    775  10000 ????
    776  10000 ????			    .PLOTSPRITEend
    777  10000 ????				       ENDM
    778  10000 ????
    779  10000 ????				       MAC	plotsprite4
    780  10000 ????
    781  10000 ????						; A macro version of plotsprite. (with 4 byte objects)
    782  10000 ????						; This trades off rom space for speed.
    783  10000 ????						; It also doesn't check if the visible screen is displayed or not.
    784  10000 ????						; It has no training wheels. It is all rusty sharp edges.
    785  10000 ????
    786  10000 ????			    .GFXLabel  SET	{1}
    787  10000 ????			    .Palette   SET	{2}	; constant
    788  10000 ????			    .SpriteX   SET	{3}	; variable
    789  10000 ????			    .SpriteY   SET	{4}	; variable
    790  10000 ????			    .ByteOffset SET	{5}	; variable
    791  10000 ????
    792  10000 ????				       if	MACARG4CONST = 0
    793  10000 ????				       lda	.SpriteY
    794  10000 ????				       else
    795  10000 ????				       lda	#.SpriteY
    796  10000 ????				       endif
    797  10000 ????				       lsr
    798  10000 ????				       lsr
    799  10000 ????				       asr	#%11111110	; ensure carry is clear
    800  10000 ????				       if	WZONEHEIGHT = 16
    801  10000 ????				       asr	#%11111110	; ensure carry is clear
    802  10000 ????				       endif
    803  10000 ????
    804  10000 ????				       tax
    805  10000 ????
    806  10000 ????				       cpx	#WZONECOUNT
    807  10000 ????				       bcs	.PLOTSPRITEnext
    808  10000 ????						; carry is clear
    809  10000 ????				       ifconst	VSCROLL
    810  10000 ????				       ldy	Xx3,x
    811  10000 ????				       lda	DLLMEM+11,y
    812  10000 ????				       else		; !VSCROLL
    813  10000 ????				       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
    814  10000 ????				       endif		; !VSCROLL
    815  10000 ????				       ifconst	DOUBLEBUFFER
    816  10000 ????				       adc	doublebufferdloffset
    817  10000 ????				       endif		; DOUBLEBUFFER
    818  10000 ????				       sta	dlpnt
    819  10000 ????				       ifconst	VSCROLL
    820  10000 ????				       lda	DLLMEM+10,y
    821  10000 ????				       else		; !VSCROLL
    822  10000 ????				       lda	DLPOINTH,x
    823  10000 ????				       endif		; !VSCROLL
    824  10000 ????				       ifconst	DOUBLEBUFFER
    825  10000 ????				       adc	#0
    826  10000 ????				       endif		; DOUBLEBUFFER
    827  10000 ????				       sta	dlpnt+1
    828  10000 ????
    829  10000 ????				       ldy	dlend,x	; find the next new object position in this zone
    830  10000 ????
    831  10000 ????				       ifconst	.ByteOffset
    832  10000 ????
    833  10000 ????				       if	MACARG5CONST = 1
    834  10000 ????				       lda	#.ByteOffset
    835  10000 ????				       else
    836  10000 ????				       lda	.ByteOffset
    837  10000 ????				       endif
    838  10000 ????				       ifconst	DOUBLEBUFFER
    839  10000 ????				       if	{1}_width = 1
    840  10000 ????				       clc
    841  10000 ????				       endif
    842  10000 ????				       endif
    843  10000 ????				       if	{1}_width = 2
    844  10000 ????				       asl
    845  10000 ????				       endif
    846  10000 ????				       if	{1}_width = 3
    847  10000 ????				       asl
    848  10000 ????				       if	MACARG5CONST = 1
    849  10000 ????				       adc	#.ByteOffset
    850  10000 ????				       else
    851  10000 ????				       adc	.ByteOffset
    852  10000 ????				       endif
    853  10000 ????				       endif
    854  10000 ????				       if	{1}_width = 4
    855  10000 ????				       asl
    856  10000 ????				       asl
    857  10000 ????				       endif
    858  10000 ????				       if	{1}_width = 5
    859  10000 ????				       asl
    860  10000 ????				       asl
    861  10000 ????				       if	MACARG5CONST = 1
    862  10000 ????				       adc	#.ByteOffset
    863  10000 ????				       else
    864  10000 ????				       adc	.ByteOffset
    865  10000 ????				       endif
    866  10000 ????				       endif
    867  10000 ????				       if	{1}_width = 6
    868  10000 ????				       asl
    869  10000 ????				       if	MACARG5CONST = 1
    870  10000 ????				       adc	#.ByteOffset
    871  10000 ????				       else
    872  10000 ????				       adc	.ByteOffset
    873  10000 ????				       endif
    874  10000 ????
    875  10000 ????				       asl
    876  10000 ????				       endif
    877  10000 ????				       if	{1}_width = 7
    878  10000 ????				       asl
    879  10000 ????				       if	MACARG5CONST = 1
    880  10000 ????				       adc	#.ByteOffset
    881  10000 ????				       else
    882  10000 ????				       adc	.ByteOffset
    883  10000 ????				       endif
    884  10000 ????				       asl
    885  10000 ????				       if	MACARG5CONST = 1
    886  10000 ????				       adc	#.ByteOffset
    887  10000 ????				       else
    888  10000 ????				       adc	.ByteOffset
    889  10000 ????				       endif
    890  10000 ????				       endif
    891  10000 ????				       if	{1}_width = 8
    892  10000 ????				       asl
    893  10000 ????				       asl
    894  10000 ????				       asl
    895  10000 ????				       endif
    896  10000 ????				       if	{1}_width = 9
    897  10000 ????				       asl
    898  10000 ????				       asl
    899  10000 ????				       asl
    900  10000 ????				       if	MACARG5CONST = 1
    901  10000 ????				       adc	#.ByteOffset
    902  10000 ????				       else
    903  10000 ????				       adc	.ByteOffset
    904  10000 ????				       endif
    905  10000 ????				       endif
    906  10000 ????				       if	{1}_width = 10
    907  10000 ????				       asl
    908  10000 ????				       asl
    909  10000 ????				       if	MACARG5CONST = 1
    910  10000 ????				       adc	#.ByteOffset
    911  10000 ????				       else
    912  10000 ????				       adc	.ByteOffset
    913  10000 ????				       endif
    914  10000 ????				       asl
    915  10000 ????				       endif
    916  10000 ????				       if	{1}_width = 11
    917  10000 ????				       asl
    918  10000 ????				       asl
    919  10000 ????				       if	MACARG5CONST = 1
    920  10000 ????				       adc	#.ByteOffset
    921  10000 ????				       else
    922  10000 ????				       adc	.ByteOffset
    923  10000 ????				       endif
    924  10000 ????				       asl
    925  10000 ????				       if	MACARG5CONST = 1
    926  10000 ????				       adc	#.ByteOffset
    927  10000 ????				       else
    928  10000 ????				       adc	.ByteOffset
    929  10000 ????				       endif
    930  10000 ????				       endif
    931  10000 ????				       if	{1}_width = 12
    932  10000 ????				       asl
    933  10000 ????				       if	MACARG5CONST = 1
    934  10000 ????				       adc	#.ByteOffset
    935  10000 ????				       else
    936  10000 ????				       adc	.ByteOffset
    937  10000 ????				       endif
    938  10000 ????				       asl
    939  10000 ????				       asl
    940  10000 ????				       endif
    941  10000 ????				       if	{1}_width = 13
    942  10000 ????				       asl
    943  10000 ????				       if	MACARG5CONST = 1
    944  10000 ????				       adc	#.ByteOffset
    945  10000 ????				       else
    946  10000 ????				       adc	.ByteOffset
    947  10000 ????				       endif
    948  10000 ????				       asl
    949  10000 ????				       asl
    950  10000 ????				       if	MACARG5CONST = 1
    951  10000 ????				       adc	#.ByteOffset
    952  10000 ????				       else
    953  10000 ????				       adc	.ByteOffset
    954  10000 ????				       endif
    955  10000 ????				       endif
    956  10000 ????				       if	{1}_width = 14
    957  10000 ????				       asl
    958  10000 ????				       if	MACARG5CONST = 1
    959  10000 ????				       adc	#.ByteOffset
    960  10000 ????				       else
    961  10000 ????				       adc	.ByteOffset
    962  10000 ????				       endif
    963  10000 ????				       asl
    964  10000 ????				       if	MACARG5CONST = 1
    965  10000 ????				       adc	#.ByteOffset
    966  10000 ????				       else
    967  10000 ????				       adc	.ByteOffset
    968  10000 ????				       endif
    969  10000 ????				       asl
    970  10000 ????				       endif
    971  10000 ????				       if	{1}_width = 15
    972  10000 ????				       asl
    973  10000 ????				       if	MACARG5CONST = 1
    974  10000 ????				       adc	#.ByteOffset
    975  10000 ????				       else
    976  10000 ????				       adc	.ByteOffset
    977  10000 ????				       endif
    978  10000 ????				       asl
    979  10000 ????				       if	MACARG5CONST = 1
    980  10000 ????				       adc	#.ByteOffset
    981  10000 ????				       else
    982  10000 ????				       adc	.ByteOffset
    983  10000 ????				       endif
    984  10000 ????				       asl
    985  10000 ????				       if	MACARG5CONST = 1
    986  10000 ????				       adc	#.ByteOffset
    987  10000 ????				       else
    988  10000 ????				       adc	.ByteOffset
    989  10000 ????				       endif
    990  10000 ????				       endif
    991  10000 ????				       if	{1}_width = 16
    992  10000 ????				       asl
    993  10000 ????				       asl
    994  10000 ????				       asl
    995  10000 ????				       asl
    996  10000 ????				       endif
    997  10000 ????				       adc	#<.GFXLabel	; carry is clear via previous asl or asr
    998  10000 ????				       else
    999  10000 ????				       lda	#<.GFXLabel	; carry is clear via previous asl or asr
   1000  10000 ????				       endif		; .ByteOffset
   1001  10000 ????				       sta	(dlpnt),y	; #1 - low byte object address
   1002  10000 ????
   1003  10000 ????				       iny
   1004  10000 ????
   1005  10000 ????				       if	MACARG2CONST = 1
   1006  10000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
   1007  10000 ????				       else
   1008  10000 ????				       lda	#({1}_width_twoscompliment)
   1009  10000 ????				       ora	.Palette
   1010  10000 ????				       endif
   1011  10000 ????				       sta	(dlpnt),y	; #2 - palette|width
   1012  10000 ????
   1013  10000 ????				       iny
   1014  10000 ????				       if	MACARG4CONST = 0
   1015  10000 ????				       lda	.SpriteY
   1016  10000 ????				       else
   1017  10000 ????				       lda	#.SpriteY
   1018  10000 ????				       endif
   1019  10000 ????				       and	#(WZONEHEIGHT - 1)
   1020  10000 ????				       cmp	#1	; clear carry if our sprite is just in this zone
   1021  10000 ????				       ora	#>.GFXLabel
   1022  10000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
   1023  10000 ????
   1024  10000 ????				       iny
   1025  10000 ????				       if	MACARG3CONST = 1
   1026  10000 ????				       lda	#.SpriteX
   1027  10000 ????				       else
   1028  10000 ????				       lda	.SpriteX
   1029  10000 ????				       endif
   1030  10000 ????				       sta	(dlpnt),y	; #4 - x object position
   1031  10000 ????
   1032  10000 ????				       iny
   1033  10000 ????				       sty	dlend,x
   1034  10000 ????
   1035  10000 ????				       ifconst	ALWAYSTERMINATE
   1036  10000 ????				       iny
   1037  10000 ????				       lda	#0
   1038  10000 ????				       sta	(dlpnt),y
   1039  10000 ????				       endif
   1040  10000 ????
   1041  10000 ????				       bcc	.PLOTSPRITEend
   1042  10000 ????
   1043  10000 ????			    .PLOTSPRITEnext
   1044  10000 ????				       inx		; next zone
   1045  10000 ????
   1046  10000 ????				       cpx	#WZONECOUNT
   1047  10000 ????				       bcs	.PLOTSPRITEend
   1048  10000 ????						; carry is clear
   1049  10000 ????				       ifconst	VSCROLL
   1050  10000 ????				       ldy	Xx3,x
   1051  10000 ????				       lda	DLLMEM+11,y
   1052  10000 ????				       else		; !VSCROLL
   1053  10000 ????				       lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
   1054  10000 ????				       endif		; !VSCROLL
   1055  10000 ????				       ifconst	DOUBLEBUFFER
   1056  10000 ????				       adc	doublebufferdloffset
   1057  10000 ????				       endif		; DOUBLEBUFFER
   1058  10000 ????				       sta	dlpnt
   1059  10000 ????				       ifconst	VSCROLL
   1060  10000 ????				       lda	DLLMEM+10,y
   1061  10000 ????				       else		; !VSCROLL
   1062  10000 ????				       lda	DLPOINTH,x
   1063  10000 ????				       endif		; !VSCROLL
   1064  10000 ????				       ifconst	DOUBLEBUFFER
   1065  10000 ????				       adc	#0
   1066  10000 ????				       endif		; DOUBLEBUFFER
   1067  10000 ????				       sta	dlpnt+1
   1068  10000 ????
   1069  10000 ????				       ldy	dlend,x	; find the next new object position in this zone
   1070  10000 ????
   1071  10000 ????				       ifconst	.ByteOffset
   1072  10000 ????
   1073  10000 ????				       if	MACARG5CONST = 1
   1074  10000 ????				       lda	#.ByteOffset
   1075  10000 ????				       else
   1076  10000 ????				       lda	.ByteOffset
   1077  10000 ????				       endif
   1078  10000 ????				       if	{1}_width = 1
   1079  10000 ????				       clc
   1080  10000 ????				       endif
   1081  10000 ????				       if	{1}_width = 2
   1082  10000 ????				       asl		; carry clear
   1083  10000 ????				       endif
   1084  10000 ????				       if	{1}_width = 3
   1085  10000 ????				       asl		; carry clear
   1086  10000 ????				       if	MACARG5CONST = 1
   1087  10000 ????				       adc	#.ByteOffset
   1088  10000 ????				       else
   1089  10000 ????				       adc	.ByteOffset
   1090  10000 ????				       endif
   1091  10000 ????				       endif
   1092  10000 ????				       if	{1}_width = 4
   1093  10000 ????				       asl		; carry clear
   1094  10000 ????				       asl
   1095  10000 ????				       endif
   1096  10000 ????				       if	{1}_width = 5
   1097  10000 ????				       asl		; carry clear
   1098  10000 ????				       asl
   1099  10000 ????				       if	MACARG5CONST = 1
   1100  10000 ????				       adc	#.ByteOffset
   1101  10000 ????				       else
   1102  10000 ????				       adc	.ByteOffset
   1103  10000 ????				       endif
   1104  10000 ????				       endif
   1105  10000 ????				       if	{1}_width = 6
   1106  10000 ????				       asl		; carry clear
   1107  10000 ????				       if	MACARG5CONST = 1
   1108  10000 ????				       adc	#.ByteOffset
   1109  10000 ????				       else
   1110  10000 ????				       adc	.ByteOffset
   1111  10000 ????				       endif
   1112  10000 ????
   1113  10000 ????				       asl
   1114  10000 ????				       endif
   1115  10000 ????				       if	{1}_width = 7
   1116  10000 ????				       asl		; carry clear
   1117  10000 ????				       if	MACARG5CONST = 1
   1118  10000 ????				       adc	#.ByteOffset
   1119  10000 ????				       else
   1120  10000 ????				       adc	.ByteOffset
   1121  10000 ????				       endif
   1122  10000 ????				       asl
   1123  10000 ????				       endif
   1124  10000 ????				       if	{1}_width = 8
   1125  10000 ????				       asl		; carry clear
   1126  10000 ????				       asl
   1127  10000 ????				       asl
   1128  10000 ????				       endif
   1129  10000 ????				       if	{1}_width = 9
   1130  10000 ????				       asl		; carry clear
   1131  10000 ????				       asl
   1132  10000 ????				       asl
   1133  10000 ????				       if	MACARG5CONST = 1
   1134  10000 ????				       adc	#.ByteOffset
   1135  10000 ????				       else
   1136  10000 ????				       adc	.ByteOffset
   1137  10000 ????				       endif
   1138  10000 ????				       endif
   1139  10000 ????				       if	{1}_width = 10
   1140  10000 ????				       asl		; carry clear
   1141  10000 ????				       asl
   1142  10000 ????				       if	MACARG5CONST = 1
   1143  10000 ????				       adc	#.ByteOffset
   1144  10000 ????				       else
   1145  10000 ????				       adc	.ByteOffset
   1146  10000 ????				       endif
   1147  10000 ????				       asl
   1148  10000 ????				       endif
   1149  10000 ????				       if	{1}_width = 11
   1150  10000 ????				       asl		; carry clear
   1151  10000 ????				       asl
   1152  10000 ????				       if	MACARG5CONST = 1
   1153  10000 ????				       adc	#.ByteOffset
   1154  10000 ????				       else
   1155  10000 ????				       adc	.ByteOffset
   1156  10000 ????				       endif
   1157  10000 ????				       asl
   1158  10000 ????				       if	MACARG5CONST = 1
   1159  10000 ????				       adc	#.ByteOffset
   1160  10000 ????				       else
   1161  10000 ????				       adc	.ByteOffset
   1162  10000 ????				       endif
   1163  10000 ????				       endif
   1164  10000 ????				       if	{1}_width = 12
   1165  10000 ????				       asl		; carry clear
   1166  10000 ????				       if	MACARG5CONST = 1
   1167  10000 ????				       adc	#.ByteOffset
   1168  10000 ????				       else
   1169  10000 ????				       adc	.ByteOffset
   1170  10000 ????				       endif
   1171  10000 ????				       asl
   1172  10000 ????				       asl
   1173  10000 ????				       endif
   1174  10000 ????				       if	{1}_width = 13
   1175  10000 ????				       asl		; carry clear
   1176  10000 ????				       if	MACARG5CONST = 1
   1177  10000 ????				       adc	#.ByteOffset
   1178  10000 ????				       else
   1179  10000 ????				       adc	.ByteOffset
   1180  10000 ????				       endif
   1181  10000 ????				       asl
   1182  10000 ????				       asl
   1183  10000 ????				       if	MACARG5CONST = 1
   1184  10000 ????				       adc	#.ByteOffset
   1185  10000 ????				       else
   1186  10000 ????				       adc	.ByteOffset
   1187  10000 ????				       endif
   1188  10000 ????				       endif
   1189  10000 ????				       if	{1}_width = 14
   1190  10000 ????				       asl		; carry clear
   1191  10000 ????				       if	MACARG5CONST = 1
   1192  10000 ????				       adc	#.ByteOffset
   1193  10000 ????				       else
   1194  10000 ????				       adc	.ByteOffset
   1195  10000 ????				       endif
   1196  10000 ????				       asl
   1197  10000 ????				       if	MACARG5CONST = 1
   1198  10000 ????				       adc	#.ByteOffset
   1199  10000 ????				       else
   1200  10000 ????				       adc	.ByteOffset
   1201  10000 ????				       endif
   1202  10000 ????				       asl
   1203  10000 ????				       endif
   1204  10000 ????				       if	{1}_width = 15
   1205  10000 ????				       asl
   1206  10000 ????				       if	MACARG5CONST = 1
   1207  10000 ????				       adc	#.ByteOffset
   1208  10000 ????				       else
   1209  10000 ????				       adc	.ByteOffset
   1210  10000 ????				       endif
   1211  10000 ????				       asl
   1212  10000 ????				       if	MACARG5CONST = 1
   1213  10000 ????				       adc	#.ByteOffset
   1214  10000 ????				       else
   1215  10000 ????				       adc	.ByteOffset
   1216  10000 ????				       endif
   1217  10000 ????				       asl
   1218  10000 ????				       if	MACARG5CONST = 1
   1219  10000 ????				       adc	#.ByteOffset
   1220  10000 ????				       else
   1221  10000 ????				       adc	.ByteOffset
   1222  10000 ????				       endif
   1223  10000 ????				       endif
   1224  10000 ????				       if	{1}_width = 16
   1225  10000 ????				       asl
   1226  10000 ????				       asl
   1227  10000 ????				       asl
   1228  10000 ????				       asl
   1229  10000 ????				       endif
   1230  10000 ????				       adc	#<.GFXLabel
   1231  10000 ????				       else
   1232  10000 ????				       lda	#<.GFXLabel
   1233  10000 ????				       endif		; .ByteOffset
   1234  10000 ????				       sta	(dlpnt),y	; #1 - low byte object address
   1235  10000 ????
   1236  10000 ????				       iny
   1237  10000 ????				       if	MACARG2CONST = 1
   1238  10000 ????				       lda	#({1}_width_twoscompliment | (.Palette * 32))
   1239  10000 ????				       else
   1240  10000 ????				       lda	#({1}_width_twoscompliment)
   1241  10000 ????				       ora	.Palette
   1242  10000 ????				       endif
   1243  10000 ????
   1244  10000 ????				       sta	(dlpnt),y	; #2 - palette|width
   1245  10000 ????
   1246  10000 ????				       iny
   1247  10000 ????				       if	MACARG4CONST = 0
   1248  10000 ????				       lda	.SpriteY
   1249  10000 ????				       else
   1250  10000 ????				       lda	#.SpriteY
   1251  10000 ????				       endif
   1252  10000 ????				       and	#(WZONEHEIGHT - 1)
   1253  10000 ????				       ora	#>(.GFXLabel - (WZONEHEIGHT * 256))	; start in the dma hole
   1254  10000 ????				       sta	(dlpnt),y	; #3 - hi byte object address
   1255  10000 ????
   1256  10000 ????				       iny
   1257  10000 ????				       if	MACARG3CONST = 1
   1258  10000 ????				       lda	#.SpriteX
   1259  10000 ????				       else
   1260  10000 ????				       lda	.SpriteX
   1261  10000 ????				       endif
   1262  10000 ????				       sta	(dlpnt),y	; #4 - x object position
   1263  10000 ????
   1264  10000 ????				       iny
   1265  10000 ????				       sty	dlend,x
   1266  10000 ????
   1267  10000 ????				       ifconst	ALWAYSTERMINATE
   1268  10000 ????				       iny
   1269  10000 ????				       lda	#0
   1270  10000 ????				       sta	(dlpnt),y
   1271  10000 ????				       endif
   1272  10000 ????
   1273  10000 ????			    .PLOTSPRITEend
   1274  10000 ????				       ENDM
   1275  10000 ????
   1276  10000 ????				       MAC	scrollsetup
   1277  10000 ????
   1278  10000 ????						; If vertical scrolling is enabled...
   1279  10000 ????						;   * Fills the DLs with hidden masking sprites.
   1280  10000 ????						; Adds blank sprites to the DLs to fill the screen.
   1281  10000 ????						; If horizontal scrolling is enabled...
   1282  10000 ????						;   * Adds another blank DL off-screen
   1283  10000 ????
   1284  10000 ????						; {1} - constant - the first dl of the scrolling area
   1285  10000 ????						; {2} - symbol   - blank tile label
   1286  10000 ????
   1287  10000 ????						; *** clear the saved dl ending for scrolling zones...
   1288  10000 ????				       ldx	#{1}
   1289  10000 ????				       lda	#0
   1290  10000 ????			    .scrollcleardls
   1291  10000 ????				       sta	dlend,x
   1292  10000 ????				       inx
   1293  10000 ????				       cpx	#WZONECOUNT
   1294  10000 ????				       bne	.scrollcleardls
   1295  10000 ????
   1296  10000 ????				       ifconst	VSCROLL
   1297  10000 ????						; *** adjust the ending for our mask dl to allow for mask objects...
   1298  10000 ????				       dex
   1299  10000 ????				       lda	#(maskscrollspriteend-maskscrollsprite)
   1300  10000 ????				       sta	dlend,x
   1301  10000 ????
   1302  10000 ????						; *** Add 4x dma masking objects to last zone...
   1303  10000 ????				       ldx	#(maskscrollspriteend-maskscrollsprite-1)
   1304  10000 ????			    .scrollpopulateloop1
   1305  10000 ????				       lda	maskscrollsprite,x
   1306  10000 ????				       sta	LASTZONEADDRESS+0,x
   1307  10000 ????				       ifconst	DOUBLEBUFFER
   1308  10000 ????				       sta	LASTZONEADDRESS+0+DOUBLEBUFFEROFFSET,x
   1309  10000 ????				       endif		; DOUBLEBUFFER
   1310  10000 ????				       dex
   1311  10000 ????				       bpl	.scrollpopulateloop1
   1312  10000 ????				       inx		; x=0
   1313  10000 ????				       stx	finescrolly
   1314  10000 ????				       endif		; VSCROLL
   1315  10000 ????
   1316  10000 ????						; *** Add blank sprite-tile objects to the scrolling zones...
   1317  10000 ????			    PLOTSP4    =	1	; ensure we use 4 byte sprites
   1318  10000 ????
   1319  10000 ????						; convert byte width of the sprit to coordinate width...
   1320  10000 ????				       if	{2}_mode = 0	; ### 160A, 320A, 320D
   1321  10000 ????			    .scrollXWIDTH SET	({2}_width * 4)	; 4x 160-mode pixels per byte
   1322  10000 ????				       else		; ### 160B, 320B, 320C
   1323  10000 ????			    .scrollXWIDTH SET	({2}_width * 2)	; 2x 160-mode pixels per byte
   1324  10000 ????				       endif
   1325  10000 ????
   1326  10000 ????						; figure out how many sprites we need to fill a screen width...
   1327  10000 ????			    .scrollSPRITECOuNT SET	((160+.scrollXWIDTH-1)/.scrollXWIDTH)
   1328  10000 ????				       ifconst	HSCROLL
   1329  10000 ????			    .scrollSPRITECOuNT SET	(.scrollSPRITECOuNT+1)
   1330  10000 ????				       endif		; HSCROLL
   1331  10000 ????
   1332  10000 ????						; setup plotsprite4 parameters...
   1333  10000 ????				       lda	#<{2}
   1334  10000 ????				       sta	temp1
   1335  10000 ????				       lda	#>{2}
   1336  10000 ????				       sta	temp2
   1337  10000 ????				       lda	#{2}_width_twoscompliment
   1338  10000 ????				       sta	temp3	; width
   1339  10000 ????
   1340  10000 ????				       lda	#{1}
   1341  10000 ????				       asl
   1342  10000 ????				       asl
   1343  10000 ????				       asl
   1344  10000 ????				       if	WZONEHEIGHT
   1345  10000 ????				       asl
   1346  10000 ????				       endif
   1347  10000 ????				       sta	temp5	; Y
   1348  10000 ????			    .scrollpopulateloop2
   1349  10000 ????				       lda	#0
   1350  10000 ????				       sta	temp4	; X
   1351  10000 ????			    .scrollpopulateloop3
   1352  10000 ????				       jsr	skipplotsprite4wait
   1353  10000 ????				       lda	temp4	; X
   1354  10000 ????				       clc
   1355  10000 ????				       adc	#.scrollXWIDTH
   1356  10000 ????				       sta	temp4	; X
   1357  10000 ????				       cmp	#(.scrollSPRITECOuNT*.scrollXWIDTH)
   1358  10000 ????				       bne	.scrollpopulateloop3
   1359  10000 ????				       lda	temp5	; Y
   1360  10000 ????				       clc
   1361  10000 ????				       adc	#WZONEHEIGHT
   1362  10000 ????				       sta	temp5	; Y
   1363  10000 ????				       cmp	#((WZONECOUNT*WZONEHEIGHT)+WZONEHEIGHT)
   1364  10000 ????				       bne	.scrollpopulateloop2
   1365  10000 ????				       ENDM
   1366  10000 ????
   1367  10000 ????				       MAC	sizeof
   1368  10000 ????
   1369  10000 ????						; echoes the size difference between the current address and the
   1370  10000 ????						; a label that was passed as an argument. This is a quick way to
   1371  10000 ????						; determine the size of a structure.
   1372  10000 ????
   1373  10000 ????			    .NAME      SETSTR	{1}
   1374  10000 ????				       echo	" The Size of",.NAME,"is:",[* - {1}]d,[* - {2}]d,"bytes."
   1375  10000 ????				       ENDM
   1376  10000 ????
   1377  10000 ????						;
   1378  10000 ????						; speakjet.inc
   1379  10000 ????						;
   1380  10000 ????						;
   1381  10000 ????						; AtariVox Speech Synth Driver
   1382  10000 ????						;
   1383  10000 ????						; By Alex Herbert, 2004
   1384  10000 ????						;
   1385  10000 ????
   1386  10000 ????
   1387  10000 ????
   1388  10000 ????
   1389  10000 ????						; Constants
   1390  10000 ????
   1391  10000 ????
   1392  10000 ????		00 01	    SERIAL_OUTMASK equ	$01
   1393  10000 ????		00 02	    SERIAL_RDYMASK equ	$02
   1394  10000 ????
   1395  10000 ????
   1396  10000 ????
   1397  10000 ????						; Macros
   1398  10000 ????
   1399  10000 ????				       mac	spkout
   1400  10000 ????
   1401  10000 ????						; check buffer-full status
   1402  10000 ????				       lda	SWCHA
   1403  10000 ????				       and	#SERIAL_RDYMASK
   1404  10000 ????				       beq	.speech_done
   1405  10000 ????
   1406  10000 ????						; get next speech byte
   1407  10000 ????				       ldy	#$00
   1408  10000 ????				       lda	(speech_addr),y
   1409  10000 ????
   1410  10000 ????						; invert data and check for end of string
   1411  10000 ????				       eor	#$ff
   1412  10000 ????						;sta BACKGRND ; debug - uncomment to flash the background color with vox data
   1413  10000 ????				       beq	.speech_done
   1414  10000 ????				       sta	{1}
   1415  10000 ????
   1416  10000 ????						; increment speech pointer
   1417  10000 ????				       inc	speech_addr
   1418  10000 ????				       bne	.incaddr_skip
   1419  10000 ????				       inc	speech_addr+1
   1420  10000 ????			    .incaddr_skip
   1421  10000 ????
   1422  10000 ????						; output byte as serial data
   1423  10000 ????
   1424  10000 ????				       sec		; start bit
   1425  10000 ????			    .byteout_loop
   1426  10000 ????						; put carry flag into bit 0 of SWACNT, preserving other bits
   1427  10000 ????				       lda	SWACNT	; 4
   1428  10000 ????				       and	#$fe	; 2 6
   1429  10000 ????				       adc	#$00	; 2 8
   1430  10000 ????				       sta	SWACNT	; 4 12
   1431  10000 ????
   1432  10000 ????						; 10 bits sent? (1 start bit, 8 data bits, 1 stop bit)
   1433  10000 ????				       cpy	#$09	; 2 14
   1434  10000 ????				       beq	.speech_done	; 2 16
   1435  10000 ????				       iny		; 2 18
   1436  10000 ????
   1437  10000 ????						; the 7800 is 1.5x faster than the 2600. Waste more cycles here
   1438  10000 ????						; to match the original baud rate...
   1439  10000 ????						;ldx	  #$07 ; 2600
   1440  10000 ????				       ldx	#$0D
   1441  10000 ????
   1442  10000 ????			    .delay_loop
   1443  10000 ????				       dex		;
   1444  10000 ????				       bne	.delay_loop	; 36 54
   1445  10000 ????
   1446  10000 ????						; shift next data bit into carry
   1447  10000 ????				       lsr	{1}	; 5 59
   1448  10000 ????
   1449  10000 ????						; and loop (branch always taken)
   1450  10000 ????				       bpl	.byteout_loop	; 3 62 cycles for loop
   1451  10000 ????
   1452  10000 ????			    .speech_done
   1453  10000 ????
   1454  10000 ????				       endm
   1455  10000 ????
   1456  10000 ????
   1457  10000 ????				       mac	speak
   1458  10000 ????
   1459  10000 ????				       lda	#<{1}
   1460  10000 ????				       sta	speech_addr
   1461  10000 ????				       lda	#>{1}
   1462  10000 ????				       sta	speech_addr+1
   1463  10000 ????
   1464  10000 ????				       endm
   1465  10000 ????
   1466  10000 ????
   1467  10000 ????
   1468  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
   1469  10000 ????
   1470  10000 ????				       processor	6502
   1471  10000 ????
------- FILE 7800basic.h LEVEL 2 PASS 3
      0  10000 ????				       include	"7800basic.h"
      1  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  10000 ????
      3  10000 ????				       processor	6502
------- FILE 7800.h LEVEL 3 PASS 3
      0  10000 ????				       include	"7800.h"
      1  10000 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  10000 ????
      3  10000 ????						; 7800.h
      4  10000 ????						; Version 1.0, 2019/12/13
      5  10000 ????
      6  10000 ????						; This file defines hardware registers and memory mapping for the
      7  10000 ????						; Atari 7800. It is distributed as a companion machine-specific support package
      8  10000 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
      9  10000 ????						; available at https://github.com/dasm-assembler/dasm
     10  10000 ????
     11  10000 ????
     12  10000 ????						; ******************** 7800 Hardware Addresses ***************************
     13  10000 ????						;
     14  10000 ????						;	 MEMORY MAP USAGE OF THE 7800
     15  10000 ????						;
     16  10000 ????						;	  00 -   1F	TIA REGISTERS
     17  10000 ????						;	  20 -   3F	MARIA REGISTERS
     18  10000 ????						;	  40 -   FF	RAM block 0 (zero page)
     19  10000 ????						;	 100 -  11F	TIA   (mirror of 0000-001f)
     20  10000 ????						;	 120 -  13F	MARIA (mirror of 0020-003f)
     21  10000 ????						;	 140 -  1FF	RAM block 1 (stack)
     22  10000 ????						;	 200 -  21F	TIA   (mirror of 0000-001f)
     23  10000 ????						;	 220 -  23F	MARIA (mirror of 0020-003f)
     24  10000 ????						;	 240 -  27F	???
     25  10000 ????						;	 280 -  2FF	RIOT I/O ports and timers
     26  10000 ????						;	 300 -  31F	TIA   (mirror of 0000-001f)
     27  10000 ????						;	 320 -  33F	MARIA (mirror of 0020-003f)
     28  10000 ????						;	 340 -  3FF	???
     29  10000 ????						;	 400 -  47F	unused address space
     30  10000 ????						;	 480 -  4FF	RIOT RAM
     31  10000 ????						;	 500 -  57F	unused address space
     32  10000 ????						;	 580 -  5FF	RIOT RAM (mirror of 0480-04ff)
     33  10000 ????						;	 600 - 17FF	unused address space
     34  10000 ????						;	1800 - 203F	RAM
     35  10000 ????						;	2040 - 20FF	RAM block 0 (mirror of 0000-001f)
     36  10000 ????						;	2100 - 213F	RAM
     37  10000 ????						;	2140 - 21FF	RAM block 1 (mirror of 0140-01ff)
     38  10000 ????						;	2200 - 27FF	RAM
     39  10000 ????						;	2800 - 2FFF	unavailable to external devices (bios bus-conflict)
     40  10000 ????						;	3000 - 3FFF	unused address space
     41  10000 ????						;	4000 - FF7F	potential cartridge address space
     42  10000 ????						;	FF80 - FFF9	RESERVED FOR ENCRYPTION
     43  10000 ????						;	FFFA - FFFF	6502 VECTORS
     44  10000 ????
     45  10000 ????
     46  10000 ????						;****** 00-1F ********* TIA REGISTERS ******************
     47  10000 ????
     48  10000 ????		00 01	    INPTCTRL   =	$01	;Input control. In same address space as TIA. write-only
     49  10000 ????		00 01	    VBLANK     =	$01	;VBLANK. D7=1:dump paddle caps to ground.     write-only
     50  10000 ????		00 02	    _WSYNC     =	$02	;Wait for HSync			       write-only
     51  10000 ????		00 03	    _RSYNC     =	$03	;Reset HSync				       write-only
     52  10000 ????		00 08	    INPT0      =	$08	;Paddle Control Input 0		       read-only
     53  10000 ????		00 09	    INPT1      =	$09	;Paddle Control Input 1		       read-only
     54  10000 ????		00 0a	    INPT2      =	$0A	;Paddle Control Input 2		       read-only
     55  10000 ????		00 0b	    INPT3      =	$0B	;Paddle Control Input 3		       read-only
     56  10000 ????
     57  10000 ????						; ** some common alternate names for INPT0/1/2/3
     58  10000 ????		00 08	    INPT4B     =	$08	;Joystick 0 Fire 1			       read-only
     59  10000 ????		00 09	    INPT4A     =	$09	;Joystick 0 Fire 1			       read-only
     60  10000 ????		00 0a	    INPT5B     =	$0A	;Joystick 1 Fire 0			       read-only
     61  10000 ????		00 0b	    INPT5A     =	$0B	;Joystick 1 Fire 1			       read-only
     62  10000 ????		00 08	    INPT4R     =	$08	;Joystick 0 Fire 1			       read-only
     63  10000 ????		00 09	    INPT4L     =	$09	;Joystick 0 Fire 1			       read-only
     64  10000 ????		00 0a	    INPT5R     =	$0A	;Joystick 1 Fire 0			       read-only
     65  10000 ????		00 0b	    INPT5L     =	$0B	;Joystick 1 Fire 1			       read-only
     66  10000 ????
     67  10000 ????		00 0c	    INPT4      =	$0C	;Player 0 Fire Button Input		       read-only
     68  10000 ????		00 0d	    INPT5      =	$0D	;Player 1 Fire Button Input		       read-only
     69  10000 ????
     70  10000 ????		00 15	    AUDC0      =	$15	;Audio Control Channel   0		       write-only
     71  10000 ????		00 16	    AUDC1      =	$16	;Audio Control Channel   1		       write-only
     72  10000 ????		00 17	    AUDF0      =	$17	;Audio Frequency Channel 0		       write-only
     73  10000 ????		00 18	    AUDF1      =	$18	;Audio Frequency Channel 1		       write-only
     74  10000 ????		00 19	    AUDV0      =	$19	;Audio Volume Channel	  0		       write-only
     75  10000 ????		00 1a	    AUDV1      =	$1A	;Audio Volume Channel	  1		       write-only
     76  10000 ????
     77  10000 ????						;****** 20-3F ********* MARIA REGISTERS ***************
     78  10000 ????
     79  10000 ????		00 20	    BACKGRND   =	$20	;Background Color			       write-only
     80  10000 ????		00 21	    P0C1       =	$21	;Palette 0 - Color 1			       write-only
     81  10000 ????		00 22	    P0C2       =	$22	;Palette 0 - Color 2			       write-only
     82  10000 ????		00 23	    P0C3       =	$23	;Palette 0 - Color 3			       write-only
     83  10000 ????		00 24	    WSYNC      =	$24	;Wait For Sync 			       write-only
     84  10000 ????		00 25	    P1C1       =	$25	;Palette 1 - Color 1			       write-only
     85  10000 ????		00 26	    P1C2       =	$26	;Palette 1 - Color 2			       write-only
     86  10000 ????		00 27	    P1C3       =	$27	;Palette 1 - Color 3			       write-only
     87  10000 ????		00 28	    MSTAT      =	$28	;Maria Status				       read-only
     88  10000 ????		00 29	    P2C1       =	$29	;Palette 2 - Color 1			       write-only
     89  10000 ????		00 2a	    P2C2       =	$2A	;Palette 2 - Color 2			       write-only
     90  10000 ????		00 2b	    P2C3       =	$2B	;Palette 2 - Color 3			       write-only
     91  10000 ????		00 2c	    DPPH       =	$2C	;Display List List Pointer High	       write-only
     92  10000 ????		00 2d	    P3C1       =	$2D	;Palette 3 - Color 1			       write-only
     93  10000 ????		00 2e	    P3C2       =	$2E	;Palette 3 - Color 2			       write-only
     94  10000 ????		00 2f	    P3C3       =	$2F	;Palette 3 - Color 3			       write-only
     95  10000 ????		00 30	    DPPL       =	$30	;Display List List Pointer Low 	       write-only
     96  10000 ????		00 31	    P4C1       =	$31	;Palette 4 - Color 1			       write-only
     97  10000 ????		00 32	    P4C2       =	$32	;Palette 4 - Color 2			       write-only
     98  10000 ????		00 33	    P4C3       =	$33	;Palette 4 - Color 3			       write-only
     99  10000 ????		00 34	    CHARBASE   =	$34	;Character Base Address		       write-only
    100  10000 ????		00 34	    CHBASE     =	$34	;Character Base Address		       write-only
    101  10000 ????		00 35	    P5C1       =	$35	;Palette 5 - Color 1			       write-only
    102  10000 ????		00 36	    P5C2       =	$36	;Palette 5 - Color 2			       write-only
    103  10000 ????		00 37	    P5C3       =	$37	;Palette 5 - Color 3			       write-only
    104  10000 ????		00 38	    OFFSET     =	$38	;Unused - Store zero here		       write-only
    105  10000 ????		00 39	    P6C1       =	$39	;Palette 6 - Color 1			       write-only
    106  10000 ????		00 3a	    P6C2       =	$3A	;Palette 6 - Color 2			       write-only
    107  10000 ????		00 3b	    P6C3       =	$3B	;Palette 6 - Color 3			       write-only
    108  10000 ????		00 3c	    CTRL       =	$3C	;Maria Control Register		       write-only
    109  10000 ????		00 3d	    P7C1       =	$3D	;Palette 7 - Color 1			       write-only
    110  10000 ????		00 3e	    P7C2       =	$3E	;Palette 7 - Color 2			       write-only
    111  10000 ????		00 3f	    P7C3       =	$3F	;Palette 7 - Color 3			       write-only
    112  10000 ????
    113  10000 ????
    114  10000 ????						;****** 280-2FF ******* PIA PORTS AND TIMERS ************
    115  10000 ????
    116  10000 ????		02 80	    SWCHA      =	$280	;P0+P1 Joystick Directional Input	       read-write
    117  10000 ????		02 81	    CTLSWA     =	$281	;I/O Control for SCHWA 		       read-write
    118  10000 ????		02 81	    SWACNT     =	$281	;VCS name for above			       read-write
    119  10000 ????		02 82	    SWCHB      =	$282	;Console Switches			       read-write
    120  10000 ????		02 83	    CTLSWB     =	$283	;I/O Control for SCHWB 		       read-write
    121  10000 ????		02 83	    SWBCNT     =	$283	;VCS name for above			       read-write
    122  10000 ????		02 84	    INTIM      =	$284	;Interval Timer Read			       read-only
    123  10000 ????		02 85	    TIMINT     =	$285	;Interval Timer Interrupt		       read-only
    124  10000 ????
    125  10000 ????		02 94	    TIM1T      =	$294	;Set 1    CLK Interval (838   nsec/interval)  write-only
    126  10000 ????		02 95	    TIM8T      =	$295	;Set 8    CLK Interval (6.7   usec/interval)  write-only
    127  10000 ????		02 96	    TIM64T     =	$296	;Set 64   CLK Interval (63.6  usec/interval)  write-only
    128  10000 ????		02 97	    T1024T     =	$297	;Set 1024 CLK Interval (858.2 usec/interval)  write-only
    129  10000 ????		02 9e	    TIM64TI    =	$29E	;Interrupt timer 64T			       write-only
    130  10000 ????
    131  10000 ????						;XM
    132  10000 ????		04 70	    XCTRL      =	$470	; 7=YM2151 6=RAM@6k 5=RAM@4k 4=pokey@450 3=hsc 2=cart 1=RoF_bank1 0=RoF_bank2
    133  10000 ????		04 70	    XCTRL1     =	$470
    134  10000 ????		04 78	    XCTRL2     =	$478
    135  10000 ????		04 7c	    XCTRL3     =	$47c
    136  10000 ????		04 71	    XCTRL4     =	$471
    137  10000 ????		04 72	    XCTRL5     =	$472
    138  10000 ????
    139  10000 ????						; Pokey register relative locations, since its base may be different
    140  10000 ????						; depending on the hardware.
    141  10000 ????		00 00	    PAUDF0     =	$0	; extra audio channels and frequencies
    142  10000 ????		00 01	    PAUDC0     =	$1
    143  10000 ????		00 02	    PAUDF1     =	$2
    144  10000 ????		00 03	    PAUDC1     =	$3
    145  10000 ????		00 04	    PAUDF2     =	$4
    146  10000 ????		00 05	    PAUDC2     =	$5
    147  10000 ????		00 06	    PAUDF3     =	$6
    148  10000 ????		00 07	    PAUDC3     =	$7
    149  10000 ????		00 08	    PAUDCTL    =	$8	; Audio Control
    150  10000 ????		00 09	    PSTIMER    =	$9
    151  10000 ????		00 0a	    PRANDOM    =	$A	; 17 bit polycounter pseudo random
    152  10000 ????		00 0f	    PSKCTL     =	$F	; Serial Port control
------- FILE 7800basic.h
------- FILE 7800basic_variable_redefs.h LEVEL 3 PASS 3
      0  10000 ????				       include	"7800basic_variable_redefs.h"
      1  10000 ????						; This file contains variable mapping and other information for the current project.
      2  10000 ????
      3  10000 ????		00 82	    BAR_OFFSET =	FONT_SPR_CHARS * 2
      4  10000 ????
      5  10000 ????		00 41	    FONT_SPR_CHARS =	65
      6  10000 ????
      7  10000 ????		00 0c	    PICKUP_STRING_LENGTH =	12
      8  10000 ????
      9  10000 ????		00 78	    PICKUP_TIME =	120
     10  10000 ????
     11  10000 ????		00 78	    FAIRY_ITEM_TIME =	120
     12  10000 ????
     13  10000 ????		00 48	    MP_CHANGE_XETHER =	$48
     14  10000 ????
     15  10000 ????		00 10	    MP_CHANGE_ETHER =	$10
     16  10000 ????
     17  10000 ????		00 05	    MP_CHANGE_PRISM =	$05
     18  10000 ????
     19  10000 ????		00 48	    HP_CHANGE_XPOTION =	$48
     20  10000 ????
     21  10000 ????		00 30	    HP_CHANGE_HIPOTION =	$30
     22  10000 ????
     23  10000 ????		00 20	    HP_CHANGE_POTION =	$20
     24  10000 ????
     25  10000 ????		00 10	    HP_CHANGE_FOOD =	$10
     26  10000 ????
     27  10000 ????		00 10	    PW_A       =	16
     28  10000 ????
     29  10000 ????		00 13	    PW_0       =	19
     30  10000 ????
     31  10000 ????		00 c0	    MENU_EQUIP_EXIT_Y =	192
     32  10000 ????
     33  10000 ????		00 7c	    MENU_EQUIP_EXIT_X =	124
     34  10000 ????
     35  10000 ????		00 b0	    MENU_EQUIP_INV3_Y =	176
     36  10000 ????
     37  10000 ????		00 8e	    MENU_EQUIP_INV2_Y =	142
     38  10000 ????
     39  10000 ????		00 70	    MENU_EQUIP_INV1_Y =	112
     40  10000 ????
     41  10000 ????		00 50	    MENU_EQUIP_INV0_Y =	80
     42  10000 ????
     43  10000 ????		00 0c	    MENU_EQUIP_INV_X =	12
     44  10000 ????
     45  10000 ????		00 a0	    MENU_EQUIP_CHARM_Y =	160
     46  10000 ????
     47  10000 ????		00 80	    MENU_EQUIP_ARMOR_Y =	128
     48  10000 ????
     49  10000 ????		00 60	    MENU_EQUIP_SHIELD_Y =	96
     50  10000 ????
     51  10000 ????		00 40	    MENU_EQUIP_SWORD_Y =	64
     52  10000 ????
     53  10000 ????		00 4c	    MENU_EQUIP_EQUIPPED_X =	76
     54  10000 ????
     55  10000 ????		00 04	    MENU_EQUIP_MAX_OPTIONS =	4
     56  10000 ????
     57  10000 ????		00 2c	    ITEM_NAME_LENGTH =	( 8 / 2 ) * 11
     58  10000 ????
     59  10000 ????		00 20	    ITEMS_HP_Y =	32
     60  10000 ????
     61  10000 ????		00 50	    ITEMS_HP_X =	80
     62  10000 ????
     63  10000 ????		00 04	    MENU_TAP_FRAMES =	4
     64  10000 ????
     65  10000 ????		00 74	    MENU_MAIN_RELICS_X =	116
     66  10000 ????
     67  10000 ????		00 48	    MENU_MAIN_EQUIP_X =	72
     68  10000 ????
     69  10000 ????		00 28	    MENU_MAIN_MAGIC_X =	40
     70  10000 ????
     71  10000 ????		00 c0	    MENU_MAIN_ITEMS_Y =	192
     72  10000 ????
     73  10000 ????		00 0c	    MENU_MAIN_ITEMS_X =	12
     74  10000 ????
     75  10000 ????		00 3e	    CHAR_SPACE =	62
     76  10000 ????
     77  10000 ????		00 03	    MENU_MAIN_MAX_OPTIONS =	3
     78  10000 ????
     79  10000 ????		00 06	    MENU_GAMEOVER =	6
     80  10000 ????
     81  10000 ????		00 05	    MENU_PASSWORD =	5
     82  10000 ????
     83  10000 ????		00 04	    MENU_RELICS =	4
     84  10000 ????
     85  10000 ????		00 03	    MENU_EQUIP =	3
     86  10000 ????
     87  10000 ????		00 02	    MENU_MAGIC =	2
     88  10000 ????
     89  10000 ????		00 01	    MENU_ITEMS =	1
     90  10000 ????
     91  10000 ????		00 00	    MENU_MAIN  =	0
     92  10000 ????
     93  10000 ????		00 02	    F_HILLS_SAVE2_D =	DIR_DOWN
     94  10000 ????
     95  10000 ????		00 80	    F_HILLS_SAVE2_Y =	$80
     96  10000 ????
     97  10000 ????		00 72	    F_HILLS_SAVE2_X =	$72
     98  10000 ????
     99  10000 ????		00 05	    F_HILLS_SAVE2_I =	5
    100  10000 ????
    101  10000 ????		00 40	    M_HILLS_SAVE2_Y =	64
    102  10000 ????
    103  10000 ????		00 5e	    M_HILLS_SAVE2_X =	94
    104  10000 ????
    105  10000 ????		00 02	    F_HILLS_SAVE1_D =	DIR_DOWN
    106  10000 ????
    107  10000 ????		00 70	    F_HILLS_SAVE1_Y =	$70
    108  10000 ????
    109  10000 ????		00 50	    F_HILLS_SAVE1_X =	$50
    110  10000 ????
    111  10000 ????		00 11	    F_HILLS_SAVE1_I =	17
    112  10000 ????
    113  10000 ????		00 60	    M_HILLS_SAVE1_Y =	96
    114  10000 ????
    115  10000 ????		00 4e	    M_HILLS_SAVE1_X =	78
    116  10000 ????
    117  10000 ????		00 01	    F_HILLS_START_D =	DIR_UP
    118  10000 ????
    119  10000 ????		00 a0	    F_HILLS_START_Y =	$A0
    120  10000 ????
    121  10000 ????		00 64	    F_HILLS_START_X =	$64
    122  10000 ????
    123  10000 ????		00 16	    F_HILLS_START_I =	22
    124  10000 ????
    125  10000 ????		00 70	    M_HILLS_START_Y =	112
    126  10000 ????
    127  10000 ????		00 3e	    M_HILLS_START_X =	62
    128  10000 ????
    129  10000 ????		00 02	    F_RIVER_SAVE2_D =	DIR_DOWN
    130  10000 ????
    131  10000 ????		00 80	    F_RIVER_SAVE2_Y =	$80
    132  10000 ????
    133  10000 ????		00 72	    F_RIVER_SAVE2_X =	$72
    134  10000 ????
    135  10000 ????		00 05	    F_RIVER_SAVE2_I =	5
    136  10000 ????
    137  10000 ????		00 40	    M_RIVER_SAVE2_Y =	64
    138  10000 ????
    139  10000 ????		00 5e	    M_RIVER_SAVE2_X =	94
    140  10000 ????
    141  10000 ????		00 02	    F_RIVER_SAVE1_D =	DIR_DOWN
    142  10000 ????
    143  10000 ????		00 70	    F_RIVER_SAVE1_Y =	$70
    144  10000 ????
    145  10000 ????		00 50	    F_RIVER_SAVE1_X =	$50
    146  10000 ????
    147  10000 ????		00 11	    F_RIVER_SAVE1_I =	17
    148  10000 ????
    149  10000 ????		00 60	    M_RIVER_SAVE1_Y =	96
    150  10000 ????
    151  10000 ????		00 4e	    M_RIVER_SAVE1_X =	78
    152  10000 ????
    153  10000 ????		00 02	    F_RIVER_START_D =	DIR_DOWN
    154  10000 ????
    155  10000 ????		00 50	    F_RIVER_START_Y =	$50
    156  10000 ????
    157  10000 ????		00 4c	    F_RIVER_START_X =	76
    158  10000 ????
    159  10000 ????		00 16	    F_RIVER_START_I =	22
    160  10000 ????
    161  10000 ????		00 70	    M_RIVER_START_Y =	112
    162  10000 ????
    163  10000 ????		00 3e	    M_RIVER_START_X =	62
    164  10000 ????
    165  10000 ????		00 11	    ROOMR_N    =	17
    166  10000 ????
    167  10000 ????		00 10	    ROOML_N    =	16
    168  10000 ????
    169  10000 ????		00 0f	    ROOMR_U    =	15
    170  10000 ????
    171  10000 ????		00 0e	    ROOML_U    =	14
    172  10000 ????
    173  10000 ????		00 0d	    ROOMR_D    =	13
    174  10000 ????
    175  10000 ????		00 0c	    ROOML_D    =	12
    176  10000 ????
    177  10000 ????		00 0b	    ROOMR_UD   =	11
    178  10000 ????
    179  10000 ????		00 0a	    ROOML_UD   =	10
    180  10000 ????
    181  10000 ????		00 09	    ROOMR_UR   =	9
    182  10000 ????
    183  10000 ????		00 08	    ROOML_UL   =	8
    184  10000 ????
    185  10000 ????		00 07	    ROOMR_DR   =	7
    186  10000 ????
    187  10000 ????		00 06	    ROOML_DL   =	6
    188  10000 ????
    189  10000 ????		00 05	    ROOMR_R    =	5
    190  10000 ????
    191  10000 ????		00 04	    ROOML_L    =	4
    192  10000 ????
    193  10000 ????		00 03	    ROOMR_UDR  =	3
    194  10000 ????
    195  10000 ????		00 02	    ROOML_UDL  =	2
    196  10000 ????
    197  10000 ????		00 01	    ROOMR_B    =	1
    198  10000 ????
    199  10000 ????		00 00	    ROOML_B    =	0
    200  10000 ????
    201  10000 ????		00 78	    LIGHTNING_DELAY =	120
    202  10000 ????
    203  10000 ????		00 08	    LIGHTNING_FRAMES =	8
    204  10000 ????
    205  10000 ????		00 0f	    MAX_OBJECTS =	15
    206  10000 ????
    207  10000 ????		00 0c	    MAX_MAP_OBJECTS =	12
    208  10000 ????
    209  10000 ????		00 07	    ROOMS_PER_ROW =	7
    210  10000 ????
    211  10000 ????		00 04	    T_HILLS    =	4
    212  10000 ????
    213  10000 ????		00 03	    T_RIVER    =	3
    214  10000 ????
    215  10000 ????		00 02	    T_CASTLE   =	2
    216  10000 ????
    217  10000 ????		00 01	    T_FOREST   =	1
    218  10000 ????
    219  10000 ????		00 00	    T_TITLE    =	0
    220  10000 ????
    221  10000 ????		00 08	    TILE_WIDTH =	8
    222  10000 ????
    223  10000 ????		00 10	    TILE_HEIGHT =	16
    224  10000 ????
    225  10000 ????		00 50	    WHITE_DARKNESS =	$50
    226  10000 ????
    227  10000 ????		00 0f	    FADE_NORMAL =	15
    228  10000 ????
    229  10000 ????		00 00	    FADE_DARKNESS =	0
    230  10000 ????
    231  10000 ????		00 78	    POISON_FRAMES =	120
    232  10000 ????
    233  10000 ????		00 01	    POISON_DMG =	1
    234  10000 ????
    235  10000 ????		00 06	    STATUS_REGEN =	6
    236  10000 ????
    237  10000 ????		00 05	    STATUS_FURY =	5
    238  10000 ????
    239  10000 ????		00 04	    STATUS_STONE =	4
    240  10000 ????
    241  10000 ????		00 03	    STATUS_CURSE =	3
    242  10000 ????
    243  10000 ????		00 02	    STATUS_DARK =	2
    244  10000 ????
    245  10000 ????		00 01	    STATUS_POISON =	1
    246  10000 ????
    247  10000 ????		00 00	    STATUS_NONE =	0
    248  10000 ????
    249  10000 ????		00 df	    MASK_REGEN =	%11011111
    250  10000 ????
    251  10000 ????		00 ef	    MASK_FURY  =	%11101111
    252  10000 ????
    253  10000 ????		00 f7	    MASK_STONE =	%11110111
    254  10000 ????
    255  10000 ????		00 fb	    MASK_CURSE =	%11111011
    256  10000 ????
    257  10000 ????		00 fd	    MASK_DARK  =	%11111101
    258  10000 ????
    259  10000 ????		00 fe	    MASK_POISON =	%11111110
    260  10000 ????
    261  10000 ????		00 20	    BITS_REGEN =	%00100000
    262  10000 ????
    263  10000 ????		00 10	    BITS_FURY  =	%00010000
    264  10000 ????
    265  10000 ????		00 08	    BITS_STONE =	%00001000
    266  10000 ????
    267  10000 ????		00 04	    BITS_CURSE =	%00000100
    268  10000 ????
    269  10000 ????		00 02	    BITS_DARK  =	%00000010
    270  10000 ????
    271  10000 ????		00 01	    BITS_POISON =	%00000001
    272  10000 ????
    273  10000 ????		00 0c	    PLAYER_MP_QUARTER =	PLAYER_MP_MAX / 4
    274  10000 ????
    275  10000 ????		00 18	    PLAYER_MP_HALF =	PLAYER_MP_MAX / 2
    276  10000 ????
    277  10000 ????		00 30	    PLAYER_MP_MAX =	48
    278  10000 ????
    279  10000 ????		00 0c	    PLAYER_HP_QUARTER =	PLAYER_HP_MAX / 4
    280  10000 ????
    281  10000 ????		00 18	    PLAYER_HP_HALF =	PLAYER_HP_MAX / 2
    282  10000 ????
    283  10000 ????		00 30	    PLAYER_HP_MAX =	48
    284  10000 ????
    285  10000 ????		00 04	    INVULN_FRAMES =	4
    286  10000 ????
    287  10000 ????		00 0c	    CHANT_START_TIME =	12
    288  10000 ????
    289  10000 ????		00 08	    ATTACK_FRAMES =	8
    290  10000 ????
    291  10000 ????		00 0d	    FRAME_DEATH =	13
    292  10000 ????
    293  10000 ????		00 0c	    FRAME_CHANT =	12
    294  10000 ????
    295  10000 ????		00 0b	    FRAME_ATK_R =	11
    296  10000 ????
    297  10000 ????		00 0a	    FRAME_ATK_L =	10
    298  10000 ????
    299  10000 ????		00 09	    FRAME_ATK_U =	9
    300  10000 ????
    301  10000 ????		00 08	    FRAME_ATK_D =	8
    302  10000 ????
    303  10000 ????		00 06	    FRAME_RIGHT =	6
    304  10000 ????
    305  10000 ????		00 04	    FRAME_LEFT =	4
    306  10000 ????
    307  10000 ????		00 00	    FRAME_DOWN =	0
    308  10000 ????
    309  10000 ????		00 02	    FRAME_UP   =	2
    310  10000 ????
    311  10000 ????		00 07	    STATE_DEATH =	7
    312  10000 ????
    313  10000 ????		00 03	    STATE_HOP  =	3
    314  10000 ????
    315  10000 ????		00 02	    STATE_KNOCKBACK =	2
    316  10000 ????
    317  10000 ????		00 06	    STATE_CHANT =	6
    318  10000 ????
    319  10000 ????		00 05	    STATE_CHANT_START =	5
    320  10000 ????
    321  10000 ????		00 04	    STATE_ATTACK =	4
    322  10000 ????
    323  10000 ????		00 01	    STATE_MOVING =	1
    324  10000 ????
    325  10000 ????		00 00	    STATE_STAND =	0
    326  10000 ????
    327  10000 ????		00 06	    SHIELD_OFFSET_Y_UP_STAND =	6
    328  10000 ????
    329  10000 ????		00 06	    SHIELD_OFFSET_Y_UP =	6
    330  10000 ????
    331  10000 ????		00 07	    SHIELD_OFFSET_Y =	7
    332  10000 ????
    333  10000 ????		00 00	    SHIELD_OFFSET_X_UP_STAND =	0
    334  10000 ????
    335  10000 ????		00 08	    SHIELD_OFFSET_X_DOWN_STAND =	8
    336  10000 ????
    337  10000 ????		00 07	    SHIELD_OFFSET_X_RIGHT_STAND =	7
    338  10000 ????
    339  10000 ????		ff ff ff fe SHIELD_OFFSET_X_LEFT_STAND =	- 2
    340  10000 ????
    341  10000 ????		ff ff ff fd SHIELD_OFFSET_X_UP =	- 3
    342  10000 ????
    343  10000 ????		00 08	    SHIELD_OFFSET_X_DOWN =	8
    344  10000 ????
    345  10000 ????		00 07	    SHIELD_OFFSET_X_RIGHT =	7
    346  10000 ????
    347  10000 ????		00 06	    SHIELD_OFFSET_X_LEFT =	6
    348  10000 ????
    349  10000 ????		00 04	    SHIELD_FRAMES =	4
    350  10000 ????
    351  10000 ????		00 0c	    SWORD_OFFSET_RIGHT =	12
    352  10000 ????
    353  10000 ????		ff ff ff f4 SWORD_OFFSET_LEFT =	- 12
    354  10000 ????
    355  10000 ????		ff ff ff f0 SWORD_OFFSET_UP =	- 16
    356  10000 ????
    357  10000 ????		00 0f	    SWORD_OFFSET_DOWN =	15
    358  10000 ????
    359  10000 ????		00 04	    SWORD_FRAMES =	4
    360  10000 ????
    361  10000 ????		00 0c	    PLAYER_WIDTH =	12
    362  10000 ????
    363  10000 ????		00 10	    PLAYER_HEIGHT =	16
    364  10000 ????
    365  10000 ????		00 0f	    BUTTON_HOLD_FRAMES =	15
    366  10000 ????
    367  10000 ????		00 10	    ANIM_TIME  =	16
    368  10000 ????
    369  10000 ????		00 04	    EXIT_WEST  =	4
    370  10000 ????
    371  10000 ????		00 03	    EXIT_EAST  =	3
    372  10000 ????
    373  10000 ????		00 02	    EXIT_SOUTH =	2
    374  10000 ????
    375  10000 ????		00 01	    EXIT_NORTH =	1
    376  10000 ????
    377  10000 ????		00 00	    EXIT_NONE  =	0
    378  10000 ????
    379  10000 ????		00 04	    DIR_RIGHT  =	4
    380  10000 ????
    381  10000 ????		00 03	    DIR_LEFT   =	3
    382  10000 ????
    383  10000 ????		00 02	    DIR_DOWN   =	2
    384  10000 ????
    385  10000 ????		00 01	    DIR_UP     =	1
    386  10000 ????
    387  10000 ????		00 02	    STATE_MENU =	2
    388  10000 ????
    389  10000 ????		00 01	    STATE_FIELD =	1
    390  10000 ????
    391  10000 ????		00 00	    STATE_TITLE =	0
    392  10000 ????
    393  10000 ????		00 00	    plot_skelsword_hi =	# > .plot_skelsword
    394  10000 ????
    395  10000 ????		00 00	    plot_skelsword_lo =	# < .plot_skelsword
    396  10000 ????
    397  10000 ????		00 00	    plot_skeleton_hi =	# > .plot_skeleton
    398  10000 ????
    399  10000 ????		00 00	    plot_skeleton_lo =	# < .plot_skeleton
    400  10000 ????
    401  10000 ????		00 00	    plot_priest_hi =	# > .plot_priest
    402  10000 ????
    403  10000 ????		00 00	    plot_priest_lo =	# < .plot_priest
    404  10000 ????
    405  10000 ????		00 00	    plot_wolf_hi =	# > .plot_wolf
    406  10000 ????
    407  10000 ????		00 00	    plot_wolf_lo =	# < .plot_wolf
    408  10000 ????
    409  10000 ????		00 00	    plot_torch_hi =	# > .plot_torch
    410  10000 ????
    411  10000 ????		00 00	    plot_torch_lo =	# < .plot_torch
    412  10000 ????
    413  10000 ????		00 00	    m_relic_inv_hi =	# > m_relic_inv
    414  10000 ????
    415  10000 ????		00 00	    m_relic_inv_lo =	# < m_relic_inv
    416  10000 ????
    417  10000 ????		00 00	    m_charm_inv_hi =	# > m_charm_inv
    418  10000 ????
    419  10000 ????		00 00	    m_charm_inv_lo =	# < m_charm_inv
    420  10000 ????
    421  10000 ????		00 00	    m_armor_inv_hi =	# > m_armor_inv
    422  10000 ????
    423  10000 ????		00 00	    m_armor_inv_lo =	# < m_armor_inv
    424  10000 ????
    425  10000 ????		00 00	    m_shield_inv_hi =	# > m_shield_inv
    426  10000 ????
    427  10000 ????		00 00	    m_shield_inv_lo =	# < m_shield_inv
    428  10000 ????
    429  10000 ????		00 00	    m_sword_inv_hi =	# > m_sword_inv
    430  10000 ????
    431  10000 ????		00 00	    m_sword_inv_lo =	# < m_sword_inv
    432  10000 ????
    433  10000 ????		00 00	    m_item_qty_hi =	# > m_item_qty
    434  10000 ????
    435  10000 ????		00 00	    m_item_qty_lo =	# < m_item_qty
    436  10000 ????
    437  10000 ????		00 00	    m_item_inv_hi =	# > m_item_inv
    438  10000 ????
    439  10000 ????		00 00	    m_item_inv_lo =	# < m_item_inv
    440  10000 ????
    441  10000 ????		00 a1	    PAL_H_WATER =	$A1
    442  10000 ????
    443  10000 ????		00 c0	    PAL_H_VEG  =	$C0
    444  10000 ????
    445  10000 ????		00 11	    PAL_H_DIRT =	$11
    446  10000 ????
    447  10000 ????		00 08	    PAL_H_LTGRY =	$08
    448  10000 ????
    449  10000 ????		00 03	    PAL_H_DKGRY =	$03
    450  10000 ????
    451  10000 ????		00 06	    PAL_H_GRND =	$06
    452  10000 ????
    453  10000 ????		00 0f	    PAL_WFALL3 =	$0F
    454  10000 ????
    455  10000 ????		00 a3	    PAL_WFALL2 =	$A3
    456  10000 ????
    457  10000 ????		00 a1	    PAL_WFALL1 =	$A1
    458  10000 ????
    459  10000 ????		00 27	    PAL_C_LTGOLD =	$27
    460  10000 ????
    461  10000 ????		00 23	    PAL_C_DKGOLD =	$23
    462  10000 ????
    463  10000 ????		00 0f	    PAL_C_SKELWH =	$0F
    464  10000 ????
    465  10000 ????		00 33	    PAL_C_SKELAR =	$33
    466  10000 ????
    467  10000 ????		00 00	    PAL_C_SKELBL =	$00
    468  10000 ????
    469  10000 ????		00 a2	    PAL_C_BRTILE =	$A2
    470  10000 ????
    471  10000 ????		00 a1	    PAL_C_LTTILE =	$A1
    472  10000 ????
    473  10000 ????		00 a0	    PAL_C_DKTILE =	$A0
    474  10000 ????
    475  10000 ????		00 42	    PAL_C_BRCARP =	$42
    476  10000 ????
    477  10000 ????		00 41	    PAL_C_LTCARP =	$41
    478  10000 ????
    479  10000 ????		00 40	    PAL_C_DKCARP =	$40
    480  10000 ????
    481  10000 ????		00 05	    PAL_C_BRWALL =	$05
    482  10000 ????
    483  10000 ????		00 04	    PAL_C_LTWALL =	$04
    484  10000 ????
    485  10000 ????		00 03	    PAL_C_MDWALL =	$03
    486  10000 ????
    487  10000 ????		00 02	    PAL_C_DKWALL =	$02
    488  10000 ????
    489  10000 ????		00 aa	    PAL_C_LIGHTN =	$AA
    490  10000 ????
    491  10000 ????		00 90	    PAL_C_SKY  =	$90
    492  10000 ????
    493  10000 ????		00 12	    PAL_F_LTBRN =	$12
    494  10000 ????
    495  10000 ????		00 10	    PAL_F_DKBRN =	$10
    496  10000 ????
    497  10000 ????		00 06	    PAL_F_LTWTR =	$06
    498  10000 ????
    499  10000 ????		00 a1	    PAL_F_WATER =	$A1
    500  10000 ????
    501  10000 ????		00 06	    PAL_F_LTGRY =	$06
    502  10000 ????
    503  10000 ????		00 03	    PAL_F_DKGRY =	$03
    504  10000 ????
    505  10000 ????		00 c3	    PAL_F_LTGRN =	$C3
    506  10000 ????
    507  10000 ????		00 c0	    PAL_F_DKGRN =	$C0
    508  10000 ????
    509  10000 ????		00 11	    PAL_F_GRND =	$11
    510  10000 ????
    511  10000 ????		00 79	    BAR_FLASH_COLOR =	$79
    512  10000 ????
    513  10000 ????		00 76	    BAR_NORMAL_COLOR =	$76
    514  10000 ????
    515  10000 ????		00 60	    CHANT_COLOR =	$60
    516  10000 ????
    517  10000 ????		00 10	    HAIR_COLOR =	PAL_DKBRWN
    518  10000 ????
    519  10000 ????		00 d5	    PAL_COPPER =	$D5
    520  10000 ????
    521  10000 ????		00 a3	    PAL_LTBLUE =	$A3
    522  10000 ????
    523  10000 ????		00 91	    PAL_DKBLUE =	$91
    524  10000 ????
    525  10000 ????		00 19	    PAL_GOLD   =	$19
    526  10000 ????
    527  10000 ????		00 45	    PAL_LTRED  =	$45
    528  10000 ????
    529  10000 ????		00 30	    PAL_DKRED  =	$30
    530  10000 ????
    531  10000 ????		00 3b	    PAL_SKIN   =	$3B
    532  10000 ????
    533  10000 ????		00 23	    PAL_LTBRWN =	$23
    534  10000 ????
    535  10000 ????		00 10	    PAL_DKBRWN =	$10
    536  10000 ????
    537  10000 ????		00 0f	    PAL_WHITE  =	$0F
    538  10000 ????
    539  10000 ????		00 76	    PAL_LTPURP =	$76
    540  10000 ????
    541  10000 ????		00 60	    PAL_DKPURP =	$60
    542  10000 ????
    543  10000 ????		00 00	    PAL_BLACK  =	$00
    544  10000 ????
    545  10000 ????		00 00	    fireball_ai_hi =	# > .fireball_ai
    546  10000 ????
    547  10000 ????		00 00	    fireball_ai_lo =	# < .fireball_ai
    548  10000 ????
    549  10000 ????		00 00	    octoink_ai_hi =	# > .fireball_ai
    550  10000 ????
    551  10000 ????		00 00	    octoink_ai_lo =	# < .fireball_ai
    552  10000 ????
    553  10000 ????		00 00	    darkspark_ai_hi =	# > .fireball_ai
    554  10000 ????
    555  10000 ????		00 00	    darkspark_ai_lo =	# < .fireball_ai
    556  10000 ????
    557  10000 ????		00 00	    skelsword_ai_hi =	# > .skelsword_ai
    558  10000 ????
    559  10000 ????		00 00	    skelsword_ai_lo =	# < .skelsword_ai
    560  10000 ????
    561  10000 ????		00 00	    fairy_ai_hi =	# > .fairy_ai
    562  10000 ????
    563  10000 ????		00 00	    fairy_ai_lo =	# < .fairy_ai
    564  10000 ????
    565  10000 ????		00 00	    rghost_ai_hi =	# > .rghost_ai
    566  10000 ????
    567  10000 ????		00 00	    rghost_ai_lo =	# < .rghost_ai
    568  10000 ????
    569  10000 ????		00 00	    ghost_ai_hi =	# > .ghost_ai
    570  10000 ????
    571  10000 ????		00 00	    ghost_ai_lo =	# < .ghost_ai
    572  10000 ????
    573  10000 ????		00 00	    mredslime_ai_hi =	# > .redslime_ai
    574  10000 ????
    575  10000 ????		00 00	    mredslime_ai_lo =	# < .redslime_ai
    576  10000 ????
    577  10000 ????		00 00	    redslime_ai_hi =	# > .redslime_ai
    578  10000 ????
    579  10000 ????		00 00	    redslime_ai_lo =	# < .redslime_ai
    580  10000 ????
    581  10000 ????		00 00	    priest_ai_hi =	# > .priest_ai
    582  10000 ????
    583  10000 ????		00 00	    priest_ai_lo =	# < .priest_ai
    584  10000 ????
    585  10000 ????		00 00	    raven_ai_hi =	# > .raven_ai
    586  10000 ????
    587  10000 ????		00 00	    raven_ai_lo =	# < .raven_ai
    588  10000 ????
    589  10000 ????		00 00	    mslime_ai_hi =	# > .slime_ai
    590  10000 ????
    591  10000 ????		00 00	    mslime_ai_lo =	# < .slime_ai
    592  10000 ????
    593  10000 ????		00 00	    slime_ai_hi =	# > .slime_ai
    594  10000 ????
    595  10000 ????		00 00	    slime_ai_lo =	# < .slime_ai
    596  10000 ????
    597  10000 ????		00 00	    octopus_ai_hi =	# > .octopus_ai
    598  10000 ????
    599  10000 ????		00 00	    octopus_ai_lo =	# < .octopus_ai
    600  10000 ????
    601  10000 ????		00 00	    nix_ai_hi  =	# > .nix_ai
    602  10000 ????
    603  10000 ????		00 00	    nix_ai_lo  =	# < .nix_ai
    604  10000 ????
    605  10000 ????		00 00	    warg_ai_hi =	# > .warg_ai
    606  10000 ????
    607  10000 ????		00 00	    warg_ai_lo =	# < .warg_ai
    608  10000 ????
    609  10000 ????		00 00	    wolf_ai_hi =	# > .wolf_ai
    610  10000 ????
    611  10000 ????		00 00	    wolf_ai_lo =	# < .wolf_ai
    612  10000 ????
    613  10000 ????		00 00	    torch_ai_hi =	# > .torch_tile_block
    614  10000 ????
    615  10000 ????		00 00	    torch_ai_lo =	# < .torch_tile_block
    616  10000 ????
    617  10000 ????		00 04	    FIREBALL_MAX_FRAMES =	4
    618  10000 ????
    619  10000 ????		00 08	    FIREBALL_MP_COST =	8
    620  10000 ????
    621  10000 ????		00 02	    FIREBALL_DAMAGE =	2
    622  10000 ????
    623  10000 ????		00 00	    FIREBALL_SPEED_LO =	0
    624  10000 ????
    625  10000 ????		00 02	    FIREBALL_SPEED_HI =	2
    626  10000 ????
    627  10000 ????		00 36	    FAIRY_CHASE_Y =	54
    628  10000 ????
    629  10000 ????		00 28	    FAIRY_CHASE_X =	40
    630  10000 ????
    631  10000 ????		00 03	    F_FAIRY_ITEM2 =	3
    632  10000 ????
    633  10000 ????		00 02	    F_FAIRY_ITEM1 =	2
    634  10000 ????
    635  10000 ????		00 01	    F_FAIRY_WING2 =	1
    636  10000 ????
    637  10000 ????		00 00	    F_FAIRY_WING1 =	0
    638  10000 ????
    639  10000 ????		00 ff	    FAIRY_MDEF =	255
    640  10000 ????
    641  10000 ????		00 ff	    FAIRY_DEF  =	255
    642  10000 ????
    643  10000 ????		00 00	    FAIRY_DAMAGE =	0
    644  10000 ????
    645  10000 ????		00 80	    FAIRY_FRICTION_LO =	128
    646  10000 ????
    647  10000 ????		00 00	    FAIRY_FRICTION_HI =	0
    648  10000 ????
    649  10000 ????		00 80	    FAIRY_VEL_CAP_LO =	128
    650  10000 ????
    651  10000 ????		00 01	    FAIRY_VEL_CAP_HI =	1
    652  10000 ????
    653  10000 ????		00 ff	    FAIRY_HP   =	255
    654  10000 ????
    655  10000 ????		00 00	    FAIRY_SPEED_LO =	0
    656  10000 ????
    657  10000 ????		00 01	    FAIRY_SPEED_HI =	1
    658  10000 ????
    659  10000 ????		00 06	    OCTOINK_DAMAGE =	6
    660  10000 ????
    661  10000 ????		00 00	    OCTOINK_SPEED_LO =	0
    662  10000 ????
    663  10000 ????		00 02	    OCTOINK_SPEED_HI =	2
    664  10000 ????
    665  10000 ????		00 05	    F_OCTO_SHOOT_R =	5
    666  10000 ????
    667  10000 ????		00 06	    F_OCTO_SHOOT_L =	6
    668  10000 ????
    669  10000 ????		00 04	    F_OCTO_SHOOT_U =	4
    670  10000 ????
    671  10000 ????		00 03	    F_OCTO_SHOOT_D =	3
    672  10000 ????
    673  10000 ????		00 02	    F_OCTO_POP_2 =	2
    674  10000 ????
    675  10000 ????		00 01	    F_OCTO_POP =	1
    676  10000 ????
    677  10000 ????		00 00	    F_OCTO_SHADOW =	0
    678  10000 ????
    679  10000 ????		00 04	    OCTO_SHADOW_PAL =	4
    680  10000 ????
    681  10000 ????		00 02	    OCTO_PAL   =	2
    682  10000 ????
    683  10000 ????		00 1e	    OCTOPUS_SHOOT_FRAMES =	30
    684  10000 ????
    685  10000 ????		00 14	    OCTOPUS_SWIM_TIMER =	20
    686  10000 ????
    687  10000 ????		00 3c	    OCTOPUS_POP_TIMER =	60
    688  10000 ????
    689  10000 ????		00 04	    OCTOPUS_HP =	4
    690  10000 ????
    691  10000 ????		00 14	    NIX_TAIL_TIME =	20
    692  10000 ????
    693  10000 ????		00 14	    NIX_ATK2_TIME =	20
    694  10000 ????
    695  10000 ????		00 14	    NIX_ATK_TIME =	20
    696  10000 ????
    697  10000 ????		00 25	    NIX_OFFSET_Y =	NIX_RANGE_Y / 2
    698  10000 ????
    699  10000 ????		00 1a	    NIX_OFFSET_X =	NIX_RANGE_X / 2
    700  10000 ????
    701  10000 ????		00 4a	    NIX_RANGE_Y =	74
    702  10000 ????
    703  10000 ????		00 35	    NIX_RANGE_X =	53
    704  10000 ????
    705  10000 ????		00 28	    NIX_HEIGHT =	40
    706  10000 ????
    707  10000 ????		00 1c	    NIX_WIDTH  =	28
    708  10000 ????
    709  10000 ????		00 05	    F_NIX_BLANK =	5
    710  10000 ????
    711  10000 ????		00 04	    F_NIX_SHADOW =	4
    712  10000 ????
    713  10000 ????		00 03	    F_NIX_TAIL2 =	3
    714  10000 ????
    715  10000 ????		00 02	    F_NIX_TAIL =	2
    716  10000 ????
    717  10000 ????		00 01	    F_NIX_ATTACK =	1
    718  10000 ????
    719  10000 ????		00 00	    F_NIX_EMERGE =	0
    720  10000 ????
    721  10000 ????		00 05	    RSLIME_SPEED_LO =	5
    722  10000 ????
    723  10000 ????		00 00	    RSLIME_SPEED_HI =	0
    724  10000 ????
    725  10000 ????		00 00	    RSLIME_FRICTION_LO =	0
    726  10000 ????
    727  10000 ????		00 01	    RSLIME_FRICTION_HI =	1
    728  10000 ????
    729  10000 ????		00 00	    MRSLIME_MDEF =	0
    730  10000 ????
    731  10000 ????		00 00	    MRSLIME_DEF =	0
    732  10000 ????
    733  10000 ????		00 00	    RSLIME_MDEF =	0
    734  10000 ????
    735  10000 ????		00 ff	    RSLIME_DEF =	255
    736  10000 ????
    737  10000 ????		00 02	    RSLIME_DAMAGE =	2
    738  10000 ????
    739  10000 ????		00 00	    RSLIME_VEL_CAP_LO =	0
    740  10000 ????
    741  10000 ????		00 01	    RSLIME_VEL_CAP_HI =	1
    742  10000 ????
    743  10000 ????		00 02	    MRSLIME_HP =	RSLIME_HP / 2
    744  10000 ????
    745  10000 ????		00 04	    RSLIME_HP  =	4
    746  10000 ????
    747  10000 ????		00 80	    RSLIME_DROP_RATE =	128
    748  10000 ????
    749  10000 ????		00 04	    RETRACT_FRAMES =	4
    750  10000 ????
    751  10000 ????		00 03	    SKELSWORD_DAMAGE =	3
    752  10000 ????
    753  10000 ????		00 06	    DARKSPARK_DAMAGE =	6
    754  10000 ????
    755  10000 ????		00 00	    DARKSPARK_SPEED_LO =	0
    756  10000 ????
    757  10000 ????		00 02	    DARKSPARK_SPEED_HI =	2
    758  10000 ????
    759  10000 ????		00 14	    PRIEST_CAST_FRAMES =	20
    760  10000 ????
    761  10000 ????		00 14	    PRIEST_WALK_TIMER =	20
    762  10000 ????
    763  10000 ????		00 00	    RAVEN_MDEF =	0
    764  10000 ????
    765  10000 ????		00 00	    RAVEN_DEF  =	0
    766  10000 ????
    767  10000 ????		00 00	    RAVEN_SPEED_LO =	0
    768  10000 ????
    769  10000 ????		00 01	    RAVEN_SPEED_HI =	1
    770  10000 ????
    771  10000 ????		00 00	    RAVEN_FRICTION_LO =	0
    772  10000 ????
    773  10000 ????		00 00	    RAVEN_FRICTION_HI =	0
    774  10000 ????
    775  10000 ????		00 04	    RAVEN_DAMAGE =	4
    776  10000 ????
    777  10000 ????		00 00	    RAVEN_VEL_CAP_LO =	0
    778  10000 ????
    779  10000 ????		00 02	    RAVEN_VEL_CAP_HI =	2
    780  10000 ????
    781  10000 ????		00 04	    RAVEN_HP   =	4
    782  10000 ????
    783  10000 ????		00 80	    RAVEN_DROP_RATE =	128
    784  10000 ????
    785  10000 ????		00 0a	    RAVEN_FLIGHT_TIME =	10
    786  10000 ????
    787  10000 ????		00 32	    RAVEN_CHASE_DIST =	50
    788  10000 ????
    789  10000 ????		00 05	    SLIME_SPEED_LO =	5
    790  10000 ????
    791  10000 ????		00 00	    SLIME_SPEED_HI =	0
    792  10000 ????
    793  10000 ????		00 00	    SLIME_FRICTION_LO =	0
    794  10000 ????
    795  10000 ????		00 01	    SLIME_FRICTION_HI =	1
    796  10000 ????
    797  10000 ????		00 00	    MSLIME_MDEF =	0
    798  10000 ????
    799  10000 ????		00 00	    MSLIME_DEF =	0
    800  10000 ????
    801  10000 ????		00 00	    SLIME_MDEF =	0
    802  10000 ????
    803  10000 ????		00 ff	    SLIME_DEF  =	255
    804  10000 ????
    805  10000 ????		00 04	    SLIME_DAMAGE =	4
    806  10000 ????
    807  10000 ????		00 00	    SLIME_VEL_CAP_LO =	0
    808  10000 ????
    809  10000 ????		00 01	    SLIME_VEL_CAP_HI =	1
    810  10000 ????
    811  10000 ????		00 02	    MSLIME_HP  =	SLIME_HP / 2
    812  10000 ????
    813  10000 ????		00 04	    SLIME_HP   =	4
    814  10000 ????
    815  10000 ????		00 80	    SLIME_DROP_RATE =	128
    816  10000 ????
    817  10000 ????		00 20	    WOLF_CHASE_OFFSET_Y =	WOLF_CHASE_DIST_Y / 2
    818  10000 ????
    819  10000 ????		00 18	    WOLF_CHASE_OFFSET_X =	WOLF_CHASE_DIST_X / 2
    820  10000 ????
    821  10000 ????		00 40	    WOLF_CHASE_DIST_Y =	64
    822  10000 ????
    823  10000 ????		00 30	    WOLF_CHASE_DIST_X =	48
    824  10000 ????
    825  10000 ????		00 20	    WOLF_CHASE_DIST =	32
    826  10000 ????
    827  10000 ????		00 40	    WOLF_DROP_RATE =	64
    828  10000 ????
    829  10000 ????		00 02	    WOLF_MDEF  =	2
    830  10000 ????
    831  10000 ????		00 00	    WOLF_DEF   =	0
    832  10000 ????
    833  10000 ????		00 01	    WOLF_DAMAGE =	1
    834  10000 ????
    835  10000 ????		00 00	    WOLF_FRICTION_LO =	0
    836  10000 ????
    837  10000 ????		00 01	    WOLF_FRICTION_HI =	1
    838  10000 ????
    839  10000 ????		00 00	    WOLF_VEL_CAP_LO =	0
    840  10000 ????
    841  10000 ????		00 01	    WOLF_VEL_CAP_HI =	1
    842  10000 ????
    843  10000 ????		00 02	    WOLF_HP    =	2
    844  10000 ????
    845  10000 ????		00 00	    WOLF_SPEED_LO =	0
    846  10000 ????
    847  10000 ????		00 01	    WOLF_SPEED_HI =	1
    848  10000 ????
    849  10000 ????		00 c0	    COMMON_DROP_RATE =	192
    850  10000 ????
    851  10000 ????		00 fe	    RARE_DROP_RATE =	254
    852  10000 ????
    853  10000 ????		00 f9	    TYPE_CHARM10 =	249
    854  10000 ????
    855  10000 ????		00 f8	    TYPE_CHARM9 =	248
    856  10000 ????
    857  10000 ????		00 f7	    TYPE_CHARM8 =	247
    858  10000 ????
    859  10000 ????		00 f6	    TYPE_CHARM7 =	246
    860  10000 ????
    861  10000 ????		00 f5	    TYPE_CHARM6 =	245
    862  10000 ????
    863  10000 ????		00 f4	    TYPE_CHARM5 =	244
    864  10000 ????
    865  10000 ????		00 f3	    TYPE_CHARM4 =	243
    866  10000 ????
    867  10000 ????		00 f2	    TYPE_CHARM3 =	242
    868  10000 ????
    869  10000 ????		00 f1	    TYPE_CHARM2 =	241
    870  10000 ????
    871  10000 ????		00 f0	    TYPE_CHARM1 =	240
    872  10000 ????
    873  10000 ????		00 ef	    TYPE_ARMOR10 =	239
    874  10000 ????
    875  10000 ????		00 ee	    TYPE_ARMOR9 =	238
    876  10000 ????
    877  10000 ????		00 ed	    TYPE_ARMOR8 =	237
    878  10000 ????
    879  10000 ????		00 ec	    TYPE_ARMOR7 =	236
    880  10000 ????
    881  10000 ????		00 eb	    TYPE_ARMOR6 =	235
    882  10000 ????
    883  10000 ????		00 ea	    TYPE_ARMOR5 =	234
    884  10000 ????
    885  10000 ????		00 e9	    TYPE_ARMOR4 =	233
    886  10000 ????
    887  10000 ????		00 e8	    TYPE_ARMOR3 =	232
    888  10000 ????
    889  10000 ????		00 e7	    TYPE_ARMOR2 =	231
    890  10000 ????
    891  10000 ????		00 e6	    TYPE_ARMOR1 =	230
    892  10000 ????
    893  10000 ????		00 e5	    TYPE_SHIELD10 =	229
    894  10000 ????
    895  10000 ????		00 e4	    TYPE_SHIELD9 =	228
    896  10000 ????
    897  10000 ????		00 e3	    TYPE_SHIELD8 =	227
    898  10000 ????
    899  10000 ????		00 e2	    TYPE_SHIELD7 =	226
    900  10000 ????
    901  10000 ????		00 e1	    TYPE_SHIELD6 =	225
    902  10000 ????
    903  10000 ????		00 e0	    TYPE_SHIELD5 =	224
    904  10000 ????
    905  10000 ????		00 df	    TYPE_SHIELD4 =	223
    906  10000 ????
    907  10000 ????		00 de	    TYPE_SHIELD3 =	222
    908  10000 ????
    909  10000 ????		00 dd	    TYPE_SHIELD2 =	221
    910  10000 ????
    911  10000 ????		00 dc	    TYPE_SHIELD1 =	220
    912  10000 ????
    913  10000 ????		00 d3	    TYPE_BONE_SCIM =	TYPE_SWORD2
    914  10000 ????
    915  10000 ????		00 d2	    TYPE_RAPIER =	TYPE_SWORD1
    916  10000 ????
    917  10000 ????		00 db	    TYPE_SWORD10 =	219
    918  10000 ????
    919  10000 ????		00 da	    TYPE_SWORD9 =	218
    920  10000 ????
    921  10000 ????		00 d9	    TYPE_SWORD8 =	217
    922  10000 ????
    923  10000 ????		00 d8	    TYPE_SWORD7 =	216
    924  10000 ????
    925  10000 ????		00 d7	    TYPE_SWORD6 =	215
    926  10000 ????
    927  10000 ????		00 d6	    TYPE_SWORD5 =	214
    928  10000 ????
    929  10000 ????		00 d5	    TYPE_SWORD4 =	213
    930  10000 ????
    931  10000 ????		00 d4	    TYPE_SWORD3 =	212
    932  10000 ????
    933  10000 ????		00 d3	    TYPE_SWORD2 =	211
    934  10000 ????
    935  10000 ????		00 d2	    TYPE_SWORD1 =	210
    936  10000 ????
    937  10000 ????		00 ce	    TYPE_WATERFALL =	TYPE_RELIC7
    938  10000 ????
    939  10000 ????		00 cd	    TYPE_NIXTAIL =	TYPE_RELIC6
    940  10000 ????
    941  10000 ????		00 cc	    TYPE_BESTIARY =	TYPE_RELIC5
    942  10000 ????
    943  10000 ????		00 cb	    TYPE_OWLCARD =	TYPE_RELIC4
    944  10000 ????
    945  10000 ????		00 ca	    TYPE_GHOSTCARD =	TYPE_RELIC3
    946  10000 ????
    947  10000 ????		00 c9	    TYPE_CATCARD =	TYPE_RELIC2
    948  10000 ????
    949  10000 ????		00 c8	    TYPE_FAIRYCARD =	TYPE_RELIC1
    950  10000 ????
    951  10000 ????		00 d1	    TYPE_RELIC10 =	209
    952  10000 ????
    953  10000 ????		00 d0	    TYPE_RELIC9 =	208
    954  10000 ????
    955  10000 ????		00 cf	    TYPE_RELIC8 =	207
    956  10000 ????
    957  10000 ????		00 ce	    TYPE_RELIC7 =	206
    958  10000 ????
    959  10000 ????		00 cd	    TYPE_RELIC6 =	205
    960  10000 ????
    961  10000 ????		00 cc	    TYPE_RELIC5 =	204
    962  10000 ????
    963  10000 ????		00 cb	    TYPE_RELIC4 =	203
    964  10000 ????
    965  10000 ????		00 ca	    TYPE_RELIC3 =	202
    966  10000 ????
    967  10000 ????		00 c9	    TYPE_RELIC2 =	201
    968  10000 ????
    969  10000 ????		00 c8	    TYPE_RELIC1 =	200
    970  10000 ????
    971  10000 ????		00 c7	    TYPE_LIFEAPPLE =	TYPE_ITEM10
    972  10000 ????
    973  10000 ????		00 c6	    TYPE_SOFT  =	TYPE_ITEM9
    974  10000 ????
    975  10000 ????		00 c5	    TYPE_UNCURSE =	TYPE_ITEM8
    976  10000 ????
    977  10000 ????		00 c4	    TYPE_EYEDROP =	TYPE_ITEM7
    978  10000 ????
    979  10000 ????		00 c3	    TYPE_ANTIDOTE =	TYPE_ITEM6
    980  10000 ????
    981  10000 ????		00 c2	    TYPE_ELIXIR =	TYPE_ITEM5
    982  10000 ????
    983  10000 ????		00 c1	    TYPE_HIETHER =	TYPE_ITEM4
    984  10000 ????
    985  10000 ????		00 c0	    TYPE_ETHER =	TYPE_ITEM3
    986  10000 ????
    987  10000 ????		00 bf	    TYPE_HIPOTION =	TYPE_ITEM2
    988  10000 ????
    989  10000 ????		00 be	    TYPE_POTION =	TYPE_ITEM1
    990  10000 ????
    991  10000 ????		00 c7	    TYPE_ITEM10 =	199
    992  10000 ????
    993  10000 ????		00 c6	    TYPE_ITEM9 =	198
    994  10000 ????
    995  10000 ????		00 c5	    TYPE_ITEM8 =	197
    996  10000 ????
    997  10000 ????		00 c4	    TYPE_ITEM7 =	196
    998  10000 ????
    999  10000 ????		00 c3	    TYPE_ITEM6 =	195
   1000  10000 ????
   1001  10000 ????		00 c2	    TYPE_ITEM5 =	194
   1002  10000 ????
   1003  10000 ????		00 c1	    TYPE_ITEM4 =	193
   1004  10000 ????
   1005  10000 ????		00 c0	    TYPE_ITEM3 =	192
   1006  10000 ????
   1007  10000 ????		00 bf	    TYPE_ITEM2 =	191
   1008  10000 ????
   1009  10000 ????		00 be	    TYPE_ITEM1 =	190
   1010  10000 ????
   1011  10000 ????		00 bd	    TYPE_SPELL10 =	189
   1012  10000 ????
   1013  10000 ????		00 bc	    TYPE_SPELL9 =	188
   1014  10000 ????
   1015  10000 ????		00 bb	    TYPE_SPELL8 =	187
   1016  10000 ????
   1017  10000 ????		00 ba	    TYPE_SPELL7 =	186
   1018  10000 ????
   1019  10000 ????		00 b9	    TYPE_SPELL6 =	185
   1020  10000 ????
   1021  10000 ????		00 b8	    TYPE_SPELL5 =	184
   1022  10000 ????
   1023  10000 ????		00 b7	    TYPE_SPELL4 =	183
   1024  10000 ????
   1025  10000 ????		00 b6	    TYPE_SPELL3 =	182
   1026  10000 ????
   1027  10000 ????		00 b5	    TYPE_SPELL2 =	181
   1028  10000 ????
   1029  10000 ????		00 b4	    TYPE_SPELL1 =	180
   1030  10000 ????
   1031  10000 ????		00 b3	    TYPE_KEY5  =	179
   1032  10000 ????
   1033  10000 ????		00 b2	    TYPE_KEY4  =	178
   1034  10000 ????
   1035  10000 ????		00 b1	    TYPE_KEY3  =	177
   1036  10000 ????
   1037  10000 ????		00 b0	    TYPE_KEY2  =	176
   1038  10000 ????
   1039  10000 ????		00 af	    TYPE_KEY1  =	175
   1040  10000 ????
   1041  10000 ????		00 ae	    TYPE_MAP5  =	174
   1042  10000 ????
   1043  10000 ????		00 ad	    TYPE_MAP4  =	173
   1044  10000 ????
   1045  10000 ????		00 ac	    TYPE_MAP3  =	172
   1046  10000 ????
   1047  10000 ????		00 ab	    TYPE_MAP2  =	171
   1048  10000 ????
   1049  10000 ????		00 aa	    TYPE_MAP1  =	170
   1050  10000 ????
   1051  10000 ????		00 a6	    TYPE_FOOD  =	166
   1052  10000 ????
   1053  10000 ????		00 a5	    TYPE_PRISM =	165
   1054  10000 ????
   1055  10000 ????		00 a4	    TYPE_COIN  =	164
   1056  10000 ????
   1057  10000 ????		00 a3	    TYPE_DOOR_LOCK =	163
   1058  10000 ????
   1059  10000 ????		00 a2	    TYPE_DOOR  =	162
   1060  10000 ????
   1061  10000 ????		00 a1	    TYPE_DOOR_OPEN =	161
   1062  10000 ????
   1063  10000 ????		00 a0	    TYPE_BLOOD =	160
   1064  10000 ????
   1065  10000 ????		00 a0	    TYPE_STATIC =	TYPE_BLOOD
   1066  10000 ????
   1067  10000 ????		00 97	    TYPE_F_FAIRY =	151
   1068  10000 ????
   1069  10000 ????		00 96	    TYPE_FIREBALL =	150
   1070  10000 ????
   1071  10000 ????		00 8d	    TYPE_OCTOINK =	141
   1072  10000 ????
   1073  10000 ????		00 8c	    TYPE_DARKSPARK =	140
   1074  10000 ????
   1075  10000 ????		00 81	    TYPE_PROJECTILE =	TYPE_SKELSWORD
   1076  10000 ????
   1077  10000 ????		00 81	    TYPE_SKELSWORD =	129
   1078  10000 ????
   1079  10000 ????		00 80	    TYPE_SPAWNER =	128
   1080  10000 ????
   1081  10000 ????		00 0e	    TYPE_RGHOST =	14
   1082  10000 ????
   1083  10000 ????		00 0d	    TYPE_GHOST =	13
   1084  10000 ????
   1085  10000 ????		00 0c	    TYPE_MRSLIME =	12
   1086  10000 ????
   1087  10000 ????		00 0b	    TYPE_RSLIME =	11
   1088  10000 ????
   1089  10000 ????		00 0a	    TYPE_SKELETON =	10
   1090  10000 ????
   1091  10000 ????		00 09	    TYPE_PRIEST =	9
   1092  10000 ????
   1093  10000 ????		00 08	    TYPE_RAVEN =	8
   1094  10000 ????
   1095  10000 ????		00 07	    TYPE_MSLIME =	7
   1096  10000 ????
   1097  10000 ????		00 06	    TYPE_SLIME =	6
   1098  10000 ????
   1099  10000 ????		00 05	    TYPE_OCTOPUS =	5
   1100  10000 ????
   1101  10000 ????		00 04	    TYPE_MERMAN =	TYPE_NIX
   1102  10000 ????
   1103  10000 ????		00 04	    TYPE_NIX   =	4
   1104  10000 ????
   1105  10000 ????		00 03	    TYPE_WARG  =	3
   1106  10000 ????
   1107  10000 ????		00 02	    TYPE_WOLF  =	2
   1108  10000 ????
   1109  10000 ????		00 01	    TYPE_TORCH =	1
   1110  10000 ????
   1111  10000 ????		00 01	    collisionwrap =	1
------- FILE 7800basic.h
      6  10000 ????
      7  10000 ????						;************ 7800 overall RAM map **************
      8  10000 ????
      9  10000 ????						;	   40-FF	 zero page RAM
     10  10000 ????						;	  140-1FF	 RAM (stack)
     11  10000 ????						;	 1800-203F	 RAM
     12  10000 ????						;	 2100-213F	 RAM
     13  10000 ????						;	 2200-27FF	 RAM
     14  10000 ????
     15  10000 ????						;************ 7800basic RAM usage map **************
     16  10000 ????
     17  10000 ????						;	   40-FF	 numerous defines, listed below
     18  10000 ????						;	  140-1FF	 RAM (stack)
     19  10000 ????
     20  10000 ????						;	 1800-187F	 DLL  (1800-18DF with page flipping enabled)
     21  10000 ????						;	 1880-1FFF	 DLs  (18E0-1FFF with page flipping enabled)
     22  10000 ????
     23  10000 ????						;	 2000-203F	 Reserved
     24  10000 ????						;	 2100-213F	 Reserved
     25  10000 ????						;	 2200-27FF	 Free
     26  10000 ????
     27  10000 ????		1f e0	    eeprombuffer =	$1FE0
     28  10000 ????		18 00	    DLLMEM     =	$1800
     29  10000 ????		00 70	    DBOFFSET   =	$70	; $E0 length DL is /2 for double-buffering
     30  10000 ????
     31  10000 ????			   -	       ifconst	PLOTVALUEPAGE
     32  10000 ????			   -VALBUFFER  =	(PLOTVALUEPAGE*256)
     33  10000 ????				       else
     34  10000 ????		20 00	    VALBUFFER  =	$2000	; to $203F  ** never let VALBUFFER straddle pages
     35  10000 ????				       endif
     36  10000 ????
     37  10000 ????
     38  10000 ????		21 00	    pausestate =	$2100
     39  10000 ????		21 01	    dlzero     =	$2101	; zero to force end of $2100 DL, which we use in vblank and overscan
     40  10000 ????		21 02	    sINPT1     =	$2102	; save register for joy button joy0
     41  10000 ????		21 03	    sINPT3     =	$2103	; save register for joy button joy1
     42  10000 ????		21 04	    currentbank =	$2104
     43  10000 ????
     44  10000 ????		21 05	    currentrambank =	$2105
     45  10000 ????		21 06	    charactermode =	$2106
     46  10000 ????		21 07	    sCTRL      =	$2107
     47  10000 ????		21 08	    pokeydetected =	$2108
     48  10000 ????		21 09	    paldetected =	$2109
     49  10000 ????		21 0a	    avoxdetected =	$210A
     50  10000 ????		21 0b	    sCHARBASE  =	$210B	; save register for CHARBASE
     51  10000 ????
     52  10000 ????		21 0c	    hsdevice   =	$210C
     53  10000 ????		21 0d	    hsdifficulty =	$210D
     54  10000 ????		21 0e	    hserror    =	$210E
     55  10000 ????		21 0f	    hsgameslot =	$210F
     56  10000 ????		21 10	    hsnewscoreline =	$2110
     57  10000 ????		21 11	    hsnewscorerank =	$2111
     58  10000 ????		21 12	    HSRAMTable =	$2112	; to $212F (30 bytes) Format: III*5, SSS*5
     59  10000 ????		21 12	    HSRAMInitials =	$2112	; see above
     60  10000 ????		21 21	    HSRAMScores =	$2121	; see above
     61  10000 ????
     62  10000 ????		21 31	    sSWCHA     =	$2131
     63  10000 ????						; reserved	 = $2132
     64  10000 ????
     65  10000 ????		21 33	    hsdisplaymode =	$2133
     66  10000 ????		21 34	    gamedifficulty =	$2134
     67  10000 ????		21 35	    hsinitialpos =	$2135
     68  10000 ????		21 36	    hsinitialhold =	$2136
     69  10000 ????		21 37	    hscursorx  =	$2137
     70  10000 ????		21 38	    hsjoydebounce =	$2138
     71  10000 ????		21 39	    hsswcha    =	$2139
     72  10000 ????		21 3a	    hsinpt1    =	$213A
     73  10000 ????		21 3b	    hscolorchaseindex =	$213B
     74  10000 ????		21 3c	    visibleDLLstart =	$213C
     75  10000 ????		21 3d	    overscanDLLstart =	$213D
     76  10000 ????		21 3e	    frameslost =	$213E
     77  10000 ????		21 3f	    hsreturn   =	$213F
     78  10000 ????
     79  10000 ????
     80  10000 ????		00 40	    rand       =	$40
     81  10000 ????		00 41	    rand16     =	$41
     82  10000 ????		00 42	    temp1      =	$42
     83  10000 ????		00 43	    temp2      =	$43
     84  10000 ????		00 44	    temp3      =	$44
     85  10000 ????		00 45	    temp4      =	$45
     86  10000 ????		00 46	    temp5      =	$46
     87  10000 ????		00 47	    temp6      =	$47
     88  10000 ????		00 48	    temp7      =	$48
     89  10000 ????		00 49	    temp8      =	$49
     90  10000 ????		00 4a	    temp9      =	$4a
     91  10000 ????
     92  10000 ????		00 4b	    pokeybase  =	$4b
     93  10000 ????		00 4b	    pokeybaselo =	$4b
     94  10000 ????		00 4c	    pokeybasehi =	$4c
     95  10000 ????
     96  10000 ????		00 4d	    visibleover =	$4d
     97  10000 ????
     98  10000 ????		00 4e	    sfx1pointlo =	$4e
     99  10000 ????		00 4f	    sfx2pointlo =	$4f
    100  10000 ????		00 50	    sfx1pointhi =	$50
    101  10000 ????		00 51	    sfx2pointhi =	$51
    102  10000 ????
    103  10000 ????		00 52	    sfx1priority =	$52
    104  10000 ????		00 53	    sfx2priority =	$53
    105  10000 ????		00 54	    sfx1poffset =	$54
    106  10000 ????		00 55	    sfx2poffset =	$55
    107  10000 ????
    108  10000 ????		00 56	    sfx1frames =	$56
    109  10000 ????		00 57	    sfx2frames =	$57
    110  10000 ????		00 58	    sfx1tick   =	$58
    111  10000 ????		00 59	    sfx2tick   =	$59
    112  10000 ????
    113  10000 ????		00 5a	    tempmath   =	$5a
    114  10000 ????
    115  10000 ????		00 5b	    pokey1pointlo =	$5b
    116  10000 ????		00 5c	    pokey1pointhi =	$5c
    117  10000 ????		00 5d	    pokey2pointlo =	$5d
    118  10000 ????		00 5e	    pokey2pointhi =	$5e
    119  10000 ????		00 5f	    pokey3pointlo =	$5f
    120  10000 ????		00 60	    pokey3pointhi =	$60
    121  10000 ????		00 61	    pokey4pointlo =	$61
    122  10000 ????		00 62	    pokey4pointhi =	$62
    123  10000 ????
    124  10000 ????		00 63	    dlpnt      =	$63	; to $64
    125  10000 ????		00 65	    dlend      =	$65	; to $81 - for 29 possible visible dll entries
    126  10000 ????		00 82	    dlendsave  =	$82	; to $9e - for 29 possible visible dll entries
    127  10000 ????
    128  10000 ????		00 9f	    speech_addr =	$9f
    129  10000 ????		00 a0	    speech_addr_hi =	$a0
    130  10000 ????
    131  10000 ????		00 a1	    HSGameTableLo =	$a1
    132  10000 ????		00 a2	    HSGameTableHi =	$a2
    133  10000 ????		00 a3	    HSVoxHi    =	$a3
    134  10000 ????		00 a4	    HSVoxLo    =	$a4
    135  10000 ????
    136  10000 ????						;channel pointers
    137  10000 ????
    138  10000 ????		00 a5	    songchannel1layer1lo =	$a5
    139  10000 ????		00 a6	    songchannel2layer1lo =	$a6
    140  10000 ????		00 a7	    songchannel3layer1lo =	$a7
    141  10000 ????		00 a8	    songchannel4layer1lo =	$a8
    142  10000 ????
    143  10000 ????		00 a9	    songchannel1layer2lo =	$a9
    144  10000 ????		00 aa	    songchannel2layer2lo =	$aA
    145  10000 ????		00 ab	    songchannel3layer2lo =	$aB
    146  10000 ????		00 ac	    songchannel4layer2lo =	$aC
    147  10000 ????
    148  10000 ????		00 ad	    songchannel1layer3lo =	$aD
    149  10000 ????		00 ae	    songchannel2layer3lo =	$aE
    150  10000 ????		00 af	    songchannel3layer3lo =	$aF
    151  10000 ????		00 b0	    songchannel4layer3lo =	$b0
    152  10000 ????
    153  10000 ????		00 b1	    songchannel1layer1hi =	$b1
    154  10000 ????		00 b2	    songchannel2layer1hi =	$b2
    155  10000 ????		00 b3	    songchannel3layer1hi =	$b3
    156  10000 ????		00 b4	    songchannel4layer1hi =	$b4
    157  10000 ????
    158  10000 ????		00 b5	    songchannel1layer2hi =	$b5
    159  10000 ????		00 b6	    songchannel2layer2hi =	$b6
    160  10000 ????		00 b7	    songchannel3layer2hi =	$b7
    161  10000 ????		00 b8	    songchannel4layer2hi =	$b8
    162  10000 ????
    163  10000 ????		00 b9	    songchannel1layer3hi =	$b9
    164  10000 ????		00 ba	    songchannel2layer3hi =	$bA
    165  10000 ????		00 bb	    songchannel3layer3hi =	$bB
    166  10000 ????		00 bc	    songchannel4layer3hi =	$bC
    167  10000 ????
    168  10000 ????		00 bd	    songdatalo =	$bd
    169  10000 ????		00 be	    songdatahi =	$be
    170  10000 ????
    171  10000 ????		00 bf	    inactivechannelcount =	$bf
    172  10000 ????
    173  10000 ????		00 c0	    songchannel1transpose =	$c0
    174  10000 ????		00 c1	    songchannel2transpose =	$c1
    175  10000 ????		00 c2	    songchannel3transpose =	$c2
    176  10000 ????		00 c3	    songchannel4transpose =	$c3
    177  10000 ????
    178  10000 ????		00 c4	    songstackindex =	$c4
    179  10000 ????
    180  10000 ????		00 c5	    songchannel1instrumentlo =	$c5
    181  10000 ????		00 c6	    songchannel2instrumentlo =	$c6
    182  10000 ????		00 c7	    songchannel3instrumentlo =	$c7
    183  10000 ????		00 c8	    songchannel4instrumentlo =	$c8
    184  10000 ????
    185  10000 ????		00 c9	    songchannel1instrumenthi =	$c9
    186  10000 ????		00 ca	    songchannel2instrumenthi =	$ca
    187  10000 ????		00 cb	    songchannel3instrumenthi =	$cb
    188  10000 ????		00 cc	    songchannel4instrumenthi =	$cc
    189  10000 ????
    190  10000 ????		00 cd	    sfx1notedata =	$cd
    191  10000 ????		00 ce	    sfx2notedata =	$ce
    192  10000 ????
    193  10000 ????		00 cf	    songloops  =	$cf
    194  10000 ????
    195  10000 ????		00 d0	    songpointerlo =	$D0
    196  10000 ????		00 d1	    songpointerhi =	$D1
    197  10000 ????
    198  10000 ????		00 d2	    voxlock    =	$D2
    199  10000 ????		00 d3	    voxqueuesize =	$D3
    200  10000 ????
    201  10000 ????		00 d4	    vblankroutines =	$D4
    202  10000 ????
    203  10000 ????		00 d5	    doublebufferstate =	$D5
    204  10000 ????		00 d6	    doublebufferdloffset =	$D6
    205  10000 ????		00 d7	    doublebufferbufferdirty =	$D7
    206  10000 ????
    207  10000 ????		00 d8	    inttemp1   =	$D8
    208  10000 ????		00 d9	    inttemp2   =	$D9
    209  10000 ????		00 da	    inttemp3   =	$DA
    210  10000 ????		00 db	    inttemp4   =	$DB
    211  10000 ????		00 dc	    inttemp5   =	$DC
    212  10000 ????		00 dd	    inttemp6   =	$DD
    213  10000 ????
    214  10000 ????		00 de	    sfxschedulelock =	$DE
    215  10000 ????		00 df	    sfxschedulemissed =	$DF
    216  10000 ????		00 e0	    sfxinstrumentlo =	$E0
    217  10000 ????		00 e1	    sfxinstrumenthi =	$E1
    218  10000 ????		00 e2	    sfxpitchoffset =	$E2
    219  10000 ????		00 e3	    sfxnoteindex =	$E3
    220  10000 ????
    221  10000 ????						; reserved = $E4
    222  10000 ????						; reserved = $E5
    223  10000 ????
    224  10000 ????		00 e6	    A	       =	$e6
    225  10000 ????		00 e6	    a	       =	$e6
    226  10000 ????		00 e7	    B	       =	$e7
    227  10000 ????		00 e7	    b	       =	$e7
    228  10000 ????		00 e8	    C	       =	$e8
    229  10000 ????		00 e8	    c	       =	$e8
    230  10000 ????		00 e9	    D	       =	$e9
    231  10000 ????		00 e9	    d	       =	$e9
    232  10000 ????		00 ea	    E	       =	$ea
    233  10000 ????		00 ea	    e	       =	$ea
    234  10000 ????		00 eb	    F	       =	$eb
    235  10000 ????		00 eb	    f	       =	$eb
    236  10000 ????		00 ec	    G	       =	$ec
    237  10000 ????		00 ec	    g	       =	$ec
    238  10000 ????		00 ed	    H	       =	$ed
    239  10000 ????		00 ed	    h	       =	$ed
    240  10000 ????		00 ee	    I	       =	$ee
    241  10000 ????		00 ee	    i	       =	$ee
    242  10000 ????		00 ef	    J	       =	$ef
    243  10000 ????		00 ef	    j	       =	$ef
    244  10000 ????		00 f0	    K	       =	$f0
    245  10000 ????		00 f0	    k	       =	$f0
    246  10000 ????		00 f1	    L	       =	$f1
    247  10000 ????		00 f1	    l	       =	$f1
    248  10000 ????		00 f2	    M	       =	$f2
    249  10000 ????		00 f2	    m	       =	$f2
    250  10000 ????		00 f3	    N	       =	$f3
    251  10000 ????		00 f3	    n	       =	$f3
    252  10000 ????		00 f4	    O	       =	$f4
    253  10000 ????		00 f4	    o	       =	$f4
    254  10000 ????		00 f5	    P	       =	$f5
    255  10000 ????		00 f5	    p	       =	$f5
    256  10000 ????		00 f6	    Q	       =	$f6
    257  10000 ????		00 f6	    q	       =	$f6
    258  10000 ????		00 f7	    R	       =	$f7
    259  10000 ????		00 f7	    r	       =	$f7
    260  10000 ????		00 f8	    S	       =	$f8
    261  10000 ????		00 f8	    s	       =	$f8
    262  10000 ????		00 f9	    T	       =	$f9
    263  10000 ????		00 f9	    t	       =	$f9
    264  10000 ????		00 fa	    U	       =	$fa
    265  10000 ????		00 fa	    u	       =	$fa
    266  10000 ????		00 fb	    V	       =	$fb
    267  10000 ????		00 fb	    v	       =	$fb
    268  10000 ????		00 fc	    W	       =	$fc
    269  10000 ????		00 fc	    w	       =	$fc
    270  10000 ????		00 fd	    X	       =	$fd
    271  10000 ????		00 fd	    x	       =	$fd
    272  10000 ????		00 fe	    Y	       =	$fe
    273  10000 ????		00 fe	    y	       =	$fe
    274  10000 ????		00 ff	    Z	       =	$ff
    275  10000 ????		00 ff	    z	       =	$ff
    276  10000 ????
    277  10000 ????						; var0-var99 variables use the top of the stack
    278  10000 ????		01 40	    var0       =	$140
    279  10000 ????		01 41	    var1       =	$141
    280  10000 ????		01 42	    var2       =	$142
    281  10000 ????		01 43	    var3       =	$143
    282  10000 ????		01 44	    var4       =	$144
    283  10000 ????		01 45	    var5       =	$145
    284  10000 ????		01 46	    var6       =	$146
    285  10000 ????		01 47	    var7       =	$147
    286  10000 ????		01 48	    var8       =	$148
    287  10000 ????		01 49	    var9       =	$149
    288  10000 ????		01 4a	    var10      =	$14a
    289  10000 ????		01 4b	    var11      =	$14b
    290  10000 ????		01 4c	    var12      =	$14c
    291  10000 ????		01 4d	    var13      =	$14d
    292  10000 ????		01 4e	    var14      =	$14e
    293  10000 ????		01 4f	    var15      =	$14f
    294  10000 ????		01 50	    var16      =	$150
    295  10000 ????		01 51	    var17      =	$151
    296  10000 ????		01 52	    var18      =	$152
    297  10000 ????		01 53	    var19      =	$153
    298  10000 ????		01 54	    var20      =	$154
    299  10000 ????		01 55	    var21      =	$155
    300  10000 ????		01 56	    var22      =	$156
    301  10000 ????		01 57	    var23      =	$157
    302  10000 ????		01 58	    var24      =	$158
    303  10000 ????		01 59	    var25      =	$159
    304  10000 ????		01 5a	    var26      =	$15a
    305  10000 ????		01 5b	    var27      =	$15b
    306  10000 ????		01 5c	    var28      =	$15c
    307  10000 ????		01 5d	    var29      =	$15d
    308  10000 ????		01 5e	    var30      =	$15e
    309  10000 ????		01 5f	    var31      =	$15f
    310  10000 ????		01 60	    var32      =	$160
    311  10000 ????		01 61	    var33      =	$161
    312  10000 ????		01 62	    var34      =	$162
    313  10000 ????		01 63	    var35      =	$163
    314  10000 ????		01 64	    var36      =	$164
    315  10000 ????		01 65	    var37      =	$165
    316  10000 ????		01 66	    var38      =	$166
    317  10000 ????		01 67	    var39      =	$167
    318  10000 ????		01 68	    var40      =	$168
    319  10000 ????		01 69	    var41      =	$169
    320  10000 ????		01 6a	    var42      =	$16a
    321  10000 ????		01 6b	    var43      =	$16b
    322  10000 ????		01 6c	    var44      =	$16c
    323  10000 ????		01 6d	    var45      =	$16d
    324  10000 ????		01 6e	    var46      =	$16e
    325  10000 ????		01 6f	    var47      =	$16f
    326  10000 ????		01 70	    var48      =	$170
    327  10000 ????		01 71	    var49      =	$171
    328  10000 ????		01 72	    var50      =	$172
    329  10000 ????		01 73	    var51      =	$173
    330  10000 ????		01 74	    var52      =	$174
    331  10000 ????		01 75	    var53      =	$175
    332  10000 ????		01 76	    var54      =	$176
    333  10000 ????		01 77	    var55      =	$177
    334  10000 ????		01 78	    var56      =	$178
    335  10000 ????		01 79	    var57      =	$179
    336  10000 ????		01 7a	    var58      =	$17a
    337  10000 ????		01 7b	    var59      =	$17b
    338  10000 ????		01 7c	    var60      =	$17c
    339  10000 ????		01 7d	    var61      =	$17d
    340  10000 ????		01 7e	    var62      =	$17e
    341  10000 ????		01 7f	    var63      =	$17f
    342  10000 ????		01 80	    var64      =	$180
    343  10000 ????		01 81	    var65      =	$181
    344  10000 ????		01 82	    var66      =	$182
    345  10000 ????		01 83	    var67      =	$183
    346  10000 ????		01 84	    var68      =	$184
    347  10000 ????		01 85	    var69      =	$185
    348  10000 ????		01 86	    var70      =	$186
    349  10000 ????		01 87	    var71      =	$187
    350  10000 ????		01 88	    var72      =	$188
    351  10000 ????		01 89	    var73      =	$189
    352  10000 ????		01 8a	    var74      =	$18a
    353  10000 ????		01 8b	    var75      =	$18b
    354  10000 ????		01 8c	    var76      =	$18c
    355  10000 ????		01 8d	    var77      =	$18d
    356  10000 ????		01 8e	    var78      =	$18e
    357  10000 ????		01 8f	    var79      =	$18f
    358  10000 ????		01 90	    var80      =	$190
    359  10000 ????		01 91	    var81      =	$191
    360  10000 ????		01 92	    var82      =	$192
    361  10000 ????		01 93	    var83      =	$193
    362  10000 ????		01 94	    var84      =	$194
    363  10000 ????		01 95	    var85      =	$195
    364  10000 ????		01 96	    var86      =	$196
    365  10000 ????		01 97	    var87      =	$197
    366  10000 ????		01 98	    var88      =	$198
    367  10000 ????		01 99	    var89      =	$199
    368  10000 ????		01 9a	    var90      =	$19a
    369  10000 ????		01 9b	    var91      =	$19b
    370  10000 ????		01 9c	    var92      =	$19c
    371  10000 ????		01 9d	    var93      =	$19d
    372  10000 ????		01 9e	    var94      =	$19e
    373  10000 ????		01 9f	    var95      =	$19f
    374  10000 ????		01 a0	    var96      =	$1a0
    375  10000 ????		01 a1	    var97      =	$1a1
    376  10000 ????		01 a2	    var98      =	$1a2
    377  10000 ????		01 a3	    var99      =	$1a3
    378  10000 ????
    379 U01c3 ????				      SEG.U	"7800basicRAM"
    380 U01a4					      ORG	$1A4
    381 U01a4
    382 U01a4							; MAX allocation locations are in comments...
    383 U01a4		       00	   framecounter DS	1	; $1A4
    384 U01a5		       00	   countdownseconds DS	1	; $1A5
    385 U01a6		       00 00 00    score0     DS	3	; $1A6 $1A7 $1A8
    386 U01a9		       00 00 00    score1     DS	3	; $1A9 $1AA $1AB
    387 U01ac		       00	   pausebuttonflag DS	1	; $1AC
    388 U01ad		       00	   valbufend  DS	1	; $1AD
    389 U01ae		       00	   valbufendsave DS	1	; $1AE
    390 U01af		       00	   finescrollx DS	1	; $1AF
    391 U01b0		       00	   finescrolly DS	1	; $1B0
    392 U01b1		       00	   joybuttonmode DS	1	; $1B1 ; track joysticks that were changed to one-button mode
    393 U01b2		       00	   interruptindex DS	1	; $1B2
    394 U01b3
    395 U01b3				  -	      ifconst	DOUBLEBUFFER
    396 U01b3				  -doublebufferminimumframetarget DS	1	; $1B3
    397 U01b3				  -doublebufferminimumframeindex DS	1	; $1B4
    398 U01b3					      endif
    399 U01b3
    400 U01b3		       00	   pausedisable DS	1	; $1B5
    401 U01b4		       00	   XCTRL1s    DS	1	; $1B6
    402 U01b5
    403 U01b5				  -	      ifconst	AVOXVOICE
    404 U01b5				  -avoxenable DS	1	; $1B7
    405 U01b5				  -tempavox   DS	1	; $1B8
    406 U01b5					      endif
    407 U01b5
    408 U01b5				  -	      ifconst	MUSICTRACKER
    409 U01b5				  -songtempo  DS	1	; $1B9
    410 U01b5				  -songtick   DS	1	; $1BA
    411 U01b5				  -
    412 U01b5				  -songchannel1layer1loops DS	1	; $1BB
    413 U01b5				  -songchannel2layer1loops DS	1	; $1BC
    414 U01b5				  -songchannel3layer1loops DS	1	; $1BD
    415 U01b5				  -songchannel4layer1loops DS	1	; $1BE
    416 U01b5				  -
    417 U01b5				  -songchannel1layer2loops DS	1	; $1BF
    418 U01b5				  -songchannel2layer2loops DS	1	; $1C0
    419 U01b5				  -songchannel3layer2loops DS	1	; $1C1
    420 U01b5				  -songchannel4layer2loops DS	1	; $1C2
    421 U01b5				  -
    422 U01b5				  -songchannel1layer3loops DS	1	; $1C3
    423 U01b5				  -songchannel2layer3loops DS	1	; $1C4
    424 U01b5				  -songchannel3layer3loops DS	1	; $1C5
    425 U01b5				  -songchannel4layer3loops DS	1	; $1C6
    426 U01b5				  -
    427 U01b5				  -songchannel1busywait DS	1	; $1C7
    428 U01b5				  -songchannel2busywait DS	1	; $1C8
    429 U01b5				  -songchannel3busywait DS	1	; $1C9
    430 U01b5				  -songchannel4busywait DS	1	; $1CA
    431 U01b5				  -
    432 U01b5				  -songchannel1stackdepth DS	1	; $1CB
    433 U01b5				  -songchannel2stackdepth DS	1	; $1CC
    434 U01b5				  -songchannel3stackdepth DS	1	; $1CD
    435 U01b5				  -songchannel4stackdepth DS	1	; $1CE
    436 U01b5					      endif
    437 U01b5
    438 U01b5		       00	   palframes  DS	1
    439 U01b6		       00	   ntscslowframe DS	1
    440 U01b7		       00	   palfastframe DS	1
    441 U01b8
    442 U01b8				  -	      ifconst	MOUSESUPPORT
    443 U01b8				  -port0resolution DS	1
    444 U01b8				  -port1resolution DS	1
    445 U01b8					      else
    446 U01b8				  -	      ifconst	TRAKBALLSUPPORT
    447 U01b8				  -port0resolution DS	1
    448 U01b8				  -port1resolution DS	1
    449 U01b8					      endif
    450 U01b8					      endif
    451 U01b8
    452 U01b8		       00	   port0control DS	1
    453 U01b9		       00	   port1control DS	1
    454 U01ba
    455 U01ba							; port#control values...
    456 U01ba							;	1 = proline
    457 U01ba							;	2 = lightgun
    458 U01ba							;	3 = paddle
    459 U01ba							;	4 = trakball
    460 U01ba							;	5 = vcs joystick
    461 U01ba							;	6 = driving
    462 U01ba							;	7 = keypad
    463 U01ba							;	8 = st mouse/cx80
    464 U01ba							;	9 = amiga mouse
    465 U01ba							;     10 = atarivox
    466 U01ba
    467 U01ba							; controller 0 data...
    468 U01ba		       00	   paddleposition0 DS	1
    469 U01ba		       01 ba	   keypadmatrix0a =	paddleposition0
    470 U01ba		       01 ba	   drivingposition0 =	paddleposition0
    471 U01ba		       01 ba	   trakballx0 =	paddleposition0
    472 U01ba		       01 ba	   mousex0    =	paddleposition0
    473 U01ba		       01 ba	   lighttgunx0 =	paddleposition0
    474 U01ba		       01 ba	   snes2atari0lo =	paddleposition0
    475 U01ba		       01 ba	   mega7800data0 =	paddleposition0
    476 U01bb
    477 U01bb							; controller 1 data...
    478 U01bb		       00	   paddleposition2 DS	1
    479 U01bb		       01 bb	   keypadmatrix1a =	paddleposition2
    480 U01bb		       01 bb	   drivingposition1 =	paddleposition2
    481 U01bb		       01 bb	   trakballx1 =	paddleposition2
    482 U01bb		       01 bb	   mousex1    =	paddleposition2
    483 U01bb		       01 bb	   lightgunx1 =	paddleposition2
    484 U01bb		       01 bb	   snes2atari1lo =	paddleposition2
    485 U01bb		       01 bb	   mega7800data1 =	paddleposition2
    486 U01bc
    487 U01bc							; controller 0 altdata...
    488 U01bc		       00	   paddleposition1 DS	1
    489 U01bc		       01 bc	   keypadmatrix0b =	paddleposition1
    490 U01bc		       01 bc	   trakbally0 =	paddleposition1
    491 U01bc		       01 bc	   mousey0    =	paddleposition1
    492 U01bc		       01 bc	   lightguny0 =	paddleposition1
    493 U01bc		       01 bc	   snes2atari0hi =	paddleposition1
    494 U01bc		       01 bc	   mega7800state0 =	paddleposition1
    495 U01bd
    496 U01bd							; controller 1 altdata...
    497 U01bd		       00	   paddleposition3 DS	1
    498 U01bd		       01 bd	   keypadmatrix1b =	paddleposition3
    499 U01bd		       01 bd	   trakbally1 =	paddleposition3
    500 U01bd		       01 bd	   mousey1    =	paddleposition3
    501 U01bd		       01 bd	   lightguny1 =	paddleposition3
    502 U01bd		       01 bd	   snes2atari1hi =	paddleposition3
    503 U01bd		       01 bd	   mega7800state1 =	paddleposition3
    504 U01be
    505 U01be							; controller state save. for trakball state+dir codes, rotary position codes
    506 U01be		       00	   controller0statesave DS	1
    507 U01be		       01 be	   paddleprevious0 =	controller0statesave
    508 U01be		       01 be	   mousecodex0 =	controller0statesave
    509 U01be		       01 be	   trakballcodex0 =	controller0statesave
    510 U01be		       01 be	   keypadmatrix0c =	controller0statesave
    511 U01be		       01 be	   snesdetected0 =	controller0statesave
    512 U01bf
    513 U01bf		       00	   controller1statesave DS	1
    514 U01bf		       01 bf	   paddleprevious2 =	controller1statesave
    515 U01bf		       01 bf	   mousecodex1 =	controller1statesave
    516 U01bf		       01 bf	   trakballcodex1 =	controller1statesave
    517 U01bf		       01 bf	   keypadmatrix1c =	controller1statesave
    518 U01bf		       01 bf	   snesdetected1 =	controller1statesave
    519 U01c0
    520 U01c0		       00	   paddleprevious1 DS	1
    521 U01c0		       01 c0	   keypadmatrix0d =	paddleprevious1
    522 U01c0		       01 c0	   mousecodey0 =	paddleprevious1
    523 U01c0		       01 c0	   trakballcodey0 =	paddleprevious1
    524 U01c1
    525 U01c1		       00	   paddleprevious3 DS	1
    526 U01c1		       01 c1	   keypadmatrix1d =	paddleprevious3
    527 U01c1		       01 c1	   mousecodey1 =	paddleprevious3
    528 U01c1		       01 c1	   trakballcodey1 =	paddleprevious3
    529 U01c2
    530 U01c2				  -	      ifconst	pokeysupport
    531 U01c2				  -pokey1frames DS	1
    532 U01c2				  -pokey1tick DS	1
    533 U01c2				  -pokey2frames DS	1
    534 U01c2				  -pokey2tick DS	1
    535 U01c2				  -pokey3frames DS	1
    536 U01c2				  -pokey3tick DS	1
    537 U01c2				  -pokey4frames DS	1
    538 U01c2				  -pokey4tick DS	1
    539 U01c2				  -pokey1priority DS	1
    540 U01c2				  -pokey1offset DS	1
    541 U01c2				  -pokey2priority DS	1
    542 U01c2				  -pokey2offset DS	1
    543 U01c2				  -pokey3priority DS	1
    544 U01c2				  -pokey3offset DS	1
    545 U01c2				  -pokey4priority DS	1
    546 U01c2				  -pokey4offset DS	1
    547 U01c2					      endif
    548 U01c2
    549 U01c2				  -	      ifconst	pokeykeysupport
    550 U01c2				  -pokeylastkeycode DS	1
    551 U01c2				  -pokeykeycode DS	1
    552 U01c2				  -pokeykeydebounce DS	1
    553 U01c2					      endif
    554 U01c2
    555 U01c2				  -	      ifconst	RMT
    556 U01c2				  -rasterpause DS	1
    557 U01c2					      endif		; RMT
    558 U01c2				  -	      ifconst	RMTVOLUME
    559 U01c2				  -rmtvolume  DS	1
    560 U01c2					      endif		; RMTVOLUME
    561 U01c2				  -	      ifconst	TIAVOLUME
    562 U01c2				  -tiavolume  DS	1
    563 U01c2					      endif		; TIAVOLUME
    564 U01c2
    565 U01c2				  -	      ifconst	FOURBITFADE
    566 U01c2				  -fourbittemp1 DS	1
    567 U01c2				  -fourbitfadevalue DS	1
    568 U01c2				  -fourbittemp1int DS	1
    569 U01c2				  -fourbitfadevalueint DS	1
    570 U01c2					      endif		; FOURBITFADE
    571 U01c2
    572 U01c2				  -	      ifconst	SNES2ATARISUPPORT
    573 U01c2				  -snesport   DS	1
    574 U01c2					      endif		; SNES2ATARISUPPORT
    575 U01c2
    576 U01c2				  -	      ifconst	KEYPADSUPPORT
    577 U01c2				  -keypadcounter DS	1
    578 U01c2					      endif
    579 U01c2
    580 U01c2				  -	      ifconst	MULTIBUTTON
    581 U01c2				  -multibuttoncount0 DS	1
    582 U01c2				  -multibuttoncount1 DS	1
    583 U01c2					      endif
    584 U01c2
    585 U01c2							; see if we need an interrupthold byte...
    586 U01c2				   INTERRUPTNEEDED SET	0
    587 U01c2				  -	      ifconst	.topscreenroutine
    588 U01c2				  -INTERRUPTNEEDED SET	1
    589 U01c2					      endif
    590 U01c2				  -	      ifconst	.bottomscreenroutine
    591 U01c2				  -INTERRUPTNEEDED SET	1
    592 U01c2					      endif
    593 U01c2				  -	      ifconst	.userinterrupt
    594 U01c2				  -INTERRUPTNEEDED SET	1
    595 U01c2					      endif
    596 U01c2				  -	      if	INTERRUPTNEEDED = 1
    597 U01c2				  -interrupthold DS	1
    598 U01c2					      endif
    599 U01c2
    600 U01c2					      ifnconst	CANARYOFF
    601 U01c2		       00	   canary     DS	1
    602 U01c3					      endif
    603 U01c3
    604 U01c3					      ifnconst	bankswitchmode
   stack allowance: 30 nested subroutines.
    605 U01c3					      echo	"  stack allowance:",[($1FF - .)/2]d,"nested subroutines."
    606 U01c3				  -	      else
    607 U01c3				  -	      echo	"  stack allowance:",[($1FF - .)/3]d,"nested subroutines."
    608 U01c3					      endif
    609 U01c3					      ifnconst	CANARYOFF
   the canary is situated at: $1c2
    610 U01c3					      echo	"  the canary is situated at:",[canary]
    611 U01c3				  -	      else
    612 U01c3				  -	      echo	"  the canary is disabled."
    613 U01c3					      endif
    614 U01c3
    615 U01c3							; $1EE - $1FF reserved for stack
    616 U01c3
    617  10000 ????				       SEG	"GAME"
    618  10000 ????
------- FILE constants.78b.asm
------- FILE 7800_extravars.h LEVEL 2 PASS 3
      0  10000 ????				       include	"7800_extravars.h"
      1  10000 ????		22 00	    var100     =	$2200
      2  10000 ????		22 01	    var101     =	$2201
      3  10000 ????		22 02	    var102     =	$2202
      4  10000 ????		22 03	    var103     =	$2203
      5  10000 ????		22 04	    var104     =	$2204
      6  10000 ????		22 05	    var105     =	$2205
      7  10000 ????		22 06	    var106     =	$2206
      8  10000 ????		22 07	    var107     =	$2207
      9  10000 ????		22 08	    var108     =	$2208
     10  10000 ????		22 09	    var109     =	$2209
     11  10000 ????		22 0a	    var110     =	$220A
     12  10000 ????		22 0b	    var111     =	$220B
     13  10000 ????		22 0c	    var112     =	$220C
     14  10000 ????		22 0d	    var113     =	$220D
     15  10000 ????		22 0e	    var114     =	$220E
     16  10000 ????		22 0f	    var115     =	$220F
     17  10000 ????		22 10	    var116     =	$2210
     18  10000 ????		22 11	    var117     =	$2211
     19  10000 ????		22 12	    var118     =	$2212
     20  10000 ????		22 13	    var119     =	$2213
     21  10000 ????		22 14	    var120     =	$2214
     22  10000 ????		22 15	    var121     =	$2215
     23  10000 ????		22 16	    var122     =	$2216
     24  10000 ????		22 17	    var123     =	$2217
     25  10000 ????		22 18	    var124     =	$2218
     26  10000 ????		22 19	    var125     =	$2219
     27  10000 ????		22 1a	    var126     =	$221A
     28  10000 ????		22 1b	    var127     =	$221B
     29  10000 ????		22 1c	    var128     =	$221C
     30  10000 ????		22 1d	    var129     =	$221D
     31  10000 ????		22 1e	    var130     =	$221E
     32  10000 ????		22 1f	    var131     =	$221F
     33  10000 ????		22 20	    var132     =	$2220
     34  10000 ????		22 21	    var133     =	$2221
     35  10000 ????		22 22	    var134     =	$2222
     36  10000 ????		22 23	    var135     =	$2223
     37  10000 ????		22 24	    var136     =	$2224
     38  10000 ????		22 25	    var137     =	$2225
     39  10000 ????		22 26	    var138     =	$2226
     40  10000 ????		22 27	    var139     =	$2227
     41  10000 ????		22 28	    var140     =	$2228
     42  10000 ????		22 29	    var141     =	$2229
     43  10000 ????		22 2a	    var142     =	$222A
     44  10000 ????		22 2b	    var143     =	$222B
     45  10000 ????		22 2c	    var144     =	$222C
     46  10000 ????		22 2d	    var145     =	$222D
     47  10000 ????		22 2e	    var146     =	$222E
     48  10000 ????		22 2f	    var147     =	$222F
     49  10000 ????		22 30	    var148     =	$2230
     50  10000 ????		22 31	    var149     =	$2231
     51  10000 ????		22 32	    var150     =	$2232
     52  10000 ????		22 33	    var151     =	$2233
     53  10000 ????		22 34	    var152     =	$2234
     54  10000 ????		22 35	    var153     =	$2235
     55  10000 ????		22 36	    var154     =	$2236
     56  10000 ????		22 37	    var155     =	$2237
     57  10000 ????		22 38	    var156     =	$2238
     58  10000 ????		22 39	    var157     =	$2239
     59  10000 ????		22 3a	    var158     =	$223A
     60  10000 ????		22 3b	    var159     =	$223B
     61  10000 ????		22 3c	    var160     =	$223C
     62  10000 ????		22 3d	    var161     =	$223D
     63  10000 ????		22 3e	    var162     =	$223E
     64  10000 ????		22 3f	    var163     =	$223F
     65  10000 ????		22 40	    var164     =	$2240
     66  10000 ????		22 41	    var165     =	$2241
     67  10000 ????		22 42	    var166     =	$2242
     68  10000 ????		22 43	    var167     =	$2243
     69  10000 ????		22 44	    var168     =	$2244
     70  10000 ????		22 45	    var169     =	$2245
     71  10000 ????		22 46	    var170     =	$2246
     72  10000 ????		22 47	    var171     =	$2247
     73  10000 ????		22 48	    var172     =	$2248
     74  10000 ????		22 49	    var173     =	$2249
     75  10000 ????		22 4a	    var174     =	$224A
     76  10000 ????		22 4b	    var175     =	$224B
     77  10000 ????		22 4c	    var176     =	$224C
     78  10000 ????		22 4d	    var177     =	$224D
     79  10000 ????		22 4e	    var178     =	$224E
     80  10000 ????		22 4f	    var179     =	$224F
     81  10000 ????		22 50	    var180     =	$2250
     82  10000 ????		22 51	    var181     =	$2251
     83  10000 ????		22 52	    var182     =	$2252
     84  10000 ????		22 53	    var183     =	$2253
     85  10000 ????		22 54	    var184     =	$2254
     86  10000 ????		22 55	    var185     =	$2255
     87  10000 ????		22 56	    var186     =	$2256
     88  10000 ????		22 57	    var187     =	$2257
     89  10000 ????		22 58	    var188     =	$2258
     90  10000 ????		22 59	    var189     =	$2259
     91  10000 ????		22 5a	    var190     =	$225A
     92  10000 ????		22 5b	    var191     =	$225B
     93  10000 ????		22 5c	    var192     =	$225C
     94  10000 ????		22 5d	    var193     =	$225D
     95  10000 ????		22 5e	    var194     =	$225E
     96  10000 ????		22 5f	    var195     =	$225F
     97  10000 ????		22 60	    var196     =	$2260
     98  10000 ????		22 61	    var197     =	$2261
     99  10000 ????		22 62	    var198     =	$2262
    100  10000 ????		22 63	    var199     =	$2263
    101  10000 ????		22 64	    var200     =	$2264
    102  10000 ????		22 65	    var201     =	$2265
    103  10000 ????		22 66	    var202     =	$2266
    104  10000 ????		22 67	    var203     =	$2267
    105  10000 ????		22 68	    var204     =	$2268
    106  10000 ????		22 69	    var205     =	$2269
    107  10000 ????		22 6a	    var206     =	$226A
    108  10000 ????		22 6b	    var207     =	$226B
    109  10000 ????		22 6c	    var208     =	$226C
    110  10000 ????		22 6d	    var209     =	$226D
    111  10000 ????		22 6e	    var210     =	$226E
    112  10000 ????		22 6f	    var211     =	$226F
    113  10000 ????		22 70	    var212     =	$2270
    114  10000 ????		22 71	    var213     =	$2271
    115  10000 ????		22 72	    var214     =	$2272
    116  10000 ????		22 73	    var215     =	$2273
    117  10000 ????		22 74	    var216     =	$2274
    118  10000 ????		22 75	    var217     =	$2275
    119  10000 ????		22 76	    var218     =	$2276
    120  10000 ????		22 77	    var219     =	$2277
    121  10000 ????		22 78	    var220     =	$2278
    122  10000 ????		22 79	    var221     =	$2279
    123  10000 ????		22 7a	    var222     =	$227A
    124  10000 ????		22 7b	    var223     =	$227B
    125  10000 ????		22 7c	    var224     =	$227C
    126  10000 ????		22 7d	    var225     =	$227D
    127  10000 ????		22 7e	    var226     =	$227E
    128  10000 ????		22 7f	    var227     =	$227F
    129  10000 ????		22 80	    var228     =	$2280
    130  10000 ????		22 81	    var229     =	$2281
    131  10000 ????		22 82	    var230     =	$2282
    132  10000 ????		22 83	    var231     =	$2283
    133  10000 ????		22 84	    var232     =	$2284
    134  10000 ????		22 85	    var233     =	$2285
    135  10000 ????		22 86	    var234     =	$2286
    136  10000 ????		22 87	    var235     =	$2287
    137  10000 ????		22 88	    var236     =	$2288
    138  10000 ????		22 89	    var237     =	$2289
    139  10000 ????		22 8a	    var238     =	$228A
    140  10000 ????		22 8b	    var239     =	$228B
    141  10000 ????		22 8c	    var240     =	$228C
    142  10000 ????		22 8d	    var241     =	$228D
    143  10000 ????		22 8e	    var242     =	$228E
    144  10000 ????		22 8f	    var243     =	$228F
    145  10000 ????		22 90	    var244     =	$2290
    146  10000 ????		22 91	    var245     =	$2291
    147  10000 ????		22 92	    var246     =	$2292
    148  10000 ????		22 93	    var247     =	$2293
    149  10000 ????		22 94	    var248     =	$2294
    150  10000 ????		22 95	    var249     =	$2295
    151  10000 ????		22 96	    var250     =	$2296
    152  10000 ????		22 97	    var251     =	$2297
    153  10000 ????		22 98	    var252     =	$2298
    154  10000 ????		22 99	    var253     =	$2299
    155  10000 ????		22 9a	    var254     =	$229A
    156  10000 ????		22 9b	    var255     =	$229B
    157  10000 ????		22 9c	    var256     =	$229C
    158  10000 ????		22 9d	    var257     =	$229D
    159  10000 ????		22 9e	    var258     =	$229E
    160  10000 ????		22 9f	    var259     =	$229F
    161  10000 ????		22 a0	    var260     =	$22A0
    162  10000 ????		22 a1	    var261     =	$22A1
    163  10000 ????		22 a2	    var262     =	$22A2
    164  10000 ????		22 a3	    var263     =	$22A3
    165  10000 ????		22 a4	    var264     =	$22A4
    166  10000 ????		22 a5	    var265     =	$22A5
    167  10000 ????		22 a6	    var266     =	$22A6
    168  10000 ????		22 a7	    var267     =	$22A7
    169  10000 ????		22 a8	    var268     =	$22A8
    170  10000 ????		22 a9	    var269     =	$22A9
    171  10000 ????		22 aa	    var270     =	$22AA
    172  10000 ????		22 ab	    var271     =	$22AB
    173  10000 ????		22 ac	    var272     =	$22AC
    174  10000 ????		22 ad	    var273     =	$22AD
    175  10000 ????		22 ae	    var274     =	$22AE
    176  10000 ????		22 af	    var275     =	$22AF
    177  10000 ????		22 b0	    var276     =	$22B0
    178  10000 ????		22 b1	    var277     =	$22B1
    179  10000 ????		22 b2	    var278     =	$22B2
    180  10000 ????		22 b3	    var279     =	$22B3
    181  10000 ????		22 b4	    var280     =	$22B4
    182  10000 ????		22 b5	    var281     =	$22B5
    183  10000 ????		22 b6	    var282     =	$22B6
    184  10000 ????		22 b7	    var283     =	$22B7
    185  10000 ????		22 b8	    var284     =	$22B8
    186  10000 ????		22 b9	    var285     =	$22B9
    187  10000 ????		22 ba	    var286     =	$22BA
    188  10000 ????		22 bb	    var287     =	$22BB
    189  10000 ????		22 bc	    var288     =	$22BC
    190  10000 ????		22 bd	    var289     =	$22BD
    191  10000 ????		22 be	    var290     =	$22BE
    192  10000 ????		22 bf	    var291     =	$22BF
    193  10000 ????		22 c0	    var292     =	$22C0
    194  10000 ????		22 c1	    var293     =	$22C1
    195  10000 ????		22 c2	    var294     =	$22C2
    196  10000 ????		22 c3	    var295     =	$22C3
    197  10000 ????		22 c4	    var296     =	$22C4
    198  10000 ????		22 c5	    var297     =	$22C5
    199  10000 ????		22 c6	    var298     =	$22C6
    200  10000 ????		22 c7	    var299     =	$22C7
    201  10000 ????		22 c8	    var300     =	$22C8
    202  10000 ????		22 c9	    var301     =	$22C9
    203  10000 ????		22 ca	    var302     =	$22CA
    204  10000 ????		22 cb	    var303     =	$22CB
    205  10000 ????		22 cc	    var304     =	$22CC
    206  10000 ????		22 cd	    var305     =	$22CD
    207  10000 ????		22 ce	    var306     =	$22CE
    208  10000 ????		22 cf	    var307     =	$22CF
    209  10000 ????		22 d0	    var308     =	$22D0
    210  10000 ????		22 d1	    var309     =	$22D1
    211  10000 ????		22 d2	    var310     =	$22D2
    212  10000 ????		22 d3	    var311     =	$22D3
    213  10000 ????		22 d4	    var312     =	$22D4
    214  10000 ????		22 d5	    var313     =	$22D5
    215  10000 ????		22 d6	    var314     =	$22D6
    216  10000 ????		22 d7	    var315     =	$22D7
    217  10000 ????		22 d8	    var316     =	$22D8
    218  10000 ????		22 d9	    var317     =	$22D9
    219  10000 ????		22 da	    var318     =	$22DA
    220  10000 ????		22 db	    var319     =	$22DB
    221  10000 ????		22 dc	    var320     =	$22DC
    222  10000 ????		22 dd	    var321     =	$22DD
    223  10000 ????		22 de	    var322     =	$22DE
    224  10000 ????		22 df	    var323     =	$22DF
    225  10000 ????		22 e0	    var324     =	$22E0
    226  10000 ????		22 e1	    var325     =	$22E1
    227  10000 ????		22 e2	    var326     =	$22E2
    228  10000 ????		22 e3	    var327     =	$22E3
    229  10000 ????		22 e4	    var328     =	$22E4
    230  10000 ????		22 e5	    var329     =	$22E5
    231  10000 ????		22 e6	    var330     =	$22E6
    232  10000 ????		22 e7	    var331     =	$22E7
    233  10000 ????		22 e8	    var332     =	$22E8
    234  10000 ????		22 e9	    var333     =	$22E9
    235  10000 ????		22 ea	    var334     =	$22EA
    236  10000 ????		22 eb	    var335     =	$22EB
    237  10000 ????		22 ec	    var336     =	$22EC
    238  10000 ????		22 ed	    var337     =	$22ED
    239  10000 ????		22 ee	    var338     =	$22EE
    240  10000 ????		22 ef	    var339     =	$22EF
    241  10000 ????		22 f0	    var340     =	$22F0
    242  10000 ????		22 f1	    var341     =	$22F1
    243  10000 ????		22 f2	    var342     =	$22F2
    244  10000 ????		22 f3	    var343     =	$22F3
    245  10000 ????		22 f4	    var344     =	$22F4
    246  10000 ????		22 f5	    var345     =	$22F5
    247  10000 ????		22 f6	    var346     =	$22F6
    248  10000 ????		22 f7	    var347     =	$22F7
    249  10000 ????		22 f8	    var348     =	$22F8
    250  10000 ????		22 f9	    var349     =	$22F9
    251  10000 ????		22 fa	    var350     =	$22FA
    252  10000 ????		22 fb	    var351     =	$22FB
    253  10000 ????		22 fc	    var352     =	$22FC
    254  10000 ????		22 fd	    var353     =	$22FD
    255  10000 ????		22 fe	    var354     =	$22FE
    256  10000 ????		22 ff	    var355     =	$22FF
    257  10000 ????		23 00	    var356     =	$2300
    258  10000 ????		23 01	    var357     =	$2301
    259  10000 ????		23 02	    var358     =	$2302
    260  10000 ????		23 03	    var359     =	$2303
    261  10000 ????		23 04	    var360     =	$2304
    262  10000 ????		23 05	    var361     =	$2305
    263  10000 ????		23 06	    var362     =	$2306
    264  10000 ????		23 07	    var363     =	$2307
    265  10000 ????		23 08	    var364     =	$2308
    266  10000 ????		23 09	    var365     =	$2309
    267  10000 ????		23 0a	    var366     =	$230A
    268  10000 ????		23 0b	    var367     =	$230B
    269  10000 ????		23 0c	    var368     =	$230C
    270  10000 ????		23 0d	    var369     =	$230D
    271  10000 ????		23 0e	    var370     =	$230E
    272  10000 ????		23 0f	    var371     =	$230F
    273  10000 ????		23 10	    var372     =	$2310
    274  10000 ????		23 11	    var373     =	$2311
    275  10000 ????		23 12	    var374     =	$2312
    276  10000 ????		23 13	    var375     =	$2313
    277  10000 ????		23 14	    var376     =	$2314
    278  10000 ????		23 15	    var377     =	$2315
    279  10000 ????		23 16	    var378     =	$2316
    280  10000 ????		23 17	    var379     =	$2317
    281  10000 ????		23 18	    var380     =	$2318
    282  10000 ????		23 19	    var381     =	$2319
    283  10000 ????		23 1a	    var382     =	$231A
    284  10000 ????		23 1b	    var383     =	$231B
    285  10000 ????		23 1c	    var384     =	$231C
    286  10000 ????		23 1d	    var385     =	$231D
    287  10000 ????		23 1e	    var386     =	$231E
    288  10000 ????		23 1f	    var387     =	$231F
    289  10000 ????		23 20	    var388     =	$2320
    290  10000 ????		23 21	    var389     =	$2321
    291  10000 ????		23 22	    var390     =	$2322
    292  10000 ????		23 23	    var391     =	$2323
    293  10000 ????		23 24	    var392     =	$2324
    294  10000 ????		23 25	    var393     =	$2325
    295  10000 ????		23 26	    var394     =	$2326
    296  10000 ????		23 27	    var395     =	$2327
    297  10000 ????		23 28	    var396     =	$2328
    298  10000 ????		23 29	    var397     =	$2329
    299  10000 ????		23 2a	    var398     =	$232A
    300  10000 ????		23 2b	    var399     =	$232B
    301  10000 ????		23 2c	    var400     =	$232C
    302  10000 ????		23 2d	    var401     =	$232D
    303  10000 ????		23 2e	    var402     =	$232E
    304  10000 ????		23 2f	    var403     =	$232F
    305  10000 ????		23 30	    var404     =	$2330
    306  10000 ????		23 31	    var405     =	$2331
    307  10000 ????		23 32	    var406     =	$2332
    308  10000 ????		23 33	    var407     =	$2333
    309  10000 ????		23 34	    var408     =	$2334
    310  10000 ????		23 35	    var409     =	$2335
    311  10000 ????		23 36	    var410     =	$2336
    312  10000 ????		23 37	    var411     =	$2337
    313  10000 ????		23 38	    var412     =	$2338
    314  10000 ????		23 39	    var413     =	$2339
    315  10000 ????		23 3a	    var414     =	$233A
    316  10000 ????		23 3b	    var415     =	$233B
    317  10000 ????		23 3c	    var416     =	$233C
    318  10000 ????		23 3d	    var417     =	$233D
    319  10000 ????		23 3e	    var418     =	$233E
    320  10000 ????		23 3f	    var419     =	$233F
    321  10000 ????		23 40	    var420     =	$2340
    322  10000 ????		23 41	    var421     =	$2341
    323  10000 ????		23 42	    var422     =	$2342
    324  10000 ????		23 43	    var423     =	$2343
    325  10000 ????		23 44	    var424     =	$2344
    326  10000 ????		23 45	    var425     =	$2345
    327  10000 ????		23 46	    var426     =	$2346
    328  10000 ????		23 47	    var427     =	$2347
    329  10000 ????		23 48	    var428     =	$2348
    330  10000 ????		23 49	    var429     =	$2349
    331  10000 ????		23 4a	    var430     =	$234A
    332  10000 ????		23 4b	    var431     =	$234B
    333  10000 ????		23 4c	    var432     =	$234C
    334  10000 ????		23 4d	    var433     =	$234D
    335  10000 ????		23 4e	    var434     =	$234E
    336  10000 ????		23 4f	    var435     =	$234F
    337  10000 ????		23 50	    var436     =	$2350
    338  10000 ????		23 51	    var437     =	$2351
    339  10000 ????		23 52	    var438     =	$2352
    340  10000 ????		23 53	    var439     =	$2353
    341  10000 ????		23 54	    var440     =	$2354
    342  10000 ????		23 55	    var441     =	$2355
    343  10000 ????		23 56	    var442     =	$2356
    344  10000 ????		23 57	    var443     =	$2357
    345  10000 ????		23 58	    var444     =	$2358
    346  10000 ????		23 59	    var445     =	$2359
    347  10000 ????		23 5a	    var446     =	$235A
    348  10000 ????		23 5b	    var447     =	$235B
    349  10000 ????		23 5c	    var448     =	$235C
    350  10000 ????		23 5d	    var449     =	$235D
    351  10000 ????		23 5e	    var450     =	$235E
    352  10000 ????		23 5f	    var451     =	$235F
    353  10000 ????		23 60	    var452     =	$2360
    354  10000 ????		23 61	    var453     =	$2361
    355  10000 ????		23 62	    var454     =	$2362
    356  10000 ????		23 63	    var455     =	$2363
    357  10000 ????		23 64	    var456     =	$2364
    358  10000 ????		23 65	    var457     =	$2365
    359  10000 ????		23 66	    var458     =	$2366
    360  10000 ????		23 67	    var459     =	$2367
    361  10000 ????		23 68	    var460     =	$2368
    362  10000 ????		23 69	    var461     =	$2369
    363  10000 ????		23 6a	    var462     =	$236A
    364  10000 ????		23 6b	    var463     =	$236B
    365  10000 ????		23 6c	    var464     =	$236C
    366  10000 ????		23 6d	    var465     =	$236D
    367  10000 ????		23 6e	    var466     =	$236E
    368  10000 ????		23 6f	    var467     =	$236F
    369  10000 ????		23 70	    var468     =	$2370
    370  10000 ????		23 71	    var469     =	$2371
    371  10000 ????		23 72	    var470     =	$2372
    372  10000 ????		23 73	    var471     =	$2373
    373  10000 ????		23 74	    var472     =	$2374
    374  10000 ????		23 75	    var473     =	$2375
    375  10000 ????		23 76	    var474     =	$2376
    376  10000 ????		23 77	    var475     =	$2377
    377  10000 ????		23 78	    var476     =	$2378
    378  10000 ????		23 79	    var477     =	$2379
    379  10000 ????		23 7a	    var478     =	$237A
    380  10000 ????		23 7b	    var479     =	$237B
    381  10000 ????		23 7c	    var480     =	$237C
    382  10000 ????		23 7d	    var481     =	$237D
    383  10000 ????		23 7e	    var482     =	$237E
    384  10000 ????		23 7f	    var483     =	$237F
    385  10000 ????		23 80	    var484     =	$2380
    386  10000 ????		23 81	    var485     =	$2381
    387  10000 ????		23 82	    var486     =	$2382
    388  10000 ????		23 83	    var487     =	$2383
    389  10000 ????		23 84	    var488     =	$2384
    390  10000 ????		23 85	    var489     =	$2385
    391  10000 ????		23 86	    var490     =	$2386
    392  10000 ????		23 87	    var491     =	$2387
    393  10000 ????		23 88	    var492     =	$2388
    394  10000 ????		23 89	    var493     =	$2389
    395  10000 ????		23 8a	    var494     =	$238A
    396  10000 ????		23 8b	    var495     =	$238B
    397  10000 ????		23 8c	    var496     =	$238C
    398  10000 ????		23 8d	    var497     =	$238D
    399  10000 ????		23 8e	    var498     =	$238E
    400  10000 ????		23 8f	    var499     =	$238F
    401  10000 ????		23 90	    var500     =	$2390
    402  10000 ????		23 91	    var501     =	$2391
    403  10000 ????		23 92	    var502     =	$2392
    404  10000 ????		23 93	    var503     =	$2393
    405  10000 ????		23 94	    var504     =	$2394
    406  10000 ????		23 95	    var505     =	$2395
    407  10000 ????		23 96	    var506     =	$2396
    408  10000 ????		23 97	    var507     =	$2397
    409  10000 ????		23 98	    var508     =	$2398
    410  10000 ????		23 99	    var509     =	$2399
    411  10000 ????		23 9a	    var510     =	$239A
    412  10000 ????		23 9b	    var511     =	$239B
    413  10000 ????		23 9c	    var512     =	$239C
    414  10000 ????		23 9d	    var513     =	$239D
    415  10000 ????		23 9e	    var514     =	$239E
    416  10000 ????		23 9f	    var515     =	$239F
    417  10000 ????		23 a0	    var516     =	$23A0
    418  10000 ????		23 a1	    var517     =	$23A1
    419  10000 ????		23 a2	    var518     =	$23A2
    420  10000 ????		23 a3	    var519     =	$23A3
    421  10000 ????		23 a4	    var520     =	$23A4
    422  10000 ????		23 a5	    var521     =	$23A5
    423  10000 ????		23 a6	    var522     =	$23A6
    424  10000 ????		23 a7	    var523     =	$23A7
    425  10000 ????		23 a8	    var524     =	$23A8
    426  10000 ????		23 a9	    var525     =	$23A9
    427  10000 ????		23 aa	    var526     =	$23AA
    428  10000 ????		23 ab	    var527     =	$23AB
    429  10000 ????		23 ac	    var528     =	$23AC
    430  10000 ????		23 ad	    var529     =	$23AD
    431  10000 ????		23 ae	    var530     =	$23AE
    432  10000 ????		23 af	    var531     =	$23AF
    433  10000 ????		23 b0	    var532     =	$23B0
    434  10000 ????		23 b1	    var533     =	$23B1
    435  10000 ????		23 b2	    var534     =	$23B2
    436  10000 ????		23 b3	    var535     =	$23B3
    437  10000 ????		23 b4	    var536     =	$23B4
    438  10000 ????		23 b5	    var537     =	$23B5
    439  10000 ????		23 b6	    var538     =	$23B6
    440  10000 ????		23 b7	    var539     =	$23B7
    441  10000 ????		23 b8	    var540     =	$23B8
    442  10000 ????		23 b9	    var541     =	$23B9
    443  10000 ????		23 ba	    var542     =	$23BA
    444  10000 ????		23 bb	    var543     =	$23BB
    445  10000 ????		23 bc	    var544     =	$23BC
    446  10000 ????		23 bd	    var545     =	$23BD
    447  10000 ????		23 be	    var546     =	$23BE
    448  10000 ????		23 bf	    var547     =	$23BF
    449  10000 ????		23 c0	    var548     =	$23C0
    450  10000 ????		23 c1	    var549     =	$23C1
    451  10000 ????		23 c2	    var550     =	$23C2
    452  10000 ????		23 c3	    var551     =	$23C3
    453  10000 ????		23 c4	    var552     =	$23C4
    454  10000 ????		23 c5	    var553     =	$23C5
    455  10000 ????		23 c6	    var554     =	$23C6
    456  10000 ????		23 c7	    var555     =	$23C7
    457  10000 ????		23 c8	    var556     =	$23C8
    458  10000 ????		23 c9	    var557     =	$23C9
    459  10000 ????		23 ca	    var558     =	$23CA
    460  10000 ????		23 cb	    var559     =	$23CB
    461  10000 ????		23 cc	    var560     =	$23CC
    462  10000 ????		23 cd	    var561     =	$23CD
    463  10000 ????		23 ce	    var562     =	$23CE
    464  10000 ????		23 cf	    var563     =	$23CF
    465  10000 ????		23 d0	    var564     =	$23D0
    466  10000 ????		23 d1	    var565     =	$23D1
    467  10000 ????		23 d2	    var566     =	$23D2
    468  10000 ????		23 d3	    var567     =	$23D3
    469  10000 ????		23 d4	    var568     =	$23D4
    470  10000 ????		23 d5	    var569     =	$23D5
    471  10000 ????		23 d6	    var570     =	$23D6
    472  10000 ????		23 d7	    var571     =	$23D7
    473  10000 ????		23 d8	    var572     =	$23D8
    474  10000 ????		23 d9	    var573     =	$23D9
    475  10000 ????		23 da	    var574     =	$23DA
    476  10000 ????		23 db	    var575     =	$23DB
    477  10000 ????		23 dc	    var576     =	$23DC
    478  10000 ????		23 dd	    var577     =	$23DD
    479  10000 ????		23 de	    var578     =	$23DE
    480  10000 ????		23 df	    var579     =	$23DF
    481  10000 ????		23 e0	    var580     =	$23E0
    482  10000 ????		23 e1	    var581     =	$23E1
    483  10000 ????		23 e2	    var582     =	$23E2
    484  10000 ????		23 e3	    var583     =	$23E3
    485  10000 ????		23 e4	    var584     =	$23E4
    486  10000 ????		23 e5	    var585     =	$23E5
    487  10000 ????		23 e6	    var586     =	$23E6
    488  10000 ????		23 e7	    var587     =	$23E7
    489  10000 ????		23 e8	    var588     =	$23E8
    490  10000 ????		23 e9	    var589     =	$23E9
    491  10000 ????		23 ea	    var590     =	$23EA
    492  10000 ????		23 eb	    var591     =	$23EB
    493  10000 ????		23 ec	    var592     =	$23EC
    494  10000 ????		23 ed	    var593     =	$23ED
    495  10000 ????		23 ee	    var594     =	$23EE
    496  10000 ????		23 ef	    var595     =	$23EF
    497  10000 ????		23 f0	    var596     =	$23F0
    498  10000 ????		23 f1	    var597     =	$23F1
    499  10000 ????		23 f2	    var598     =	$23F2
    500  10000 ????		23 f3	    var599     =	$23F3
    501  10000 ????		23 f4	    var600     =	$23F4
    502  10000 ????		23 f5	    var601     =	$23F5
    503  10000 ????		23 f6	    var602     =	$23F6
    504  10000 ????		23 f7	    var603     =	$23F7
    505  10000 ????		23 f8	    var604     =	$23F8
    506  10000 ????		23 f9	    var605     =	$23F9
    507  10000 ????		23 fa	    var606     =	$23FA
    508  10000 ????		23 fb	    var607     =	$23FB
    509  10000 ????		23 fc	    var608     =	$23FC
    510  10000 ????		23 fd	    var609     =	$23FD
    511  10000 ????		23 fe	    var610     =	$23FE
    512  10000 ????		23 ff	    var611     =	$23FF
    513  10000 ????		24 00	    var612     =	$2400
    514  10000 ????		24 01	    var613     =	$2401
    515  10000 ????		24 02	    var614     =	$2402
    516  10000 ????		24 03	    var615     =	$2403
    517  10000 ????		24 04	    var616     =	$2404
    518  10000 ????		24 05	    var617     =	$2405
    519  10000 ????		24 06	    var618     =	$2406
    520  10000 ????		24 07	    var619     =	$2407
    521  10000 ????		24 08	    var620     =	$2408
    522  10000 ????		24 09	    var621     =	$2409
    523  10000 ????		24 0a	    var622     =	$240A
    524  10000 ????		24 0b	    var623     =	$240B
    525  10000 ????		24 0c	    var624     =	$240C
    526  10000 ????		24 0d	    var625     =	$240D
    527  10000 ????		24 0e	    var626     =	$240E
    528  10000 ????		24 0f	    var627     =	$240F
    529  10000 ????		24 10	    var628     =	$2410
    530  10000 ????		24 11	    var629     =	$2411
    531  10000 ????		24 12	    var630     =	$2412
    532  10000 ????		24 13	    var631     =	$2413
    533  10000 ????		24 14	    var632     =	$2414
    534  10000 ????		24 15	    var633     =	$2415
    535  10000 ????		24 16	    var634     =	$2416
    536  10000 ????		24 17	    var635     =	$2417
    537  10000 ????		24 18	    var636     =	$2418
    538  10000 ????		24 19	    var637     =	$2419
    539  10000 ????		24 1a	    var638     =	$241A
    540  10000 ????		24 1b	    var639     =	$241B
    541  10000 ????		24 1c	    var640     =	$241C
    542  10000 ????		24 1d	    var641     =	$241D
    543  10000 ????		24 1e	    var642     =	$241E
    544  10000 ????		24 1f	    var643     =	$241F
    545  10000 ????		24 20	    var644     =	$2420
    546  10000 ????		24 21	    var645     =	$2421
    547  10000 ????		24 22	    var646     =	$2422
    548  10000 ????		24 23	    var647     =	$2423
    549  10000 ????		24 24	    var648     =	$2424
    550  10000 ????		24 25	    var649     =	$2425
    551  10000 ????		24 26	    var650     =	$2426
    552  10000 ????		24 27	    var651     =	$2427
    553  10000 ????		24 28	    var652     =	$2428
    554  10000 ????		24 29	    var653     =	$2429
    555  10000 ????		24 2a	    var654     =	$242A
    556  10000 ????		24 2b	    var655     =	$242B
    557  10000 ????		24 2c	    var656     =	$242C
    558  10000 ????		24 2d	    var657     =	$242D
    559  10000 ????		24 2e	    var658     =	$242E
    560  10000 ????		24 2f	    var659     =	$242F
    561  10000 ????		24 30	    var660     =	$2430
    562  10000 ????		24 31	    var661     =	$2431
    563  10000 ????		24 32	    var662     =	$2432
    564  10000 ????		24 33	    var663     =	$2433
    565  10000 ????		24 34	    var664     =	$2434
    566  10000 ????		24 35	    var665     =	$2435
    567  10000 ????		24 36	    var666     =	$2436
    568  10000 ????		24 37	    var667     =	$2437
    569  10000 ????		24 38	    var668     =	$2438
    570  10000 ????		24 39	    var669     =	$2439
    571  10000 ????		24 3a	    var670     =	$243A
    572  10000 ????		24 3b	    var671     =	$243B
    573  10000 ????		24 3c	    var672     =	$243C
    574  10000 ????		24 3d	    var673     =	$243D
    575  10000 ????		24 3e	    var674     =	$243E
    576  10000 ????		24 3f	    var675     =	$243F
    577  10000 ????		24 40	    var676     =	$2440
    578  10000 ????		24 41	    var677     =	$2441
    579  10000 ????		24 42	    var678     =	$2442
    580  10000 ????		24 43	    var679     =	$2443
    581  10000 ????		24 44	    var680     =	$2444
    582  10000 ????		24 45	    var681     =	$2445
    583  10000 ????		24 46	    var682     =	$2446
    584  10000 ????		24 47	    var683     =	$2447
    585  10000 ????		24 48	    var684     =	$2448
    586  10000 ????		24 49	    var685     =	$2449
    587  10000 ????		24 4a	    var686     =	$244A
    588  10000 ????		24 4b	    var687     =	$244B
    589  10000 ????		24 4c	    var688     =	$244C
    590  10000 ????		24 4d	    var689     =	$244D
    591  10000 ????		24 4e	    var690     =	$244E
    592  10000 ????		24 4f	    var691     =	$244F
    593  10000 ????		24 50	    var692     =	$2450
    594  10000 ????		24 51	    var693     =	$2451
    595  10000 ????		24 52	    var694     =	$2452
    596  10000 ????		24 53	    var695     =	$2453
    597  10000 ????		24 54	    var696     =	$2454
    598  10000 ????		24 55	    var697     =	$2455
    599  10000 ????		24 56	    var698     =	$2456
    600  10000 ????		24 57	    var699     =	$2457
    601  10000 ????		24 58	    var700     =	$2458
    602  10000 ????		24 59	    var701     =	$2459
    603  10000 ????		24 5a	    var702     =	$245A
    604  10000 ????		24 5b	    var703     =	$245B
    605  10000 ????		24 5c	    var704     =	$245C
    606  10000 ????		24 5d	    var705     =	$245D
    607  10000 ????		24 5e	    var706     =	$245E
    608  10000 ????		24 5f	    var707     =	$245F
    609  10000 ????		24 60	    var708     =	$2460
    610  10000 ????		24 61	    var709     =	$2461
    611  10000 ????		24 62	    var710     =	$2462
    612  10000 ????		24 63	    var711     =	$2463
    613  10000 ????		24 64	    var712     =	$2464
    614  10000 ????		24 65	    var713     =	$2465
    615  10000 ????		24 66	    var714     =	$2466
    616  10000 ????		24 67	    var715     =	$2467
    617  10000 ????		24 68	    var716     =	$2468
    618  10000 ????		24 69	    var717     =	$2469
    619  10000 ????		24 6a	    var718     =	$246A
    620  10000 ????		24 6b	    var719     =	$246B
    621  10000 ????		24 6c	    var720     =	$246C
    622  10000 ????		24 6d	    var721     =	$246D
    623  10000 ????		24 6e	    var722     =	$246E
    624  10000 ????		24 6f	    var723     =	$246F
    625  10000 ????		24 70	    var724     =	$2470
    626  10000 ????		24 71	    var725     =	$2471
    627  10000 ????		24 72	    var726     =	$2472
    628  10000 ????		24 73	    var727     =	$2473
    629  10000 ????		24 74	    var728     =	$2474
    630  10000 ????		24 75	    var729     =	$2475
    631  10000 ????		24 76	    var730     =	$2476
    632  10000 ????		24 77	    var731     =	$2477
    633  10000 ????		24 78	    var732     =	$2478
    634  10000 ????		24 79	    var733     =	$2479
    635  10000 ????		24 7a	    var734     =	$247A
    636  10000 ????		24 7b	    var735     =	$247B
    637  10000 ????		24 7c	    var736     =	$247C
    638  10000 ????		24 7d	    var737     =	$247D
    639  10000 ????		24 7e	    var738     =	$247E
    640  10000 ????		24 7f	    var739     =	$247F
    641  10000 ????		24 80	    var740     =	$2480
    642  10000 ????		24 81	    var741     =	$2481
    643  10000 ????		24 82	    var742     =	$2482
    644  10000 ????		24 83	    var743     =	$2483
    645  10000 ????		24 84	    var744     =	$2484
    646  10000 ????		24 85	    var745     =	$2485
    647  10000 ????		24 86	    var746     =	$2486
    648  10000 ????		24 87	    var747     =	$2487
    649  10000 ????		24 88	    var748     =	$2488
    650  10000 ????		24 89	    var749     =	$2489
    651  10000 ????		24 8a	    var750     =	$248A
    652  10000 ????		24 8b	    var751     =	$248B
    653  10000 ????		24 8c	    var752     =	$248C
    654  10000 ????		24 8d	    var753     =	$248D
    655  10000 ????		24 8e	    var754     =	$248E
    656  10000 ????		24 8f	    var755     =	$248F
    657  10000 ????		24 90	    var756     =	$2490
    658  10000 ????		24 91	    var757     =	$2491
    659  10000 ????		24 92	    var758     =	$2492
    660  10000 ????		24 93	    var759     =	$2493
    661  10000 ????		24 94	    var760     =	$2494
    662  10000 ????		24 95	    var761     =	$2495
    663  10000 ????		24 96	    var762     =	$2496
    664  10000 ????		24 97	    var763     =	$2497
    665  10000 ????		24 98	    var764     =	$2498
    666  10000 ????		24 99	    var765     =	$2499
    667  10000 ????		24 9a	    var766     =	$249A
    668  10000 ????		24 9b	    var767     =	$249B
    669  10000 ????		24 9c	    var768     =	$249C
    670  10000 ????		24 9d	    var769     =	$249D
    671  10000 ????		24 9e	    var770     =	$249E
    672  10000 ????		24 9f	    var771     =	$249F
    673  10000 ????		24 a0	    var772     =	$24A0
    674  10000 ????		24 a1	    var773     =	$24A1
    675  10000 ????		24 a2	    var774     =	$24A2
    676  10000 ????		24 a3	    var775     =	$24A3
    677  10000 ????		24 a4	    var776     =	$24A4
    678  10000 ????		24 a5	    var777     =	$24A5
    679  10000 ????		24 a6	    var778     =	$24A6
    680  10000 ????		24 a7	    var779     =	$24A7
    681  10000 ????		24 a8	    var780     =	$24A8
    682  10000 ????		24 a9	    var781     =	$24A9
    683  10000 ????		24 aa	    var782     =	$24AA
    684  10000 ????		24 ab	    var783     =	$24AB
    685  10000 ????		24 ac	    var784     =	$24AC
    686  10000 ????		24 ad	    var785     =	$24AD
    687  10000 ????		24 ae	    var786     =	$24AE
    688  10000 ????		24 af	    var787     =	$24AF
    689  10000 ????		24 b0	    var788     =	$24B0
    690  10000 ????		24 b1	    var789     =	$24B1
    691  10000 ????		24 b2	    var790     =	$24B2
    692  10000 ????		24 b3	    var791     =	$24B3
    693  10000 ????		24 b4	    var792     =	$24B4
    694  10000 ????		24 b5	    var793     =	$24B5
    695  10000 ????		24 b6	    var794     =	$24B6
    696  10000 ????		24 b7	    var795     =	$24B7
    697  10000 ????		24 b8	    var796     =	$24B8
    698  10000 ????		24 b9	    var797     =	$24B9
    699  10000 ????		24 ba	    var798     =	$24BA
    700  10000 ????		24 bb	    var799     =	$24BB
    701  10000 ????		24 bc	    var800     =	$24BC
    702  10000 ????		24 bd	    var801     =	$24BD
    703  10000 ????		24 be	    var802     =	$24BE
    704  10000 ????		24 bf	    var803     =	$24BF
    705  10000 ????		24 c0	    var804     =	$24C0
    706  10000 ????		24 c1	    var805     =	$24C1
    707  10000 ????		24 c2	    var806     =	$24C2
    708  10000 ????		24 c3	    var807     =	$24C3
    709  10000 ????		24 c4	    var808     =	$24C4
    710  10000 ????		24 c5	    var809     =	$24C5
    711  10000 ????		24 c6	    var810     =	$24C6
    712  10000 ????		24 c7	    var811     =	$24C7
    713  10000 ????		24 c8	    var812     =	$24C8
    714  10000 ????		24 c9	    var813     =	$24C9
    715  10000 ????		24 ca	    var814     =	$24CA
    716  10000 ????		24 cb	    var815     =	$24CB
    717  10000 ????		24 cc	    var816     =	$24CC
    718  10000 ????		24 cd	    var817     =	$24CD
    719  10000 ????		24 ce	    var818     =	$24CE
    720  10000 ????		24 cf	    var819     =	$24CF
    721  10000 ????		24 d0	    var820     =	$24D0
    722  10000 ????		24 d1	    var821     =	$24D1
    723  10000 ????		24 d2	    var822     =	$24D2
    724  10000 ????		24 d3	    var823     =	$24D3
    725  10000 ????		24 d4	    var824     =	$24D4
    726  10000 ????		24 d5	    var825     =	$24D5
    727  10000 ????		24 d6	    var826     =	$24D6
    728  10000 ????		24 d7	    var827     =	$24D7
    729  10000 ????		24 d8	    var828     =	$24D8
    730  10000 ????		24 d9	    var829     =	$24D9
    731  10000 ????		24 da	    var830     =	$24DA
    732  10000 ????		24 db	    var831     =	$24DB
    733  10000 ????		24 dc	    var832     =	$24DC
    734  10000 ????		24 dd	    var833     =	$24DD
    735  10000 ????		24 de	    var834     =	$24DE
    736  10000 ????		24 df	    var835     =	$24DF
    737  10000 ????		24 e0	    var836     =	$24E0
    738  10000 ????		24 e1	    var837     =	$24E1
    739  10000 ????		24 e2	    var838     =	$24E2
    740  10000 ????		24 e3	    var839     =	$24E3
    741  10000 ????		24 e4	    var840     =	$24E4
    742  10000 ????		24 e5	    var841     =	$24E5
    743  10000 ????		24 e6	    var842     =	$24E6
    744  10000 ????		24 e7	    var843     =	$24E7
    745  10000 ????		24 e8	    var844     =	$24E8
    746  10000 ????		24 e9	    var845     =	$24E9
    747  10000 ????		24 ea	    var846     =	$24EA
    748  10000 ????		24 eb	    var847     =	$24EB
    749  10000 ????		24 ec	    var848     =	$24EC
    750  10000 ????		24 ed	    var849     =	$24ED
    751  10000 ????		24 ee	    var850     =	$24EE
    752  10000 ????		24 ef	    var851     =	$24EF
    753  10000 ????		24 f0	    var852     =	$24F0
    754  10000 ????		24 f1	    var853     =	$24F1
    755  10000 ????		24 f2	    var854     =	$24F2
    756  10000 ????		24 f3	    var855     =	$24F3
    757  10000 ????		24 f4	    var856     =	$24F4
    758  10000 ????		24 f5	    var857     =	$24F5
    759  10000 ????		24 f6	    var858     =	$24F6
    760  10000 ????		24 f7	    var859     =	$24F7
    761  10000 ????		24 f8	    var860     =	$24F8
    762  10000 ????		24 f9	    var861     =	$24F9
    763  10000 ????		24 fa	    var862     =	$24FA
    764  10000 ????		24 fb	    var863     =	$24FB
    765  10000 ????		24 fc	    var864     =	$24FC
    766  10000 ????		24 fd	    var865     =	$24FD
    767  10000 ????		24 fe	    var866     =	$24FE
    768  10000 ????		24 ff	    var867     =	$24FF
    769  10000 ????		25 00	    var868     =	$2500
    770  10000 ????		25 01	    var869     =	$2501
    771  10000 ????		25 02	    var870     =	$2502
    772  10000 ????		25 03	    var871     =	$2503
    773  10000 ????		25 04	    var872     =	$2504
    774  10000 ????		25 05	    var873     =	$2505
    775  10000 ????		25 06	    var874     =	$2506
    776  10000 ????		25 07	    var875     =	$2507
    777  10000 ????		25 08	    var876     =	$2508
    778  10000 ????		25 09	    var877     =	$2509
    779  10000 ????		25 0a	    var878     =	$250A
    780  10000 ????		25 0b	    var879     =	$250B
    781  10000 ????		25 0c	    var880     =	$250C
    782  10000 ????		25 0d	    var881     =	$250D
    783  10000 ????		25 0e	    var882     =	$250E
    784  10000 ????		25 0f	    var883     =	$250F
    785  10000 ????		25 10	    var884     =	$2510
    786  10000 ????		25 11	    var885     =	$2511
    787  10000 ????		25 12	    var886     =	$2512
    788  10000 ????		25 13	    var887     =	$2513
    789  10000 ????		25 14	    var888     =	$2514
    790  10000 ????		25 15	    var889     =	$2515
    791  10000 ????		25 16	    var890     =	$2516
    792  10000 ????		25 17	    var891     =	$2517
    793  10000 ????		25 18	    var892     =	$2518
    794  10000 ????		25 19	    var893     =	$2519
    795  10000 ????		25 1a	    var894     =	$251A
    796  10000 ????		25 1b	    var895     =	$251B
    797  10000 ????		25 1c	    var896     =	$251C
    798  10000 ????		25 1d	    var897     =	$251D
    799  10000 ????		25 1e	    var898     =	$251E
    800  10000 ????		25 1f	    var899     =	$251F
    801  10000 ????		25 20	    var900     =	$2520
    802  10000 ????		25 21	    var901     =	$2521
    803  10000 ????		25 22	    var902     =	$2522
    804  10000 ????		25 23	    var903     =	$2523
    805  10000 ????		25 24	    var904     =	$2524
    806  10000 ????		25 25	    var905     =	$2525
    807  10000 ????		25 26	    var906     =	$2526
    808  10000 ????		25 27	    var907     =	$2527
    809  10000 ????		25 28	    var908     =	$2528
    810  10000 ????		25 29	    var909     =	$2529
    811  10000 ????		25 2a	    var910     =	$252A
    812  10000 ????		25 2b	    var911     =	$252B
    813  10000 ????		25 2c	    var912     =	$252C
    814  10000 ????		25 2d	    var913     =	$252D
    815  10000 ????		25 2e	    var914     =	$252E
    816  10000 ????		25 2f	    var915     =	$252F
    817  10000 ????		25 30	    var916     =	$2530
    818  10000 ????		25 31	    var917     =	$2531
    819  10000 ????		25 32	    var918     =	$2532
    820  10000 ????		25 33	    var919     =	$2533
    821  10000 ????		25 34	    var920     =	$2534
    822  10000 ????		25 35	    var921     =	$2535
    823  10000 ????		25 36	    var922     =	$2536
    824  10000 ????		25 37	    var923     =	$2537
    825  10000 ????		25 38	    var924     =	$2538
    826  10000 ????		25 39	    var925     =	$2539
    827  10000 ????		25 3a	    var926     =	$253A
    828  10000 ????		25 3b	    var927     =	$253B
    829  10000 ????		25 3c	    var928     =	$253C
    830  10000 ????		25 3d	    var929     =	$253D
    831  10000 ????		25 3e	    var930     =	$253E
    832  10000 ????		25 3f	    var931     =	$253F
    833  10000 ????		25 40	    var932     =	$2540
    834  10000 ????		25 41	    var933     =	$2541
    835  10000 ????		25 42	    var934     =	$2542
    836  10000 ????		25 43	    var935     =	$2543
    837  10000 ????		25 44	    var936     =	$2544
    838  10000 ????		25 45	    var937     =	$2545
    839  10000 ????		25 46	    var938     =	$2546
    840  10000 ????		25 47	    var939     =	$2547
    841  10000 ????		25 48	    var940     =	$2548
    842  10000 ????		25 49	    var941     =	$2549
    843  10000 ????		25 4a	    var942     =	$254A
    844  10000 ????		25 4b	    var943     =	$254B
    845  10000 ????		25 4c	    var944     =	$254C
    846  10000 ????		25 4d	    var945     =	$254D
    847  10000 ????		25 4e	    var946     =	$254E
    848  10000 ????		25 4f	    var947     =	$254F
    849  10000 ????		25 50	    var948     =	$2550
    850  10000 ????		25 51	    var949     =	$2551
    851  10000 ????		25 52	    var950     =	$2552
    852  10000 ????		25 53	    var951     =	$2553
    853  10000 ????		25 54	    var952     =	$2554
    854  10000 ????		25 55	    var953     =	$2555
    855  10000 ????		25 56	    var954     =	$2556
    856  10000 ????		25 57	    var955     =	$2557
    857  10000 ????		25 58	    var956     =	$2558
    858  10000 ????		25 59	    var957     =	$2559
    859  10000 ????		25 5a	    var958     =	$255A
    860  10000 ????		25 5b	    var959     =	$255B
    861  10000 ????		25 5c	    var960     =	$255C
    862  10000 ????		25 5d	    var961     =	$255D
    863  10000 ????		25 5e	    var962     =	$255E
    864  10000 ????		25 5f	    var963     =	$255F
    865  10000 ????		25 60	    var964     =	$2560
    866  10000 ????		25 61	    var965     =	$2561
    867  10000 ????		25 62	    var966     =	$2562
    868  10000 ????		25 63	    var967     =	$2563
    869  10000 ????		25 64	    var968     =	$2564
    870  10000 ????		25 65	    var969     =	$2565
    871  10000 ????		25 66	    var970     =	$2566
    872  10000 ????		25 67	    var971     =	$2567
    873  10000 ????		25 68	    var972     =	$2568
    874  10000 ????		25 69	    var973     =	$2569
    875  10000 ????		25 6a	    var974     =	$256A
    876  10000 ????		25 6b	    var975     =	$256B
    877  10000 ????		25 6c	    var976     =	$256C
    878  10000 ????		25 6d	    var977     =	$256D
    879  10000 ????		25 6e	    var978     =	$256E
    880  10000 ????		25 6f	    var979     =	$256F
    881  10000 ????		25 70	    var980     =	$2570
    882  10000 ????		25 71	    var981     =	$2571
    883  10000 ????		25 72	    var982     =	$2572
    884  10000 ????		25 73	    var983     =	$2573
    885  10000 ????		25 74	    var984     =	$2574
    886  10000 ????		25 75	    var985     =	$2575
    887  10000 ????		25 76	    var986     =	$2576
    888  10000 ????		25 77	    var987     =	$2577
    889  10000 ????		25 78	    var988     =	$2578
    890  10000 ????		25 79	    var989     =	$2579
    891  10000 ????		25 7a	    var990     =	$257A
    892  10000 ????		25 7b	    var991     =	$257B
    893  10000 ????		25 7c	    var992     =	$257C
    894  10000 ????		25 7d	    var993     =	$257D
    895  10000 ????		25 7e	    var994     =	$257E
    896  10000 ????		25 7f	    var995     =	$257F
    897  10000 ????		25 80	    var996     =	$2580
    898  10000 ????		25 81	    var997     =	$2581
    899  10000 ????		25 82	    var998     =	$2582
    900  10000 ????		25 83	    var999     =	$2583
    901  10000 ????		25 84	    var1000    =	$2584
    902  10000 ????		25 85	    var1001    =	$2585
    903  10000 ????		25 86	    var1002    =	$2586
    904  10000 ????		25 87	    var1003    =	$2587
    905  10000 ????		25 88	    var1004    =	$2588
    906  10000 ????		25 89	    var1005    =	$2589
    907  10000 ????		25 8a	    var1006    =	$258A
    908  10000 ????		25 8b	    var1007    =	$258B
    909  10000 ????		25 8c	    var1008    =	$258C
    910  10000 ????		25 8d	    var1009    =	$258D
    911  10000 ????		25 8e	    var1010    =	$258E
    912  10000 ????		25 8f	    var1011    =	$258F
    913  10000 ????		25 90	    var1012    =	$2590
    914  10000 ????		25 91	    var1013    =	$2591
    915  10000 ????		25 92	    var1014    =	$2592
    916  10000 ????		25 93	    var1015    =	$2593
    917  10000 ????		25 94	    var1016    =	$2594
    918  10000 ????		25 95	    var1017    =	$2595
    919  10000 ????		25 96	    var1018    =	$2596
    920  10000 ????		25 97	    var1019    =	$2597
    921  10000 ????		25 98	    var1020    =	$2598
    922  10000 ????		25 99	    var1021    =	$2599
    923  10000 ????		25 9a	    var1022    =	$259A
    924  10000 ????		25 9b	    var1023    =	$259B
    925  10000 ????		25 9c	    var1024    =	$259C
    926  10000 ????		25 9d	    var1025    =	$259D
    927  10000 ????		25 9e	    var1026    =	$259E
    928  10000 ????		25 9f	    var1027    =	$259F
    929  10000 ????		25 a0	    var1028    =	$25A0
    930  10000 ????		25 a1	    var1029    =	$25A1
    931  10000 ????		25 a2	    var1030    =	$25A2
    932  10000 ????		25 a3	    var1031    =	$25A3
    933  10000 ????		25 a4	    var1032    =	$25A4
    934  10000 ????		25 a5	    var1033    =	$25A5
    935  10000 ????		25 a6	    var1034    =	$25A6
    936  10000 ????		25 a7	    var1035    =	$25A7
    937  10000 ????		25 a8	    var1036    =	$25A8
    938  10000 ????		25 a9	    var1037    =	$25A9
    939  10000 ????		25 aa	    var1038    =	$25AA
    940  10000 ????		25 ab	    var1039    =	$25AB
    941  10000 ????		25 ac	    var1040    =	$25AC
    942  10000 ????		25 ad	    var1041    =	$25AD
    943  10000 ????		25 ae	    var1042    =	$25AE
    944  10000 ????		25 af	    var1043    =	$25AF
    945  10000 ????		25 b0	    var1044    =	$25B0
    946  10000 ????		25 b1	    var1045    =	$25B1
    947  10000 ????		25 b2	    var1046    =	$25B2
    948  10000 ????		25 b3	    var1047    =	$25B3
    949  10000 ????		25 b4	    var1048    =	$25B4
    950  10000 ????		25 b5	    var1049    =	$25B5
    951  10000 ????		25 b6	    var1050    =	$25B6
    952  10000 ????		25 b7	    var1051    =	$25B7
    953  10000 ????		25 b8	    var1052    =	$25B8
    954  10000 ????		25 b9	    var1053    =	$25B9
    955  10000 ????		25 ba	    var1054    =	$25BA
    956  10000 ????		25 bb	    var1055    =	$25BB
    957  10000 ????		25 bc	    var1056    =	$25BC
    958  10000 ????		25 bd	    var1057    =	$25BD
    959  10000 ????		25 be	    var1058    =	$25BE
    960  10000 ????		25 bf	    var1059    =	$25BF
    961  10000 ????		25 c0	    var1060    =	$25C0
    962  10000 ????		25 c1	    var1061    =	$25C1
    963  10000 ????		25 c2	    var1062    =	$25C2
    964  10000 ????		25 c3	    var1063    =	$25C3
    965  10000 ????		25 c4	    var1064    =	$25C4
    966  10000 ????		25 c5	    var1065    =	$25C5
    967  10000 ????		25 c6	    var1066    =	$25C6
    968  10000 ????		25 c7	    var1067    =	$25C7
    969  10000 ????		25 c8	    var1068    =	$25C8
    970  10000 ????		25 c9	    var1069    =	$25C9
    971  10000 ????		25 ca	    var1070    =	$25CA
    972  10000 ????		25 cb	    var1071    =	$25CB
    973  10000 ????		25 cc	    var1072    =	$25CC
    974  10000 ????		25 cd	    var1073    =	$25CD
    975  10000 ????		25 ce	    var1074    =	$25CE
    976  10000 ????		25 cf	    var1075    =	$25CF
    977  10000 ????		25 d0	    var1076    =	$25D0
    978  10000 ????		25 d1	    var1077    =	$25D1
    979  10000 ????		25 d2	    var1078    =	$25D2
    980  10000 ????		25 d3	    var1079    =	$25D3
    981  10000 ????		25 d4	    var1080    =	$25D4
    982  10000 ????		25 d5	    var1081    =	$25D5
    983  10000 ????		25 d6	    var1082    =	$25D6
    984  10000 ????		25 d7	    var1083    =	$25D7
    985  10000 ????		25 d8	    var1084    =	$25D8
    986  10000 ????		25 d9	    var1085    =	$25D9
    987  10000 ????		25 da	    var1086    =	$25DA
    988  10000 ????		25 db	    var1087    =	$25DB
    989  10000 ????		25 dc	    var1088    =	$25DC
    990  10000 ????		25 dd	    var1089    =	$25DD
    991  10000 ????		25 de	    var1090    =	$25DE
    992  10000 ????		25 df	    var1091    =	$25DF
    993  10000 ????		25 e0	    var1092    =	$25E0
    994  10000 ????		25 e1	    var1093    =	$25E1
    995  10000 ????		25 e2	    var1094    =	$25E2
    996  10000 ????		25 e3	    var1095    =	$25E3
    997  10000 ????		25 e4	    var1096    =	$25E4
    998  10000 ????		25 e5	    var1097    =	$25E5
    999  10000 ????		25 e6	    var1098    =	$25E6
   1000  10000 ????		25 e7	    var1099    =	$25E7
   1001  10000 ????		25 e8	    var1100    =	$25E8
   1002  10000 ????		25 e9	    var1101    =	$25E9
   1003  10000 ????		25 ea	    var1102    =	$25EA
   1004  10000 ????		25 eb	    var1103    =	$25EB
   1005  10000 ????		25 ec	    var1104    =	$25EC
   1006  10000 ????		25 ed	    var1105    =	$25ED
   1007  10000 ????		25 ee	    var1106    =	$25EE
   1008  10000 ????		25 ef	    var1107    =	$25EF
   1009  10000 ????		25 f0	    var1108    =	$25F0
   1010  10000 ????		25 f1	    var1109    =	$25F1
   1011  10000 ????		25 f2	    var1110    =	$25F2
   1012  10000 ????		25 f3	    var1111    =	$25F3
   1013  10000 ????		25 f4	    var1112    =	$25F4
   1014  10000 ????		25 f5	    var1113    =	$25F5
   1015  10000 ????		25 f6	    var1114    =	$25F6
   1016  10000 ????		25 f7	    var1115    =	$25F7
   1017  10000 ????		25 f8	    var1116    =	$25F8
   1018  10000 ????		25 f9	    var1117    =	$25F9
   1019  10000 ????		25 fa	    var1118    =	$25FA
   1020  10000 ????		25 fb	    var1119    =	$25FB
   1021  10000 ????		25 fc	    var1120    =	$25FC
   1022  10000 ????		25 fd	    var1121    =	$25FD
   1023  10000 ????		25 fe	    var1122    =	$25FE
   1024  10000 ????		25 ff	    var1123    =	$25FF
   1025  10000 ????		26 00	    var1124    =	$2600
   1026  10000 ????		26 01	    var1125    =	$2601
   1027  10000 ????		26 02	    var1126    =	$2602
   1028  10000 ????		26 03	    var1127    =	$2603
   1029  10000 ????		26 04	    var1128    =	$2604
   1030  10000 ????		26 05	    var1129    =	$2605
   1031  10000 ????		26 06	    var1130    =	$2606
   1032  10000 ????		26 07	    var1131    =	$2607
   1033  10000 ????		26 08	    var1132    =	$2608
   1034  10000 ????		26 09	    var1133    =	$2609
   1035  10000 ????		26 0a	    var1134    =	$260A
   1036  10000 ????		26 0b	    var1135    =	$260B
   1037  10000 ????		26 0c	    var1136    =	$260C
   1038  10000 ????		26 0d	    var1137    =	$260D
   1039  10000 ????		26 0e	    var1138    =	$260E
   1040  10000 ????		26 0f	    var1139    =	$260F
   1041  10000 ????		26 10	    var1140    =	$2610
   1042  10000 ????		26 11	    var1141    =	$2611
   1043  10000 ????		26 12	    var1142    =	$2612
   1044  10000 ????		26 13	    var1143    =	$2613
   1045  10000 ????		26 14	    var1144    =	$2614
   1046  10000 ????		26 15	    var1145    =	$2615
   1047  10000 ????		26 16	    var1146    =	$2616
   1048  10000 ????		26 17	    var1147    =	$2617
   1049  10000 ????		26 18	    var1148    =	$2618
   1050  10000 ????		26 19	    var1149    =	$2619
   1051  10000 ????		26 1a	    var1150    =	$261A
   1052  10000 ????		26 1b	    var1151    =	$261B
   1053  10000 ????		26 1c	    var1152    =	$261C
   1054  10000 ????		26 1d	    var1153    =	$261D
   1055  10000 ????		26 1e	    var1154    =	$261E
   1056  10000 ????		26 1f	    var1155    =	$261F
   1057  10000 ????		26 20	    var1156    =	$2620
   1058  10000 ????		26 21	    var1157    =	$2621
   1059  10000 ????		26 22	    var1158    =	$2622
   1060  10000 ????		26 23	    var1159    =	$2623
   1061  10000 ????		26 24	    var1160    =	$2624
   1062  10000 ????		26 25	    var1161    =	$2625
   1063  10000 ????		26 26	    var1162    =	$2626
   1064  10000 ????		26 27	    var1163    =	$2627
   1065  10000 ????		26 28	    var1164    =	$2628
   1066  10000 ????		26 29	    var1165    =	$2629
   1067  10000 ????		26 2a	    var1166    =	$262A
   1068  10000 ????		26 2b	    var1167    =	$262B
   1069  10000 ????		26 2c	    var1168    =	$262C
   1070  10000 ????		26 2d	    var1169    =	$262D
   1071  10000 ????		26 2e	    var1170    =	$262E
   1072  10000 ????		26 2f	    var1171    =	$262F
   1073  10000 ????		26 30	    var1172    =	$2630
   1074  10000 ????		26 31	    var1173    =	$2631
   1075  10000 ????		26 32	    var1174    =	$2632
   1076  10000 ????		26 33	    var1175    =	$2633
   1077  10000 ????		26 34	    var1176    =	$2634
   1078  10000 ????		26 35	    var1177    =	$2635
   1079  10000 ????		26 36	    var1178    =	$2636
   1080  10000 ????		26 37	    var1179    =	$2637
   1081  10000 ????		26 38	    var1180    =	$2638
   1082  10000 ????		26 39	    var1181    =	$2639
   1083  10000 ????		26 3a	    var1182    =	$263A
   1084  10000 ????		26 3b	    var1183    =	$263B
   1085  10000 ????		26 3c	    var1184    =	$263C
   1086  10000 ????		26 3d	    var1185    =	$263D
   1087  10000 ????		26 3e	    var1186    =	$263E
   1088  10000 ????		26 3f	    var1187    =	$263F
   1089  10000 ????		26 40	    var1188    =	$2640
   1090  10000 ????		26 41	    var1189    =	$2641
   1091  10000 ????		26 42	    var1190    =	$2642
   1092  10000 ????		26 43	    var1191    =	$2643
   1093  10000 ????		26 44	    var1192    =	$2644
   1094  10000 ????		26 45	    var1193    =	$2645
   1095  10000 ????		26 46	    var1194    =	$2646
   1096  10000 ????		26 47	    var1195    =	$2647
   1097  10000 ????		26 48	    var1196    =	$2648
   1098  10000 ????		26 49	    var1197    =	$2649
   1099  10000 ????		26 4a	    var1198    =	$264A
   1100  10000 ????		26 4b	    var1199    =	$264B
   1101  10000 ????		26 4c	    var1200    =	$264C
   1102  10000 ????		26 4d	    var1201    =	$264D
   1103  10000 ????		26 4e	    var1202    =	$264E
   1104  10000 ????		26 4f	    var1203    =	$264F
   1105  10000 ????		26 50	    var1204    =	$2650
   1106  10000 ????		26 51	    var1205    =	$2651
   1107  10000 ????		26 52	    var1206    =	$2652
   1108  10000 ????		26 53	    var1207    =	$2653
   1109  10000 ????		26 54	    var1208    =	$2654
   1110  10000 ????		26 55	    var1209    =	$2655
   1111  10000 ????		26 56	    var1210    =	$2656
   1112  10000 ????		26 57	    var1211    =	$2657
   1113  10000 ????		26 58	    var1212    =	$2658
   1114  10000 ????		26 59	    var1213    =	$2659
   1115  10000 ????		26 5a	    var1214    =	$265A
   1116  10000 ????		26 5b	    var1215    =	$265B
   1117  10000 ????		26 5c	    var1216    =	$265C
   1118  10000 ????		26 5d	    var1217    =	$265D
   1119  10000 ????		26 5e	    var1218    =	$265E
   1120  10000 ????		26 5f	    var1219    =	$265F
   1121  10000 ????		26 60	    var1220    =	$2660
   1122  10000 ????		26 61	    var1221    =	$2661
   1123  10000 ????		26 62	    var1222    =	$2662
   1124  10000 ????		26 63	    var1223    =	$2663
   1125  10000 ????		26 64	    var1224    =	$2664
   1126  10000 ????		26 65	    var1225    =	$2665
   1127  10000 ????		26 66	    var1226    =	$2666
   1128  10000 ????		26 67	    var1227    =	$2667
   1129  10000 ????		26 68	    var1228    =	$2668
   1130  10000 ????		26 69	    var1229    =	$2669
   1131  10000 ????		26 6a	    var1230    =	$266A
   1132  10000 ????		26 6b	    var1231    =	$266B
   1133  10000 ????		26 6c	    var1232    =	$266C
   1134  10000 ????		26 6d	    var1233    =	$266D
   1135  10000 ????		26 6e	    var1234    =	$266E
   1136  10000 ????		26 6f	    var1235    =	$266F
   1137  10000 ????		26 70	    var1236    =	$2670
   1138  10000 ????		26 71	    var1237    =	$2671
   1139  10000 ????		26 72	    var1238    =	$2672
   1140  10000 ????		26 73	    var1239    =	$2673
   1141  10000 ????		26 74	    var1240    =	$2674
   1142  10000 ????		26 75	    var1241    =	$2675
   1143  10000 ????		26 76	    var1242    =	$2676
   1144  10000 ????		26 77	    var1243    =	$2677
   1145  10000 ????		26 78	    var1244    =	$2678
   1146  10000 ????		26 79	    var1245    =	$2679
   1147  10000 ????		26 7a	    var1246    =	$267A
   1148  10000 ????		26 7b	    var1247    =	$267B
   1149  10000 ????		26 7c	    var1248    =	$267C
   1150  10000 ????		26 7d	    var1249    =	$267D
   1151  10000 ????		26 7e	    var1250    =	$267E
   1152  10000 ????		26 7f	    var1251    =	$267F
   1153  10000 ????		26 80	    var1252    =	$2680
   1154  10000 ????		26 81	    var1253    =	$2681
   1155  10000 ????		26 82	    var1254    =	$2682
   1156  10000 ????		26 83	    var1255    =	$2683
   1157  10000 ????		26 84	    var1256    =	$2684
   1158  10000 ????		26 85	    var1257    =	$2685
   1159  10000 ????		26 86	    var1258    =	$2686
   1160  10000 ????		26 87	    var1259    =	$2687
   1161  10000 ????		26 88	    var1260    =	$2688
   1162  10000 ????		26 89	    var1261    =	$2689
   1163  10000 ????		26 8a	    var1262    =	$268A
   1164  10000 ????		26 8b	    var1263    =	$268B
   1165  10000 ????		26 8c	    var1264    =	$268C
   1166  10000 ????		26 8d	    var1265    =	$268D
   1167  10000 ????		26 8e	    var1266    =	$268E
   1168  10000 ????		26 8f	    var1267    =	$268F
   1169  10000 ????		26 90	    var1268    =	$2690
   1170  10000 ????		26 91	    var1269    =	$2691
   1171  10000 ????		26 92	    var1270    =	$2692
   1172  10000 ????		26 93	    var1271    =	$2693
   1173  10000 ????		26 94	    var1272    =	$2694
   1174  10000 ????		26 95	    var1273    =	$2695
   1175  10000 ????		26 96	    var1274    =	$2696
   1176  10000 ????		26 97	    var1275    =	$2697
   1177  10000 ????		26 98	    var1276    =	$2698
   1178  10000 ????		26 99	    var1277    =	$2699
   1179  10000 ????		26 9a	    var1278    =	$269A
   1180  10000 ????		26 9b	    var1279    =	$269B
   1181  10000 ????		26 9c	    var1280    =	$269C
   1182  10000 ????		26 9d	    var1281    =	$269D
   1183  10000 ????		26 9e	    var1282    =	$269E
   1184  10000 ????		26 9f	    var1283    =	$269F
   1185  10000 ????		26 a0	    var1284    =	$26A0
   1186  10000 ????		26 a1	    var1285    =	$26A1
   1187  10000 ????		26 a2	    var1286    =	$26A2
   1188  10000 ????		26 a3	    var1287    =	$26A3
   1189  10000 ????		26 a4	    var1288    =	$26A4
   1190  10000 ????		26 a5	    var1289    =	$26A5
   1191  10000 ????		26 a6	    var1290    =	$26A6
   1192  10000 ????		26 a7	    var1291    =	$26A7
   1193  10000 ????		26 a8	    var1292    =	$26A8
   1194  10000 ????		26 a9	    var1293    =	$26A9
   1195  10000 ????		26 aa	    var1294    =	$26AA
   1196  10000 ????		26 ab	    var1295    =	$26AB
   1197  10000 ????		26 ac	    var1296    =	$26AC
   1198  10000 ????		26 ad	    var1297    =	$26AD
   1199  10000 ????		26 ae	    var1298    =	$26AE
   1200  10000 ????		26 af	    var1299    =	$26AF
   1201  10000 ????		26 b0	    var1300    =	$26B0
   1202  10000 ????		26 b1	    var1301    =	$26B1
   1203  10000 ????		26 b2	    var1302    =	$26B2
   1204  10000 ????		26 b3	    var1303    =	$26B3
   1205  10000 ????		26 b4	    var1304    =	$26B4
   1206  10000 ????		26 b5	    var1305    =	$26B5
   1207  10000 ????		26 b6	    var1306    =	$26B6
   1208  10000 ????		26 b7	    var1307    =	$26B7
   1209  10000 ????		26 b8	    var1308    =	$26B8
   1210  10000 ????		26 b9	    var1309    =	$26B9
   1211  10000 ????		26 ba	    var1310    =	$26BA
   1212  10000 ????		26 bb	    var1311    =	$26BB
   1213  10000 ????		26 bc	    var1312    =	$26BC
   1214  10000 ????		26 bd	    var1313    =	$26BD
   1215  10000 ????		26 be	    var1314    =	$26BE
   1216  10000 ????		26 bf	    var1315    =	$26BF
   1217  10000 ????		26 c0	    var1316    =	$26C0
   1218  10000 ????		26 c1	    var1317    =	$26C1
   1219  10000 ????		26 c2	    var1318    =	$26C2
   1220  10000 ????		26 c3	    var1319    =	$26C3
   1221  10000 ????		26 c4	    var1320    =	$26C4
   1222  10000 ????		26 c5	    var1321    =	$26C5
   1223  10000 ????		26 c6	    var1322    =	$26C6
   1224  10000 ????		26 c7	    var1323    =	$26C7
   1225  10000 ????		26 c8	    var1324    =	$26C8
   1226  10000 ????		26 c9	    var1325    =	$26C9
   1227  10000 ????		26 ca	    var1326    =	$26CA
   1228  10000 ????		26 cb	    var1327    =	$26CB
   1229  10000 ????		26 cc	    var1328    =	$26CC
   1230  10000 ????		26 cd	    var1329    =	$26CD
   1231  10000 ????		26 ce	    var1330    =	$26CE
   1232  10000 ????		26 cf	    var1331    =	$26CF
   1233  10000 ????		26 d0	    var1332    =	$26D0
   1234  10000 ????		26 d1	    var1333    =	$26D1
   1235  10000 ????		26 d2	    var1334    =	$26D2
   1236  10000 ????		26 d3	    var1335    =	$26D3
   1237  10000 ????		26 d4	    var1336    =	$26D4
   1238  10000 ????		26 d5	    var1337    =	$26D5
   1239  10000 ????		26 d6	    var1338    =	$26D6
   1240  10000 ????		26 d7	    var1339    =	$26D7
   1241  10000 ????		26 d8	    var1340    =	$26D8
   1242  10000 ????		26 d9	    var1341    =	$26D9
   1243  10000 ????		26 da	    var1342    =	$26DA
   1244  10000 ????		26 db	    var1343    =	$26DB
   1245  10000 ????		26 dc	    var1344    =	$26DC
   1246  10000 ????		26 dd	    var1345    =	$26DD
   1247  10000 ????		26 de	    var1346    =	$26DE
   1248  10000 ????		26 df	    var1347    =	$26DF
   1249  10000 ????		26 e0	    var1348    =	$26E0
   1250  10000 ????		26 e1	    var1349    =	$26E1
   1251  10000 ????		26 e2	    var1350    =	$26E2
   1252  10000 ????		26 e3	    var1351    =	$26E3
   1253  10000 ????		26 e4	    var1352    =	$26E4
   1254  10000 ????		26 e5	    var1353    =	$26E5
   1255  10000 ????		26 e6	    var1354    =	$26E6
   1256  10000 ????		26 e7	    var1355    =	$26E7
   1257  10000 ????		26 e8	    var1356    =	$26E8
   1258  10000 ????		26 e9	    var1357    =	$26E9
   1259  10000 ????		26 ea	    var1358    =	$26EA
   1260  10000 ????		26 eb	    var1359    =	$26EB
   1261  10000 ????		26 ec	    var1360    =	$26EC
   1262  10000 ????		26 ed	    var1361    =	$26ED
   1263  10000 ????		26 ee	    var1362    =	$26EE
   1264  10000 ????		26 ef	    var1363    =	$26EF
   1265  10000 ????		26 f0	    var1364    =	$26F0
   1266  10000 ????		26 f1	    var1365    =	$26F1
   1267  10000 ????		26 f2	    var1366    =	$26F2
   1268  10000 ????		26 f3	    var1367    =	$26F3
   1269  10000 ????		26 f4	    var1368    =	$26F4
   1270  10000 ????		26 f5	    var1369    =	$26F5
   1271  10000 ????		26 f6	    var1370    =	$26F6
   1272  10000 ????		26 f7	    var1371    =	$26F7
   1273  10000 ????		26 f8	    var1372    =	$26F8
   1274  10000 ????		26 f9	    var1373    =	$26F9
   1275  10000 ????		26 fa	    var1374    =	$26FA
   1276  10000 ????		26 fb	    var1375    =	$26FB
   1277  10000 ????		26 fc	    var1376    =	$26FC
   1278  10000 ????		26 fd	    var1377    =	$26FD
   1279  10000 ????		26 fe	    var1378    =	$26FE
   1280  10000 ????		26 ff	    var1379    =	$26FF
   1281  10000 ????		27 00	    var1380    =	$2700
   1282  10000 ????		27 01	    var1381    =	$2701
   1283  10000 ????		27 02	    var1382    =	$2702
   1284  10000 ????		27 03	    var1383    =	$2703
   1285  10000 ????		27 04	    var1384    =	$2704
   1286  10000 ????		27 05	    var1385    =	$2705
   1287  10000 ????		27 06	    var1386    =	$2706
   1288  10000 ????		27 07	    var1387    =	$2707
   1289  10000 ????		27 08	    var1388    =	$2708
   1290  10000 ????		27 09	    var1389    =	$2709
   1291  10000 ????		27 0a	    var1390    =	$270A
   1292  10000 ????		27 0b	    var1391    =	$270B
   1293  10000 ????		27 0c	    var1392    =	$270C
   1294  10000 ????		27 0d	    var1393    =	$270D
   1295  10000 ????		27 0e	    var1394    =	$270E
   1296  10000 ????		27 0f	    var1395    =	$270F
   1297  10000 ????		27 10	    var1396    =	$2710
   1298  10000 ????		27 11	    var1397    =	$2711
   1299  10000 ????		27 12	    var1398    =	$2712
   1300  10000 ????		27 13	    var1399    =	$2713
   1301  10000 ????		27 14	    var1400    =	$2714
   1302  10000 ????		27 15	    var1401    =	$2715
   1303  10000 ????		27 16	    var1402    =	$2716
   1304  10000 ????		27 17	    var1403    =	$2717
   1305  10000 ????		27 18	    var1404    =	$2718
   1306  10000 ????		27 19	    var1405    =	$2719
   1307  10000 ????		27 1a	    var1406    =	$271A
   1308  10000 ????		27 1b	    var1407    =	$271B
   1309  10000 ????		27 1c	    var1408    =	$271C
   1310  10000 ????		27 1d	    var1409    =	$271D
   1311  10000 ????		27 1e	    var1410    =	$271E
   1312  10000 ????		27 1f	    var1411    =	$271F
   1313  10000 ????		27 20	    var1412    =	$2720
   1314  10000 ????		27 21	    var1413    =	$2721
   1315  10000 ????		27 22	    var1414    =	$2722
   1316  10000 ????		27 23	    var1415    =	$2723
   1317  10000 ????		27 24	    var1416    =	$2724
   1318  10000 ????		27 25	    var1417    =	$2725
   1319  10000 ????		27 26	    var1418    =	$2726
   1320  10000 ????		27 27	    var1419    =	$2727
   1321  10000 ????		27 28	    var1420    =	$2728
   1322  10000 ????		27 29	    var1421    =	$2729
   1323  10000 ????		27 2a	    var1422    =	$272A
   1324  10000 ????		27 2b	    var1423    =	$272B
   1325  10000 ????		27 2c	    var1424    =	$272C
   1326  10000 ????		27 2d	    var1425    =	$272D
   1327  10000 ????		27 2e	    var1426    =	$272E
   1328  10000 ????		27 2f	    var1427    =	$272F
   1329  10000 ????		27 30	    var1428    =	$2730
   1330  10000 ????		27 31	    var1429    =	$2731
   1331  10000 ????		27 32	    var1430    =	$2732
   1332  10000 ????		27 33	    var1431    =	$2733
   1333  10000 ????		27 34	    var1432    =	$2734
   1334  10000 ????		27 35	    var1433    =	$2735
   1335  10000 ????		27 36	    var1434    =	$2736
   1336  10000 ????		27 37	    var1435    =	$2737
   1337  10000 ????		27 38	    var1436    =	$2738
   1338  10000 ????		27 39	    var1437    =	$2739
   1339  10000 ????		27 3a	    var1438    =	$273A
   1340  10000 ????		27 3b	    var1439    =	$273B
   1341  10000 ????		27 3c	    var1440    =	$273C
   1342  10000 ????		27 3d	    var1441    =	$273D
   1343  10000 ????		27 3e	    var1442    =	$273E
   1344  10000 ????		27 3f	    var1443    =	$273F
   1345  10000 ????		27 40	    var1444    =	$2740
   1346  10000 ????		27 41	    var1445    =	$2741
   1347  10000 ????		27 42	    var1446    =	$2742
   1348  10000 ????		27 43	    var1447    =	$2743
   1349  10000 ????		27 44	    var1448    =	$2744
   1350  10000 ????		27 45	    var1449    =	$2745
   1351  10000 ????		27 46	    var1450    =	$2746
   1352  10000 ????		27 47	    var1451    =	$2747
   1353  10000 ????		27 48	    var1452    =	$2748
   1354  10000 ????		27 49	    var1453    =	$2749
   1355  10000 ????		27 4a	    var1454    =	$274A
   1356  10000 ????		27 4b	    var1455    =	$274B
   1357  10000 ????		27 4c	    var1456    =	$274C
   1358  10000 ????		27 4d	    var1457    =	$274D
   1359  10000 ????		27 4e	    var1458    =	$274E
   1360  10000 ????		27 4f	    var1459    =	$274F
   1361  10000 ????		27 50	    var1460    =	$2750
   1362  10000 ????		27 51	    var1461    =	$2751
   1363  10000 ????		27 52	    var1462    =	$2752
   1364  10000 ????		27 53	    var1463    =	$2753
   1365  10000 ????		27 54	    var1464    =	$2754
   1366  10000 ????		27 55	    var1465    =	$2755
   1367  10000 ????		27 56	    var1466    =	$2756
   1368  10000 ????		27 57	    var1467    =	$2757
   1369  10000 ????		27 58	    var1468    =	$2758
   1370  10000 ????		27 59	    var1469    =	$2759
   1371  10000 ????		27 5a	    var1470    =	$275A
   1372  10000 ????		27 5b	    var1471    =	$275B
   1373  10000 ????		27 5c	    var1472    =	$275C
   1374  10000 ????		27 5d	    var1473    =	$275D
   1375  10000 ????		27 5e	    var1474    =	$275E
   1376  10000 ????		27 5f	    var1475    =	$275F
   1377  10000 ????		27 60	    var1476    =	$2760
   1378  10000 ????		27 61	    var1477    =	$2761
   1379  10000 ????		27 62	    var1478    =	$2762
   1380  10000 ????		27 63	    var1479    =	$2763
   1381  10000 ????		27 64	    var1480    =	$2764
   1382  10000 ????		27 65	    var1481    =	$2765
   1383  10000 ????		27 66	    var1482    =	$2766
   1384  10000 ????		27 67	    var1483    =	$2767
   1385  10000 ????		27 68	    var1484    =	$2768
   1386  10000 ????		27 69	    var1485    =	$2769
   1387  10000 ????		27 6a	    var1486    =	$276A
   1388  10000 ????		27 6b	    var1487    =	$276B
   1389  10000 ????		27 6c	    var1488    =	$276C
   1390  10000 ????		27 6d	    var1489    =	$276D
   1391  10000 ????		27 6e	    var1490    =	$276E
   1392  10000 ????		27 6f	    var1491    =	$276F
   1393  10000 ????		27 70	    var1492    =	$2770
   1394  10000 ????		27 71	    var1493    =	$2771
   1395  10000 ????		27 72	    var1494    =	$2772
   1396  10000 ????		27 73	    var1495    =	$2773
   1397  10000 ????		27 74	    var1496    =	$2774
   1398  10000 ????		27 75	    var1497    =	$2775
   1399  10000 ????		27 76	    var1498    =	$2776
   1400  10000 ????		27 77	    var1499    =	$2777
   1401  10000 ????		27 78	    var1500    =	$2778
   1402  10000 ????		27 79	    var1501    =	$2779
   1403  10000 ????		27 7a	    var1502    =	$277A
   1404  10000 ????		27 7b	    var1503    =	$277B
   1405  10000 ????		27 7c	    var1504    =	$277C
   1406  10000 ????		27 7d	    var1505    =	$277D
   1407  10000 ????		27 7e	    var1506    =	$277E
   1408  10000 ????		27 7f	    var1507    =	$277F
   1409  10000 ????		27 80	    var1508    =	$2780
   1410  10000 ????		27 81	    var1509    =	$2781
   1411  10000 ????		27 82	    var1510    =	$2782
   1412  10000 ????		27 83	    var1511    =	$2783
   1413  10000 ????		27 84	    var1512    =	$2784
   1414  10000 ????		27 85	    var1513    =	$2785
   1415  10000 ????		27 86	    var1514    =	$2786
   1416  10000 ????		27 87	    var1515    =	$2787
   1417  10000 ????		27 88	    var1516    =	$2788
   1418  10000 ????		27 89	    var1517    =	$2789
   1419  10000 ????		27 8a	    var1518    =	$278A
   1420  10000 ????		27 8b	    var1519    =	$278B
   1421  10000 ????		27 8c	    var1520    =	$278C
   1422  10000 ????		27 8d	    var1521    =	$278D
   1423  10000 ????		27 8e	    var1522    =	$278E
   1424  10000 ????		27 8f	    var1523    =	$278F
   1425  10000 ????		27 90	    var1524    =	$2790
   1426  10000 ????		27 91	    var1525    =	$2791
   1427  10000 ????		27 92	    var1526    =	$2792
   1428  10000 ????		27 93	    var1527    =	$2793
   1429  10000 ????		27 94	    var1528    =	$2794
   1430  10000 ????		27 95	    var1529    =	$2795
   1431  10000 ????		27 96	    var1530    =	$2796
   1432  10000 ????		27 97	    var1531    =	$2797
   1433  10000 ????		27 98	    var1532    =	$2798
   1434  10000 ????		27 99	    var1533    =	$2799
   1435  10000 ????		27 9a	    var1534    =	$279A
   1436  10000 ????		27 9b	    var1535    =	$279B
   1437  10000 ????		27 9c	    var1536    =	$279C
   1438  10000 ????		27 9d	    var1537    =	$279D
   1439  10000 ????		27 9e	    var1538    =	$279E
   1440  10000 ????		27 9f	    var1539    =	$279F
   1441  10000 ????		27 a0	    var1540    =	$27A0
   1442  10000 ????		27 a1	    var1541    =	$27A1
   1443  10000 ????		27 a2	    var1542    =	$27A2
   1444  10000 ????		27 a3	    var1543    =	$27A3
   1445  10000 ????		27 a4	    var1544    =	$27A4
   1446  10000 ????		27 a5	    var1545    =	$27A5
   1447  10000 ????		27 a6	    var1546    =	$27A6
   1448  10000 ????		27 a7	    var1547    =	$27A7
   1449  10000 ????		27 a8	    var1548    =	$27A8
   1450  10000 ????		27 a9	    var1549    =	$27A9
   1451  10000 ????		27 aa	    var1550    =	$27AA
   1452  10000 ????		27 ab	    var1551    =	$27AB
   1453  10000 ????		27 ac	    var1552    =	$27AC
   1454  10000 ????		27 ad	    var1553    =	$27AD
   1455  10000 ????		27 ae	    var1554    =	$27AE
   1456  10000 ????		27 af	    var1555    =	$27AF
   1457  10000 ????		27 b0	    var1556    =	$27B0
   1458  10000 ????		27 b1	    var1557    =	$27B1
   1459  10000 ????		27 b2	    var1558    =	$27B2
   1460  10000 ????		27 b3	    var1559    =	$27B3
   1461  10000 ????		27 b4	    var1560    =	$27B4
   1462  10000 ????		27 b5	    var1561    =	$27B5
   1463  10000 ????		27 b6	    var1562    =	$27B6
   1464  10000 ????		27 b7	    var1563    =	$27B7
   1465  10000 ????		27 b8	    var1564    =	$27B8
   1466  10000 ????		27 b9	    var1565    =	$27B9
   1467  10000 ????		27 ba	    var1566    =	$27BA
   1468  10000 ????		27 bb	    var1567    =	$27BB
   1469  10000 ????		27 bc	    var1568    =	$27BC
   1470  10000 ????		27 bd	    var1569    =	$27BD
   1471  10000 ????		27 be	    var1570    =	$27BE
   1472  10000 ????		27 bf	    var1571    =	$27BF
   1473  10000 ????		27 c0	    var1572    =	$27C0
   1474  10000 ????		27 c1	    var1573    =	$27C1
   1475  10000 ????		27 c2	    var1574    =	$27C2
   1476  10000 ????		27 c3	    var1575    =	$27C3
   1477  10000 ????		27 c4	    var1576    =	$27C4
   1478  10000 ????		27 c5	    var1577    =	$27C5
   1479  10000 ????		27 c6	    var1578    =	$27C6
   1480  10000 ????		27 c7	    var1579    =	$27C7
   1481  10000 ????		27 c8	    var1580    =	$27C8
   1482  10000 ????		27 c9	    var1581    =	$27C9
   1483  10000 ????		27 ca	    var1582    =	$27CA
   1484  10000 ????		27 cb	    var1583    =	$27CB
   1485  10000 ????		27 cc	    var1584    =	$27CC
   1486  10000 ????		27 cd	    var1585    =	$27CD
   1487  10000 ????		27 ce	    var1586    =	$27CE
   1488  10000 ????		27 cf	    var1587    =	$27CF
   1489  10000 ????		27 d0	    var1588    =	$27D0
   1490  10000 ????		27 d1	    var1589    =	$27D1
   1491  10000 ????		27 d2	    var1590    =	$27D2
   1492  10000 ????		27 d3	    var1591    =	$27D3
   1493  10000 ????		27 d4	    var1592    =	$27D4
   1494  10000 ????		27 d5	    var1593    =	$27D5
   1495  10000 ????		27 d6	    var1594    =	$27D6
   1496  10000 ????		27 d7	    var1595    =	$27D7
   1497  10000 ????		27 d8	    var1596    =	$27D8
   1498  10000 ????		27 d9	    var1597    =	$27D9
   1499  10000 ????		27 da	    var1598    =	$27DA
   1500  10000 ????		27 db	    var1599    =	$27DB
   1501  10000 ????		27 dc	    var1600    =	$27DC
   1502  10000 ????		27 dd	    var1601    =	$27DD
   1503  10000 ????		27 de	    var1602    =	$27DE
   1504  10000 ????		27 df	    var1603    =	$27DF
   1505  10000 ????		27 e0	    var1604    =	$27E0
   1506  10000 ????		27 e1	    var1605    =	$27E1
   1507  10000 ????		27 e2	    var1606    =	$27E2
   1508  10000 ????		27 e3	    var1607    =	$27E3
   1509  10000 ????		27 e4	    var1608    =	$27E4
   1510  10000 ????		27 e5	    var1609    =	$27E5
   1511  10000 ????		27 e6	    var1610    =	$27E6
   1512  10000 ????		27 e7	    var1611    =	$27E7
   1513  10000 ????		27 e8	    var1612    =	$27E8
   1514  10000 ????		27 e9	    var1613    =	$27E9
   1515  10000 ????		27 ea	    var1614    =	$27EA
   1516  10000 ????		27 eb	    var1615    =	$27EB
   1517  10000 ????		27 ec	    var1616    =	$27EC
   1518  10000 ????		27 ed	    var1617    =	$27ED
   1519  10000 ????		27 ee	    var1618    =	$27EE
   1520  10000 ????		27 ef	    var1619    =	$27EF
   1521  10000 ????		27 f0	    var1620    =	$27F0
   1522  10000 ????		27 f1	    var1621    =	$27F1
   1523  10000 ????		27 f2	    var1622    =	$27F2
   1524  10000 ????		27 f3	    var1623    =	$27F3
   1525  10000 ????		27 f4	    var1624    =	$27F4
   1526  10000 ????		27 f5	    var1625    =	$27F5
   1527  10000 ????		27 f6	    var1626    =	$27F6
   1528  10000 ????		27 f7	    var1627    =	$27F7
   1529  10000 ????		27 f8	    var1628    =	$27F8
   1530  10000 ????		27 f9	    var1629    =	$27F9
   1531  10000 ????		27 fa	    var1630    =	$27FA
   1532  10000 ????		27 fb	    var1631    =	$27FB
   1533  10000 ????		27 fc	    var1632    =	$27FC
   1534  10000 ????		27 fd	    var1633    =	$27FD
   1535  10000 ????		27 fe	    var1634    =	$27FE
   1536  10000 ????		27 ff	    var1635    =	$27FF
------- FILE constants.78b.asm
   1474  10000 ????
   1475  10000 ????						; BEADHEADER... disabled for now
   1476  10000 ????						; A BEAD header gets automatically incorportated into the ROM header.
   1477  10000 ????						; For more BEAD executable info, check out the spec...
   1478  10000 ????						; http://7800.8bitdev.org/index.php/The_Atari_7800_BEAD_Execuable_Specification
   1479  10000 ????
   1480  10000 ????		00 01	    GAMEDESCRIPTIONSET =	1
   1481  10000 ????		4e 61 6d 65 GAMEDESCRIPTION =	"Test Name"
   1482  10000 ????
   1483  10000 ????
   1484  10000 ????		00 40	    BDHSC      =	%01000000
   1485  10000 ????		00 20	    BDYM       =	%00100000
   1486  10000 ????		00 10	    BDPOKEY    =	%00010000
   1487  10000 ????		00 08	    BDROF      =	%00001000
   1488  10000 ????		00 00	    BD16K      =	%00000000
   1489  10000 ????		00 01	    BD32K      =	%00000001
   1490  10000 ????		00 02	    BD48K      =	%00000010
   1491  10000 ????		00 05	    BD1800     =	%00000101
   1492  10000 ????		00 06	    BD4000     =	%00000110
   1493  10000 ????
   1494  10000 ????			   -	       ifconst	BEADHEADER
   1495  10000 ????			   -BEADHARDWARE SET	0
   1496  10000 ????			   -	       ifconst	ROM16K
   1497  10000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD16K)
   1498  10000 ????			   -	       endif
   1499  10000 ????			   -	       ifconst	ROM32K
   1500  10000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD32K)
   1501  10000 ????			   -	       endif
   1502  10000 ????			   -	       ifconst	ROM48K
   1503  10000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BD48K)
   1504  10000 ????			   -	       endif
   1505  10000 ????			   -	       ifconst	pokeysupport
   1506  10000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDPOKEY)
   1507  10000 ????			   -	       endif
   1508  10000 ????			   -	       ifconst	HSSUPPORT
   1509  10000 ????			   -BEADHARDWARE SET	(BEADHARDWARE|BDHSC)
   1510  10000 ????			   -	       endif
   1511  10000 ????				       endif
   1512  10000 ????
   1513  10000 ????						;start address of cart...
   1514  10000 ????
   1515  10000 ????			    BANK_WAS_SET SET	0
   1516  10000 ????
   1517  10000 ????			   -	       ifconst	ROM8K
   1518  10000 ????			   -	       ORG	$E000,0
   1519  10000 ????			   -BANK_WAS_SET SET	1
   1520  10000 ????				       endif		; ROM8K
   1521  10000 ????
   1522  10000 ????			   -	       ifconst	ROM16K
   1523  10000 ????			   -	       ORG	$C000,0
   1524  10000 ????			   -BANK_WAS_SET SET	1
   1525  10000 ????			   -	       ifconst	BEADHEADER
   1526  10000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
   1527  10000 ????			   -	       ifconst	GAMEDESCRIPTION
   1528  10000 ????			   -	       CLC
   1529  10000 ????			   -	       BCC	_SKIPDESCRIPTION
   1530  10000 ????			   -	       .byte	GAMEDESCRIPTION,0
   1531  10000 ????			   -_SKIPDESCRIPTION
   1532  10000 ????			   -	       endif		; GAMEDESCRIPTION
   1533  10000 ????			   -	       jmp	($FFFC)
   1534  10000 ????			   -	       endif		; BEADHEADER
   1535  10000 ????				       endif		; ROM16K
   1536  10000 ????
   1537  10000 ????			   -	       ifconst	ROM32K
   1538  10000 ????			   -	       ORG	$8000,0
   1539  10000 ????			   -BANK_WAS_SET SET	1
   1540  10000 ????			   -	       ifconst	BEADHEADER
   1541  10000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
   1542  10000 ????			   -	       ifconst	GAMEDESCRIPTION
   1543  10000 ????			   -	       CLC
   1544  10000 ????			   -	       BCC	_SKIPDESCRIPTION
   1545  10000 ????			   -	       .byte	GAMEDESCRIPTION,0
   1546  10000 ????			   -_SKIPDESCRIPTION
   1547  10000 ????			   -	       endif		; GAMEDESCRIPTION
   1548  10000 ????			   -	       jmp	($FFFC)
   1549  10000 ????			   -	       endif		; BEADHEADER
   1550  10000 ????				       endif		; ROM32K
   1551  10000 ????
   1552  10000 ????			   -	       ifconst	ROM48K
   1553  10000 ????			   -	       ORG	$4000,0
   1554  10000 ????			   -BANK_WAS_SET SET	1
   1555  10000 ????			   -	       ifconst	BEADHEADER
   1556  10000 ????			   -	       .byte	$BE,$AD,BEADHARDWARE
   1557  10000 ????			   -	       ifconst	GAMEDESCRIPTIONSET
   1558  10000 ????			   -	       CLC
   1559  10000 ????			   -	       BCC	_SKIPDESCRIPTION
   1560  10000 ????			   -	       .byte	GAMEDESCRIPTION,0
   1561  10000 ????			   -_SKIPDESCRIPTION
   1562  10000 ????			   -	       endif		; GAMEDESCRIPTIONSET
   1563  10000 ????			   -	       jmp	($FFFC)
   1564  10000 ????			   -	       endif		; BEADHEADER
   1565  10000 ????				       endif		; ROM48K
   1566  10000 ????
   1567  10000 ????			   -	       ifconst	ROM52K
   1568  10000 ????			   -BANK_WAS_SET SET	1
   1569  10000 ????			   -	       ORG	$3000,0
   1570  10000 ????				       endif		; ROM52K
   1571  10000 ????
   1572  10000 ????			   -	       ifconst	bankswitchmode
   1573  10000 ????			   -	       ifconst	ROMAT4K
   1574  10000 ????			   -BANK_WAS_SET SET	1
   1575  10000 ????			   -	       ORG	$4000,0
   1576  10000 ????			   -	       RORG	$4000
   1577  10000 ????			   -	       else		; ROMAT4K
   1578  10000 ????			   -BANK_WAS_SET SET	1
   1579  10000 ????			   -	       ORG	$8000,0
   1580  10000 ????			   -	       RORG	$8000
   1581  10000 ????			   -	       endif
   1582  10000 ????				       endif
   1583  10000 ????
   1584  10000 ????				       if	BANK_WAS_SET = 0
   1585  8000					      ORG	$8000,0	; default is 32K
   1586  8000					      endif
   1587  8000
   1588  8000				   START_OF_ROM SET	.
   1589  8000				   SPACEOVERFLOW SET	0
   1590  8000				  -	      ifnconst	SPACEOVERFLOWPASS
   1591  8000				  -SPACEOVERFLOWPASS SET	0
   1592  8000					      endif	SPACEOVERFLOWPASS
   1593  8000				   game
   1594  8000				   .
   1595  8000							;;line 1;;
   1596  8000
   1597  8000				   .
   1598  8000							;;line 2;;
   1599  8000
   1600  8000				   .
   1601  8000							;;line 3;;
   1602  8000
   1603  8000				   .L00 		;;line 4;;	    incbasic objects.78b
   1604  8000
   1605  8000				   .L01 		;;line 2;;
   1606  8000
   1607  8000				   .L02 		;;line 3;;  const TYPE_TORCH = 1
   1608  8000
   1609  8000				   .L03 		;;line 4;;  const TYPE_WOLF = 2
   1610  8000
   1611  8000				   .L04 		;;line 5;;  const TYPE_WARG = 3
   1612  8000
   1613  8000				   .L05 		;;line 6;;  const TYPE_NIX = 4
   1614  8000
   1615  8000				   .L06 		;;line 7;;  const TYPE_MERMAN = TYPE_NIX
   1616  8000
   1617  8000				   .L07 		;;line 8;;  const TYPE_OCTOPUS = 5
   1618  8000
   1619  8000				   .L08 		;;line 9;;  const TYPE_SLIME = 6
   1620  8000
   1621  8000				   .L09 		;;line 10;;  const TYPE_MSLIME = 7
   1622  8000
   1623  8000				   .L010		;;line 11;;  const TYPE_RAVEN = 8
   1624  8000
   1625  8000				   .L011		;;line 12;;  const TYPE_PRIEST = 9
   1626  8000
   1627  8000				   .L012		;;line 13;;  const TYPE_SKELETON = 10
   1628  8000
   1629  8000				   .L013		;;line 14;;  const TYPE_RSLIME = 11
   1630  8000
   1631  8000				   .L014		;;line 15;;  const TYPE_MRSLIME = 12
   1632  8000
   1633  8000				   .L015		;;line 16;;  const TYPE_GHOST = 13
   1634  8000
   1635  8000				   .L016		;;line 17;;  const TYPE_RGHOST = 14
   1636  8000
   1637  8000				   .L017		;;line 18;;  const TYPE_SPAWNER = 128
   1638  8000
   1639  8000				   .L018		;;line 19;;  const TYPE_SKELSWORD = 129
   1640  8000
   1641  8000				   .L019		;;line 20;;  const TYPE_PROJECTILE = TYPE_SKELSWORD
   1642  8000
   1643  8000				   .L020		;;line 21;;  const TYPE_DARKSPARK = 140
   1644  8000
   1645  8000				   .L021		;;line 22;;  const TYPE_OCTOINK = 141
   1646  8000
   1647  8000				   .L022		;;line 23;;  const TYPE_FIREBALL = 150
   1648  8000
   1649  8000				   .L023		;;line 24;;  const TYPE_F_FAIRY = 151
   1650  8000
   1651  8000				   .L024		;;line 25;;  const TYPE_STATIC = TYPE_BLOOD
   1652  8000
   1653  8000				   .L025		;;line 26;;  const TYPE_BLOOD = 160
   1654  8000
   1655  8000				   .L026		;;line 27;;  const TYPE_DOOR_OPEN = 161
   1656  8000
   1657  8000				   .L027		;;line 28;;  const TYPE_DOOR = 162
   1658  8000
   1659  8000				   .L028		;;line 29;;  const TYPE_DOOR_LOCK = 163
   1660  8000
   1661  8000				   .L029		;;line 30;;  const TYPE_COIN = 164
   1662  8000
   1663  8000				   .L030		;;line 31;;  const TYPE_PRISM = 165
   1664  8000
   1665  8000				   .L031		;;line 32;;  const TYPE_FOOD = 166
   1666  8000
   1667  8000				   .L032		;;line 33;;  const TYPE_MAP1 = 170
   1668  8000
   1669  8000				   .L033		;;line 34;;  const TYPE_MAP2 = 171
   1670  8000
   1671  8000				   .L034		;;line 35;;  const TYPE_MAP3 = 172
   1672  8000
   1673  8000				   .L035		;;line 36;;  const TYPE_MAP4 = 173
   1674  8000
   1675  8000				   .L036		;;line 37;;  const TYPE_MAP5 = 174
   1676  8000
   1677  8000				   .L037		;;line 38;;  const TYPE_KEY1 = 175
   1678  8000
   1679  8000				   .L038		;;line 39;;  const TYPE_KEY2 = 176
   1680  8000
   1681  8000				   .L039		;;line 40;;  const TYPE_KEY3 = 177
   1682  8000
   1683  8000				   .L040		;;line 41;;  const TYPE_KEY4 = 178
   1684  8000
   1685  8000				   .L041		;;line 42;;  const TYPE_KEY5 = 179
   1686  8000
   1687  8000				   .L042		;;line 43;;  const TYPE_SPELL1 = 180
   1688  8000
   1689  8000				   .L043		;;line 44;;  const TYPE_SPELL2 = 181
   1690  8000
   1691  8000				   .L044		;;line 45;;  const TYPE_SPELL3 = 182
   1692  8000
   1693  8000				   .L045		;;line 46;;  const TYPE_SPELL4 = 183
   1694  8000
   1695  8000				   .L046		;;line 47;;  const TYPE_SPELL5 = 184
   1696  8000
   1697  8000				   .L047		;;line 48;;  const TYPE_SPELL6 = 185
   1698  8000
   1699  8000				   .L048		;;line 49;;  const TYPE_SPELL7 = 186
   1700  8000
   1701  8000				   .L049		;;line 50;;  const TYPE_SPELL8 = 187
   1702  8000
   1703  8000				   .L050		;;line 51;;  const TYPE_SPELL9 = 188
   1704  8000
   1705  8000				   .L051		;;line 52;;  const TYPE_SPELL10 = 189
   1706  8000
   1707  8000				   .L052		;;line 53;;  const TYPE_ITEM1 = 190
   1708  8000
   1709  8000				   .L053		;;line 54;;  const TYPE_ITEM2 = 191
   1710  8000
   1711  8000				   .L054		;;line 55;;  const TYPE_ITEM3 = 192
   1712  8000
   1713  8000				   .L055		;;line 56;;  const TYPE_ITEM4 = 193
   1714  8000
   1715  8000				   .L056		;;line 57;;  const TYPE_ITEM5 = 194
   1716  8000
   1717  8000				   .L057		;;line 58;;  const TYPE_ITEM6 = 195
   1718  8000
   1719  8000				   .L058		;;line 59;;  const TYPE_ITEM7 = 196
   1720  8000
   1721  8000				   .L059		;;line 60;;  const TYPE_ITEM8 = 197
   1722  8000
   1723  8000				   .L060		;;line 61;;  const TYPE_ITEM9 = 198
   1724  8000
   1725  8000				   .L061		;;line 62;;  const TYPE_ITEM10 = 199
   1726  8000
   1727  8000				   .
   1728  8000							;;line 63;;
   1729  8000
   1730  8000				   .L062		;;line 64;;  const TYPE_POTION = TYPE_ITEM1
   1731  8000
   1732  8000				   .L063		;;line 65;;  const TYPE_HIPOTION = TYPE_ITEM2
   1733  8000
   1734  8000				   .L064		;;line 66;;  const TYPE_ETHER = TYPE_ITEM3
   1735  8000
   1736  8000				   .L065		;;line 67;;  const TYPE_HIETHER = TYPE_ITEM4
   1737  8000
   1738  8000				   .L066		;;line 68;;  const TYPE_ELIXIR = TYPE_ITEM5
   1739  8000
   1740  8000				   .L067		;;line 69;;  const TYPE_ANTIDOTE = TYPE_ITEM6
   1741  8000
   1742  8000				   .L068		;;line 70;;  const TYPE_EYEDROP = TYPE_ITEM7
   1743  8000
   1744  8000				   .L069		;;line 71;;  const TYPE_UNCURSE = TYPE_ITEM8
   1745  8000
   1746  8000				   .L070		;;line 72;;  const TYPE_SOFT = TYPE_ITEM9
   1747  8000
   1748  8000				   .L071		;;line 73;;  const TYPE_LIFEAPPLE = TYPE_ITEM10
   1749  8000
   1750  8000				   .L072		;;line 74;;  const TYPE_RELIC1 = 200
   1751  8000
   1752  8000				   .L073		;;line 75;;  const TYPE_RELIC2 = 201
   1753  8000
   1754  8000				   .L074		;;line 76;;  const TYPE_RELIC3 = 202
   1755  8000
   1756  8000				   .L075		;;line 77;;  const TYPE_RELIC4 = 203
   1757  8000
   1758  8000				   .L076		;;line 78;;  const TYPE_RELIC5 = 204
   1759  8000
   1760  8000				   .L077		;;line 79;;  const TYPE_RELIC6 = 205
   1761  8000
   1762  8000				   .L078		;;line 80;;  const TYPE_RELIC7 = 206
   1763  8000
   1764  8000				   .L079		;;line 81;;  const TYPE_RELIC8 = 207
   1765  8000
   1766  8000				   .L080		;;line 82;;  const TYPE_RELIC9 = 208
   1767  8000
   1768  8000				   .L081		;;line 83;;  const TYPE_RELIC10 = 209
   1769  8000
   1770  8000				   .
   1771  8000							;;line 84;;
   1772  8000
   1773  8000				   .L082		;;line 85;;  const TYPE_FAIRYCARD = TYPE_RELIC1
   1774  8000
   1775  8000				   .L083		;;line 86;;  const TYPE_CATCARD = TYPE_RELIC2
   1776  8000
   1777  8000				   .L084		;;line 87;;  const TYPE_GHOSTCARD = TYPE_RELIC3
   1778  8000
   1779  8000				   .L085		;;line 88;;  const TYPE_OWLCARD = TYPE_RELIC4
   1780  8000
   1781  8000				   .L086		;;line 89;;  const TYPE_BESTIARY = TYPE_RELIC5
   1782  8000
   1783  8000				   .L087		;;line 90;;  const TYPE_NIXTAIL = TYPE_RELIC6
   1784  8000
   1785  8000				   .L088		;;line 91;;  const TYPE_WATERFALL = TYPE_RELIC7
   1786  8000
   1787  8000				   .L089		;;line 92;;  const TYPE_SWORD1 = 210
   1788  8000
   1789  8000				   .L090		;;line 93;;  const TYPE_SWORD2 = 211
   1790  8000
   1791  8000				   .L091		;;line 94;;  const TYPE_SWORD3 = 212
   1792  8000
   1793  8000				   .L092		;;line 95;;  const TYPE_SWORD4 = 213
   1794  8000
   1795  8000				   .L093		;;line 96;;  const TYPE_SWORD5 = 214
   1796  8000
   1797  8000				   .L094		;;line 97;;  const TYPE_SWORD6 = 215
   1798  8000
   1799  8000				   .L095		;;line 98;;  const TYPE_SWORD7 = 216
   1800  8000
   1801  8000				   .L096		;;line 99;;  const TYPE_SWORD8 = 217
   1802  8000
   1803  8000				   .L097		;;line 100;;  const TYPE_SWORD9 = 218
   1804  8000
   1805  8000				   .L098		;;line 101;;  const TYPE_SWORD10 = 219
   1806  8000
   1807  8000				   .
   1808  8000							;;line 102;;
   1809  8000
   1810  8000				   .L099		;;line 103;;  const TYPE_RAPIER = TYPE_SWORD1
   1811  8000
   1812  8000				   .L0100		;;line 104;;  const TYPE_BONE_SCIM = TYPE_SWORD2
   1813  8000
   1814  8000				   .L0101		;;line 105;;  const TYPE_SHIELD1 = 220
   1815  8000
   1816  8000				   .L0102		;;line 106;;  const TYPE_SHIELD2 = 221
   1817  8000
   1818  8000				   .L0103		;;line 107;;  const TYPE_SHIELD3 = 222
   1819  8000
   1820  8000				   .L0104		;;line 108;;  const TYPE_SHIELD4 = 223
   1821  8000
   1822  8000				   .L0105		;;line 109;;  const TYPE_SHIELD5 = 224
   1823  8000
   1824  8000				   .L0106		;;line 110;;  const TYPE_SHIELD6 = 225
   1825  8000
   1826  8000				   .L0107		;;line 111;;  const TYPE_SHIELD7 = 226
   1827  8000
   1828  8000				   .L0108		;;line 112;;  const TYPE_SHIELD8 = 227
   1829  8000
   1830  8000				   .L0109		;;line 113;;  const TYPE_SHIELD9 = 228
   1831  8000
   1832  8000				   .L0110		;;line 114;;  const TYPE_SHIELD10 = 229
   1833  8000
   1834  8000				   .L0111		;;line 115;;  const TYPE_ARMOR1 = 230
   1835  8000
   1836  8000				   .L0112		;;line 116;;  const TYPE_ARMOR2 = 231
   1837  8000
   1838  8000				   .L0113		;;line 117;;  const TYPE_ARMOR3 = 232
   1839  8000
   1840  8000				   .L0114		;;line 118;;  const TYPE_ARMOR4 = 233
   1841  8000
   1842  8000				   .L0115		;;line 119;;  const TYPE_ARMOR5 = 234
   1843  8000
   1844  8000				   .L0116		;;line 120;;  const TYPE_ARMOR6 = 235
   1845  8000
   1846  8000				   .L0117		;;line 121;;  const TYPE_ARMOR7 = 236
   1847  8000
   1848  8000				   .L0118		;;line 122;;  const TYPE_ARMOR8 = 237
   1849  8000
   1850  8000				   .L0119		;;line 123;;  const TYPE_ARMOR9 = 238
   1851  8000
   1852  8000				   .L0120		;;line 124;;  const TYPE_ARMOR10 = 239
   1853  8000
   1854  8000				   .L0121		;;line 125;;  const TYPE_CHARM1 = 240
   1855  8000
   1856  8000				   .L0122		;;line 126;;  const TYPE_CHARM2 = 241
   1857  8000
   1858  8000				   .L0123		;;line 127;;  const TYPE_CHARM3 = 242
   1859  8000
   1860  8000				   .L0124		;;line 128;;  const TYPE_CHARM4 = 243
   1861  8000
   1862  8000				   .L0125		;;line 129;;  const TYPE_CHARM5 = 244
   1863  8000
   1864  8000				   .L0126		;;line 130;;  const TYPE_CHARM6 = 245
   1865  8000
   1866  8000				   .L0127		;;line 131;;  const TYPE_CHARM7 = 246
   1867  8000
   1868  8000				   .L0128		;;line 132;;  const TYPE_CHARM8 = 247
   1869  8000
   1870  8000				   .L0129		;;line 133;;  const TYPE_CHARM9 = 248
   1871  8000
   1872  8000				   .L0130		;;line 134;;  const TYPE_CHARM10 = 249
   1873  8000
   1874  8000				   .
   1875  8000							;;line 135;;
   1876  8000
   1877  8000				   .
   1878  8000							;;line 136;;
   1879  8000
   1880  8000				   .L0131		;;line 137;;  const RARE_DROP_RATE = 254
   1881  8000
   1882  8000				   .L0132		;;line 138;;  const COMMON_DROP_RATE = 192
   1883  8000
   1884  8000				   .
   1885  8000							;;line 139;;
   1886  8000
   1887  8000				   .
   1888  8000							;;line 140;;
   1889  8000
   1890  8000				   .L0133		;;line 141;;  const WOLF_SPEED_HI = 1
   1891  8000
   1892  8000				   .L0134		;;line 142;;  const WOLF_SPEED_LO = 0
   1893  8000
   1894  8000				   .L0135		;;line 143;;  const WOLF_HP = 2
   1895  8000
   1896  8000				   .L0136		;;line 144;;  const WOLF_VEL_CAP_HI = 1
   1897  8000
   1898  8000				   .L0137		;;line 145;;  const WOLF_VEL_CAP_LO = 0
   1899  8000
   1900  8000				   .L0138		;;line 146;;  const WOLF_FRICTION_HI = 1
   1901  8000
   1902  8000				   .L0139		;;line 147;;  const WOLF_FRICTION_LO = 0
   1903  8000
   1904  8000				   .L0140		;;line 148;;  const WOLF_DAMAGE = 1
   1905  8000
   1906  8000				   .L0141		;;line 149;;  const WOLF_DEF = 0
   1907  8000
   1908  8000				   .L0142		;;line 150;;  const WOLF_MDEF = 2
   1909  8000
   1910  8000				   .L0143		;;line 151;;  const WOLF_DROP_RATE = 64
   1911  8000
   1912  8000				   .L0144		;;line 152;;  const WOLF_CHASE_DIST = 32
   1913  8000
   1914  8000				   .L0145		;;line 153;;  const WOLF_CHASE_DIST_X = 48
   1915  8000
   1916  8000				   .L0146		;;line 154;;  const WOLF_CHASE_DIST_Y = 64
   1917  8000
   1918  8000				   .L0147		;;line 155;;  const WOLF_CHASE_OFFSET_X = WOLF_CHASE_DIST_X  /  2
   1919  8000
   1920  8000				   .L0148		;;line 156;;  const WOLF_CHASE_OFFSET_Y = WOLF_CHASE_DIST_Y  /  2
   1921  8000
   1922  8000				   .
   1923  8000							;;line 157;;
   1924  8000
   1925  8000				   .L0149		;;line 158;;  const SLIME_DROP_RATE = 128
   1926  8000
   1927  8000				   .L0150		;;line 159;;  const SLIME_HP = 4
   1928  8000
   1929  8000				   .L0151		;;line 160;;  const MSLIME_HP = SLIME_HP  /  2
   1930  8000
   1931  8000				   .L0152		;;line 161;;  const SLIME_VEL_CAP_HI = 1
   1932  8000
   1933  8000				   .L0153		;;line 162;;  const SLIME_VEL_CAP_LO = 0
   1934  8000
   1935  8000				   .L0154		;;line 163;;  const SLIME_DAMAGE = 4
   1936  8000
   1937  8000				   .L0155		;;line 164;;  const SLIME_DEF = 255
   1938  8000
   1939  8000				   .L0156		;;line 165;;  const SLIME_MDEF = 0
   1940  8000
   1941  8000				   .L0157		;;line 166;;  const MSLIME_DEF = 0
   1942  8000
   1943  8000				   .L0158		;;line 167;;  const MSLIME_MDEF = 0
   1944  8000
   1945  8000				   .L0159		;;line 168;;  const SLIME_FRICTION_HI = 1
   1946  8000
   1947  8000				   .L0160		;;line 169;;  const SLIME_FRICTION_LO = 0
   1948  8000
   1949  8000				   .L0161		;;line 170;;  const SLIME_SPEED_HI = 0
   1950  8000
   1951  8000				   .L0162		;;line 171;;  const SLIME_SPEED_LO = 5
   1952  8000
   1953  8000				   .
   1954  8000							;;line 172;;
   1955  8000
   1956  8000				   .L0163		;;line 173;;  const RAVEN_CHASE_DIST = 50
   1957  8000
   1958  8000				   .L0164		;;line 174;;  const RAVEN_FLIGHT_TIME = 10
   1959  8000
   1960  8000				   .L0165		;;line 175;;  const RAVEN_DROP_RATE = 128
   1961  8000
   1962  8000				   .L0166		;;line 176;;  const RAVEN_HP = 4
   1963  8000
   1964  8000				   .L0167		;;line 177;;  const RAVEN_VEL_CAP_HI = 2
   1965  8000
   1966  8000				   .L0168		;;line 178;;  const RAVEN_VEL_CAP_LO = 0
   1967  8000
   1968  8000				   .L0169		;;line 179;;  const RAVEN_DAMAGE = 4
   1969  8000
   1970  8000				   .L0170		;;line 180;;  const RAVEN_FRICTION_HI = 0
   1971  8000
   1972  8000				   .L0171		;;line 181;;  const RAVEN_FRICTION_LO = 0
   1973  8000
   1974  8000				   .L0172		;;line 182;;  const RAVEN_SPEED_HI = 1
   1975  8000
   1976  8000				   .L0173		;;line 183;;  const RAVEN_SPEED_LO = 0
   1977  8000
   1978  8000				   .L0174		;;line 184;;  const RAVEN_DEF = 0
   1979  8000
   1980  8000				   .L0175		;;line 185;;  const RAVEN_MDEF = 0
   1981  8000
   1982  8000				   .
   1983  8000							;;line 186;;
   1984  8000
   1985  8000				   .L0176		;;line 187;;  const PRIEST_WALK_TIMER = 20
   1986  8000
   1987  8000				   .L0177		;;line 188;;  const PRIEST_CAST_FRAMES = 20
   1988  8000
   1989  8000				   .
   1990  8000							;;line 189;;
   1991  8000
   1992  8000				   .L0178		;;line 190;;  const DARKSPARK_SPEED_HI = 2
   1993  8000
   1994  8000				   .L0179		;;line 191;;  const DARKSPARK_SPEED_LO = 0
   1995  8000
   1996  8000				   .L0180		;;line 192;;  const DARKSPARK_DAMAGE = 6
   1997  8000
   1998  8000				   .
   1999  8000							;;line 193;;
   2000  8000
   2001  8000				   .L0181		;;line 194;;  const SKELSWORD_DAMAGE = 3
   2002  8000
   2003  8000				   .L0182		;;line 195;;  const RETRACT_FRAMES = 4
   2004  8000
   2005  8000				   .
   2006  8000							;;line 196;;
   2007  8000
   2008  8000				   .L0183		;;line 197;;  const RSLIME_DROP_RATE = 128
   2009  8000
   2010  8000				   .L0184		;;line 198;;  const RSLIME_HP = 4
   2011  8000
   2012  8000				   .L0185		;;line 199;;  const MRSLIME_HP = RSLIME_HP  /	2
   2013  8000
   2014  8000				   .L0186		;;line 200;;  const RSLIME_VEL_CAP_HI = 1
   2015  8000
   2016  8000				   .L0187		;;line 201;;  const RSLIME_VEL_CAP_LO = 0
   2017  8000
   2018  8000				   .L0188		;;line 202;;  const RSLIME_DAMAGE = 2
   2019  8000
   2020  8000				   .L0189		;;line 203;;  const RSLIME_DEF = 255
   2021  8000
   2022  8000				   .L0190		;;line 204;;  const RSLIME_MDEF = 0
   2023  8000
   2024  8000				   .L0191		;;line 205;;  const MRSLIME_DEF = 0
   2025  8000
   2026  8000				   .L0192		;;line 206;;  const MRSLIME_MDEF = 0
   2027  8000
   2028  8000				   .L0193		;;line 207;;  const RSLIME_FRICTION_HI = 1
   2029  8000
   2030  8000				   .L0194		;;line 208;;  const RSLIME_FRICTION_LO = 0
   2031  8000
   2032  8000				   .L0195		;;line 209;;  const RSLIME_SPEED_HI = 0
   2033  8000
   2034  8000				   .L0196		;;line 210;;  const RSLIME_SPEED_LO = 5
   2035  8000
   2036  8000				   .
   2037  8000							;;line 211;;
   2038  8000
   2039  8000				   .
   2040  8000							;;line 212;;
   2041  8000
   2042  8000				   .L0197		;;line 213;;  const F_NIX_EMERGE = 0
   2043  8000
   2044  8000				   .L0198		;;line 214;;  const F_NIX_ATTACK = 1
   2045  8000
   2046  8000				   .L0199		;;line 215;;  const F_NIX_TAIL = 2
   2047  8000
   2048  8000				   .L0200		;;line 216;;  const F_NIX_TAIL2 = 3
   2049  8000
   2050  8000				   .L0201		;;line 217;;  const F_NIX_SHADOW = 4
   2051  8000
   2052  8000				   .L0202		;;line 218;;  const F_NIX_BLANK = 5
   2053  8000
   2054  8000				   .
   2055  8000							;;line 219;;
   2056  8000
   2057  8000				   .L0203		;;line 220;;  const NIX_WIDTH = 28
   2058  8000
   2059  8000				   .L0204		;;line 221;;  const NIX_HEIGHT = 40
   2060  8000
   2061  8000				   .L0205		;;line 222;;  const NIX_RANGE_X = 53
   2062  8000
   2063  8000				   .L0206		;;line 223;;  const NIX_RANGE_Y = 74
   2064  8000
   2065  8000				   .L0207		;;line 224;;  const NIX_OFFSET_X = NIX_RANGE_X  /  2
   2066  8000
   2067  8000				   .L0208		;;line 225;;  const NIX_OFFSET_Y = NIX_RANGE_Y  /  2
   2068  8000
   2069  8000				   .
   2070  8000							;;line 226;;
   2071  8000
   2072  8000				   .L0209		;;line 227;;  const NIX_ATK_TIME = 20
   2073  8000
   2074  8000				   .L0210		;;line 228;;  const NIX_ATK2_TIME = 20
   2075  8000
   2076  8000				   .L0211		;;line 229;;  const NIX_TAIL_TIME = 20
   2077  8000
   2078  8000				   .
   2079  8000							;;line 230;;
   2080  8000
   2081  8000				   .L0212		;;line 231;;  const OCTOPUS_HP = 4
   2082  8000
   2083  8000				   .L0213		;;line 232;;  const OCTOPUS_POP_TIMER = 60
   2084  8000
   2085  8000				   .L0214		;;line 233;;  const OCTOPUS_SWIM_TIMER = 20
   2086  8000
   2087  8000				   .L0215		;;line 234;;  const OCTOPUS_SHOOT_FRAMES = 30
   2088  8000
   2089  8000				   .
   2090  8000							;;line 235;;
   2091  8000
   2092  8000				   .L0216		;;line 236;;  const OCTO_PAL = 2
   2093  8000
   2094  8000				   .L0217		;;line 237;;  const OCTO_SHADOW_PAL = 4
   2095  8000
   2096  8000				   .
   2097  8000							;;line 238;;
   2098  8000
   2099  8000				   .L0218		;;line 239;;  const F_OCTO_SHADOW = 0
   2100  8000
   2101  8000				   .L0219		;;line 240;;  const F_OCTO_POP = 1
   2102  8000
   2103  8000				   .L0220		;;line 241;;  const F_OCTO_POP_2 = 2
   2104  8000
   2105  8000				   .L0221		;;line 242;;  const F_OCTO_SHOOT_D = 3
   2106  8000
   2107  8000				   .L0222		;;line 243;;  const F_OCTO_SHOOT_U = 4
   2108  8000
   2109  8000				   .L0223		;;line 244;;  const F_OCTO_SHOOT_L = 6
   2110  8000
   2111  8000				   .L0224		;;line 245;;  const F_OCTO_SHOOT_R = 5
   2112  8000
   2113  8000				   .
   2114  8000							;;line 246;;
   2115  8000
   2116  8000				   .L0225		;;line 247;;  const OCTOINK_SPEED_HI = 2
   2117  8000
   2118  8000				   .L0226		;;line 248;;  const OCTOINK_SPEED_LO = 0
   2119  8000
   2120  8000				   .L0227		;;line 249;;  const OCTOINK_DAMAGE = 6
   2121  8000
   2122  8000				   .
   2123  8000							;;line 250;;
   2124  8000
   2125  8000				   .
   2126  8000							;;line 251;;
   2127  8000
   2128  8000				   .
   2129  8000							;;line 252;;
   2130  8000
   2131  8000				   .L0228		;;line 253;;  const FAIRY_SPEED_HI = 1
   2132  8000
   2133  8000				   .L0229		;;line 254;;  const FAIRY_SPEED_LO = 0
   2134  8000
   2135  8000				   .L0230		;;line 255;;  const FAIRY_HP = 255
   2136  8000
   2137  8000				   .L0231		;;line 256;;  const FAIRY_VEL_CAP_HI = 1
   2138  8000
   2139  8000				   .L0232		;;line 257;;  const FAIRY_VEL_CAP_LO = 128
   2140  8000
   2141  8000				   .L0233		;;line 258;;  const FAIRY_FRICTION_HI = 0
   2142  8000
   2143  8000				   .L0234		;;line 259;;  const FAIRY_FRICTION_LO = 128
   2144  8000
   2145  8000				   .L0235		;;line 260;;  const FAIRY_DAMAGE = 0
   2146  8000
   2147  8000				   .L0236		;;line 261;;  const FAIRY_DEF = 255
   2148  8000
   2149  8000				   .L0237		;;line 262;;  const FAIRY_MDEF = 255
   2150  8000
   2151  8000				   .
   2152  8000							;;line 263;;
   2153  8000
   2154  8000				   .L0238		;;line 264;;  const F_FAIRY_WING1 = 0
   2155  8000
   2156  8000				   .L0239		;;line 265;;  const F_FAIRY_WING2 = 1
   2157  8000
   2158  8000				   .L0240		;;line 266;;  const F_FAIRY_ITEM1 = 2
   2159  8000
   2160  8000				   .L0241		;;line 267;;  const F_FAIRY_ITEM2 = 3
   2161  8000
   2162  8000				   .
   2163  8000							;;line 268;;
   2164  8000
   2165  8000				   .L0242		;;line 269;;  const FAIRY_CHASE_X = 40
   2166  8000
   2167  8000				   .L0243		;;line 270;;  const FAIRY_CHASE_Y = 54
   2168  8000
   2169  8000				   .
   2170  8000							;;line 271;;
   2171  8000
   2172  8000				   .L0244		;;line 272;;  const FIREBALL_SPEED_HI = 2
   2173  8000
   2174  8000				   .L0245		;;line 273;;  const FIREBALL_SPEED_LO = 0
   2175  8000
   2176  8000				   .L0246		;;line 274;;  const FIREBALL_DAMAGE = 2
   2177  8000
   2178  8000				   .L0247		;;line 275;;  const FIREBALL_MP_COST = 8
   2179  8000
   2180  8000				   .L0248		;;line 276;;  const FIREBALL_MAX_FRAMES = 4
   2181  8000
   2182  8000				   .
   2183  8000							;;line 277;;
   2184  8000
   2185  8000				   .
   2186  8000							;;line 278;;
   2187  8000
   2188  8000				   .L0249		;;line 279;;  const torch_ai_lo = # < .torch_tile_block
   2189  8000
   2190  8000				   .L0250		;;line 280;;  const torch_ai_hi = # > .torch_tile_block
   2191  8000
   2192  8000				   .L0251		;;line 281;;  const wolf_ai_lo = # < .wolf_ai
   2193  8000
   2194  8000				   .L0252		;;line 282;;  const wolf_ai_hi = # > .wolf_ai
   2195  8000
   2196  8000				   .L0253		;;line 283;;  const warg_ai_lo = # < .warg_ai
   2197  8000
   2198  8000				   .L0254		;;line 284;;  const warg_ai_hi = # > .warg_ai
   2199  8000
   2200  8000				   .L0255		;;line 285;;  const nix_ai_lo = # < .nix_ai
   2201  8000
   2202  8000				   .L0256		;;line 286;;  const nix_ai_hi = # > .nix_ai
   2203  8000
   2204  8000				   .L0257		;;line 287;;  const octopus_ai_lo = # < .octopus_ai
   2205  8000
   2206  8000				   .L0258		;;line 288;;  const octopus_ai_hi = # > .octopus_ai
   2207  8000
   2208  8000				   .L0259		;;line 289;;  const slime_ai_lo = # < .slime_ai
   2209  8000
   2210  8000				   .L0260		;;line 290;;  const slime_ai_hi = # > .slime_ai
   2211  8000
   2212  8000				   .L0261		;;line 291;;  const mslime_ai_lo = # < .slime_ai
   2213  8000
   2214  8000				   .L0262		;;line 292;;  const mslime_ai_hi = # > .slime_ai
   2215  8000
   2216  8000				   .L0263		;;line 293;;  const raven_ai_lo = # < .raven_ai
   2217  8000
   2218  8000				   .L0264		;;line 294;;  const raven_ai_hi = # > .raven_ai
   2219  8000
   2220  8000				   .L0265		;;line 295;;  const priest_ai_lo = # < .priest_ai
   2221  8000
   2222  8000				   .L0266		;;line 296;;  const priest_ai_hi = # > .priest_ai
   2223  8000
   2224  8000				   .L0267		;;line 297;;  const redslime_ai_lo = # < .redslime_ai
   2225  8000
   2226  8000				   .L0268		;;line 298;;  const redslime_ai_hi = # > .redslime_ai
   2227  8000
   2228  8000				   .L0269		;;line 299;;  const mredslime_ai_lo = # < .redslime_ai
   2229  8000
   2230  8000				   .L0270		;;line 300;;  const mredslime_ai_hi = # > .redslime_ai
   2231  8000
   2232  8000				   .L0271		;;line 301;;  const ghost_ai_lo = # < .ghost_ai
   2233  8000
   2234  8000				   .L0272		;;line 302;;  const ghost_ai_hi = # > .ghost_ai
   2235  8000
   2236  8000				   .L0273		;;line 303;;  const rghost_ai_lo = # < .rghost_ai
   2237  8000
   2238  8000				   .L0274		;;line 304;;  const rghost_ai_hi = # > .rghost_ai
   2239  8000
   2240  8000				   .
   2241  8000							;;line 305;;
   2242  8000
   2243  8000				   .L0275		;;line 306;;  const fairy_ai_lo = # < .fairy_ai
   2244  8000
   2245  8000				   .L0276		;;line 307;;  const fairy_ai_hi = # > .fairy_ai
   2246  8000
   2247  8000				   .
   2248  8000							;;line 308;;
   2249  8000
   2250  8000				   .L0277		;;line 309;;  const skelsword_ai_lo = # < .skelsword_ai
   2251  8000
   2252  8000				   .L0278		;;line 310;;  const skelsword_ai_hi = # > .skelsword_ai
   2253  8000
   2254  8000				   .L0279		;;line 311;;  const darkspark_ai_lo = # < .fireball_ai
   2255  8000
   2256  8000				   .L0280		;;line 312;;  const darkspark_ai_hi = # > .fireball_ai
   2257  8000
   2258  8000				   .L0281		;;line 313;;  const octoink_ai_lo = # < .fireball_ai
   2259  8000
   2260  8000				   .L0282		;;line 314;;  const octoink_ai_hi = # > .fireball_ai
   2261  8000
   2262  8000				   .L0283		;;line 315;;  const fireball_ai_lo = # < .fireball_ai
   2263  8000
   2264  8000				   .L0284		;;line 316;;  const fireball_ai_hi = # > .fireball_ai
   2265  8000
   2266  8000				   .L0285		;;line 317;;  incbasicend
   2267  8000
   2268  8000				   .
   2269  8000							;;line 2;;
   2270  8000
   2271  8000				   .L0286		;;line 3;;	    incbasic palettes.78b
   2272  8000
   2273  8000				   .			; ;;line 2;; ; -  -  -  -  -  -  -  -	-  -  -  -  -  -  -  -	-  -  -  -  -  -  -  -	-  -  -  -  -  -  -  -	-  -  -  -  -  -  -  -	-  -  -  -  -  -  -  -	-  -  -  -  -  -  -  -	-  -  -  -  -  -  -  -	-  -  -  -  -  -  -  -	-  -  -  -  -  -
   2274  8000
   2275  8000				   .
   2276  8000							;;line 3;;
   2277  8000
   2278  8000				   .
   2279  8000							;;line 4;;
   2280  8000
   2281  8000				   .L0287		;;line 5;;  const PAL_BLACK = $00
   2282  8000
   2283  8000				   .L0288		;;line 6;;  const PAL_DKPURP = $60
   2284  8000
   2285  8000				   .L0289		;;line 7;;  const PAL_LTPURP = $76
   2286  8000
   2287  8000				   .L0290		;;line 8;;  const PAL_WHITE = $0F
   2288  8000
   2289  8000				   .L0291		;;line 9;;  const PAL_DKBRWN = $10
   2290  8000
   2291  8000				   .L0292		;;line 10;;  const PAL_LTBRWN = $23
   2292  8000
   2293  8000				   .L0293		;;line 11;;  const PAL_SKIN = $3B
   2294  8000
   2295  8000				   .L0294		;;line 12;;  const PAL_DKRED = $30
   2296  8000
   2297  8000				   .L0295		;;line 13;;  const PAL_LTRED = $45
   2298  8000
   2299  8000				   .L0296		;;line 14;;  const PAL_GOLD = $19
   2300  8000
   2301  8000				   .L0297		;;line 15;;  const PAL_DKBLUE = $91
   2302  8000
   2303  8000				   .L0298		;;line 16;;  const PAL_LTBLUE = $A3
   2304  8000
   2305  8000				   .L0299		;;line 17;;  const PAL_COPPER = $D5
   2306  8000
   2307  8000				   .
   2308  8000							;;line 18;;
   2309  8000
   2310  8000				   .L0300		;;line 19;;  const HAIR_COLOR = PAL_DKBRWN
   2311  8000
   2312  8000				   .L0301		;;line 20;;  const CHANT_COLOR = $60
   2313  8000
   2314  8000				   .L0302		;;line 21;;  const BAR_NORMAL_COLOR = $76
   2315  8000
   2316  8000				   .L0303		;;line 22;;  const BAR_FLASH_COLOR = $79
   2317  8000
   2318  8000				   .
   2319  8000							;;line 23;;
   2320  8000
   2321  8000				   .
   2322  8000							;;line 24;;
   2323  8000
   2324  8000				   .
   2325  8000							;;line 25;;
   2326  8000
   2327  8000				   .
   2328  8000							;;line 26;;
   2329  8000
   2330  8000				   .L0304		;;line 27;;  const PAL_F_GRND = $11
   2331  8000
   2332  8000				   .L0305		;;line 28;;  const PAL_F_DKGRN = $C0
   2333  8000
   2334  8000				   .L0306		;;line 29;;  const PAL_F_LTGRN = $C3
   2335  8000
   2336  8000				   .L0307		;;line 30;;  const PAL_F_DKGRY = $03
   2337  8000
   2338  8000				   .L0308		;;line 31;;  const PAL_F_LTGRY = $06
   2339  8000
   2340  8000				   .L0309		;;line 32;;  const PAL_F_WATER = $A1
   2341  8000
   2342  8000				   .L0310		;;line 33;;  const PAL_F_LTWTR = $06
   2343  8000
   2344  8000				   .L0311		;;line 34;;  const PAL_F_DKBRN = $10
   2345  8000
   2346  8000				   .L0312		;;line 35;;  const PAL_F_LTBRN = $12
   2347  8000
   2348  8000				   .
   2349  8000							;;line 36;;
   2350  8000
   2351  8000				   .
   2352  8000							;;line 37;;
   2353  8000
   2354  8000				   .
   2355  8000							;;line 38;;
   2356  8000
   2357  8000				   .
   2358  8000							;;line 39;;
   2359  8000
   2360  8000				   .L0313		;;line 40;;  const PAL_C_SKY = $90
   2361  8000
   2362  8000				   .L0314		;;line 41;;  const PAL_C_LIGHTN = $AA
   2363  8000
   2364  8000				   .L0315		;;line 42;;  const PAL_C_DKWALL = $02
   2365  8000
   2366  8000				   .L0316		;;line 43;;  const PAL_C_MDWALL = $03
   2367  8000
   2368  8000				   .L0317		;;line 44;;  const PAL_C_LTWALL = $04
   2369  8000
   2370  8000				   .L0318		;;line 45;;  const PAL_C_BRWALL = $05
   2371  8000
   2372  8000				   .L0319		;;line 46;;  const PAL_C_DKCARP = $40
   2373  8000
   2374  8000				   .L0320		;;line 47;;  const PAL_C_LTCARP = $41
   2375  8000
   2376  8000				   .L0321		;;line 48;;  const PAL_C_BRCARP = $42
   2377  8000
   2378  8000				   .L0322		;;line 49;;  const PAL_C_DKTILE = $A0
   2379  8000
   2380  8000				   .L0323		;;line 50;;  const PAL_C_LTTILE = $A1
   2381  8000
   2382  8000				   .L0324		;;line 51;;  const PAL_C_BRTILE = $A2
   2383  8000
   2384  8000				   .L0325		;;line 52;;  const PAL_C_SKELBL = $00
   2385  8000
   2386  8000				   .L0326		;;line 53;;  const PAL_C_SKELAR = $33
   2387  8000
   2388  8000				   .L0327		;;line 54;;  const PAL_C_SKELWH = $0F
   2389  8000
   2390  8000				   .L0328		;;line 55;;  const PAL_C_DKGOLD = $23
   2391  8000
   2392  8000				   .L0329		;;line 56;;  const PAL_C_LTGOLD = $27
   2393  8000
   2394  8000				   .
   2395  8000							;;line 57;;
   2396  8000
   2397  8000				   .
   2398  8000							;;line 58;;
   2399  8000
   2400  8000				   .
   2401  8000							;;line 59;;
   2402  8000
   2403  8000				   .
   2404  8000							;;line 60;;
   2405  8000
   2406  8000				   .L0330		;;line 61;;  const PAL_WFALL1 = $A1
   2407  8000
   2408  8000				   .L0331		;;line 62;;  const PAL_WFALL2 = $A3
   2409  8000
   2410  8000				   .L0332		;;line 63;;  const PAL_WFALL3 = $0F
   2411  8000
   2412  8000				   .
   2413  8000							;;line 64;;
   2414  8000
   2415  8000				   .
   2416  8000							;;line 65;;
   2417  8000
   2418  8000				   .
   2419  8000							;;line 66;;
   2420  8000
   2421  8000				   .
   2422  8000							;;line 67;;
   2423  8000
   2424  8000				   .L0333		;;line 68;;  const PAL_H_GRND = $06
   2425  8000
   2426  8000				   .L0334		;;line 69;;  const PAL_H_DKGRY = $03
   2427  8000
   2428  8000				   .L0335		;;line 70;;  const PAL_H_LTGRY = $08
   2429  8000
   2430  8000				   .L0336		;;line 71;;  const PAL_H_DIRT = $11
   2431  8000
   2432  8000				   .L0337		;;line 72;;  const PAL_H_VEG = $C0
   2433  8000
   2434  8000				   .L0338		;;line 73;;  const PAL_H_WATER = $A1
   2435  8000
   2436  8000				   .L0339		;;line 74;;  incbasicend
   2437  8000
   2438  8000				   .
   2439  8000							;;line 2;;
   2440  8000
   2441  8000				   .L0340		;;line 3;;	    incbasic pointers.78b
   2442  8000
   2443  8000				   .L0341		;;line 2;;
   2444  8000
   2445  8000				   .L0342		;;line 3;;  const m_item_inv_lo = # < m_item_inv
   2446  8000
   2447  8000				   .L0343		;;line 4;;  const m_item_inv_hi = # > m_item_inv
   2448  8000
   2449  8000				   .L0344		;;line 5;;  const m_item_qty_lo = # < m_item_qty
   2450  8000
   2451  8000				   .L0345		;;line 6;;  const m_item_qty_hi = # > m_item_qty
   2452  8000
   2453  8000				   .L0346		;;line 7;;  const m_sword_inv_lo = # < m_sword_inv
   2454  8000
   2455  8000				   .L0347		;;line 8;;  const m_sword_inv_hi = # > m_sword_inv
   2456  8000
   2457  8000				   .L0348		;;line 9;;  const m_shield_inv_lo = # < m_shield_inv
   2458  8000
   2459  8000				   .L0349		;;line 10;;  const m_shield_inv_hi = # > m_shield_inv
   2460  8000
   2461  8000				   .L0350		;;line 11;;  const m_armor_inv_lo = # < m_armor_inv
   2462  8000
   2463  8000				   .L0351		;;line 12;;  const m_armor_inv_hi = # > m_armor_inv
   2464  8000
   2465  8000				   .L0352		;;line 13;;  const m_charm_inv_lo = # < m_charm_inv
   2466  8000
   2467  8000				   .L0353		;;line 14;;  const m_charm_inv_hi = # > m_charm_inv
   2468  8000
   2469  8000				   .L0354		;;line 15;;  const m_relic_inv_lo = # < m_relic_inv
   2470  8000
   2471  8000				   .L0355		;;line 16;;  const m_relic_inv_hi = # > m_relic_inv
   2472  8000
   2473  8000				   .
   2474  8000							;;line 17;;
   2475  8000
   2476  8000				   .
   2477  8000							;;line 18;;
   2478  8000
   2479  8000				   .L0356		;;line 19;;  const plot_torch_lo = # < .plot_torch
   2480  8000
   2481  8000				   .L0357		;;line 20;;  const plot_torch_hi = # > .plot_torch
   2482  8000
   2483  8000				   .L0358		;;line 21;;  const plot_wolf_lo = # < .plot_wolf
   2484  8000
   2485  8000				   .L0359		;;line 22;;  const plot_wolf_hi = # > .plot_wolf
   2486  8000
   2487  8000				   .L0360		;;line 23;;  const plot_priest_lo = # < .plot_priest
   2488  8000
   2489  8000				   .L0361		;;line 24;;  const plot_priest_hi = # > .plot_priest
   2490  8000
   2491  8000				   .L0362		;;line 25;;  const plot_skeleton_lo = # < .plot_skeleton
   2492  8000
   2493  8000				   .L0363		;;line 26;;  const plot_skeleton_hi = # > .plot_skeleton
   2494  8000
   2495  8000				   .L0364		;;line 27;;  const plot_skelsword_lo = # < .plot_skelsword
   2496  8000
   2497  8000				   .L0365		;;line 28;;  const plot_skelsword_hi = # > .plot_skelsword
   2498  8000
   2499  8000				   .L0366		;;line 29;;  incbasicend
   2500  8000
   2501  8000				   .
   2502  8000							;;line 2;;
   2503  8000
   2504  8000				   .
   2505  8000							;;line 3;;
   2506  8000
   2507  8000				   .
   2508  8000							;;line 4;;
   2509  8000
   2510  8000				   .
   2511  8000							;;line 5;;
   2512  8000
   2513  8000				   .L0367		;;line 6;;  const STATE_TITLE = 0
   2514  8000
   2515  8000				   .L0368		;;line 7;;  const STATE_FIELD = 1
   2516  8000
   2517  8000				   .L0369		;;line 8;;  const STATE_MENU = 2
   2518  8000
   2519  8000				   .
   2520  8000							;;line 9;;
   2521  8000
   2522  8000				   .
   2523  8000							;;line 10;;
   2524  8000
   2525  8000				   .
   2526  8000							;;line 11;;
   2527  8000
   2528  8000				   .
   2529  8000							;;line 12;;
   2530  8000
   2531  8000				   .L0370		;;line 13;;  const DIR_UP = 1
   2532  8000
   2533  8000				   .L0371		;;line 14;;  const DIR_DOWN = 2
   2534  8000
   2535  8000				   .L0372		;;line 15;;  const DIR_LEFT = 3
   2536  8000
   2537  8000				   .L0373		;;line 16;;  const DIR_RIGHT = 4
   2538  8000
   2539  8000				   .
   2540  8000							;;line 17;;
   2541  8000
   2542  8000				   .L0374		;;line 18;;  const EXIT_NONE = 0
   2543  8000
   2544  8000				   .L0375		;;line 19;;  const EXIT_NORTH = 1
   2545  8000
   2546  8000				   .L0376		;;line 20;;  const EXIT_SOUTH = 2
   2547  8000
   2548  8000				   .L0377		;;line 21;;  const EXIT_EAST = 3
   2549  8000
   2550  8000				   .L0378		;;line 22;;  const EXIT_WEST = 4
   2551  8000
   2552  8000				   .
   2553  8000							;;line 23;;
   2554  8000
   2555  8000				   .L0379		;;line 24;;  const ANIM_TIME = 16
   2556  8000
   2557  8000				   .L0380		;;line 25;;  const BUTTON_HOLD_FRAMES = 15
   2558  8000
   2559  8000				   .
   2560  8000							;;line 26;;
   2561  8000
   2562  8000				   .
   2563  8000							;;line 27;;
   2564  8000
   2565  8000				   .
   2566  8000							;;line 28;;
   2567  8000
   2568  8000				   .
   2569  8000							;;line 29;;
   2570  8000
   2571  8000				   .L0381		;;line 30;;  const PLAYER_HEIGHT = 16
   2572  8000
   2573  8000				   .L0382		;;line 31;;  const PLAYER_WIDTH = 12
   2574  8000
   2575  8000				   .
   2576  8000							;;line 32;;
   2577  8000
   2578  8000				   .L0383		;;line 33;;  const SWORD_FRAMES = 4
   2579  8000
   2580  8000				   .L0384		;;line 34;;  const SWORD_OFFSET_DOWN = 15
   2581  8000
   2582  8000				   .L0385		;;line 35;;  const SWORD_OFFSET_UP =  - 16
   2583  8000
   2584  8000				   .L0386		;;line 36;;  const SWORD_OFFSET_LEFT =  - 12
   2585  8000
   2586  8000				   .L0387		;;line 37;;  const SWORD_OFFSET_RIGHT = 12
   2587  8000
   2588  8000				   .
   2589  8000							;;line 38;;
   2590  8000
   2591  8000				   .L0388		;;line 39;;  const SHIELD_FRAMES = 4
   2592  8000
   2593  8000				   .L0389		;;line 40;;  const SHIELD_OFFSET_X_LEFT = 6
   2594  8000
   2595  8000				   .L0390		;;line 41;;  const SHIELD_OFFSET_X_RIGHT = 7
   2596  8000
   2597  8000				   .L0391		;;line 42;;  const SHIELD_OFFSET_X_DOWN = 8
   2598  8000
   2599  8000				   .L0392		;;line 43;;  const SHIELD_OFFSET_X_UP =  - 3
   2600  8000
   2601  8000				   .L0393		;;line 44;;  const SHIELD_OFFSET_X_LEFT_STAND =  - 2
   2602  8000
   2603  8000				   .L0394		;;line 45;;  const SHIELD_OFFSET_X_RIGHT_STAND = 7
   2604  8000
   2605  8000				   .L0395		;;line 46;;  const SHIELD_OFFSET_X_DOWN_STAND = 8
   2606  8000
   2607  8000				   .L0396		;;line 47;;  const SHIELD_OFFSET_X_UP_STAND = 0
   2608  8000
   2609  8000				   .L0397		;;line 48;;  const SHIELD_OFFSET_Y = 7
   2610  8000
   2611  8000				   .L0398		;;line 49;;  const SHIELD_OFFSET_Y_UP = 6
   2612  8000
   2613  8000				   .L0399		;;line 50;;  const SHIELD_OFFSET_Y_UP_STAND = 6
   2614  8000
   2615  8000				   .
   2616  8000							;;line 51;;
   2617  8000
   2618  8000				   .L0400		;;line 52;;  const STATE_STAND = 0
   2619  8000
   2620  8000				   .L0401		;;line 53;;  const STATE_MOVING = 1
   2621  8000
   2622  8000				   .L0402		;;line 54;;  const STATE_ATTACK = 4
   2623  8000
   2624  8000				   .L0403		;;line 55;;  const STATE_CHANT_START = 5
   2625  8000
   2626  8000				   .L0404		;;line 56;;  const STATE_CHANT = 6
   2627  8000
   2628  8000				   .L0405		;;line 57;;  const STATE_KNOCKBACK = 2
   2629  8000
   2630  8000				   .L0406		;;line 58;;  const STATE_HOP = 3
   2631  8000
   2632  8000				   .L0407		;;line 59;;  const STATE_DEATH = 7
   2633  8000
   2634  8000				   .
   2635  8000							;;line 60;;
   2636  8000
   2637  8000				   .L0408		;;line 61;;  const FRAME_UP = 2
   2638  8000
   2639  8000				   .L0409		;;line 62;;  const FRAME_DOWN = 0
   2640  8000
   2641  8000				   .L0410		;;line 63;;  const FRAME_LEFT = 4
   2642  8000
   2643  8000				   .L0411		;;line 64;;  const FRAME_RIGHT = 6
   2644  8000
   2645  8000				   .L0412		;;line 65;;  const FRAME_ATK_D = 8
   2646  8000
   2647  8000				   .L0413		;;line 66;;  const FRAME_ATK_U = 9
   2648  8000
   2649  8000				   .L0414		;;line 67;;  const FRAME_ATK_L = 10
   2650  8000
   2651  8000				   .L0415		;;line 68;;  const FRAME_ATK_R = 11
   2652  8000
   2653  8000				   .L0416		;;line 69;;  const FRAME_CHANT = 12
   2654  8000
   2655  8000				   .L0417		;;line 70;;  const FRAME_DEATH = 13
   2656  8000
   2657  8000				   .
   2658  8000							;;line 71;;
   2659  8000
   2660  8000				   .L0418		;;line 72;;  const ATTACK_FRAMES = 8
   2661  8000
   2662  8000				   .L0419		;;line 73;;  const CHANT_START_TIME = 12
   2663  8000
   2664  8000				   .L0420		;;line 74;;  const INVULN_FRAMES = 4
   2665  8000
   2666  8000				   .
   2667  8000							;;line 75;;
   2668  8000
   2669  8000				   .L0421		;;line 76;;  const PLAYER_HP_MAX = 48
   2670  8000
   2671  8000				   .L0422		;;line 77;;  const PLAYER_HP_HALF = PLAYER_HP_MAX  /  2
   2672  8000
   2673  8000				   .L0423		;;line 78;;  const PLAYER_HP_QUARTER = PLAYER_HP_MAX  /  4
   2674  8000
   2675  8000				   .L0424		;;line 79;;  const PLAYER_MP_MAX = 48
   2676  8000
   2677  8000				   .L0425		;;line 80;;  const PLAYER_MP_HALF = PLAYER_MP_MAX  /  2
   2678  8000
   2679  8000				   .L0426		;;line 81;;  const PLAYER_MP_QUARTER = PLAYER_MP_MAX  /  4
   2680  8000
   2681  8000				   .
   2682  8000							;;line 82;;
   2683  8000
   2684  8000				   .
   2685  8000							;;line 83;;
   2686  8000
   2687  8000				   .
   2688  8000							;;line 84;;
   2689  8000
   2690  8000				   .
   2691  8000							;;line 85;;
   2692  8000
   2693  8000				   .L0427		;;line 86;;  const BITS_POISON = %00000001
   2694  8000
   2695  8000				   .L0428		;;line 87;;  const BITS_DARK = %00000010
   2696  8000
   2697  8000				   .L0429		;;line 88;;  const BITS_CURSE = %00000100
   2698  8000
   2699  8000				   .L0430		;;line 89;;  const BITS_STONE = %00001000
   2700  8000
   2701  8000				   .L0431		;;line 90;;  const BITS_FURY = %00010000
   2702  8000
   2703  8000				   .L0432		;;line 91;;  const BITS_REGEN = %00100000
   2704  8000
   2705  8000				   .
   2706  8000							;;line 92;;
   2707  8000
   2708  8000				   .L0433		;;line 93;;  const MASK_POISON = %11111110
   2709  8000
   2710  8000				   .L0434		;;line 94;;  const MASK_DARK = %11111101
   2711  8000
   2712  8000				   .L0435		;;line 95;;  const MASK_CURSE = %11111011
   2713  8000
   2714  8000				   .L0436		;;line 96;;  const MASK_STONE = %11110111
   2715  8000
   2716  8000				   .L0437		;;line 97;;  const MASK_FURY = %11101111
   2717  8000
   2718  8000				   .L0438		;;line 98;;  const MASK_REGEN = %11011111
   2719  8000
   2720  8000				   .
   2721  8000							;;line 99;;
   2722  8000
   2723  8000				   .L0439		;;line 100;;  const STATUS_NONE = 0
   2724  8000
   2725  8000				   .L0440		;;line 101;;  const STATUS_POISON = 1
   2726  8000
   2727  8000				   .L0441		;;line 102;;  const STATUS_DARK = 2
   2728  8000
   2729  8000				   .L0442		;;line 103;;  const STATUS_CURSE = 3
   2730  8000
   2731  8000				   .L0443		;;line 104;;  const STATUS_STONE = 4
   2732  8000
   2733  8000				   .L0444		;;line 105;;  const STATUS_FURY = 5
   2734  8000
   2735  8000				   .L0445		;;line 106;;  const STATUS_REGEN = 6
   2736  8000
   2737  8000				   .
   2738  8000							;;line 107;;
   2739  8000
   2740  8000				   .L0446		;;line 108;;  const POISON_DMG = 1
   2741  8000
   2742  8000				   .L0447		;;line 109;;  const POISON_FRAMES = 120
   2743  8000
   2744  8000				   .
   2745  8000							;;line 110;;
   2746  8000
   2747  8000				   .L0448		;;line 111;;  const FADE_DARKNESS = 0
   2748  8000
   2749  8000				   .L0449		;;line 112;;  const FADE_NORMAL = 15
   2750  8000
   2751  8000				   .L0450		;;line 113;;  const WHITE_DARKNESS = $50
   2752  8000
   2753  8000				   .
   2754  8000							;;line 114;;
   2755  8000
   2756  8000				   .
   2757  8000							;;line 115;;
   2758  8000
   2759  8000				   .
   2760  8000							;;line 116;;
   2761  8000
   2762  8000				   .L0451		;;line 117;;  const TILE_HEIGHT = 16
   2763  8000
   2764  8000				   .L0452		;;line 118;;  const TILE_WIDTH = 8
   2765  8000
   2766  8000				   .
   2767  8000							;;line 119;;
   2768  8000
   2769  8000				   .L0453		;;line 120;;  const T_TITLE = 0
   2770  8000
   2771  8000				   .L0454		;;line 121;;  const T_FOREST = 1
   2772  8000
   2773  8000				   .L0455		;;line 122;;  const T_CASTLE = 2
   2774  8000
   2775  8000				   .L0456		;;line 123;;  const T_RIVER = 3
   2776  8000
   2777  8000				   .L0457		;;line 124;;  const T_HILLS = 4
   2778  8000
   2779  8000				   .
   2780  8000							;;line 125;;
   2781  8000
   2782  8000				   .L0458		;;line 126;;  const ROOMS_PER_ROW = 7
   2783  8000
   2784  8000				   .L0459		;;line 127;;  const MAX_MAP_OBJECTS = 12
   2785  8000
   2786  8000				   .L0460		;;line 128;;  const MAX_OBJECTS = 15
   2787  8000
   2788  8000				   .
   2789  8000							;;line 129;;
   2790  8000
   2791  8000				   .L0461		;;line 130;;  const LIGHTNING_FRAMES = 8
   2792  8000
   2793  8000				   .L0462		;;line 131;;  const LIGHTNING_DELAY = 120
   2794  8000
   2795  8000				   .
   2796  8000							;;line 132;;
   2797  8000
   2798  8000				   .
   2799  8000							;;line 133;;
   2800  8000
   2801  8000				   .L0463		;;line 134;;  const ROOML_B = 0
   2802  8000
   2803  8000				   .L0464		;;line 135;;  const ROOMR_B = 1
   2804  8000
   2805  8000				   .L0465		;;line 136;;  const ROOML_UDL = 2
   2806  8000
   2807  8000				   .L0466		;;line 137;;  const ROOMR_UDR = 3
   2808  8000
   2809  8000				   .L0467		;;line 138;;  const ROOML_L = 4
   2810  8000
   2811  8000				   .L0468		;;line 139;;  const ROOMR_R = 5
   2812  8000
   2813  8000				   .L0469		;;line 140;;  const ROOML_DL = 6
   2814  8000
   2815  8000				   .L0470		;;line 141;;  const ROOMR_DR = 7
   2816  8000
   2817  8000				   .L0471		;;line 142;;  const ROOML_UL = 8
   2818  8000
   2819  8000				   .L0472		;;line 143;;  const ROOMR_UR = 9
   2820  8000
   2821  8000				   .L0473		;;line 144;;  const ROOML_UD = 10
   2822  8000
   2823  8000				   .L0474		;;line 145;;  const ROOMR_UD = 11
   2824  8000
   2825  8000				   .L0475		;;line 146;;  const ROOML_D = 12
   2826  8000
   2827  8000				   .L0476		;;line 147;;  const ROOMR_D = 13
   2828  8000
   2829  8000				   .L0477		;;line 148;;  const ROOML_U = 14
   2830  8000
   2831  8000				   .L0478		;;line 149;;  const ROOMR_U = 15
   2832  8000
   2833  8000				   .L0479		;;line 150;;  const ROOML_N = 16
   2834  8000
   2835  8000				   .L0480		;;line 151;;  const ROOMR_N = 17
   2836  8000
   2837  8000				   .
   2838  8000							;;line 152;;
   2839  8000
   2840  8000				   .
   2841  8000							;;line 153;;
   2842  8000
   2843  8000				   .
   2844  8000							;;line 154;;
   2845  8000
   2846  8000				   .
   2847  8000							;;line 155;;
   2848  8000
   2849  8000				   .
   2850  8000							;;line 156;;
   2851  8000
   2852  8000				   .L0481		;;line 157;;  const M_RIVER_START_X = 62
   2853  8000
   2854  8000				   .L0482		;;line 158;;  const M_RIVER_START_Y = 112
   2855  8000
   2856  8000				   .
   2857  8000							;;line 159;;
   2858  8000
   2859  8000				   .L0483		;;line 160;;  const F_RIVER_START_I = 22
   2860  8000
   2861  8000				   .L0484		;;line 161;;  const F_RIVER_START_X = 76
   2862  8000
   2863  8000				   .L0485		;;line 162;;  const F_RIVER_START_Y = $50
   2864  8000
   2865  8000				   .L0486		;;line 163;;  const F_RIVER_START_D = DIR_DOWN
   2866  8000
   2867  8000				   .
   2868  8000							;;line 164;;
   2869  8000
   2870  8000				   .
   2871  8000							;;line 165;;
   2872  8000
   2873  8000				   .L0487		;;line 166;;  const M_RIVER_SAVE1_X = 78
   2874  8000
   2875  8000				   .L0488		;;line 167;;  const M_RIVER_SAVE1_Y = 96
   2876  8000
   2877  8000				   .
   2878  8000							;;line 168;;
   2879  8000
   2880  8000				   .L0489		;;line 169;;  const F_RIVER_SAVE1_I = 17
   2881  8000
   2882  8000				   .L0490		;;line 170;;  const F_RIVER_SAVE1_X = $50
   2883  8000
   2884  8000				   .L0491		;;line 171;;  const F_RIVER_SAVE1_Y = $70
   2885  8000
   2886  8000				   .L0492		;;line 172;;  const F_RIVER_SAVE1_D = DIR_DOWN
   2887  8000
   2888  8000				   .
   2889  8000							;;line 173;;
   2890  8000
   2891  8000				   .
   2892  8000							;;line 174;;
   2893  8000
   2894  8000				   .L0493		;;line 175;;  const M_RIVER_SAVE2_X = 94
   2895  8000
   2896  8000				   .L0494		;;line 176;;  const M_RIVER_SAVE2_Y = 64
   2897  8000
   2898  8000				   .
   2899  8000							;;line 177;;
   2900  8000
   2901  8000				   .L0495		;;line 178;;  const F_RIVER_SAVE2_I = 5
   2902  8000
   2903  8000				   .L0496		;;line 179;;  const F_RIVER_SAVE2_X = $72
   2904  8000
   2905  8000				   .L0497		;;line 180;;  const F_RIVER_SAVE2_Y = $80
   2906  8000
   2907  8000				   .L0498		;;line 181;;  const F_RIVER_SAVE2_D = DIR_DOWN
   2908  8000
   2909  8000				   .
   2910  8000							;;line 182;;
   2911  8000
   2912  8000				   .
   2913  8000							;;line 183;;
   2914  8000
   2915  8000				   .
   2916  8000							;;line 184;;
   2917  8000
   2918  8000				   .
   2919  8000							;;line 185;;
   2920  8000
   2921  8000				   .
   2922  8000							;;line 186;;
   2923  8000
   2924  8000				   .L0499		;;line 187;;  const M_HILLS_START_X = 62
   2925  8000
   2926  8000				   .L0500		;;line 188;;  const M_HILLS_START_Y = 112
   2927  8000
   2928  8000				   .
   2929  8000							;;line 189;;
   2930  8000
   2931  8000				   .L0501		;;line 190;;  const F_HILLS_START_I = 22
   2932  8000
   2933  8000				   .L0502		;;line 191;;  const F_HILLS_START_X = $64
   2934  8000
   2935  8000				   .L0503		;;line 192;;  const F_HILLS_START_Y = $A0
   2936  8000
   2937  8000				   .L0504		;;line 193;;  const F_HILLS_START_D = DIR_UP
   2938  8000
   2939  8000				   .
   2940  8000							;;line 194;;
   2941  8000
   2942  8000				   .
   2943  8000							;;line 195;;
   2944  8000
   2945  8000				   .L0505		;;line 196;;  const M_HILLS_SAVE1_X = 78
   2946  8000
   2947  8000				   .L0506		;;line 197;;  const M_HILLS_SAVE1_Y = 96
   2948  8000
   2949  8000				   .
   2950  8000							;;line 198;;
   2951  8000
   2952  8000				   .L0507		;;line 199;;  const F_HILLS_SAVE1_I = 17
   2953  8000
   2954  8000				   .L0508		;;line 200;;  const F_HILLS_SAVE1_X = $50
   2955  8000
   2956  8000				   .L0509		;;line 201;;  const F_HILLS_SAVE1_Y = $70
   2957  8000
   2958  8000				   .L0510		;;line 202;;  const F_HILLS_SAVE1_D = DIR_DOWN
   2959  8000
   2960  8000				   .
   2961  8000							;;line 203;;
   2962  8000
   2963  8000				   .
   2964  8000							;;line 204;;
   2965  8000
   2966  8000				   .L0511		;;line 205;;  const M_HILLS_SAVE2_X = 94
   2967  8000
   2968  8000				   .L0512		;;line 206;;  const M_HILLS_SAVE2_Y = 64
   2969  8000
   2970  8000				   .
   2971  8000							;;line 207;;
   2972  8000
   2973  8000				   .L0513		;;line 208;;  const F_HILLS_SAVE2_I = 5
   2974  8000
   2975  8000				   .L0514		;;line 209;;  const F_HILLS_SAVE2_X = $72
   2976  8000
   2977  8000				   .L0515		;;line 210;;  const F_HILLS_SAVE2_Y = $80
   2978  8000
   2979  8000				   .L0516		;;line 211;;  const F_HILLS_SAVE2_D = DIR_DOWN
   2980  8000
   2981  8000				   .
   2982  8000							;;line 212;;
   2983  8000
   2984  8000				   .
   2985  8000							;;line 213;;
   2986  8000
   2987  8000				   .
   2988  8000							;;line 214;;
   2989  8000
   2990  8000				   .
   2991  8000							;;line 215;;
   2992  8000
   2993  8000				   .L0517		;;line 216;;  const MENU_MAIN = 0
   2994  8000
   2995  8000				   .L0518		;;line 217;;  const MENU_ITEMS = 1
   2996  8000
   2997  8000				   .L0519		;;line 218;;  const MENU_MAGIC = 2
   2998  8000
   2999  8000				   .L0520		;;line 219;;  const MENU_EQUIP = 3
   3000  8000
   3001  8000				   .L0521		;;line 220;;  const MENU_RELICS = 4
   3002  8000
   3003  8000				   .L0522		;;line 221;;  const MENU_PASSWORD = 5
   3004  8000
   3005  8000				   .L0523		;;line 222;;  const MENU_GAMEOVER = 6
   3006  8000
   3007  8000				   .L0524		;;line 223;;  const MENU_MAIN_MAX_OPTIONS = 3
   3008  8000
   3009  8000				   .L0525		;;line 224;;  const CHAR_SPACE = 62
   3010  8000
   3011  8000				   .
   3012  8000							;;line 225;;
   3013  8000
   3014  8000				   .L0526		;;line 226;;  const MENU_MAIN_ITEMS_X = 12
   3015  8000
   3016  8000				   .L0527		;;line 227;;  const MENU_MAIN_ITEMS_Y = 192
   3017  8000
   3018  8000				   .L0528		;;line 228;;  const MENU_MAIN_MAGIC_X = 40
   3019  8000
   3020  8000				   .L0529		;;line 229;;  const MENU_MAIN_EQUIP_X = 72
   3021  8000
   3022  8000				   .L0530		;;line 230;;  const MENU_MAIN_RELICS_X = 116
   3023  8000
   3024  8000				   .
   3025  8000							;;line 231;;
   3026  8000
   3027  8000				   .
   3028  8000							;;line 232;;
   3029  8000
   3030  8000				   .L0531		;;line 233;;  const MENU_TAP_FRAMES = 4
   3031  8000
   3032  8000				   .
   3033  8000							;;line 234;;
   3034  8000
   3035  8000				   .L0532		;;line 235;;  const ITEMS_HP_X = 80
   3036  8000
   3037  8000				   .L0533		;;line 236;;  const ITEMS_HP_Y = 32
   3038  8000
   3039  8000				   .L0534		;;line 237;;  const ITEM_NAME_LENGTH =  ( 8 / 2 )   *	11
   3040  8000
   3041  8000				   .
   3042  8000							;;line 238;;
   3043  8000
   3044  8000				   .L0535		;;line 239;;  const MENU_EQUIP_MAX_OPTIONS = 4
   3045  8000
   3046  8000				   .L0536		;;line 240;;  const MENU_EQUIP_EQUIPPED_X = 76
   3047  8000
   3048  8000				   .L0537		;;line 241;;  const MENU_EQUIP_SWORD_Y = 64
   3049  8000
   3050  8000				   .L0538		;;line 242;;  const MENU_EQUIP_SHIELD_Y = 96
   3051  8000
   3052  8000				   .L0539		;;line 243;;  const MENU_EQUIP_ARMOR_Y = 128
   3053  8000
   3054  8000				   .L0540		;;line 244;;  const MENU_EQUIP_CHARM_Y = 160
   3055  8000
   3056  8000				   .L0541		;;line 245;;  const MENU_EQUIP_INV_X = 12
   3057  8000
   3058  8000				   .L0542		;;line 246;;  const MENU_EQUIP_INV0_Y = 80
   3059  8000
   3060  8000				   .L0543		;;line 247;;  const MENU_EQUIP_INV1_Y = 112
   3061  8000
   3062  8000				   .L0544		;;line 248;;  const MENU_EQUIP_INV2_Y = 142
   3063  8000
   3064  8000				   .L0545		;;line 249;;  const MENU_EQUIP_INV3_Y = 176
   3065  8000
   3066  8000				   .L0546		;;line 250;;  const MENU_EQUIP_EXIT_X = 124
   3067  8000
   3068  8000				   .L0547		;;line 251;;  const MENU_EQUIP_EXIT_Y = 192
   3069  8000
   3070  8000				   .
   3071  8000							;;line 252;;
   3072  8000
   3073  8000				   .
   3074  8000							;;line 253;;
   3075  8000
   3076  8000				   .L0548		;;line 254;;  const PW_0 = 19
   3077  8000
   3078  8000				   .L0549		;;line 255;;  const PW_A = 16
   3079  8000
   3080  8000				   .
   3081  8000							;;line 256;;
   3082  8000
   3083  8000				   .
   3084  8000							;;line 257;;
   3085  8000
   3086  8000				   .L0550		;;line 258;;  const HP_CHANGE_FOOD = $10
   3087  8000
   3088  8000				   .L0551		;;line 259;;  const HP_CHANGE_POTION = $20
   3089  8000
   3090  8000				   .L0552		;;line 260;;  const HP_CHANGE_HIPOTION = $30
   3091  8000
   3092  8000				   .L0553		;;line 261;;  const HP_CHANGE_XPOTION = $48
   3093  8000
   3094  8000				   .L0554		;;line 262;;  const MP_CHANGE_PRISM = $05
   3095  8000
   3096  8000				   .L0555		;;line 263;;  const MP_CHANGE_ETHER = $10
   3097  8000
   3098  8000				   .L0556		;;line 264;;  const MP_CHANGE_XETHER = $48
   3099  8000
   3100  8000				   .
   3101  8000							;;line 265;;
   3102  8000
   3103  8000				   .
   3104  8000							;;line 266;;
   3105  8000
   3106  8000				   .L0557		;;line 267;;  const FAIRY_ITEM_TIME = 120
   3107  8000
   3108  8000				   .
   3109  8000							;;line 268;;
   3110  8000
   3111  8000				   .L0558		;;line 269;;  const PICKUP_TIME = 120
   3112  8000
   3113  8000				   .L0559		;;line 270;;  const PICKUP_STRING_LENGTH = 12
   3114  8000
   3115  8000				   .
   3116  8000							;;line 271;;
   3117  8000
   3118  8000				   .
   3119  8000							;;line 272;;
   3120  8000
   3121  8000				   .
   3122  8000							;;line 273;;
   3123  8000
   3124  8000				   .
   3125  8000							;;line 274;;
   3126  8000
   3127  8000				   .
   3128  8000							;;line 275;;
   3129  8000
   3130  8000				   .L0560		;;line 276;;  const FONT_SPR_CHARS = 65
   3131  8000
   3132  8000				   .
   3133  8000							;;line 277;;
   3134  8000
   3135  8000				   .L0561		;;line 278;;  const BAR_OFFSET = FONT_SPR_CHARS  *  2
   3136  8000
   3137  8000				   .
   3138  8000							;;line 279;;
   3139  8000
   3140  8000				   DMAHOLEEND0 SET	.
   3141  8000				   gameend
   3142  8000				   DMAHOLEEND0 SET	.
   28672 bytes of ROM space left in the main area.
   3143  8000					      echo	" ",[($F000 - gameend)]d , "bytes of ROM space left in the main area."
   3144  8000				  -	      if	($F000 - gameend) < 0
   3145  8000				  -SPACEOVERFLOW SET	(SPACEOVERFLOW+1)
   3146  8000					      endif
   3147  8000				  -	      if	SPACEOVERFLOW > 0
   3148  8000				  -	      echo	""
   3149  8000				  -	      echo	"######## ERROR: space overflow detected in",[SPACEOVERFLOW]d,"areas."
   3150  8000				  -	      echo	"######## look above for areas with negative ROM space left."
   3151  8000					      endif
   3152  8000
   3153  8000
   3154  8000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   3155  8000
   3156  8000					      ifnconst	bankswitchmode
   3157  8000					      if	( * < $f000 )
   3158  f000					      ORG	$F000
   3159  f000					      endif
   3160  f000				  -	      else
   3161  f000				  -	      ifconst	ROM128K
   3162  f000				  -	      if	( * < $f000 )
   3163  f000				  -	      ORG	$27000
   3164  f000				  -	      RORG	$F000
   3165  f000				  -	      endif
   3166  f000				  -	      endif
   3167  f000				  -	      ifconst	ROM144K
   3168  f000				  -	      if	( * < $f000 )
   3169  f000				  -	      ORG	$27000
   3170  f000				  -	      RORG	$F000
   3171  f000				  -	      endif
   3172  f000				  -	      endif
   3173  f000				  -	      ifconst	ROM256K
   3174  f000				  -	      if	( * < $f000 )
   3175  f000				  -	      ORG	$47000
   3176  f000				  -	      RORG	$F000
   3177  f000				  -	      endif
   3178  f000				  -	      endif
   3179  f000				  -	      ifconst	ROM272K
   3180  f000				  -	      if	( * < $f000 )
   3181  f000				  -	      ORG	$47000
   3182  f000				  -	      RORG	$F000
   3183  f000				  -	      endif
   3184  f000				  -	      endif
   3185  f000				  -	      ifconst	ROM512K
   3186  f000				  -	      if	( * < $f000 )
   3187  f000				  -	      ORG	$87000
   3188  f000				  -	      RORG	$F000
   3189  f000				  -	      endif
   3190  f000				  -	      endif
   3191  f000				  -	      ifconst	ROM528K
   3192  f000				  -	      if	( * < $f000 )
   3193  f000				  -	      ORG	$87000
   3194  f000				  -	      RORG	$F000
   3195  f000				  -	      endif
   3196  f000				  -	      endif
   3197  f000					      endif
   3198  f000
   3199  f000							; all of these "modules" have conditional clauses in them, so even though
   3200  f000							; they're always included here, they don't take up rom unless the user
   3201  f000							; explicitly enables support for the feature.
   3202  f000
   3203  f000					      ifnconst	included.rmtplayer.asm
------- FILE rmtplayer.asm LEVEL 2 PASS 3
      0  f000					      include	rmtplayer.asm	; requires page alignment, so go first
      1  f000				  -	      ifconst	RMT
      2  f000				  -
      3  f000				  -rmtmodulestart
      4  f000				  -
      5  f000				  -			;*
      6  f000				  -			;* Raster Music Tracker, RMT Atari routine version 1.20030223
      7  f000				  -			;* (c) Radek Sterba, Raster/C.P.U., 2002 - 2003
      8  f000				  -			;* http://raster.atari.org
      9  f000				  -			;*
     10  f000				  -			;* Some small changes to allow using this code with DASM cross assembler and
     11  f000				  -			;* to compile for cartridge based systems, like the Atari 5200 or 7800,
     12  f000				  -			;* by Eckhard Stolberg ( http://home.arcor.de/estolberg/ ).
     13  f000				  -			;*
     14  f000				  -			;* More small changes were made to use this code with 7800basic, and
     15  f000				  -			;* comments by VinsCool on more recent versions were back-ported.
     16  f000				  -			;* --Mike Saarna.
     17  f000				  -			;*
     18  f000				  -			;* Warnings:
     19  f000				  -			;*
     20  f000				  -			;* 1. RMT player routine needs 19 dedicated zero page bytes, as well as cca
     21  f000				  -			;* 1KB of memory before the "PLAYER" address for frequency tables and
     22  f000				  -			;* functionary variables. It's:
     23  f000				  -			;* a) from PLAYER-$400 to PLAYER for stereo RMTplayer
     24  f000				  -			;* b) from PLAYER-$380 to PLAYER for mono RMTplayer
     25  f000				  -			;*
     26  f000				  -			;* note: This has been changed for 5200 & 7800 compatibility. Now PLAYER
     27  f000				  -			;* points to the start of the frequency tables. The player routines follows
     28  f000				  -			;* after that. The variables are now independent and can be located with
     29  f000				  -			;* PLAYER_VAR_RAM and PLAYER_ZP_RAM (see below):
     30  f000				  -			;*
     31  f000				  -			;* 2. RMT player routine MUST (!!!) be compiled aligned to a memory page.
     32  f000				  -			;* i.e. "PLAYER" address can be $..00 only!
     33  f000				  -			;*
     34  f000				  -			;* 3. Because of RMTplayer provides a lot of effects, it spent a lot of
     35  f000				  -			;* CPU time.
     36  f000				  -			;*
     37  f000				  -			;*
     38  f000				  -			;* Define the following equates here or in your main code file.
     39  f000				  -			;* Set the values according to the system you compile for.
     40  f000				  -			;*
     41  f000				  -
     42  f000				  -POKEY_BASE equ	pokeyaddress
     43  f000				  -PLAYER_ZP_RAM equ	songchannel1layer1lo	;* player routine needs 19 bytes
     44  f000				  -			;* of zero page RAM
     45  f000				  -PLAYER_VAR_RAM equ	RMTRAM	;* variables in main RAM - 173 bytes
     46  f000				  -			;* mono - 337 stereo
     47  f000				  -
     48  f000				  -ROM_BASED  equ	1	;* using a ROM based system - no self modifying code
     49  f000				  -STEREO8T   equ	0	;* 0 => compile RMTplayer for mono 4 tracks
     50  f000				  -			; ;1 => compile RMTplayer for stereo 8 tracks
     51  f000				  -
     52  f000				  -HARD_OF_HEARING equ	1	;* repeat output to pokey
     53  f000				  -
     54  f000				  -rmt_ispeed equ	PLAYER_ZP_RAM+19
     55  f000				  -rmt_intcount equ	PLAYER_ZP_RAM+20
     56  f000				  -
     57  f000				  -			;*
     58  f000				  -
     59  f000				  -	      IF	STEREO8T
     60  f000				  -TRACKS     equ	8
     61  f000				  -	      ELSE
     62  f000				  -TRACKS     equ	4
     63  f000				  -	      ENDIF
     64  f000				  -
     65  f000				  -			;*
     66  f000				  -			;* RMT FEATures definitions
     67  f000				  -			;* For optimizations of RMT player routine to concrete RMT modul only!
     68  f000				  -			;* --------BEGIN--------
     69  f000				  -FEAT_COMMAND1 equ	1	;* cca 8 bytes
     70  f000				  -FEAT_COMMAND2 equ	1	;* cca 20 bytes (+save 1 address in zero page)
     71  f000				  -			;* and quicker whole RMT routine
     72  f000				  -FEAT_COMMAND3 equ	1	;* cca 12 bytes
     73  f000				  -FEAT_COMMAND4 equ	1	;* cca 15 bytes
     74  f000				  -FEAT_COMMAND5 equ	1	;* cca 67 bytes
     75  f000				  -FEAT_COMMAND6 equ	1	;* cca 15 bytes
     76  f000				  -			;* COMMAND7 SETNOTE (i.e. command 7 with parameter != $80)
     77  f000				  -FEAT_COMMAND7SETNOTE equ	1	;* cca 12 bytes
     78  f000				  -			;* COMMAND7 VOLUMEONLY (i.e. command 7 with parameter == $80)
     79  f000				  -FEAT_COMMAND7VOLUMEONLY equ	1	;* cca 74 bytes
     80  f000				  -			;* PORTAMENTO
     81  f000				  -FEAT_PORTAMENTO equ	1	;* cca 138 bytes and quicker whole RMT routine
     82  f000				  -			;* FILTER
     83  f000				  -FEAT_FILTER equ	1	;* cca 179 bytes and quicker whole RMT routine
     84  f000				  -FEAT_FILTERG0L equ	1	;* (cca 38 bytes for each)
     85  f000				  -FEAT_FILTERG1L equ	1
     86  f000				  -FEAT_FILTERG0R equ	1
     87  f000				  -FEAT_FILTERG1R equ	1
     88  f000				  -			;* BASS16B (i.e. distortion value 6)
     89  f000				  -FEAT_BASS16 equ	1	;* cca 194 bytes +128bytes freq table and
     90  f000				  -			;* quicker whole RMT routine
     91  f000				  -FEAT_BASS16G1L equ	1	;* (cca 47 bytes for each)
     92  f000				  -FEAT_BASS16G3L equ	1
     93  f000				  -FEAT_BASS16G1R equ	1
     94  f000				  -FEAT_BASS16G3R equ	1
     95  f000				  -			;* VOLUME ONLY for particular generators
     96  f000				  -FEAT_VOLUMEONLYG0L equ	1	;* (cca 7 bytes for each)
     97  f000				  -FEAT_VOLUMEONLYG2L equ	1
     98  f000				  -FEAT_VOLUMEONLYG3L equ	1
     99  f000				  -FEAT_VOLUMEONLYG0R equ	1
    100  f000				  -FEAT_VOLUMEONLYG2R equ	1
    101  f000				  -FEAT_VOLUMEONLYG3R equ	1
    102  f000				  -			;* TABLE TYPE (i.e. TABLETYPE=1)
    103  f000				  -FEAT_TABLETYPE equ	1	;* cca 53 bytes and quicker whole RMT routine
    104  f000				  -			;* TABLE MODE (i.e. TABLEMODE=1)
    105  f000				  -FEAT_TABLEMODE equ	1	;* cca 16 bytes and quicker whole RMT routine
    106  f000				  -			;* AUDCTLMANUALSET (i.e. any MANUAL AUDCTL setting to nonzero value)
    107  f000				  -FEAT_AUDCTLMANUALSET equ	1	;* cca 27 bytes and quicker whole RMT routine
    108  f000				  -			;* --------END--------
    109  f000				  -			;*
    110  f000				  -			;*
    111  f000				  -			;* RMT ZeroPage addresses
    112  f000				  -
    113  f000				  -MEMLOC     SET	PLAYER_ZP_RAM
    114  f000				  -p_tis      =	MEMLOC
    115  f000				  -p_instrstable =	MEMLOC
    116  f000				  -MEMLOC     SET	(MEMLOC+2)
    117  f000				  -ptrTracksTblLo =	MEMLOC
    118  f000				  -MEMLOC     SET	(MEMLOC+2)
    119  f000				  -ptrTracksTblHi =	MEMLOC
    120  f000				  -MEMLOC     SET	(MEMLOC+2)
    121  f000				  -ptrSongLines =	MEMLOC
    122  f000				  -MEMLOC     SET	(MEMLOC+2)
    123  f000				  -
    124  f000				  -_ns	      =	MEMLOC
    125  f000				  -MEMLOC     SET	(MEMLOC+2)
    126  f000				  -_nr	      =	MEMLOC
    127  f000				  -MEMLOC     SET	(MEMLOC+2)
    128  f000				  -_nt	      =	MEMLOC
    129  f000				  -MEMLOC     SET	(MEMLOC+2)
    130  f000				  -
    131  f000				  -rmtreg1    =	MEMLOC
    132  f000				  -MEMLOC     SET	(MEMLOC+1)
    133  f000				  -rmtreg2    =	MEMLOC
    134  f000				  -MEMLOC     SET	(MEMLOC+1)
    135  f000				  -rmtreg3    =	MEMLOC
    136  f000				  -MEMLOC     SET	(MEMLOC+1)
    137  f000				  -_tmp       =	MEMLOC
    138  f000				  -MEMLOC     SET	(MEMLOC+1)
    139  f000				  -	      IF	FEAT_COMMAND2
    140  f000				  -frqaddcmd2 =	MEMLOC
    141  f000				  -MEMLOC     SET	(MEMLOC+1)
    142  f000				  -	      ENDIF
    143  f000				  -
    144  f000				  -			;*
    145  f000				  -			;* Variables in main RAM used by player routine.
    146  f000				  -			;* 337 bytes for stereo - 173 bytes for mono
    147  f000				  -			;*
    148  f000				  -
    149  f000				  -MEMLOC     SET	PLAYER_VAR_RAM
    150  f000				  -track_variables =	MEMLOC
    151  f000				  -
    152  f000				  -trackn_TblLo =	MEMLOC
    153  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    154  f000				  -trackn_TblHi =	MEMLOC
    155  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    156  f000				  -trackn_idx =	MEMLOC
    157  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    158  f000				  -trackn_pause =	MEMLOC
    159  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    160  f000				  -trackn_note =	MEMLOC
    161  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    162  f000				  -trackn_volume =	MEMLOC
    163  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    164  f000				  -trackn_distor =	MEMLOC
    165  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    166  f000				  -trackn_shiftfrq =	MEMLOC
    167  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    168  f000				  -
    169  f000				  -	      IF	FEAT_PORTAMENTO
    170  f000				  -trackn_portafrqc =	MEMLOC
    171  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    172  f000				  -trackn_portafrqa =	MEMLOC
    173  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    174  f000				  -trackn_portaspeed =	MEMLOC
    175  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    176  f000				  -trackn_portaspeeda =	MEMLOC
    177  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    178  f000				  -trackn_portadepth =	MEMLOC
    179  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    180  f000				  -	      ENDIF
    181  f000				  -
    182  f000				  -trackn_instrx2 =	MEMLOC
    183  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    184  f000				  -trackn_instrdb =	MEMLOC
    185  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    186  f000				  -trackn_instrhb =	MEMLOC
    187  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    188  f000				  -trackn_instridx =	MEMLOC
    189  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    190  f000				  -trackn_instrlen =	MEMLOC
    191  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    192  f000				  -trackn_instrlop =	MEMLOC
    193  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    194  f000				  -trackn_instrreachend =	MEMLOC
    195  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    196  f000				  -trackn_volumeslidedepth =	MEMLOC
    197  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    198  f000				  -trackn_volumeslidevalue =	MEMLOC
    199  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    200  f000				  -trackn_volumemin =	MEMLOC
    201  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    202  f000				  -trackn_effdelay =	MEMLOC
    203  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    204  f000				  -trackn_effvibratoa =	MEMLOC
    205  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    206  f000				  -trackn_effvibratobeg =	MEMLOC
    207  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    208  f000				  -trackn_effvibratoend =	MEMLOC
    209  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    210  f000				  -trackn_effshift =	MEMLOC
    211  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    212  f000				  -trackn_tabletypespeed =	MEMLOC
    213  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    214  f000				  -
    215  f000				  -	      IF	FEAT_TABLEMODE
    216  f000				  -trackn_tablemode =	MEMLOC
    217  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    218  f000				  -	      ENDIF
    219  f000				  -
    220  f000				  -trackn_tablenote =	MEMLOC
    221  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    222  f000				  -
    223  f000				  -trackn_tablea =	MEMLOC
    224  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    225  f000				  -trackn_tableend =	MEMLOC
    226  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    227  f000				  -trackn_tablelop =	MEMLOC
    228  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    229  f000				  -trackn_tablespeeda =	MEMLOC
    230  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    231  f000				  -trackn_command =	MEMLOC
    232  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    233  f000				  -
    234  f000				  -	      IF	FEAT_BASS16
    235  f000				  -trackn_outnote =	MEMLOC
    236  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    237  f000				  -	      ENDIF
    238  f000				  -	      IF	FEAT_FILTER
    239  f000				  -trackn_filter =	MEMLOC
    240  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    241  f000				  -	      ENDIF
    242  f000				  -
    243  f000				  -trackn_audf =	MEMLOC
    244  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    245  f000				  -trackn_audc =	MEMLOC
    246  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    247  f000				  -
    248  f000				  -	      IF	FEAT_AUDCTLMANUALSET
    249  f000				  -trackn_audctl =	MEMLOC
    250  f000				  -MEMLOC     SET	(MEMLOC+TRACKS)
    251  f000				  -	      ENDIF
    252  f000				  -
    253  f000				  -v_audctl   =	MEMLOC
    254  f000				  -MEMLOC     SET	(MEMLOC+1)
    255  f000				  -v_audctl2  =	MEMLOC
    256  f000				  -MEMLOC     SET	(MEMLOC+1)
    257  f000				  -v_speed    =	MEMLOC
    258  f000				  -MEMLOC     SET	(MEMLOC+1)
    259  f000				  -v_aspeed   =	MEMLOC
    260  f000				  -MEMLOC     SET	(MEMLOC+1)
    261  f000				  -v_bspeed   =	MEMLOC
    262  f000				  -MEMLOC     SET	(MEMLOC+1)
    263  f000				  -v_instrspeed =	MEMLOC
    264  f000				  -MEMLOC     SET	(MEMLOC+1)
    265  f000				  -smc_silence_instrspeed =	MEMLOC
    266  f000				  -MEMLOC     SET	(MEMLOC+1)
    267  f000				  -v_maxtracklen =	MEMLOC
    268  f000				  -MEMLOC     SET	(MEMLOC+1)
    269  f000				  -v_abeat    =	MEMLOC
    270  f000				  -MEMLOC     SET	(MEMLOC+1)
    271  f000				  -
    272  f000				  -track_endvariables =	MEMLOC
    273  f000				  -
    274  f000				  -			;*
    275  f000				  -			;* Data tables used by player routine.
    276  f000				  -			;*
    277  f000				  -	      ALIGN	256
    278  f000				  -PLAYER     =	.
    279  f000				  -
    280  f000				  -volumetab
    281  f000				  -	      dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    282  f000				  -	      dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
    283  f000				  -	      dc.b	$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01,$02,$02,$02,$02
    284  f000				  -	      dc.b	$00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02,$03,$03,$03
    285  f000				  -	      dc.b	$00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03,$04,$04
    286  f000				  -	      dc.b	$00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
    287  f000				  -	      dc.b	$00,$00,$01,$01,$02,$02,$02,$03,$03,$04,$04,$04,$05,$05,$06,$06
    288  f000				  -	      dc.b	$00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
    289  f000				  -	      dc.b	$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07,$08
    290  f000				  -	      dc.b	$00,$01,$01,$02,$02,$03,$04,$04,$05,$05,$06,$07,$07,$08,$08,$09
    291  f000				  -	      dc.b	$00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$07,$07,$08,$09,$09,$0A
    292  f000				  -	      dc.b	$00,$01,$01,$02,$03,$04,$04,$05,$06,$07,$07,$08,$09,$0A,$0A,$0B
    293  f000				  -	      dc.b	$00,$01,$02,$02,$03,$04,$05,$06,$06,$07,$08,$09,$0A,$0A,$0B,$0C
    294  f000				  -	      dc.b	$00,$01,$02,$03,$03,$04,$05,$06,$07,$08,$09,$0A,$0A,$0B,$0C,$0D
    295  f000				  -	      dc.b	$00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0A,$0B,$0C,$0D,$0E
    296  f000				  -	      dc.b	$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0A,$0B,$0C,$0D,$0E,$0F
    297  f000				  -
    298  f000				  -frqtab
    299  f000				  -			; ERT [<frqtab]!=0 ;* frqtab must begin at the memory page bound!
    300  f000				  -			;* (i.e. $..00 address)
    301  f000				  -frqtabbass1
    302  f000				  -	      dc.b	$BF,$B6,$AA,$A1,$98,$8F,$89,$80,$F2,$E6,$DA,$CE,$BF,$B6,$AA,$A1
    303  f000				  -	      dc.b	$98,$8F,$89,$80,$7A,$71,$6B,$65,$5F,$5C,$56,$50,$4D,$47,$44,$3E
    304  f000				  -	      dc.b	$3C,$38,$35,$32,$2F,$2D,$2A,$28,$25,$23,$21,$1F,$1D,$1C,$1A,$18
    305  f000				  -	      dc.b	$17,$16,$14,$13,$12,$11,$10,$0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07
    306  f000				  -frqtabbass2
    307  f000				  -	      dc.b	$FF,$F1,$E4,$D8,$CA,$C0,$B5,$AB,$A2,$99,$8E,$87,$7F,$79,$73,$70
    308  f000				  -	      dc.b	$66,$61,$5A,$55,$52,$4B,$48,$43,$3F,$3C,$39,$37,$33,$30,$2D,$2A
    309  f000				  -	      dc.b	$28,$25,$24,$21,$1F,$1E,$1C,$1B,$19,$17,$16,$15,$13,$12,$11,$10
    310  f000				  -	      dc.b	$0F,$0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00
    311  f000				  -frqtabpure
    312  f000				  -	      dc.b	$F3,$E6,$D9,$CC,$C1,$B5,$AD,$A2,$99,$90,$88,$80,$79,$72,$6C,$66
    313  f000				  -	      dc.b	$60,$5B,$55,$51,$4C,$48,$44,$40,$3C,$39,$35,$32,$2F,$2D,$2A,$28
    314  f000				  -	      dc.b	$25,$23,$21,$1F,$1D,$1C,$1A,$18,$17,$16,$14,$13,$12,$11,$10,$0F
    315  f000				  -	      dc.b	$0E,$0D,$0C,$0B,$0A,$09,$08,$07,$06,$05,$04,$03,$02,$01,$00,$00
    316  f000				  -	      IF	FEAT_BASS16
    317  f000				  -frqtabbasshi
    318  f000				  -	      dc.b	$0D,$0D,$0C,$0B,$0B,$0A,$0A,$09,$08,$08,$07,$07,$07,$06,$06,$05
    319  f000				  -	      dc.b	$05,$05,$04,$04,$04,$04,$03,$03,$03,$03,$03,$02,$02,$02,$02,$02
    320  f000				  -	      dc.b	$02,$02,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$01,$00,$00
    321  f000				  -	      dc.b	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
    322  f000				  -	      ENDIF
    323  f000				  -
    324  f000				  -	      IF	FEAT_BASS16
    325  f000				  -frqtabbasslo
    326  f000				  -	      dc.b	$F2,$33,$96,$E2,$38,$8C,$00,$6A,$E8,$6A,$EF,$80,$08,$AE,$46,$E6
    327  f000				  -	      dc.b	$95,$41,$F6,$B0,$6E,$30,$F6,$BB,$84,$52,$22,$F4,$C8,$A0,$7A,$55
    328  f000				  -	      dc.b	$34,$14,$F5,$D8,$BD,$A4,$8D,$77,$60,$4E,$38,$27,$15,$06,$F7,$E8
    329  f000				  -	      dc.b	$DB,$CF,$C3,$B8,$AC,$A2,$9A,$90,$88,$7F,$78,$70,$6A,$64,$5E,$00
    330  f000				  -	      ENDIF
    331  f000				  -
    332  f000				  -	      IF	ROM_BASED
    333  f000				  -rts_tab    dc.w	cmd0-1,cmd1-1,cmd2-1,cmd3-1,cmd4-1,cmd5-1,cmd6-1,cmd7-1
    334  f000				  -	      ENDIF
    335  f000				  -INSTRPAR   equ	12
    336  f000				  -tabbeganddistor
    337  f000				  -	      dc.b	frqtabpure-frqtab,$00
    338  f000				  -	      dc.b	frqtabpure-frqtab,$20
    339  f000				  -	      dc.b	frqtabpure-frqtab,$40
    340  f000				  -	      dc.b	frqtabbass1-frqtab,$c0
    341  f000				  -	      dc.b	frqtabpure-frqtab,$80
    342  f000				  -	      dc.b	frqtabpure-frqtab,$a0
    343  f000				  -	      dc.b	frqtabbass1-frqtab,$c0
    344  f000				  -	      dc.b	frqtabbass2-frqtab,$c0
    345  f000				  -vibtabbeg  dc.b	0,vib1-vib0,vib2-vib0,vib3-vib0,vibx-vib0
    346  f000				  -vib0       dc.b	0
    347  f000				  -vib1       dc.b	1,-1,-1,1
    348  f000				  -vib2       dc.b	1,0,-1,-1,0,1
    349  f000				  -vib3       dc.b	1,1,0,-1,-1,-1,-1,0,1,1
    350  f000				  -vibx
    351  f000				  -emptytrack
    352  f000				  -	      dc.b	62,0
    353  f000				  -
    354  f000				  -			;*
    355  f000				  -			;* Set of RMT main vectors:
    356  f000				  -			;*
    357  f000				  -RASTERMUSICTRACKER
    358  f000				  -	      jmp	rmt_init	;* Must be run first, to clear memory and initialise
    359  f000				  -			;* the player... Once this is done, run rmt_play
    360  f000				  -			;* afterwards, or Set_Pokey if you want to manually
    361  f000				  -			;* time certain things.
    362  f000				  -
    363  f000				  -	      jmp	rmt_play	;* One play each subroutine call. SetPokey is
    364  f000				  -			;* executed first, then all the play code is ran
    365  f000				  -			;* once, until the RTS. rmt_play could be called
    366  f000				  -			;* multiple times per frame if wanted.
    367  f000				  -
    368  f000				  -	      jmp	rmt_p3	;* Similar to rmt_play, but will also skip SetPokey
    369  f000				  -			;* and the instruments/songlines/tracklines
    370  f000				  -			;* initialisation, very useful for playing simple
    371  f000				  -			;* things.
    372  f000				  -
    373  f000				  -	      jmp	rmt_silence	;* Run this to stop the driver, and reset all POKEY
    374  f000				  -			;* registers to 0. This is also part of rmt_init
    375  f000				  -			;* when it is executed first.
    376  f000				  -
    377  f000				  -	      jmp	SetPokey	;* Run to copy the contents of the Shadow POKEY
    378  f000				  -			;* registers (v_audctl, v_skctl, trackn_audf,x etc)
    379  f000				  -			;* into the real ones. Will be run first each time
    380  f000				  -			;* rmt_play is called.
    381  f000				  -rmt_init
    382  f000				  -	      stx	_ns
    383  f000				  -	      sty	_ns+1
    384  f000				  -	      pha
    385  f000				  -	      IF	track_endvariables-track_variables>255
    386  f000				  -	      ldy	#0
    387  f000				  -	      tya
    388  f000				  -ri_clear_loop
    389  f000				  -	      sta	track_variables,y
    390  f000				  -	      sta	track_endvariables-$100,y
    391  f000				  -	      iny
    392  f000				  -	      bne	ri_clear_loop
    393  f000				  -	      ELSE
    394  f000				  -	      ldy	#track_endvariables-track_variables
    395  f000				  -	      lda	#0
    396  f000				  -ri_clear_loop
    397  f000				  -	      sta	track_variables-1,y
    398  f000				  -	      dey
    399  f000				  -	      bne	ri_clear_loop
    400  f000				  -	      ENDIF
    401  f000				  -			;* Parse the RMT module data
    402  f000				  -			;* Track length: +4
    403  f000				  -	      ldy	#4
    404  f000				  -	      lda	(_ns),y
    405  f000				  -	      sta	v_maxtracklen	;* Change the code to store the track length
    406  f000				  -	      iny
    407  f000				  -	      lda	(_ns),y
    408  f000				  -	      sta	v_speed	;* Change the code to store the song speed
    409  f000				  -	      iny
    410  f000				  -	      lda	(_ns),y
    411  f000				  -	      sta	v_instrspeed	;* Change the code to store the instrument speed
    412  f000				  -	      sta	smc_silence_instrspeed
    413  f000				  -
    414  f000				  -			; Copy 4 pointers: +8
    415  f000				  -			; -> InstrumentPtrs[]	       2 bytes
    416  f000				  -			; -> TracksPtrsLow[]	       2 bytes
    417  f000				  -			; -> TracksPtrsHi	       2 bytes
    418  f000				  -			; -> SongData		       2 bytes
    419  f000				  -	      ldy	#8
    420  f000				  -ri_copy_loop
    421  f000				  -	      lda	(_ns),y
    422  f000				  -	      sta	p_tis-8,y
    423  f000				  -	      iny
    424  f000				  -	      cpy	#8+8	;* we started at 8, so loop until 16
    425  f000				  -	      bne	ri_copy_loop
    426  f000				  -
    427  f000				  -	      pla
    428  f000				  -	      pha
    429  f000				  -	      IF	STEREO8T
    430  f000				  -	      asl
    431  f000				  -	      asl
    432  f000				  -	      asl
    433  f000				  -	      clc
    434  f000				  -	      adc	ptrSongLines
    435  f000				  -	      sta	ptrSongLines
    436  f000				  -	      pla
    437  f000				  -	      and	#$e0
    438  f000				  -	      asl
    439  f000				  -	      rol
    440  f000				  -	      rol
    441  f000				  -	      rol
    442  f000				  -	      ELSE
    443  f000				  -	      asl
    444  f000				  -	      asl
    445  f000				  -	      clc
    446  f000				  -	      adc	ptrSongLines
    447  f000				  -	      sta	ptrSongLines
    448  f000				  -	      pla
    449  f000				  -	      and	#$c0
    450  f000				  -	      asl
    451  f000				  -	      rol
    452  f000				  -	      rol
    453  f000				  -	      ENDIF
    454  f000				  -	      adc	ptrSongLines+1
    455  f000				  -	      sta	ptrSongLines+1
    456  f000				  -
    457  f000				  -	      jsr	GetSongLine
    458  f000				  -
    459  f000				  -	      jsr	GetTrackLine
    460  f000				  -	      jsr	InitOfNewSetInstrumentsOnly
    461  f000				  -	      jsr	rmt_silence
    462  f000				  -	      lda	v_instrspeed
    463  f000				  -	      rts
    464  f000				  -
    465  f000				  -rmt_silence
    466  f000				  -	      IF	STEREO8T
    467  f000				  -	      lda	#0
    468  f000				  -	      sta	POKEY_BASE+$08
    469  f000				  -	      sta	POKEY_BASE_S+$08
    470  f000				  -	      ldy	#3
    471  f000				  -	      sty	POKEY_BASE+$0f
    472  f000				  -	      sty	POKEY_BASE_S+$0f
    473  f000				  -	      ldy	#8
    474  f000				  -rmt_silence_loop
    475  f000				  -	      sta	POKEY_BASE+$00,y
    476  f000				  -	      sta	POKEY_BASE_S+$00,y
    477  f000				  -	      dey
    478  f000				  -	      bpl	rmt_silence_loop
    479  f000				  -	      ELSE
    480  f000				  -	      lda	#0
    481  f000				  -	      sta	POKEY_BASE+$08
    482  f000				  -	      ldy	#3
    483  f000				  -	      sty	POKEY_BASE+$0f
    484  f000				  -	      ldy	#8
    485  f000				  -rmt_silence_loop
    486  f000				  -	      sta	POKEY_BASE+$00,y
    487  f000				  -	      dey
    488  f000				  -	      bpl	rmt_silence_loop
    489  f000				  -	      ENDIF
    490  f000				  -	      rts
    491  f000				  -
    492  f000				  -GetSongLine
    493  f000				  -	      ldx	#0
    494  f000				  -	      stx	v_abeat
    495  f000				  -gsl_loop
    496  f000				  -	      ldx	#0
    497  f000				  -gsl_nextSongLine
    498  f000				  -	      txa
    499  f000				  -	      tay
    500  f000				  -	      lda	(ptrSongLines),y
    501  f000				  -	      cmp	#$fe	;* check for "goto line"
    502  f000				  -	      bcs	gsl_GotoOrEmpty	;* and handle it.
    503  f000				  -			;* (A) = Real track #
    504  f000				  -			;* Get the ptr to the track data and store it in ptrTracksTblLo
    505  f000				  -	      tay
    506  f000				  -	      lda	(ptrTracksTblLo),y
    507  f000				  -	      sta	trackn_TblLo,x
    508  f000				  -	      lda	(ptrTracksTblHi),y
    509  f000				  -gsl_initTrack
    510  f000				  -	      sta	trackn_TblHi,x
    511  f000				  -
    512  f000				  -	      lda	#0	;* reset the track index to 0 trackn_idx[x] = 0
    513  f000				  -	      sta	trackn_idx,x
    514  f000				  -
    515  f000				  -	      lda	#1
    516  f000				  -	      sta	trackn_pause,x	;* #1 is a new track, #0 is no new track
    517  f000				  -
    518  f000				  -	      lda	#$80	;* mark that there is no new instrument
    519  f000				  -	      sta	trackn_instrx2,x	;* #$80 is negative, will BMI when encountered,
    520  f000				  -			;* meaning no new instrument initialisation
    521  f000				  -	      inx
    522  f000				  -	      cpx	#TRACKS	;* if x < TRACKS --> gsl_nextSongLine
    523  f000				  -	      bne	gsl_nextSongLine
    524  f000				  -
    525  f000				  -			;* Done with data points of a song line, move to the next line
    526  f000				  -	      lda	ptrSongLines
    527  f000				  -	      clc
    528  f000				  -	      adc	#TRACKS
    529  f000				  -	      sta	ptrSongLines
    530  f000				  -	      bcc	gsl_skipSongHiIncrement
    531  f000				  -	      inc	ptrSongLines+1
    532  f000				  -gsl_skipSongHiIncrement
    533  f000				  -	      rts
    534  f000				  -
    535  f000				  -gsl_GotoOrEmpty
    536  f000				  -			; "cmp #$FE" performed prior to getting here
    537  f000				  -	      beq	gsl_Goto
    538  f000				  -
    539  f000				  -gsl_Empty
    540  f000				  -	      lda	#<emptytrack
    541  f000				  -	      sta	trackn_TblLo,x
    542  f000				  -	      lda	#>emptytrack
    543  f000				  -	      jmp	gsl_initTrack
    544  f000				  -
    545  f000				  -gsl_Goto
    546  f000				  -			; Data format: 0xFE, ???, low, high bytes of ptr to next song line
    547  f000				  -	      ldy	#2
    548  f000				  -	      lda	(ptrSongLines),y
    549  f000				  -	      tax
    550  f000				  -	      iny
    551  f000				  -	      lda	(ptrSongLines),y
    552  f000				  -	      sta	ptrSongLines+1
    553  f000				  -	      stx	ptrSongLines
    554  f000				  -	      jmp	gsl_loop
    555  f000				  -
    556  f000				  -GetTrackLine
    557  f000				  -rmtoo0
    558  f000				  -rmtoo0a
    559  f000				  -	      lda	v_speed
    560  f000				  -	      sta	v_bspeed
    561  f000				  -	      ldx	#0
    562  f000				  -gtl_loopTracks
    563  f000				  -	      lda	trackn_pause,x
    564  f000				  -	      beq	gtl_checkEndOfLoop
    565  f000				  -	      dec	trackn_pause,x
    566  f000				  -	      bne	gtl_checkEndOfLoop
    567  f000				  -	      inc	trackn_pause,x
    568  f000				  -
    569  f000				  -	      lda	trackn_TblLo,x
    570  f000				  -	      sta	_ns
    571  f000				  -	      lda	trackn_TblHi,x
    572  f000				  -	      sta	_ns+1
    573  f000				  -
    574  f000				  -oo1i
    575  f000				  -	      ldy	trackn_idx,x
    576  f000				  -			;* Get a track data point
    577  f000				  -			;* 0 - 60 = Note, instr and volume data
    578  f000				  -			;* 61 - Volume only
    579  f000				  -			;* 62 = Pause/empty line
    580  f000				  -			;* 63 - Speed, go loop or end
    581  f000				  -	      lda	(_ns),y
    582  f000				  -	      sta	rmtreg1
    583  f000				  -	      iny
    584  f000				  -	      lda	(_ns),y
    585  f000				  -	      sta	rmtreg2
    586  f000				  -	      iny
    587  f000				  -	      tya
    588  f000				  -	      sta	trackn_idx,x
    589  f000				  -
    590  f000				  -	      lda	rmtreg1
    591  f000				  -	      and	#$3f
    592  f000				  -	      cmp	#61
    593  f000				  -	      beq	gtl_ProcessVolumeData
    594  f000				  -	      bcs	gtl_Is62or63
    595  f000				  -
    596  f000				  -			;* if we're here it's a note, so store it.
    597  f000				  -	      sta	trackn_note,x
    598  f000				  -	      IF	FEAT_BASS16
    599  f000				  -	      sta	trackn_outnote,x
    600  f000				  -	      ENDIF
    601  f000				  -
    602  f000				  -			;* Process the instrument #
    603  f000				  -	      lda	rmtreg2
    604  f000				  -	      lsr
    605  f000				  -	      and	#$3f*2
    606  f000				  -	      sta	trackn_instrx2,x
    607  f000				  -
    608  f000				  -gtl_ProcessVolumeData
    609  f000				  -	      lda	rmtreg2
    610  f000				  -	      lsr
    611  f000				  -	      ror	rmtreg1
    612  f000				  -	      lsr
    613  f000				  -	      ror	rmtreg1
    614  f000				  -	      lda	rmtreg1
    615  f000				  -	      and	#$f0
    616  f000				  -	      sta	trackn_volume,x
    617  f000				  -gtl_checkEndOfLoop
    618  f000				  -	      inx
    619  f000				  -	      cpx	#TRACKS
    620  f000				  -	      bne	gtl_loopTracks
    621  f000				  -	      lda	v_bspeed
    622  f000				  -	      sta	v_speed
    623  f000				  -	      sta	v_aspeed
    624  f000				  -	      rts
    625  f000				  -
    626  f000				  -gtl_Is62or63
    627  f000				  -	      cmp	#63
    628  f000				  -	      beq	rmtoo63
    629  f000				  -	      lda	rmtreg1
    630  f000				  -	      and	#$c0
    631  f000				  -	      beq	rmtoo62_b
    632  f000				  -	      asl
    633  f000				  -	      rol
    634  f000				  -	      rol
    635  f000				  -	      sta	trackn_pause,x
    636  f000				  -	      dec	trackn_idx,x
    637  f000				  -	      jmp	gtl_checkEndOfLoop
    638  f000				  -
    639  f000				  -rmtoo62_b
    640  f000				  -	      lda	rmtreg2
    641  f000				  -	      sta	trackn_pause,x
    642  f000				  -	      jmp	gtl_checkEndOfLoop
    643  f000				  -
    644  f000				  -rmtoo63
    645  f000				  -	      lda	rmtreg1
    646  f000				  -	      bmi	rmtoo63_1X
    647  f000				  -	      lda	rmtreg2
    648  f000				  -	      sta	v_bspeed
    649  f000				  -	      jmp	oo1i
    650  f000				  -rmtoo63_1X
    651  f000				  -	      cmp	#255
    652  f000				  -	      beq	rmtoo63_11
    653  f000				  -	      lda	rmtreg2
    654  f000				  -	      sta	trackn_idx,x
    655  f000				  -	      jmp	oo1i
    656  f000				  -
    657  f000				  -rmtoo63_11
    658  f000				  -	      jsr	GetSongLine
    659  f000				  -	      jmp	rmtoo0
    660  f000				  -
    661  f000				  -InitOfNewSetInstrumentsOnly
    662  f000				  -	      ldx	#0
    663  f000				  -p2x1       ldy	trackn_instrx2,x
    664  f000				  -	      bmi	p2x2	;* if negative, no new instrument to initialise for this channel
    665  f000				  -	      jsr	SetUpInstrumentY2
    666  f000				  -	      lda	#$80
    667  f000				  -	      sta	trackn_instrx2,x
    668  f000				  -p2x2
    669  f000				  -	      inx
    670  f000				  -	      cpx	#TRACKS
    671  f000				  -	      bne	p2x1
    672  f000				  -	      rts
    673  f000				  -
    674  f000				  -rmt_play
    675  f000				  -rmt_p0
    676  f000				  -	      jsr	SetPokey
    677  f000				  -rmt_p1
    678  f000				  -	      dec	smc_silence_instrspeed
    679  f000				  -	      beq	rmtp1a
    680  f000				  -	      jmp	rmt_p3
    681  f000				  -rmtp1a
    682  f000				  -	      lda	v_instrspeed
    683  f000				  -	      sta	smc_silence_instrspeed
    684  f000				  -rmt_p2
    685  f000				  -	      dec	v_aspeed
    686  f000				  -	      bne	rmt_p3
    687  f000				  -	      inc	v_abeat
    688  f000				  -	      lda	v_abeat
    689  f000				  -	      cmp	v_maxtracklen
    690  f000				  -	      bne	rmtp2o2
    691  f000				  -	      jsr	GetSongLine
    692  f000				  -rmtp2o2
    693  f000				  -	      jsr	GetTrackLine
    694  f000				  -	      jmp	rmt_p2X
    695  f000				  -go_ppnext
    696  f000				  -	      jmp	ppnext
    697  f000				  -rmt_p2X
    698  f000				  -	      jsr	InitOfNewSetInstrumentsOnly
    699  f000				  -rmt_p3
    700  f000				  -	      lda	#>frqtab
    701  f000				  -	      sta	_nr+1
    702  f000				  -
    703  f000				  -	      ldx	#0
    704  f000				  -rmtpp1
    705  f000				  -	      lda	trackn_instrhb,x
    706  f000				  -	      beq	go_ppnext
    707  f000				  -	      sta	_ns+1
    708  f000				  -	      lda	trackn_instrdb,x
    709  f000				  -	      sta	_ns
    710  f000				  -	      ldy	trackn_instridx,x
    711  f000				  -	      lda	(_ns),y
    712  f000				  -	      sta	rmtreg1
    713  f000				  -	      iny
    714  f000				  -	      lda	(_ns),y
    715  f000				  -	      sta	rmtreg2
    716  f000				  -	      iny
    717  f000				  -	      lda	(_ns),y
    718  f000				  -	      sta	rmtreg3
    719  f000				  -	      iny
    720  f000				  -	      tya
    721  f000				  -	      cmp	trackn_instrlen,x
    722  f000				  -	      bcc	rmtpp2
    723  f000				  -	      beq	rmtpp2
    724  f000				  -	      lda	#$80
    725  f000				  -	      sta	trackn_instrreachend,x
    726  f000				  -rmtpp1b
    727  f000				  -	      lda	trackn_instrlop,x
    728  f000				  -rmtpp2
    729  f000				  -	      sta	trackn_instridx,x
    730  f000				  -	      lda	rmtreg1
    731  f000				  -	      IF	STEREO8T
    732  f000				  -	      cpx	#4
    733  f000				  -	      bcc	rmtpp2s
    734  f000				  -	      lsr
    735  f000				  -	      lsr
    736  f000				  -	      lsr
    737  f000				  -	      lsr
    738  f000				  -rmtpp2s
    739  f000				  -	      ENDIF
    740  f000				  -	      and	#$0f
    741  f000				  -	      ora	trackn_volume,x
    742  f000				  -	      tay
    743  f000				  -	      lda	volumetab,y
    744  f000				  -	      pha
    745  f000				  -	      lda	rmtreg2
    746  f000				  -	      and	#$0e
    747  f000				  -	      tay
    748  f000				  -	      lda	tabbeganddistor,y
    749  f000				  -	      sta	_nr
    750  f000				  -	      pla
    751  f000				  -	      ora	tabbeganddistor+1,y
    752  f000				  -	      sta	trackn_audc,x
    753  f000				  -	      jmp	InstrumentsEffects
    754  f000				  -returnfromInstrumentsEffects
    755  f000				  -	      IF	FEAT_COMMAND2
    756  f000				  -	      lda	#0
    757  f000				  -	      sta	frqaddcmd2
    758  f000				  -	      ENDIF
    759  f000				  -	      lda	rmtreg2
    760  f000				  -	      sta	trackn_command,x
    761  f000				  -	      and	#$70
    762  f000				  -	      lsr
    763  f000				  -	      lsr
    764  f000				  -	      IF	ROM_BASED
    765  f000				  -	      lsr
    766  f000				  -	      tay
    767  f000				  -	      lda	rts_tab+1,y
    768  f000				  -	      pha
    769  f000				  -	      lda	rts_tab,y
    770  f000				  -	      pha
    771  f000				  -	      rts
    772  f000				  -	      ELSE
    773  f000				  -	      sta	jmx+1
    774  f000				  -jmx
    775  f000				  -	      bcc	*
    776  f000				  -	      jmp	cmd0
    777  f000				  -	      nop
    778  f000				  -	      jmp	cmd1
    779  f000				  -	      nop
    780  f000				  -	      jmp	cmd2
    781  f000				  -	      nop
    782  f000				  -	      jmp	cmd3
    783  f000				  -	      nop
    784  f000				  -	      jmp	cmd4
    785  f000				  -	      nop
    786  f000				  -	      jmp	cmd5
    787  f000				  -	      nop
    788  f000				  -	      jmp	cmd6
    789  f000				  -	      nop
    790  f000				  -	      jmp	cmd7
    791  f000				  -	      ENDIF
    792  f000				  -cmd0
    793  f000				  -	      lda	trackn_note,x
    794  f000				  -	      clc
    795  f000				  -	      adc	rmtreg3
    796  f000				  -cmd0a
    797  f000				  -	      IF	FEAT_TABLETYPE
    798  f000				  -	      ldy	trackn_tabletypespeed,x
    799  f000				  -	      bmi	cmd0b
    800  f000				  -	      ENDIF
    801  f000				  -	      clc
    802  f000				  -	      adc	trackn_tablenote,x
    803  f000				  -	      cmp	#61
    804  f000				  -	      bcc	cmd0a1
    805  f000				  -	      lda	#0
    806  f000				  -	      sta	trackn_audc,x
    807  f000				  -	      lda	#63
    808  f000				  -cmd0a1
    809  f000				  -	      IF	FEAT_BASS16
    810  f000				  -	      sta	trackn_outnote,x
    811  f000				  -	      ENDIF
    812  f000				  -	      tay
    813  f000				  -	      lda	(_nr),y
    814  f000				  -	      clc
    815  f000				  -	      adc	trackn_shiftfrq,x
    816  f000				  -	      IF	FEAT_COMMAND2
    817  f000				  -	      clc
    818  f000				  -	      adc	frqaddcmd2
    819  f000				  -	      ENDIF
    820  f000				  -	      sta	trackn_audf,x
    821  f000				  -	      jmp	rmtpp9
    822  f000				  -	      IF	FEAT_TABLETYPE
    823  f000				  -cmd0b
    824  f000				  -	      cmp	#61
    825  f000				  -	      bcc	cmd0b1
    826  f000				  -	      lda	#0
    827  f000				  -	      sta	trackn_audc,x
    828  f000				  -	      lda	#63
    829  f000				  -cmd0b1
    830  f000				  -	      tay
    831  f000				  -	      lda	trackn_shiftfrq,x
    832  f000				  -	      clc
    833  f000				  -	      adc	trackn_tablenote,x
    834  f000				  -	      clc
    835  f000				  -	      adc	(_nr),y
    836  f000				  -	      IF	FEAT_COMMAND2
    837  f000				  -	      clc
    838  f000				  -	      adc	frqaddcmd2
    839  f000				  -	      ENDIF
    840  f000				  -	      sta	trackn_audf,x
    841  f000				  -	      jmp	rmtpp9
    842  f000				  -	      ENDIF
    843  f000				  -cmd1
    844  f000				  -	      IF	FEAT_COMMAND1
    845  f000				  -	      lda	rmtreg3
    846  f000				  -	      sta	trackn_audf,x
    847  f000				  -	      jmp	rmtpp9
    848  f000				  -	      ENDIF
    849  f000				  -cmd2
    850  f000				  -	      IF	FEAT_COMMAND2
    851  f000				  -	      lda	rmtreg3
    852  f000				  -	      sta	frqaddcmd2
    853  f000				  -	      lda	trackn_note,x
    854  f000				  -	      jmp	cmd0a
    855  f000				  -	      ENDIF
    856  f000				  -cmd3
    857  f000				  -	      IF	FEAT_COMMAND3
    858  f000				  -	      lda	trackn_note,x
    859  f000				  -	      clc
    860  f000				  -	      adc	rmtreg3
    861  f000				  -	      sta	trackn_note,x
    862  f000				  -	      jmp	cmd0a
    863  f000				  -	      ENDIF
    864  f000				  -cmd4
    865  f000				  -	      IF	FEAT_COMMAND4
    866  f000				  -	      lda	trackn_shiftfrq,x
    867  f000				  -	      clc
    868  f000				  -	      adc	rmtreg3
    869  f000				  -	      sta	trackn_shiftfrq,x
    870  f000				  -	      lda	trackn_note,x
    871  f000				  -	      jmp	cmd0a
    872  f000				  -	      ENDIF
    873  f000				  -cmd5
    874  f000				  -	      IF	FEAT_COMMAND5&&FEAT_PORTAMENTO
    875  f000				  -	      IF	FEAT_TABLETYPE
    876  f000				  -	      lda	trackn_tabletypespeed,x
    877  f000				  -	      bpl	cmd5a1
    878  f000				  -	      ldy	trackn_note,x
    879  f000				  -	      lda	(_nr),y
    880  f000				  -	      clc
    881  f000				  -	      adc	trackn_tablenote,x
    882  f000				  -	      jmp	cmd5ax
    883  f000				  -	      ENDIF
    884  f000				  -cmd5a1
    885  f000				  -	      lda	trackn_note,x
    886  f000				  -	      clc
    887  f000				  -	      adc	trackn_tablenote,x
    888  f000				  -	      cmp	#61
    889  f000				  -	      bcc	cmd5a2
    890  f000				  -	      lda	#63
    891  f000				  -cmd5a2
    892  f000				  -	      tay
    893  f000				  -	      lda	(_nr),y
    894  f000				  -cmd5ax
    895  f000				  -	      sta	trackn_portafrqc,x
    896  f000				  -	      ldy	rmtreg3
    897  f000				  -	      bne	cmd5a
    898  f000				  -	      sta	trackn_portafrqa,x
    899  f000				  -cmd5a
    900  f000				  -	      tya
    901  f000				  -	      lsr
    902  f000				  -	      lsr
    903  f000				  -	      lsr
    904  f000				  -	      lsr
    905  f000				  -	      sta	trackn_portaspeed,x
    906  f000				  -	      sta	trackn_portaspeeda,x
    907  f000				  -	      lda	rmtreg3
    908  f000				  -	      and	#$0f
    909  f000				  -	      sta	trackn_portadepth,x
    910  f000				  -	      lda	trackn_note,x
    911  f000				  -	      jmp	cmd0a
    912  f000				  -	      ELSE
    913  f000				  -	      IF	FEAT_COMMAND5
    914  f000				  -	      jmp	rmtpp9
    915  f000				  -	      ENDIF
    916  f000				  -	      ENDIF
    917  f000				  -cmd6
    918  f000				  -	      IF	FEAT_COMMAND6&&FEAT_FILTER
    919  f000				  -	      lda	rmtreg3
    920  f000				  -	      clc
    921  f000				  -	      adc	trackn_filter,x
    922  f000				  -	      sta	trackn_filter,x
    923  f000				  -	      lda	trackn_note,x
    924  f000				  -	      jmp	cmd0a
    925  f000				  -	      ELSE
    926  f000				  -	      IF	FEAT_COMMAND6
    927  f000				  -	      jmp	rmtpp9
    928  f000				  -	      ENDIF
    929  f000				  -	      ENDIF
    930  f000				  -cmd7
    931  f000				  -	      IF	FEAT_COMMAND7SETNOTE||FEAT_COMMAND7VOLUMEONLY
    932  f000				  -	      IF	FEAT_COMMAND7SETNOTE
    933  f000				  -	      lda	rmtreg3
    934  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY
    935  f000				  -	      cmp	#$80
    936  f000				  -	      beq	cmd7a
    937  f000				  -	      ENDIF
    938  f000				  -	      sta	trackn_note,x
    939  f000				  -	      jmp	cmd0a
    940  f000				  -	      ENDIF
    941  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY
    942  f000				  -cmd7a
    943  f000				  -	      lda	trackn_audc,x
    944  f000				  -	      ora	#$f0
    945  f000				  -	      sta	trackn_audc,x
    946  f000				  -	      lda	trackn_note,x
    947  f000				  -	      jmp	cmd0a
    948  f000				  -	      ENDIF
    949  f000				  -	      ENDIF
    950  f000				  -rmtpp9
    951  f000				  -	      IF	FEAT_PORTAMENTO
    952  f000				  -	      lda	trackn_portaspeeda,x
    953  f000				  -	      beq	rmtpp10
    954  f000				  -	      sec
    955  f000				  -	      sbc	#1
    956  f000				  -	      sta	trackn_portaspeeda,x
    957  f000				  -	      bne	rmtpp10
    958  f000				  -	      lda	trackn_portaspeed,x
    959  f000				  -	      sta	trackn_portaspeeda,x
    960  f000				  -	      lda	trackn_portafrqa,x
    961  f000				  -	      cmp	trackn_portafrqc,x
    962  f000				  -	      beq	rmtpp10
    963  f000				  -	      bcs	pps1
    964  f000				  -	      adc	trackn_portadepth,x
    965  f000				  -	      bcs	pps8
    966  f000				  -	      cmp	trackn_portafrqc,x
    967  f000				  -	      bcs	pps8
    968  f000				  -	      jmp	pps9
    969  f000				  -pps1
    970  f000				  -	      sbc	trackn_portadepth,x
    971  f000				  -	      bcc	pps8
    972  f000				  -	      cmp	trackn_portafrqc,x
    973  f000				  -	      bcs	pps9
    974  f000				  -pps8
    975  f000				  -	      lda	trackn_portafrqc,x
    976  f000				  -pps9
    977  f000				  -	      sta	trackn_portafrqa,x
    978  f000				  -rmtpp10
    979  f000				  -	      lda	rmtreg2
    980  f000				  -	      and	#$01
    981  f000				  -	      beq	rmtpp11
    982  f000				  -	      lda	trackn_portafrqa,x
    983  f000				  -	      clc
    984  f000				  -	      adc	trackn_shiftfrq,x
    985  f000				  -	      sta	trackn_audf,x
    986  f000				  -rmtpp11
    987  f000				  -	      ENDIF
    988  f000				  -ppnext
    989  f000				  -	      inx
    990  f000				  -	      cpx	#TRACKS
    991  f000				  -	      beq	rmt_p4
    992  f000				  -	      jmp	rmtpp1
    993  f000				  -rmt_p4
    994  f000				  -	      IF	FEAT_AUDCTLMANUALSET
    995  f000				  -	      ldx	#3
    996  f000				  -	      lda	#0
    997  f000				  -qq0	      ora	trackn_audctl,x
    998  f000				  -	      dex
    999  f000				  -	      bpl	qq0
   1000  f000				  -	      sta	v_audctl
   1001  f000				  -qq1
   1002  f000				  -	      ldx	v_audctl
   1003  f000				  -	      ELSE
   1004  f000				  -	      ldx	#0
   1005  f000				  -	      stx	v_audctl
   1006  f000				  -	      ENDIF
   1007  f000				  -	      IF	FEAT_FILTER
   1008  f000				  -	      IF	FEAT_FILTERG0L
   1009  f000				  -	      lda	trackn_command+0
   1010  f000				  -	      bpl	qq2
   1011  f000				  -	      lda	trackn_audc+0
   1012  f000				  -	      and	#$0f
   1013  f000				  -	      beq	qq2
   1014  f000				  -	      lda	trackn_audf+0
   1015  f000				  -	      clc
   1016  f000				  -	      adc	trackn_filter+0
   1017  f000				  -	      sta	trackn_audf+2
   1018  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2L
   1019  f000				  -	      lda	trackn_audc+2
   1020  f000				  -	      and	#$10
   1021  f000				  -	      bne	qq1a
   1022  f000				  -	      ENDIF
   1023  f000				  -	      lda	#0
   1024  f000				  -	      sta	trackn_audc+2
   1025  f000				  -qq1a
   1026  f000				  -	      txa
   1027  f000				  -	      ora	#4
   1028  f000				  -	      tax
   1029  f000				  -	      ENDIF
   1030  f000				  -qq2
   1031  f000				  -	      IF	FEAT_FILTERG1L
   1032  f000				  -	      lda	trackn_command+1
   1033  f000				  -	      bpl	qq3
   1034  f000				  -	      lda	trackn_audc+1
   1035  f000				  -	      and	#$0f
   1036  f000				  -	      beq	qq3
   1037  f000				  -	      lda	trackn_audf+1
   1038  f000				  -	      clc
   1039  f000				  -	      adc	trackn_filter+1
   1040  f000				  -	      sta	trackn_audf+3
   1041  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG3L
   1042  f000				  -	      lda	trackn_audc+3
   1043  f000				  -	      and	#$10
   1044  f000				  -	      bne	qq2a
   1045  f000				  -	      ENDIF
   1046  f000				  -	      lda	#0
   1047  f000				  -	      sta	trackn_audc+3
   1048  f000				  -qq2a
   1049  f000				  -	      txa
   1050  f000				  -	      ora	#2
   1051  f000				  -	      tax
   1052  f000				  -	      ENDIF
   1053  f000				  -qq3
   1054  f000				  -	      IF	FEAT_FILTERG0L||FEAT_FILTERG1L
   1055  f000				  -	      cpx	v_audctl
   1056  f000				  -	      bne	qq5
   1057  f000				  -	      ENDIF
   1058  f000				  -	      ENDIF
   1059  f000				  -	      IF	FEAT_BASS16
   1060  f000				  -	      IF	FEAT_BASS16G1L
   1061  f000				  -	      lda	trackn_command+1
   1062  f000				  -	      and	#$0e
   1063  f000				  -	      cmp	#6
   1064  f000				  -	      bne	qq4
   1065  f000				  -	      lda	trackn_audc+1
   1066  f000				  -	      and	#$0f
   1067  f000				  -	      beq	qq4
   1068  f000				  -	      ldy	trackn_outnote+1
   1069  f000				  -	      lda	frqtabbasslo,y
   1070  f000				  -	      sta	trackn_audf+0
   1071  f000				  -	      lda	frqtabbasshi,y
   1072  f000				  -	      sta	trackn_audf+1
   1073  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG0L
   1074  f000				  -	      lda	trackn_audc+0
   1075  f000				  -	      and	#$10
   1076  f000				  -	      bne	qq3a
   1077  f000				  -	      ENDIF
   1078  f000				  -	      lda	#0
   1079  f000				  -	      sta	trackn_audc+0
   1080  f000				  -qq3a
   1081  f000				  -	      txa
   1082  f000				  -	      ora	#$50
   1083  f000				  -	      tax
   1084  f000				  -	      ENDIF
   1085  f000				  -qq4
   1086  f000				  -	      IF	FEAT_BASS16G3L
   1087  f000				  -	      lda	trackn_command+3
   1088  f000				  -	      and	#$0e
   1089  f000				  -	      cmp	#6
   1090  f000				  -	      bne	qq5
   1091  f000				  -	      lda	trackn_audc+3
   1092  f000				  -	      and	#$0f
   1093  f000				  -	      beq	qq5
   1094  f000				  -	      ldy	trackn_outnote+3
   1095  f000				  -	      lda	frqtabbasslo,y
   1096  f000				  -	      sta	trackn_audf+2
   1097  f000				  -	      lda	frqtabbasshi,y
   1098  f000				  -	      sta	trackn_audf+3
   1099  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2L
   1100  f000				  -	      lda	trackn_audc+2
   1101  f000				  -	      and	#$10
   1102  f000				  -	      bne	qq4a
   1103  f000				  -	      ENDIF
   1104  f000				  -	      lda	#0
   1105  f000				  -	      sta	trackn_audc+2
   1106  f000				  -qq4a
   1107  f000				  -	      txa
   1108  f000				  -	      ora	#$28
   1109  f000				  -	      tax
   1110  f000				  -	      ENDIF
   1111  f000				  -	      ENDIF
   1112  f000				  -qq5
   1113  f000				  -	      stx	v_audctl
   1114  f000				  -	      IF	STEREO8T
   1115  f000				  -	      IF	FEAT_AUDCTLMANUALSET
   1116  f000				  -	      ldx	#3
   1117  f000				  -	      lda	#0
   1118  f000				  -qs0	      ora	trackn_audctl+4,x
   1119  f000				  -	      dex
   1120  f000				  -	      bpl	qs0
   1121  f000				  -	      sta	v_audctl2
   1122  f000				  -qs1
   1123  f000				  -	      ldx	v_audctl2
   1124  f000				  -	      ELSE
   1125  f000				  -	      ldx	#0
   1126  f000				  -	      stx	v_audctl2
   1127  f000				  -	      ENDIF
   1128  f000				  -	      IF	FEAT_FILTER
   1129  f000				  -	      IF	FEAT_FILTERG0R
   1130  f000				  -	      lda	trackn_command+0+4
   1131  f000				  -	      bpl	qs2
   1132  f000				  -	      lda	trackn_audc+0+4
   1133  f000				  -	      and	#$0f
   1134  f000				  -	      beq	qs2
   1135  f000				  -	      lda	trackn_audf+0+4
   1136  f000				  -	      clc
   1137  f000				  -	      adc	trackn_filter+0+4
   1138  f000				  -	      sta	trackn_audf+2+4
   1139  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2R
   1140  f000				  -	      lda	trackn_audc+2+4
   1141  f000				  -	      and	#$10
   1142  f000				  -	      bne	qs1a
   1143  f000				  -	      ENDIF
   1144  f000				  -	      lda	#0
   1145  f000				  -	      sta	trackn_audc+2+4
   1146  f000				  -qs1a
   1147  f000				  -	      txa
   1148  f000				  -	      ora	#4
   1149  f000				  -	      tax
   1150  f000				  -	      ENDIF
   1151  f000				  -qs2
   1152  f000				  -	      IF	FEAT_FILTERG1R
   1153  f000				  -	      lda	trackn_command+1+4
   1154  f000				  -	      bpl	qs3
   1155  f000				  -	      lda	trackn_audc+1+4
   1156  f000				  -	      and	#$0f
   1157  f000				  -	      beq	qs3
   1158  f000				  -	      lda	trackn_audf+1+4
   1159  f000				  -	      clc
   1160  f000				  -	      adc	trackn_filter+1+4
   1161  f000				  -	      sta	trackn_audf+3+4
   1162  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG3R
   1163  f000				  -	      lda	trackn_audc+3+4
   1164  f000				  -	      and	#$10
   1165  f000				  -	      bne	qs2a
   1166  f000				  -	      ENDIF
   1167  f000				  -	      lda	#0
   1168  f000				  -	      sta	trackn_audc+3+4
   1169  f000				  -qs2a
   1170  f000				  -	      txa
   1171  f000				  -	      ora	#2
   1172  f000				  -	      tax
   1173  f000				  -	      ENDIF
   1174  f000				  -qs3
   1175  f000				  -	      IF	FEAT_FILTERG0R||FEAT_FILTERG1R
   1176  f000				  -	      cpx	v_audctl2
   1177  f000				  -	      bne	qs5
   1178  f000				  -	      ENDIF
   1179  f000				  -	      ENDIF
   1180  f000				  -	      IF	FEAT_BASS16
   1181  f000				  -	      IF	FEAT_BASS16G1R
   1182  f000				  -	      lda	trackn_command+1+4
   1183  f000				  -	      and	#$0e
   1184  f000				  -	      cmp	#6
   1185  f000				  -	      bne	qs4
   1186  f000				  -	      lda	trackn_audc+1+4
   1187  f000				  -	      and	#$0f
   1188  f000				  -	      beq	qs4
   1189  f000				  -	      ldy	trackn_outnote+1+4
   1190  f000				  -	      lda	frqtabbasslo,y
   1191  f000				  -	      sta	trackn_audf+0+4
   1192  f000				  -	      lda	frqtabbasshi,y
   1193  f000				  -	      sta	trackn_audf+1+4
   1194  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG0R
   1195  f000				  -	      lda	trackn_audc+0+4
   1196  f000				  -	      and	#$10
   1197  f000				  -	      bne	qs3a
   1198  f000				  -	      ENDIF
   1199  f000				  -	      lda	#0
   1200  f000				  -	      sta	trackn_audc+0+4
   1201  f000				  -qs3a
   1202  f000				  -	      txa
   1203  f000				  -	      ora	#$50
   1204  f000				  -	      tax
   1205  f000				  -	      ENDIF
   1206  f000				  -qs4
   1207  f000				  -	      IF	FEAT_BASS16G3R
   1208  f000				  -	      lda	trackn_command+3+4
   1209  f000				  -	      and	#$0e
   1210  f000				  -	      cmp	#6
   1211  f000				  -	      bne	qs5
   1212  f000				  -	      lda	trackn_audc+3+4
   1213  f000				  -	      and	#$0f
   1214  f000				  -	      beq	qs5
   1215  f000				  -	      ldy	trackn_outnote+3+4
   1216  f000				  -	      lda	frqtabbasslo,y
   1217  f000				  -	      sta	trackn_audf+2+4
   1218  f000				  -	      lda	frqtabbasshi,y
   1219  f000				  -	      sta	trackn_audf+3+4
   1220  f000				  -	      IF	FEAT_COMMAND7VOLUMEONLY&&FEAT_VOLUMEONLYG2R
   1221  f000				  -	      lda	trackn_audc+2+4
   1222  f000				  -	      and	#$10
   1223  f000				  -	      bne	qs4a
   1224  f000				  -	      ENDIF
   1225  f000				  -	      lda	#0
   1226  f000				  -	      sta	trackn_audc+2+4
   1227  f000				  -qs4a
   1228  f000				  -	      txa
   1229  f000				  -	      ora	#$28
   1230  f000				  -	      tax
   1231  f000				  -	      ENDIF
   1232  f000				  -	      ENDIF
   1233  f000				  -qs5
   1234  f000				  -	      stx	v_audctl2
   1235  f000				  -	      ENDIF
   1236  f000				  -rmt_p5
   1237  f000				  -	      lda	smc_silence_instrspeed
   1238  f000				  -	      rts
   1239  f000				  -SetPokey
   1240  f000				  -	      IF	STEREO8T
   1241  f000				  -	      ldy	v_audctl2
   1242  f000				  -	      lda	trackn_audf+0+4
   1243  f000				  -	      ldx	trackn_audf+0
   1244  f000				  -	      sta	POKEY_BASE_S+$00
   1245  f000				  -	      stx	POKEY_BASE+$00
   1246  f000				  -	      lda	trackn_audc+0+4
   1247  f000				  -	      ldx	trackn_audc+0
   1248  f000				  -	      sta	POKEY_BASE_S+$01
   1249  f000				  -	      stx	POKEY_BASE+$01
   1250  f000				  -	      lda	trackn_audf+1+4
   1251  f000				  -	      ldx	trackn_audf+1
   1252  f000				  -	      sta	POKEY_BASE_S+$02
   1253  f000				  -	      stx	POKEY_BASE+$02
   1254  f000				  -	      lda	trackn_audc+1+4
   1255  f000				  -	      ldx	trackn_audc+1
   1256  f000				  -	      sta	POKEY_BASE_S+$03
   1257  f000				  -	      stx	POKEY_BASE+$03
   1258  f000				  -	      lda	trackn_audf+2+4
   1259  f000				  -	      ldx	trackn_audf+2
   1260  f000				  -	      sta	POKEY_BASE_S+$04
   1261  f000				  -	      stx	POKEY_BASE+$04
   1262  f000				  -	      lda	trackn_audc+2+4
   1263  f000				  -	      ldx	trackn_audc+2
   1264  f000				  -	      sta	POKEY_BASE_S+$05
   1265  f000				  -	      stx	POKEY_BASE+$05
   1266  f000				  -	      lda	trackn_audf+3+4
   1267  f000				  -	      ldx	trackn_audf+3
   1268  f000				  -	      sta	POKEY_BASE_S+$06
   1269  f000				  -	      stx	POKEY_BASE+$06
   1270  f000				  -	      lda	trackn_audc+3+4
   1271  f000				  -	      ldx	trackn_audc+3
   1272  f000				  -	      sta	POKEY_BASE_S+$07
   1273  f000				  -	      stx	POKEY_BASE+$07
   1274  f000				  -	      lda	v_audctl
   1275  f000				  -	      sty	POKEY_BASE_S+$08
   1276  f000				  -	      sta	POKEY_BASE+$08
   1277  f000				  -	      ELSE
   1278  f000				  -
   1279  f000				  -	      ifconst	RMTVOLUME
   1280  f000				  -	      lda	rmtvolume
   1281  f000				  -	      sta	fourbitfadevalueint
   1282  f000				  -	      endif
   1283  f000				  -	      ldy	v_audctl
   1284  f000				  -	      ldx	trackn_audf+0
   1285  f000				  -	      lda	trackn_audc+0
   1286  f000				  -	      ifconst	RMTVOLUME
   1287  f000				  -	      jsr	fourbitfadeint
   1288  f000				  -	      endif
   1289  f000				  -	      stx	POKEY_BASE+$00+0
   1290  f000				  -	      if	HARD_OF_HEARING
   1291  f000				  -	      stx	POKEY_BASE+$00+0
   1292  f000				  -	      endif
   1293  f000				  -	      sta	POKEY_BASE+$01+0
   1294  f000				  -	      if	HARD_OF_HEARING
   1295  f000				  -	      sta	POKEY_BASE+$01+0
   1296  f000				  -	      endif
   1297  f000				  -
   1298  f000				  -	      ldx	trackn_audf+1
   1299  f000				  -	      lda	trackn_audc+1
   1300  f000				  -	      ifconst	RMTVOLUME
   1301  f000				  -	      jsr	fourbitfadeint
   1302  f000				  -	      endif
   1303  f000				  -	      stx	POKEY_BASE+$00+2
   1304  f000				  -	      if	HARD_OF_HEARING
   1305  f000				  -	      stx	POKEY_BASE+$00+2
   1306  f000				  -	      endif
   1307  f000				  -	      sta	POKEY_BASE+$01+2
   1308  f000				  -	      if	HARD_OF_HEARING
   1309  f000				  -	      sta	POKEY_BASE+$01+2
   1310  f000				  -	      endif
   1311  f000				  -
   1312  f000				  -	      ldx	trackn_audf+2
   1313  f000				  -	      lda	trackn_audc+2
   1314  f000				  -	      ifconst	RMTVOLUME
   1315  f000				  -	      jsr	fourbitfadeint
   1316  f000				  -	      endif
   1317  f000				  -	      stx	POKEY_BASE+$00+4
   1318  f000				  -	      if	HARD_OF_HEARING
   1319  f000				  -	      stx	POKEY_BASE+$00+4
   1320  f000				  -	      endif
   1321  f000				  -	      sta	POKEY_BASE+$01+4
   1322  f000				  -	      if	HARD_OF_HEARING
   1323  f000				  -	      sta	POKEY_BASE+$01+4
   1324  f000				  -	      endif
   1325  f000				  -
   1326  f000				  -	      ldx	trackn_audf+3
   1327  f000				  -	      lda	trackn_audc+3
   1328  f000				  -	      ifconst	RMTVOLUME
   1329  f000				  -	      jsr	fourbitfadeint
   1330  f000				  -	      endif
   1331  f000				  -	      stx	POKEY_BASE+$00+6
   1332  f000				  -	      if	HARD_OF_HEARING
   1333  f000				  -	      stx	POKEY_BASE+$00+6
   1334  f000				  -	      endif
   1335  f000				  -	      sta	POKEY_BASE+$01+6
   1336  f000				  -	      if	HARD_OF_HEARING
   1337  f000				  -	      sta	POKEY_BASE+$01+6
   1338  f000				  -	      endif
   1339  f000				  -
   1340  f000				  -	      sty	POKEY_BASE+$08
   1341  f000				  -	      if	HARD_OF_HEARING
   1342  f000				  -	      sty	POKEY_BASE+$08
   1343  f000				  -	      endif
   1344  f000				  -
   1345  f000				  -	      ENDIF
   1346  f000				  -	      rts
   1347  f000				  -SetUpInstrumentY2
   1348  f000				  -	      lda	(p_instrstable),y
   1349  f000				  -	      sta	trackn_instrdb,x
   1350  f000				  -	      sta	_nt
   1351  f000				  -	      iny
   1352  f000				  -	      lda	(p_instrstable),y
   1353  f000				  -	      sta	trackn_instrhb,x
   1354  f000				  -	      sta	_nt+1
   1355  f000				  -	      ldy	#0
   1356  f000				  -	      lda	(_nt),y
   1357  f000				  -	      sta	trackn_tableend,x
   1358  f000				  -	      clc
   1359  f000				  -	      adc	#1
   1360  f000				  -	      sta	trackn_instridx,x
   1361  f000				  -	      iny
   1362  f000				  -	      lda	(_nt),y
   1363  f000				  -	      sta	trackn_tablelop,x
   1364  f000				  -	      iny
   1365  f000				  -	      lda	(_nt),y
   1366  f000				  -	      sta	trackn_instrlen,x
   1367  f000				  -	      iny
   1368  f000				  -	      lda	(_nt),y
   1369  f000				  -	      sta	trackn_instrlop,x
   1370  f000				  -	      iny
   1371  f000				  -	      lda	(_nt),y
   1372  f000				  -	      sta	trackn_tabletypespeed,x
   1373  f000				  -	      IF	FEAT_TABLETYPE||FEAT_TABLEMODE
   1374  f000				  -	      and	#$3f
   1375  f000				  -	      ENDIF
   1376  f000				  -	      sta	trackn_tablespeeda,x
   1377  f000				  -	      IF	FEAT_TABLEMODE
   1378  f000				  -	      lda	(_nt),y
   1379  f000				  -	      and	#$40
   1380  f000				  -	      sta	trackn_tablemode,x
   1381  f000				  -	      ENDIF
   1382  f000				  -	      iny
   1383  f000				  -	      IF	FEAT_AUDCTLMANUALSET
   1384  f000				  -	      lda	(_nt),y
   1385  f000				  -	      sta	trackn_audctl,x
   1386  f000				  -	      ENDIF
   1387  f000				  -	      iny
   1388  f000				  -	      lda	(_nt),y
   1389  f000				  -	      sta	trackn_volumeslidedepth,x
   1390  f000				  -	      iny
   1391  f000				  -	      lda	(_nt),y
   1392  f000				  -	      sta	trackn_volumemin,x
   1393  f000				  -	      iny
   1394  f000				  -	      lda	(_nt),y
   1395  f000				  -	      sta	trackn_effdelay,x
   1396  f000				  -	      iny
   1397  f000				  -	      lda	(_nt),y
   1398  f000				  -	      tay
   1399  f000				  -	      lda	vibtabbeg,y
   1400  f000				  -	      sta	trackn_effvibratoa,x
   1401  f000				  -	      sta	trackn_effvibratobeg,x
   1402  f000				  -	      lda	vibtabbeg+1,y
   1403  f000				  -	      sta	trackn_effvibratoend,x
   1404  f000				  -	      ldy	#10
   1405  f000				  -	      lda	(_nt),y
   1406  f000				  -	      sta	trackn_effshift,x
   1407  f000				  -	      lda	#128
   1408  f000				  -	      sta	trackn_volumeslidevalue,x
   1409  f000				  -	      lda	#0
   1410  f000				  -	      sta	trackn_instrreachend,x
   1411  f000				  -	      sta	trackn_shiftfrq,x
   1412  f000				  -	      lda	#INSTRPAR
   1413  f000				  -	      sta	trackn_tablea,x
   1414  f000				  -	      tay
   1415  f000				  -	      lda	(_nt),y
   1416  f000				  -	      sta	trackn_tablenote,x
   1417  f000				  -	      IF	FEAT_FILTER
   1418  f000				  -	      lda	#1
   1419  f000				  -	      sta	trackn_filter,x
   1420  f000				  -	      ENDIF
   1421  f000				  -	      rts
   1422  f000				  -InstrumentsEffects
   1423  f000				  -	      lda	trackn_effdelay,x
   1424  f000				  -	      beq	ei2
   1425  f000				  -	      tay
   1426  f000				  -	      dey
   1427  f000				  -	      bne	ei1
   1428  f000				  -	      lda	trackn_shiftfrq,x
   1429  f000				  -	      clc
   1430  f000				  -	      adc	trackn_effshift,x
   1431  f000				  -	      clc
   1432  f000				  -	      ldy	trackn_effvibratoa,x
   1433  f000				  -	      adc	vib0,y
   1434  f000				  -	      sta	trackn_shiftfrq,x
   1435  f000				  -	      iny
   1436  f000				  -	      tya
   1437  f000				  -	      cmp	trackn_effvibratoend,x
   1438  f000				  -	      bne	ei1a
   1439  f000				  -	      lda	trackn_effvibratobeg,x
   1440  f000				  -ei1a
   1441  f000				  -	      sta	trackn_effvibratoa,x
   1442  f000				  -	      jmp	ei2
   1443  f000				  -ei1
   1444  f000				  -	      tya
   1445  f000				  -	      sta	trackn_effdelay,x
   1446  f000				  -ei2
   1447  f000				  -	      lda	trackn_tableend,x
   1448  f000				  -	      cmp	#INSTRPAR
   1449  f000				  -	      beq	ei3
   1450  f000				  -	      lda	trackn_tablespeeda,x
   1451  f000				  -	      bpl	ei2f
   1452  f000				  -ei2c
   1453  f000				  -	      lda	trackn_tablea,x
   1454  f000				  -	      clc
   1455  f000				  -	      adc	#1
   1456  f000				  -	      cmp	trackn_tableend,x
   1457  f000				  -	      bcc	ei2a
   1458  f000				  -	      beq	ei2a
   1459  f000				  -	      lda	trackn_tablelop,x
   1460  f000				  -ei2a
   1461  f000				  -	      sta	trackn_tablea,x
   1462  f000				  -	      lda	trackn_instrdb,x
   1463  f000				  -	      sta	_nt
   1464  f000				  -	      lda	trackn_instrhb,x
   1465  f000				  -	      sta	_nt+1
   1466  f000				  -	      ldy	trackn_tablea,x
   1467  f000				  -	      lda	(_nt),y
   1468  f000				  -	      IF	FEAT_TABLEMODE
   1469  f000				  -	      ldy	trackn_tablemode,x
   1470  f000				  -	      beq	ei2e
   1471  f000				  -	      clc
   1472  f000				  -	      adc	trackn_tablenote,x
   1473  f000				  -ei2e
   1474  f000				  -	      ENDIF
   1475  f000				  -	      sta	trackn_tablenote,x
   1476  f000				  -	      lda	trackn_tabletypespeed,x
   1477  f000				  -	      IF	FEAT_TABLETYPE||FEAT_TABLEMODE
   1478  f000				  -	      and	#$3f
   1479  f000				  -	      ENDIF
   1480  f000				  -ei2f
   1481  f000				  -	      sec
   1482  f000				  -	      sbc	#1
   1483  f000				  -	      sta	trackn_tablespeeda,x
   1484  f000				  -ei3
   1485  f000				  -	      lda	trackn_instrreachend,x
   1486  f000				  -	      bpl	ei4
   1487  f000				  -	      lda	trackn_volume,x
   1488  f000				  -	      beq	ei4
   1489  f000				  -	      cmp	trackn_volumemin,x
   1490  f000				  -	      beq	ei4
   1491  f000				  -	      bcc	ei4
   1492  f000				  -	      tay
   1493  f000				  -	      lda	trackn_volumeslidevalue,x
   1494  f000				  -	      clc
   1495  f000				  -	      adc	trackn_volumeslidedepth,x
   1496  f000				  -	      sta	trackn_volumeslidevalue,x
   1497  f000				  -	      bcc	ei4
   1498  f000				  -	      tya
   1499  f000				  -	      sbc	#16
   1500  f000				  -	      sta	trackn_volume,x
   1501  f000				  -ei4
   1502  f000				  -	      jmp	returnfromInstrumentsEffects
   1503  f000				  -
   1504  f000				  -rmtmoduleend
   1505  f000				  -	      echo	"  (rmtplayer module is using ",[(rmtmoduleend-rmtmodulestart)]d," bytes of rom)"
   1506  f000				  -	      echo	"  (rmtplayer module is using ",[(MEMLOC-RMTRAM-1)]d," bytes of ram)"
   1507  f000				  -
   1508  f000					      endif		; RMT
------- FILE constants.78b.asm
   3205  f000					      endif
   3206  f000					      ifnconst	included.7800vox.asm
------- FILE 7800vox.asm LEVEL 2 PASS 3
      0  f000					      include	7800vox.asm
      1  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  f000
      3  f000							; AtariVox 7800basic wrapper
      4  f000
      5  f000							; to be called with
      6  f000							; A=# of bytes
      7  f000							;
      8  f000
      9  f000				  -	      ifconst	HSSUPPORT
     10  f000				  -
     11  f000				  -_7800voxstart
     12  f000				  -
     13  f000				  -AVoxReadBytes
     14  f000				  -	      sta	temp8
     15  f000				  -	      jsr	i2c_startwrite
     16  f000				  -	      bcs	eeprom_error
     17  f000				  -
     18  f000				  -	      lda	HSVoxHi
     19  f000				  -	      jsr	i2c_txbyte
     20  f000				  -	      lda	HSVoxLo
     21  f000				  -	      jsr	i2c_txbyte
     22  f000				  -	      jsr	i2c_stopwrite
     23  f000				  -
     24  f000				  -	      jsr	i2c_startread
     25  f000				  -
     26  f000				  -	      ldx	#0
     27  f000				  -AVoxReadBytesLoop
     28  f000				  -	      jsr	i2c_rxbyte
     29  f000				  -	      sta	eeprombuffer,x
     30  f000				  -	      inx
     31  f000				  -	      cpx	temp8
     32  f000				  -	      bne	AVoxReadBytesLoop
     33  f000				  -	      jsr	i2c_stopread
     34  f000				  -	      lda	#0
     35  f000				  -	      rts
     36  f000				  -
     37  f000				  -			; to be called with
     38  f000				  -			; A=# of bytes
     39  f000				  -			;
     40  f000				  -
     41  f000				  -AVoxWriteBytes
     42  f000				  -	      sta	temp8
     43  f000				  -	      jsr	i2c_startwrite
     44  f000				  -	      bcs	eeprom_error
     45  f000				  -
     46  f000				  -	      lda	HSVoxHi
     47  f000				  -	      jsr	i2c_txbyte
     48  f000				  -	      lda	HSVoxLo
     49  f000				  -	      jsr	i2c_txbyte
     50  f000				  -
     51  f000				  -	      ldx	#$00
     52  f000				  -AVoxWriteBytesLoop
     53  f000				  -	      lda	eeprombuffer,x
     54  f000				  -	      jsr	i2c_txbyte
     55  f000				  -	      inx
     56  f000				  -	      cpx	temp8
     57  f000				  -	      bne	AVoxWriteBytesLoop
     58  f000				  -	      jsr	i2c_stopwrite
     59  f000				  -
     60  f000				  -	      lda	#0
     61  f000				  -	      rts
     62  f000				  -
     63  f000				  -eeprom_error
     64  f000				  -	      lda	#$ff
     65  f000				  -	      rts
     66  f000				  -
     67  f000				  -AVoxDetect
     68  f000				  -
     69  f000				  -	      jsr	i2c_startwrite
     70  f000				  -	      bcs	eeprom_error
     71  f000				  -	      lda	#$30
     72  f000				  -	      jsr	i2c_txbyte
     73  f000				  -	      lda	#$00
     74  f000				  -	      jsr	i2c_txbyte
     75  f000				  -	      jsr	i2c_stopwrite
     76  f000				  -	      rts
     77  f000				  -
     78  f000				  -	      include	"i2c7800.inc"
     79  f000				  -	      I2C_SUBS	temp9
     80  f000				  -
     81  f000				  -_7800voxend
     82  f000				  -
     83  f000				  -	      echo	"  (7800vox module is using ",[(_7800voxend-_7800voxstart)]d," bytes)"
     84  f000				  -
     85  f000					      endif
     86  f000
------- FILE constants.78b.asm
   3208  f000					      endif
   3209  f000					      ifnconst	included.pokeysound.asm
------- FILE pokeysound.asm LEVEL 2 PASS 3
      0  f000					      include	pokeysound.asm
      1  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  f000
      3  f000
      4  f000				  -	      ifconst	pokeysupport
      5  f000				  -
      6  f000				  -pokeysoundmodulestart
      7  f000				  -
      8  f000				  -mutepokey
      9  f000				  -	      lda	#0
     10  f000				  -	      ldy	#7
     11  f000				  -mutepokeyloop
     12  f000				  -	      sta	pokey1pointlo,y
     13  f000				  -	      sta	(pokeybaselo),y
     14  f000				  -	      dey
     15  f000				  -	      bpl	mutepokeyloop
     16  f000				  -	      rts
     17  f000				  -
     18  f000				  -	      ifconst	pokeysfxsupport
     19  f000				  -
     20  f000				  -checkpokeyplaying
     21  f000				  -	      ldx	#6
     22  f000				  -checkpokeyplayingloop
     23  f000				  -	      lda	pokey1pointlo,x
     24  f000				  -	      ora	pokey1pointhi,x
     25  f000				  -	      beq	pokeychannelinactive
     26  f000				  -	      jsr	playpokeysfxA	; x=channel*2
     27  f000				  -pokeychannelinactive
     28  f000				  -	      dex
     29  f000				  -	      dex
     30  f000				  -	      bpl	checkpokeyplayingloop
     31  f000				  -	      rts
     32  f000				  -
     33  f000				  -playpokeysfxA
     34  f000				  -	      txa
     35  f000				  -	      tay
     36  f000				  -	      lda	pokey1tick,x
     37  f000				  -	      beq	playpokeysfxAcont
     38  f000				  -	      sec
     39  f000				  -	      sbc	#1
     40  f000				  -	      sta	pokey1tick,x	; sound resolution is >1 frame, and we're mid-tock...
     41  f000				  -	      rts
     42  f000				  -
     43  f000				  -playpokeysfxAcont
     44  f000				  -	      lda	pokey1frames,x	; set the frame countdown for this sound chunk
     45  f000				  -	      sta	pokey1tick,x
     46  f000				  -
     47  f000				  -	      lda	pokey1priority,x	; decrease the sound's priority if its non-zero
     48  f000				  -	      beq	playpokeysfxAcont2
     49  f000				  -	      sec
     50  f000				  -	      sbc	#1
     51  f000				  -	      sta	pokey1priority,x
     52  f000				  -playpokeysfxAcont2
     53  f000				  -
     54  f000				  -			; *** FREQUENCY
     55  f000				  -	      lda	(pokey1pointlo,x)
     56  f000				  -	      sta	inttemp1
     57  f000				  -	      clc
     58  f000				  -	      adc	pokey1offset,x	; take into account any pitch modification
     59  f000				  -	      sta	(pokeybaselo),y	; PAUDF0,0
     60  f000				  -
     61  f000				  -			;advance the data pointer +1
     62  f000				  -	      inc	pokey1pointlo,x
     63  f000				  -	      bne	skippokeyhiinc1
     64  f000				  -	      inc	pokey1pointhi,x
     65  f000				  -skippokeyhiinc1
     66  f000				  -
     67  f000				  -			; *** WAVE
     68  f000				  -	      lda	(pokey1pointlo,x)
     69  f000				  -	      asl
     70  f000				  -	      asl
     71  f000				  -	      asl
     72  f000				  -	      asl		; x16
     73  f000				  -
     74  f000				  -			;advance the data pointer +1
     75  f000				  -	      inc	pokey1pointlo,x
     76  f000				  -	      bne	skippokeyhiinc2
     77  f000				  -	      inc	pokey1pointhi,x
     78  f000				  -skippokeyhiinc2
     79  f000				  -
     80  f000				  -	      ora	(pokey1pointlo,x)
     81  f000				  -	      iny
     82  f000				  -	      sta	(pokeybaselo),y
     83  f000				  -
     84  f000				  -	      ora	inttemp1	; check if F|C|V=0
     85  f000				  -	      beq	zeropokeypoint	; if so, we're at the end of the sound.
     86  f000				  -
     87  f000				  -			; advance the pointer +1, on to the next sound chunk
     88  f000				  -	      inc	pokey1pointlo,x
     89  f000				  -	      bne	skippokeyhiinc3
     90  f000				  -	      inc	pokey1pointhi,x
     91  f000				  -skippokeyhiinc3
     92  f000				  -	      rts
     93  f000				  -
     94  f000				  -zeropokeypoint
     95  f000				  -	      sta	pokey1pointlo,x
     96  f000				  -	      sta	pokey1pointhi,x
     97  f000				  -	      sta	pokey1priority,x
     98  f000				  -	      rts
     99  f000				  -
    100  f000				  -schedulepokeysfx
    101  f000				  -	      ldx	#6
    102  f000				  -schedulepokeysfxloop
    103  f000				  -	      lda	pokey1pointlo,x
    104  f000				  -	      ora	pokey1pointhi,x
    105  f000				  -	      bne	schedulespokeysearch
    106  f000				  -	      jmp	schedulepokeyX	; we found an unused channel, so use it...
    107  f000				  -schedulespokeysearch
    108  f000				  -	      dex
    109  f000				  -	      dex
    110  f000				  -	      bpl	schedulepokeysfxloop
    111  f000				  -
    112  f000				  -			; if we're here, all 4 channels are presently playing a sound...
    113  f000				  -	      ldy	#1
    114  f000				  -	      lda	(sfxinstrumentlo),y	; peek at the priority of this sfx...
    115  f000				  -	      bne	schedulepokeysfxcont1
    116  f000				  -	      rts		; ...and skip it if it's 0 priority
    117  f000				  -schedulepokeysfxcont1
    118  f000				  -
    119  f000				  -			; figure out which current sound has the lowest priority...
    120  f000				  -	      lda	#0
    121  f000				  -	      sta	temp8
    122  f000				  -	      lda	pokey1priority
    123  f000				  -	      sta	temp9
    124  f000				  -	      ldx	#6
    125  f000				  -findlowprioritypokeyloop
    126  f000				  -	      lda	pokey1priority,x
    127  f000				  -	      cmp	temp9
    128  f000				  -	      bcs	findlowprioritypokeyloopcontinue
    129  f000				  -	      sta	temp9
    130  f000				  -	      stx	temp8
    131  f000				  -findlowprioritypokeyloopcontinue
    132  f000				  -	      dex
    133  f000				  -	      dex
    134  f000				  -	      bne	findlowprioritypokeyloop
    135  f000				  -	      ldx	temp8	; the low priority channel we'll interrupt
    136  f000				  -
    137  f000				  -schedulepokeyX
    138  f000				  -			;called with X=2*pokey channel to play on...
    139  f000				  -	      ldy	#1	; get priority and sound-resolution (in frames)
    140  f000				  -	      lda	(sfxinstrumentlo),y
    141  f000				  -	      sta	pokey1priority,x
    142  f000				  -	      iny
    143  f000				  -	      lda	(sfxinstrumentlo),y
    144  f000				  -	      sta	pokey1frames,x
    145  f000				  -
    146  f000				  -	      lda	sfxinstrumentlo
    147  f000				  -	      clc
    148  f000				  -	      adc	#3
    149  f000				  -	      sta	pokey1pointlo,x
    150  f000				  -	      lda	sfxinstrumenthi
    151  f000				  -	      adc	#0
    152  f000				  -	      sta	pokey1pointhi,x
    153  f000				  -	      lda	sfxpitchoffset
    154  f000				  -	      sta	pokey1offset,x
    155  f000				  -	      lda	#0
    156  f000				  -	      sta	pokey1tick,x
    157  f000				  -	      rts
    158  f000				  -	      else
    159  f000				  -schedulepokeysfx		; just some stubs
    160  f000				  -checkpokeyplaying
    161  f000				  -	      rts
    162  f000				  -	      endif		; pokeysfxsupport
    163  f000				  -
    164  f000				  -			; pokey detection routine. we check for pokey in the XBOARD/XM location,
    165  f000				  -			; and the standard $4000 location.
    166  f000				  -			; if pokey the pokey is present, this routine will reset it.
    167  f000				  -	      ifconst	pokeyaddress
    168  f000				  -detectpokeylocation
    169  f000				  -	      lda	#<pokeyaddress
    170  f000				  -	      sta	pokeybaselo
    171  f000				  -	      lda	#>pokeyaddress
    172  f000				  -	      sta	pokeybasehi
    173  f000				  -	      lda	#$ff
    174  f000				  -	      sta	pokeydetected
    175  f000				  -
    176  f000				  -	      if	pokeyaddress = $450
    177  f000				  -	      lda	XCTRL1s
    178  f000				  -	      ora	#%00010100
    179  f000				  -	      sta	XCTRL1s
    180  f000				  -	      sta	XCTRL1
    181  f000				  -	      endif
    182  f000				  -
    183  f000				  -
    184  f000				  -	      lda	#0
    185  f000				  -	      ldy	#15
    186  f000				  -clearpokeyloop
    187  f000				  -	      sta	(pokeybase),y
    188  f000				  -	      dey
    189  f000				  -	      bpl	clearpokeyloop
    190  f000				  -			; take pokey out of reset...
    191  f000				  -	      ldy	#PSKCTL
    192  f000				  -	      lda	#3
    193  f000				  -	      sta	(pokeybase),y
    194  f000				  -	      ldy	#PAUDCTL
    195  f000				  -	      lda	#0
    196  f000				  -	      sta	(pokeybase),y
    197  f000				  -	      rts
    198  f000				  -	      else		; !pokeyaddress
    199  f000				  -detectpokeylocation
    200  f000				  -			;XBoard/XM...
    201  f000				  -	      ldx	#2
    202  f000				  -detectpokeyloop
    203  f000				  -	      lda	XCTRL1s
    204  f000				  -	      ora	#%00010100
    205  f000				  -	      and	POKEYXMMASK,x
    206  f000				  -	      sta	XCTRL1s
    207  f000				  -	      sta	XCTRL1
    208  f000				  -
    209  f000				  -	      lda	POKEYCHECKLO,x
    210  f000				  -	      sta	pokeybaselo
    211  f000				  -	      lda	POKEYCHECKHI,x
    212  f000				  -	      sta	pokeybasehi
    213  f000				  -	      jsr	checkforpokey
    214  f000				  -	      lda	pokeydetected
    215  f000				  -	      beq	foundpokeychip
    216  f000				  -	      dex
    217  f000				  -	      bpl	detectpokeyloop
    218  f000				  -foundpokeychip
    219  f000				  -	      eor	#$ff	; invert state for 7800basic if...then test
    220  f000				  -	      sta	pokeydetected
    221  f000				  -	      rts
    222  f000				  -
    223  f000				  -POKEYXMMASK
    224  f000				  -			;     XM POKEY on    XM POKEY off   XM POKEY off
    225  f000				  -	      .byte	%11111111, %11101111, %11101111
    226  f000				  -
    227  f000				  -POKEYCHECKLO
    228  f000				  -	      .byte	<$0450, <$0450, <$4000
    229  f000				  -POKEYCHECKHI
    230  f000				  -	      .byte	>$0450, >$0450, >$4000
    231  f000				  -
    232  f000				  -checkforpokey
    233  f000				  -	      ldy	#$0f
    234  f000				  -	      lda	#$00
    235  f000				  -	      sta	pokeydetected	; start off by assuming pokey will be detected
    236  f000				  -resetpokeyregistersloop
    237  f000				  -	      sta	(pokeybase),y
    238  f000				  -	      dey
    239  f000				  -	      bpl	resetpokeyregistersloop
    240  f000				  -
    241  f000				  -	      ldy	#PAUDCTL
    242  f000				  -	      sta	(pokeybase),y
    243  f000				  -	      ldy	#PSKCTL
    244  f000				  -	      sta	(pokeybase),y
    245  f000				  -
    246  f000				  -			; let the dust settle...
    247  f000				  -	      nop
    248  f000				  -	      nop
    249  f000				  -	      nop
    250  f000				  -
    251  f000				  -	      lda	#4
    252  f000				  -	      sta	temp9
    253  f000				  -pokeycheckloop1
    254  f000				  -			; we're in reset, so the RANDOM register should read $ff...
    255  f000				  -	      ldy	#PRANDOM
    256  f000				  -	      lda	(pokeybase),y
    257  f000				  -	      cmp	#$ff
    258  f000				  -	      bne	nopokeydetected
    259  f000				  -	      dec	temp9
    260  f000				  -	      bne	pokeycheckloop1
    261  f000				  -
    262  f000				  -			; take pokey out of reset...
    263  f000				  -	      ldy	#PSKCTL
    264  f000				  -	      lda	#3
    265  f000				  -	      sta	(pokeybase),y
    266  f000				  -	      ldy	#PAUDCTL
    267  f000				  -	      lda	#0
    268  f000				  -	      sta	(pokeybase),y
    269  f000				  -
    270  f000				  -			; let the dust settle again...
    271  f000				  -	      nop
    272  f000				  -	      nop
    273  f000				  -	      nop
    274  f000				  -
    275  f000				  -	      lda	#4
    276  f000				  -	      sta	temp9
    277  f000				  -pokeycheckloop2
    278  f000				  -			; we're out of reset, so RANDOM should read non-$ff...
    279  f000				  -	      ldy	#PRANDOM
    280  f000				  -	      lda	(pokeybase),y
    281  f000				  -	      cmp	#$ff
    282  f000				  -	      beq	skippokeycheckreturn
    283  f000				  -	      rts
    284  f000				  -skippokeycheckreturn
    285  f000				  -	      dec	temp9
    286  f000				  -	      bne	pokeycheckloop2
    287  f000				  -nopokeydetected
    288  f000				  -	      dec	pokeydetected	; pokeydetected=#$ff
    289  f000				  -	      rts
    290  f000				  -
    291  f000				  -	      endif		; !pokeyaddress
    292  f000				  -
    293  f000				  -pokeysoundmoduleend
    294  f000				  -
    295  f000				  -	      echo	"  (pokeysound module is using ",[(pokeysoundmoduleend-pokeysoundmodulestart)]d," bytes of rom)"
    296  f000				  -
    297  f000					      endif		; pokeysupport
------- FILE constants.78b.asm
   3211  f000					      endif
   3212  f000					      ifnconst	included.snes2atari.asm
------- FILE snes2atari.asm LEVEL 2 PASS 3
      0  f000					      include	snes2atari.asm
      1  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  f000
      3  f000				  -	      ifconst	SNES2ATARISUPPORT
      4  f000				  -snes2atarimodulestart
      5  f000				  -
      6  f000				  -SNES_CLOCK_PORT_BIT
      7  f000				  -	      .byte	$10,$01
      8  f000				  -SNES_CTLSWA_MASK
      9  f000				  -	      .byte	$30,$03
     10  f000				  -SNES_CTLSWA_SIGNAL
     11  f000				  -	      .byte	$C0,$0C
     12  f000				  -
     13  f000				  -			; Probe each port for SNES, and see if autodetection succeeds anywhere.
     14  f000				  -SNES_AUTODETECT
     15  f000				  -	      ifconst	HSSUPPORT
     16  f000				  -			; ** an atarivox might be plugged in, so we skip scanning the second
     17  f000				  -			; ** port for a snes if vox was detected...
     18  f000				  -	      lda	hsdevice	; b1 high means atarivox/savekey was detected
     19  f000				  -	      lsr
     20  f000				  -	      and	#1
     21  f000				  -	      eor	#1
     22  f000				  -	      tax
     23  f000				  -	      else
     24  f000				  -	      ldx	#1
     25  f000				  -	      endif		; HSSUPPORT
     26  f000				  -
     27  f000				  -SNES_AUTODETECT_LOOP
     28  f000				  -	      ifnconst	MULTIBUTTON	; snesdetect shouldn't be used in multibutton mode
     29  f000				  -	      lda	#1	; proline
     30  f000				  -	      sta	port0control,x
     31  f000				  -	      jsr	setportforinput
     32  f000				  -	      jsr	setonebuttonmode
     33  f000				  -	      jsr	SNES_READ
     34  f000				  -	      lda	snesdetected0,x
     35  f000				  -	      bne	SNES_AUTODETECT_FOUND
     36  f000				  -			; detection failed
     37  f000				  -	      jsr	setportforinput
     38  f000				  -	      jsr	settwobuttonmode
     39  f000				  -	      dex
     40  f000				  -	      bpl	SNES_AUTODETECT_LOOP
     41  f000				  -	      rts
     42  f000				  -SNES_AUTODETECT_FOUND
     43  f000				  -	      lda	#11	; formally set the snes controller
     44  f000				  -	      sta	port0control,x
     45  f000				  -	      stx	snesport
     46  f000				  -	      endif		; !MULTIBUTTON
     47  f000				  -	      rts
     48  f000					      endif		; SNES2ATARISUPPORT
     49  f000
     50  f000				   snes2atarihandler
     51  f000				  -	      ifconst	SNES2ATARISUPPORT
     52  f000				  -SNES2ATARI
     53  f000				  -	      jsr	SNES_READ
     54  f000				  -	      jmp	buttonreadloopreturn
     55  f000				  -
     56  f000				  -SNES_READ
     57  f000				  -			; x=0 for left port, x=1 for right
     58  f000				  -	      lda	port0control,x
     59  f000				  -	      cmp	#11	; snes
     60  f000				  -	      bne	snes2atari_signal_go	; if this is a first auto-detection read, go ahead and signal
     61  f000				  -	      lda	snesdetected0,x
     62  f000				  -	      bne	snes2atari_signal_skip	; if snes was available in previous frames, skip signalling
     63  f000				  -snes2atari_signal_go
     64  f000				  -	      jsr	SNES2ATARI_SIGNAL
     65  f000				  -snes2atari_signal_skip
     66  f000				  -
     67  f000				  -	      lda	CTLSWA
     68  f000				  -	      and	SWCHA_DIRMASK+1,x	; preserve other nibble
     69  f000				  -	      ora	SNES_CTLSWA_MASK,x
     70  f000				  -	      sta	CTLSWA	; enable pins UP/DOWN to work as outputs
     71  f000				  -
     72  f000				  -	      lda	SWCHA
     73  f000				  -	      and	SWCHA_DIRMASK+1,x	; preserve other nibble
     74  f000				  -	      ora	SNES_CTLSWA_MASK,x
     75  f000				  -
     76  f000				  -	      sta	SWCHA	; latch+clock high
     77  f000				  -	      nop
     78  f000				  -	      nop
     79  f000				  -	      nop
     80  f000				  -	      nop
     81  f000				  -	      nop
     82  f000				  -	      nop
     83  f000				  -	      nop
     84  f000				  -	      lda	SWCHA
     85  f000				  -	      and	SWCHA_DIRMASK+1,x	; preserve other nibble
     86  f000				  -	      sta	SWCHA	; latch and clock low
     87  f000				  -	      ldy	#16	; 16 bits
     88  f000				  -SNES2ATARILOOP
     89  f000				  -	      rol	INPT4,x	; sample data into carry
     90  f000				  -	      lda	SWCHA
     91  f000				  -	      and	SWCHA_DIRMASK+1,x	; preserve other nibble
     92  f000				  -	      ora	SNES_CLOCK_PORT_BIT,x
     93  f000				  -	      sta	SWCHA	; clock low
     94  f000				  -	      rol	snes2atari0lo,x
     95  f000				  -	      rol	snes2atari0hi,x
     96  f000				  -	      lda	SWCHA
     97  f000				  -	      and	SWCHA_DIRMASK+1,x	; preserve other nibble
     98  f000				  -	      sta	SWCHA	; latch and clock low
     99  f000				  -	      dey		; next bit
    100  f000				  -	      bne	SNES2ATARILOOP
    101  f000				  -	      rol	INPT4,x	; 17th bit should be lo if controller is there.
    102  f000				  -	      rol		; 17th snes bit into A low bit
    103  f000				  -	      eor	snes2atari0lo,x	; 16th bit should be hi if controller is there.
    104  f000				  -	      and	#1
    105  f000				  -	      sta	snesdetected0,x
    106  f000				  -	      beq	SNES_STOP_CLOCK	; if snes isn't detected, leave port in default state
    107  f000				  -	      stx	snesport	; snesport keeps the index of the latest autodetected controller
    108  f000				  -	      lda	SWCHA
    109  f000				  -	      and	SWCHA_DIRMASK+1,x	; preserve other nibble
    110  f000				  -	      ora	SNES_CLOCK_PORT_BIT,x
    111  f000				  -	      jmp	SNES_STOP_CLOCK
    112  f000				  -SNES_STOP_CLOCK
    113  f000				  -	      sta	SWCHA	; clock low
    114  f000				  -	      lda	CTLSWA
    115  f000				  -	      and	SWCHA_DIRMASK+1,x	; preserve other nibble
    116  f000				  -			;ora SNES_CLOCK_PORT_BIT,x
    117  f000				  -	      sta	CTLSWA	; set port bits to input avoid conflict with other drivers
    118  f000				  -	      ifconst	MULTIBUTTON
    119  f000				  -	      lda	snesdetected0,x
    120  f000				  -	      bne	snesexit
    121  f000				  -	      lda	#1	; proline
    122  f000				  -	      sta	port0control,x
    123  f000				  -	      jmp	settwobuttonmode
    124  f000				  -snesexit
    125  f000				  -	      lda	#6
    126  f000				  -	      sta	multibuttoncount0,x
    127  f000				  -			; stuff directions into sSWCHA nibble and buttons into sINPT1,x...
    128  f000				  -	      lda	s2a_joyshiftcount,x
    129  f000				  -	      tay
    130  f000				  -	      lda	snes2atari0hi,x
    131  f000				  -snesjoypadloop
    132  f000				  -	      lsr
    133  f000				  -	      rol	inttemp6
    134  f000				  -	      dey
    135  f000				  -	      bpl	snesjoypadloop
    136  f000				  -	      lda	sSWCHA
    137  f000				  -	      ora	SWCHA_DIRMASK,x	; turn off the bits for this port
    138  f000				  -	      sta	sSWCHA
    139  f000				  -	      lda	inttemp6
    140  f000				  -	      ora	SWCHA_DIRMASK+1,x	; don't change the other port
    141  f000				  -	      and	sSWCHA
    142  f000				  -	      sta	sSWCHA
    143  f000				  -
    144  f000				  -			; snes2atari0hi = B  Y  Se St *  *  *	*
    145  f000				  -			; snes2atari0lo = A  X  Ls Rs
    146  f000				  -			; sINPT1	 = B  A  Y  X  Ls Rs Se St
    147  f000				  -	      lda	snes2atari0lo,x
    148  f000				  -	      sta	inttemp5
    149  f000				  -	      lda	snes2atari0hi,x
    150  f000				  -	      sta	inttemp6
    151  f000				  -	      asl	inttemp5	; A
    152  f000				  -	      rol
    153  f000				  -	      asl	inttemp6	; B
    154  f000				  -	      rol
    155  f000				  -	      asl	inttemp6	; Y
    156  f000				  -	      rol
    157  f000				  -	      asl	inttemp5	; X
    158  f000				  -	      rol
    159  f000				  -	      asl	inttemp5	; Ls
    160  f000				  -	      rol
    161  f000				  -	      asl	inttemp5	; Rs
    162  f000				  -	      rol
    163  f000				  -	      asl	inttemp6	; Ls
    164  f000				  -	      rol
    165  f000				  -	      asl	inttemp6	; Rs
    166  f000				  -	      rol
    167  f000				  -	      eor	#%11000000	; invert to match proline
    168  f000				  -	      sta	sINPT1,x
    169  f000				  -	      endif		; MULTIBUTTON
    170  f000				  -	      rts
    171  f000				  -SNES2ATARI_SIGNAL
    172  f000				  -			; signal to SNES2ATARI++ that we want SNES mode...
    173  f000				  -	      lda	CTLSWA
    174  f000				  -	      and	SWCHA_DIRMASK+1,x	; preserve other nibble
    175  f000				  -	      ora	SNES_CTLSWA_SIGNAL,x
    176  f000				  -	      sta	CTLSWA
    177  f000				  -	      lda	SWCHA
    178  f000				  -	      and	SWCHA_DIRMASK+1,x	; preserve other nibble
    179  f000				  -	      sta	SWCHA
    180  f000				  -	      ldy	#16
    181  f000				  -SNES_SIGNAL_LOOP
    182  f000				  -	      dey
    183  f000				  -	      bne	SNES_SIGNAL_LOOP
    184  f000				  -	      lda	SWCHA
    185  f000				  -	      ora	SWCHA_DIRMASK,x
    186  f000				  -	      sta	SWCHA
    187  f000				  -	      rts
    188  f000				  -s2a_joyshiftcount
    189  f000				  -	      .byte	7,3
    190  f000				  -snes2atarimoduleend
    191  f000				  -	      echo	"  (snes2atari module is using ",[(snes2atarimoduleend-snes2atarimodulestart)]d," bytes of rom)"
    192  f000					      endif		; SNES2ATARISUPPORT
    193  f000
    194  f000
------- FILE constants.78b.asm
   3214  f000					      endif
   3215  f000					      ifnconst	included.mega7800.asm
------- FILE mega7800.asm LEVEL 2 PASS 3
      0  f000					      include	mega7800.asm
      1  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  f000
      3  f000				   mega7800handlerstart
      4  f000				   mega7800handler
      5  f000				  -	      ifconst	MEGA7800SUPPORT
      6  f000				  -
      7  f000				  -			; ** stuff the joyick directions into the shadow register
      8  f000				  -	      lda	sSWCHA	; clear previous dirs for this pad, from
      9  f000				  -	      ora	SWCHA_DIRMASK,x	; our sSWCHA nibble.
     10  f000				  -	      sta	sSWCHA
     11  f000				  -	      lda	SWCHA	; load the actual joystick dirs, ensuring
     12  f000				  -	      ora	SWCHA_DIRMASK+1,x	; we don't change the other nibble.
     13  f000				  -	      and	sSWCHA
     14  f000				  -	      sta	sSWCHA
     15  f000				  -
     16  f000				  -			; x=0 for left port, x=1 for right
     17  f000				  -
     18  f000				  -	      lda	#0
     19  f000				  -	      sta	inttemp5	; temporary button-state storage
     20  f000				  -	      sta	inttemp6	; temporary button-state storage
     21  f000				  -
     22  f000				  -	      lda	CTLSWA
     23  f000				  -	      and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     24  f000				  -	      ora	MEGA_INIT,x
     25  f000				  -	      sta	CTLSWA	; enable pins UP/DOWN to work as outputs
     26  f000				  -
     27  f000				  -			; the controller type bits take a few cycles to get set after we start
     28  f000				  -			; an extended read, so we'll start the first extended read early...
     29  f000				  -	      lda	SWCHA
     30  f000				  -	      and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     31  f000				  -	      sta	SWCHA	; all bits are low, which STARTS the extended read
     32  f000				  -	      nop
     33  f000				  -	      nop
     34  f000				  -
     35  f000				  -			; first read  will be pad state (mega7800 connect and controller type)
     36  f000				  -			; second read will be 3 button support (SACB)
     37  f000				  -			; third read  will be 6 button support (MXYZ)
     38  f000				  -
     39  f000				  -	      ldy	#5	; read 6x states, with the first 2x being the controller type
     40  f000				  -m7readloop
     41  f000				  -	      lda	SWCHA
     42  f000				  -	      and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     43  f000				  -	      sta	SWCHA	; all bits are low, which STARTS the read
     44  f000				  -
     45  f000				  -	      lda	SWCHA
     46  f000				  -	      cpx	#1
     47  f000				  -	      bne	m7skipp1shift
     48  f000				  -	      asl
     49  f000				  -	      asl
     50  f000				  -	      asl
     51  f000				  -	      asl
     52  f000				  -m7skipp1shift
     53  f000				  -	      asl		; button bit 1 into carry
     54  f000				  -	      rol	inttemp6
     55  f000				  -	      rol	inttemp5
     56  f000				  -	      asl		; button bit 0 into carry
     57  f000				  -	      rol	inttemp6
     58  f000				  -	      rol	inttemp5
     59  f000				  -
     60  f000				  -	      lda	SWCHA
     61  f000				  -	      and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     62  f000				  -	      ora	MEGA_NEXT,x
     63  f000				  -	      sta	SWCHA
     64  f000				  -
     65  f000				  -	      dey
     66  f000				  -	      bpl	m7readloop
     67  f000				  -
     68  f000				  -	      lda	CTLSWA
     69  f000				  -	      and	SWCHA_DIRMASK+1,x	; preserve other port nibble
     70  f000				  -	      sta	CTLSWA	; set this port back to input
     71  f000				  -
     72  f000				  -			; if mega7800 isn't detected this frame, unpress any buttons...
     73  f000				  -	      lda	inttemp5
     74  f000				  -	      and	#%00000011
     75  f000				  -	      beq	m7skipscuttle
     76  f000				  -	      lda	#$ff
     77  f000				  -	      sta	inttemp6
     78  f000				  -	      ifconst	MULTIBUTTON
     79  f000				  -			; the controller isn't present... revert to proline
     80  f000				  -	      lda	#1	; proline
     81  f000				  -	      sta	port0control,x
     82  f000				  -	      rts
     83  f000				  -	      endif		; MULTIBUTTON
     84  f000				  -m7skipscuttle
     85  f000				  -	      ifconst	MULTIBUTTON
     86  f000				  -	      lda	inttemp5
     87  f000				  -	      lsr
     88  f000				  -	      lsr
     89  f000				  -	      and	#3
     90  f000				  -	      tay
     91  f000				  -	      lda	megabuttons,y
     92  f000				  -	      sta	multibuttoncount0,x
     93  f000				  -	      endif		; MULTIBUTTON
     94  f000				  -
     95  f000				  -	      lda	inttemp5
     96  f000				  -	      sta	mega7800state0,x
     97  f000				  -	      lda	inttemp6
     98  f000				  -	      sta	mega7800data0,x
     99  f000				  -
    100  f000				  -	      ifconst	MULTIBUTTON
    101  f000				  -			; now update the genric multi-button bits...
    102  f000				  -	      ldy	#7
    103  f000				  -m7shuffleloop
    104  f000				  -	      lda	inttemp6
    105  f000				  -	      and	m7reorder,y
    106  f000				  -	      clc
    107  f000				  -	      adc	#$FF	; bit value in carry
    108  f000				  -	      rol	inttemp5
    109  f000				  -	      dey
    110  f000				  -	      bpl	m7shuffleloop
    111  f000				  -	      lda	inttemp5
    112  f000				  -	      eor	#%11000000
    113  f000				  -	      sta	sINPT1,x
    114  f000				  -	      rts
    115  f000				  -
    116  f000				  -megabuttons
    117  f000				  -	      .byte	6,2,3,2
    118  f000				  -m7reorder
    119  f000				  -			;	  S	     M	       Z	 Y
    120  f000				  -	      .byte	%00100000,%00000010,%00000100,%00001000
    121  f000				  -			;	  X	     C	       A	 B
    122  f000				  -	      .byte	%00000001,%10000000,%00010000,%01000000
    123  f000				  -	      else		;  !MULTIBUTTON
    124  f000				  -	      rts
    125  f000				  -	      endif		; !MULTIBUTTON
    126  f000				  -
    127  f000				  -MEGA_INIT
    128  f000				  -	      .byte	%00110000,%00000011
    129  f000				  -MEGA_NEXT
    130  f000				  -	      .byte	%00100000,%00000010
    131  f000				  -
    132  f000				  -mega7800handlerend
    133  f000				  -	      echo	"  (mega7800 module is using ",[(mega7800handlerend-mega7800handlerstart)]d," bytes of rom)"
    134  f000				  -
    135  f000					      endif		; MEGA7800SUPPORT
    136  f000
------- FILE constants.78b.asm
   3217  f000					      endif
   3218  f000					      ifnconst	included.tracker.asm
------- FILE tracker.asm LEVEL 2 PASS 3
      0  f000					      include	tracker.asm
      1  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  f000
      3  f000
      4  f000				  -	      ifconst	MUSICTRACKER
      5  f000				  -
      6  f000				  -trackerstart
      7  f000				  -
      8  f000				  -			; ** songtempo lists how many 256ths of a frame a 16th note lasts
      9  f000				  -			; ** the player operates on a 16th note grid.
     10  f000				  -
     11  f000				  -servicesongover
     12  f000				  -	      rts
     13  f000				  -servicesong
     14  f000				  -	      ifconst	PAUSESILENT
     15  f000				  -	      lda	pausestate
     16  f000				  -	      bne	servicesongover
     17  f000				  -	      endif
     18  f000				  -	      lda	songtempo
     19  f000				  -	      beq	servicesongover	; ** if song is off/paused then return
     20  f000				  -servicesongcontinue
     21  f000				  -	      lda	sfxschedulelock
     22  f000				  -	      sta	sfxschedulemissed
     23  f000				  -	      bne	servicesongover
     24  f000				  -	      lda	songtempo
     25  f000				  -	      clc
     26  f000				  -	      adc	songtick	; add songtempo to songtick until it rolls over
     27  f000				  -	      sta	songtick	; this is how we break away from 50/60Hz timing.
     28  f000				  -	      bcc	servicesongover
     29  f000				  -			; ** if we're here a new 16th note has passed
     30  f000				  -			; ** check if a new note is due on any of the 4 channels
     31  f000				  -servicesongredo
     32  f000				  -	      ldx	#3
     33  f000				  -checkchannelloop
     34  f000				  -	      dec	songchannel1busywait,x
     35  f000				  -	      bpl	carryoncheckingchannel
     36  f000				  -	      txa
     37  f000				  -	      pha		; save X for the loop
     38  f000				  -	      jsr	processsongdata
     39  f000				  -	      pla		; restore X for the loop
     40  f000				  -	      tax
     41  f000				  -carryoncheckingchannel
     42  f000				  -	      dex
     43  f000				  -	      bpl	checkchannelloop
     44  f000				  -	      lda	inactivechannelcount
     45  f000				  -	      cmp	#15
     46  f000				  -	      bne	skipstopsong
     47  f000				  -	      lda	songloops
     48  f000				  -	      bne	doasongloop
     49  f000				  -			;lda #0
     50  f000				  -	      sta	songtempo	; all channels are done. stop the song
     51  f000				  -	      rts
     52  f000				  -doasongloop
     53  f000				  -	      bmi	skipsongloopadjust
     54  f000				  -	      dec	songloops
     55  f000				  -skipsongloopadjust
     56  f000				  -	      jsr	setsongchannels
     57  f000				  -	      jmp	servicesongredo
     58  f000				  -skipstopsong
     59  f000				  -	      rts
     60  f000				  -
     61  f000				  -processsongdata
     62  f000				  -			; channel needs processing
     63  f000				  -			; X=channel #
     64  f000				  -
     65  f000				  -	      txa
     66  f000				  -	      clc
     67  f000				  -	      adc	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
     68  f000				  -	      tay
     69  f000				  -
     70  f000				  -
     71  f000				  -			; ** indirect x is cumbersome with mult-byte commands.
     72  f000				  -			; ** setup a pointer to the song data for indirect y addressing.
     73  f000				  -	      lda	songchannel1layer1lo,y
     74  f000				  -	      sta	songdatalo
     75  f000				  -	      lda	songchannel1layer1hi,y
     76  f000				  -	      sta	songdatahi
     77  f000				  -			;ora songdatalo
     78  f000				  -	      bne	channelhasdata
     79  f000				  -			;channel data is pointing at $0000
     80  f000				  -	      lda	#$7F
     81  f000				  -	      sta	songchannel1busywait,x	; skip a bunch of notes
     82  f000				  -setchannelcountbits
     83  f000				  -	      lda	channel2bits,x
     84  f000				  -	      ora	inactivechannelcount
     85  f000				  -	      sta	inactivechannelcount
     86  f000				  -	      rts
     87  f000				  -channelhasdata
     88  f000				  -
     89  f000				  -	      sty	songstackindex
     90  f000				  -	      ldy	#0
     91  f000				  -	      lda	(songdatalo),y	; ** load in the next byte of song data, so we can decode it
     92  f000				  -	      cmp	#$ff
     93  f000				  -	      bne	carryoncheckingdatatype	; ** $ff=pattern end marker
     94  f000				  -	      jmp	handlechannelEOD
     95  f000				  -
     96  f000				  -carryoncheckingdatatype
     97  f000				  -	      and	#$F0
     98  f000				  -	      cmp	#$C0
     99  f000				  -	      beq	handlechannelrest	; 0000XXXX=rest
    100  f000				  -	      cmp	#$F0
    101  f000				  -	      beq	handlemultibytecommand
    102  f000				  -	      cmp	#$D0
    103  f000				  -	      beq	handlesemiup
    104  f000				  -	      cmp	#$E0
    105  f000				  -	      beq	handlesemidown
    106  f000				  -handlenotedata
    107  f000				  -			; ** TODO: note playing is a terrible choice for fall-through
    108  f000				  -
    109  f000				  -			; ** its simple note data, prepare arguments for schedulesfx
    110  f000				  -
    111  f000				  -			; ** set the note length
    112  f000				  -	      lda	(songdatalo),y
    113  f000				  -	      and	#$0F
    114  f000				  -	      sta	songchannel1busywait,x
    115  f000				  -
    116  f000				  -			; ** load the instrument
    117  f000				  -	      lda	songchannel1instrumentlo,x
    118  f000				  -	      sta	sfxinstrumentlo
    119  f000				  -	      lda	songchannel1instrumenthi,x
    120  f000				  -	      sta	sfxinstrumenthi
    121  f000				  -
    122  f000				  -			; ** get the note, and transpose
    123  f000				  -	      lda	(songdatalo),y
    124  f000				  -	      lsr
    125  f000				  -	      lsr
    126  f000				  -	      lsr
    127  f000				  -	      lsr
    128  f000				  -	      clc
    129  f000				  -	      adc	songchannel1transpose,x	; ** add it to the transpose index
    130  f000				  -			; ** its up the respective SFX scheduler to handle and save the note data
    131  f000				  -	      sta	sfxnoteindex
    132  f000				  -
    133  f000				  -	      lda	#0
    134  f000				  -	      sta	sfxpitchoffset
    135  f000				  -
    136  f000				  -	      jsr	schedulesfx
    137  f000				  -skipnoteschedule
    138  f000				  -	      jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    139  f000				  -
    140  f000				  -handlechannelrest
    141  f000				  -			; ** set the note length
    142  f000				  -	      lda	(songdatalo),y
    143  f000				  -	      and	#$0F
    144  f000				  -	      sta	songchannel1busywait,x
    145  f000				  -	      jmp	advancethesongpointer1byte	; advance to the next data byte and exit
    146  f000				  -
    147  f000				  -handlesemiup
    148  f000				  -	      lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    149  f000				  -	      and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    150  f000				  -	      clc
    151  f000				  -handlesemidownentry
    152  f000				  -	      adc	songchannel1transpose,x	; ** add it to the transpose index
    153  f000				  -	      sta	songchannel1transpose,x
    154  f000				  -	      jsr	advancethesongpointer1byte
    155  f000				  -	      jmp	processsongdata	; semi doesn't have note length, so process the next data byte...
    156  f000				  -
    157  f000				  -handlesemidown
    158  f000				  -	      lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    159  f000				  -	      and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    160  f000				  -	      eor	#$ff	; ** its easier if we negate it, and then add it instead.
    161  f000				  -	      sec
    162  f000				  -	      jmp	handlesemidownentry
    163  f000				  -
    164  f000				  -handlemultibytecommand
    165  f000				  -	      lda	(songdatalo),y	; ** reload the song data, so we can get at the lower nibble
    166  f000				  -	      and	#$0f	; ** since we need to mask the nibble of the subtracted value,
    167  f000				  -	      cmp	#$08	; ** load new instrument?
    168  f000				  -	      bne	nothandleinstrumentchange
    169  f000				  -handleinstrumentchange
    170  f000				  -	      iny
    171  f000				  -	      lda	(songdatalo),y
    172  f000				  -	      sta	songchannel1instrumentlo,x
    173  f000				  -	      iny
    174  f000				  -	      lda	(songdatalo),y
    175  f000				  -	      sta	songchannel1instrumenthi,x
    176  f000				  -	      lda	#3
    177  f000				  -	      jsr	advancethesongpointerNbytes	; advance 3 bytes
    178  f000				  -	      jmp	processsongdata
    179  f000				  -
    180  f000				  -nothandleinstrumentchange
    181  f000				  -	      cmp	#$09	; ** absolute tempo change?
    182  f000				  -	      bne	nothandletempochange
    183  f000				  -	      lda	#0
    184  f000				  -	      sta	songtempo
    185  f000				  -handlerelativetempochange
    186  f000				  -	      iny
    187  f000				  -	      lda	(songdatalo),y
    188  f000				  -	      clc
    189  f000				  -	      adc	songtempo
    190  f000				  -	      sta	songtempo
    191  f000				  -	      lda	#2
    192  f000				  -	      jsr	advancethesongpointerNbytes	; advance 2 bytes
    193  f000				  -	      jmp	processsongdata
    194  f000				  -
    195  f000				  -nothandletempochange
    196  f000				  -	      cmp	#$0A	; ** relative tempo change?:
    197  f000				  -	      beq	handlerelativetempochange
    198  f000				  -	      cmp	#$0B	; ** octave/semi change?
    199  f000				  -	      beq	handleoctavesemichange
    200  f000				  -handlepatterndata
    201  f000				  -			; ** if we're here its a pattern/loop "subroutine"
    202  f000				  -			; ** move the channel's "stack" pointer and populate the new stack level
    203  f000				  -
    204  f000				  -	      lda	#4
    205  f000				  -	      clc
    206  f000				  -	      adc	songchannel1stackdepth,x
    207  f000				  -	      sta	songchannel1stackdepth,x	; stack depth value will be 0, 4, or 8
    208  f000				  -
    209  f000				  -	      stx	inttemp6	; about to invalidate x. save it.
    210  f000				  -	      lda	songstackindex
    211  f000				  -	      adc	#4
    212  f000				  -	      tax
    213  f000				  -
    214  f000				  -	      lda	(songdatalo),y
    215  f000				  -	      and	#$7
    216  f000				  -	      sta	songchannel1layer1loops,x
    217  f000				  -	      iny
    218  f000				  -	      lda	(songdatalo),y
    219  f000				  -	      sta	songchannel1layer1lo,x
    220  f000				  -	      iny
    221  f000				  -	      lda	(songdatalo),y
    222  f000				  -	      sta	songchannel1layer1hi,x
    223  f000				  -
    224  f000				  -	      ldx	inttemp6	; restore x with the channel #
    225  f000				  -
    226  f000				  -			; ** advance will operate on the old stack level, since we didn't store the updated songstackindex...
    227  f000				  -	      lda	#3
    228  f000				  -	      jsr	advancethesongpointerNbytes	; advance 3 bytes
    229  f000				  -
    230  f000				  -			; ** ...but the new stack level will be correctly picked up when we process the next byte.
    231  f000				  -	      jmp	processsongdata
    232  f000				  -
    233  f000				  -handlechannelEOD
    234  f000				  -			; ** check if there are loops remaining on the pattern
    235  f000				  -	      stx	inttemp6
    236  f000				  -	      ldx	songstackindex
    237  f000				  -	      dec	songchannel1layer1loops,x
    238  f000				  -	      bmi	handlechannelEODnoloop
    239  f000				  -			; ** loops are remaining. set the pattern pointer to the pattern start, which is contained after the EOD
    240  f000				  -	      iny
    241  f000				  -	      lda	(songdatalo),y
    242  f000				  -	      sta	songchannel1layer1lo,x
    243  f000				  -	      iny
    244  f000				  -	      lda	(songdatalo),y
    245  f000				  -	      sta	songchannel1layer1hi,x
    246  f000				  -	      ldx	inttemp6
    247  f000				  -	      jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    248  f000				  -
    249  f000				  -handlechannelEODnoloop
    250  f000				  -			; this pattern/loop is done playing. "pop" the stack
    251  f000				  -	      ldx	inttemp6
    252  f000				  -	      lda	songchannel1stackdepth,x
    253  f000				  -	      beq	handlerootchannelEOD
    254  f000				  -	      sec
    255  f000				  -	      sbc	#4
    256  f000				  -	      sta	songchannel1stackdepth,x
    257  f000				  -	      jmp	processsongdata	; EOD handling doesn't have note length, so process the next data byte...
    258  f000				  -
    259  f000				  -handlerootchannelEOD
    260  f000				  -			; this channel is done. point it to $ff data so we no longer process this channel.
    261  f000				  -	      lda	#0
    262  f000				  -	      sta	songchannel1layer1lo,x
    263  f000				  -	      sta	songchannel1layer1hi,x
    264  f000				  -	      sta	songchannel1busywait,x
    265  f000				  -	      jmp	setchannelcountbits
    266  f000				  -	      rts
    267  f000				  -
    268  f000				  -nothandlepatternchange
    269  f000				  -handleoctavesemichange
    270  f000				  -	      iny
    271  f000				  -	      lda	(songdatalo),y
    272  f000				  -	      sta	songchannel1transpose,x
    273  f000				  -	      lda	#2
    274  f000				  -	      jsr	advancethesongpointerNbytes	; advance 2 bytes
    275  f000				  -	      jmp	processsongdata
    276  f000				  -
    277  f000				  -advancethesongpointer1byte
    278  f000				  -	      txa
    279  f000				  -	      ldx	songstackindex
    280  f000				  -	      inc	songchannel1layer1lo,x
    281  f000				  -	      bne	skiphiadvancethesongpointer1byte
    282  f000				  -	      inc	songchannel1layer1hi,x
    283  f000				  -skiphiadvancethesongpointer1byte
    284  f000				  -	      tax
    285  f000				  -	      rts
    286  f000				  -
    287  f000				  -advancethesongpointerNbytes
    288  f000				  -			; entered with A=# of byte to advance
    289  f000				  -	      stx	inttemp6
    290  f000				  -	      ldx	songstackindex
    291  f000				  -	      clc
    292  f000				  -	      adc	songchannel1layer1lo,x
    293  f000				  -	      sta	songchannel1layer1lo,x
    294  f000				  -	      lda	#0
    295  f000				  -	      adc	songchannel1layer1hi,x
    296  f000				  -	      sta	songchannel1layer1hi,x
    297  f000				  -	      ldx	inttemp6
    298  f000				  -	      rts
    299  f000				  -
    300  f000				  -clearsongmemory
    301  f000				  -	      lda	#0
    302  f000				  -	      ldx	#(songchannel4instrumenthi-songchannel1layer1lo)
    303  f000				  -clearsongmemoryloop1
    304  f000				  -	      sta	songchannel1layer1lo,x
    305  f000				  -	      dex
    306  f000				  -	      bpl	clearsongmemoryloop1
    307  f000				  -
    308  f000				  -	      ldx	#(songchannel4stackdepth-songchannel1layer1loops)
    309  f000				  -clearsongmemoryloop2
    310  f000				  -	      sta	songchannel1layer1loops,x
    311  f000				  -	      dex
    312  f000				  -	      bpl	clearsongmemoryloop2
    313  f000				  -
    314  f000				  -	      lda	#$ff
    315  f000				  -	      ldx	#3
    316  f000				  -clearsongmemoryloop3
    317  f000				  -	      sta	songchannel1busywait,x
    318  f000				  -	      dex
    319  f000				  -	      bpl	clearsongmemoryloop3
    320  f000				  -	      rts
    321  f000				  -
    322  f000				  -setsongchannels
    323  f000				  -	      jsr	clearsongmemory
    324  f000				  -	      ldy	#7
    325  f000				  -	      ldx	#3
    326  f000				  -setsongchannelsloop
    327  f000				  -	      lda	(songpointerlo),y
    328  f000				  -	      sta	songchannel1layer1hi,x
    329  f000				  -	      dey
    330  f000				  -	      lda	(songpointerlo),y
    331  f000				  -	      sta	songchannel1layer1lo,x
    332  f000				  -	      dex
    333  f000				  -	      dey
    334  f000				  -	      bpl	setsongchannelsloop
    335  f000				  -	      rts
    336  f000				  -
    337  f000				  -channel2bits
    338  f000				  -	      .byte	1,2,4,8
    339  f000				  -
    340  f000				  -tiatrackeroctavenotes
    341  f000				  -	      ifconst	BUZZBASS
    342  f000				  -LOWC       =	15
    343  f000				  -	      else
    344  f000				  -LOWC       =	14
    345  f000				  -	      endif
    346  f000				  -			; ****** ELECTRONIC (0 to 11)
    347  f000				  -	      .byte	LOWC,20	; c0	 16.1Hz
    348  f000				  -	      .byte	LOWC,18	; c#0
    349  f000				  -	      .byte	LOWC,17	; d0
    350  f000				  -	      .byte	LOWC,16	; d#0
    351  f000				  -	      .byte	LOWC,15	; e0
    352  f000				  -	      .byte	LOWC,14	; f0  (very off)
    353  f000				  -	      .byte	LOWC,14	; f#0
    354  f000				  -	      .byte	LOWC,13	; g0
    355  f000				  -	      .byte	LOWC,12	; g#0
    356  f000				  -	      .byte	LOWC,11	; a0
    357  f000				  -	      .byte	LOWC,11	; a#0 (very off)
    358  f000				  -	      .byte	LOWC,10	; b0	 30.7Hz
    359  f000				  -
    360  f000				  -			; ****** SLIGHTLY BUZZY (12 to 23)
    361  f000				  -	      .byte	6,30	; c1	 32.7Hz
    362  f000				  -	      .byte	6,28	; c#1
    363  f000				  -	      .byte	6,27	; d1
    364  f000				  -	      .byte	6,25	; d#1
    365  f000				  -	      .byte	6,24	; e1
    366  f000				  -	      .byte	6,22	; f1
    367  f000				  -	      .byte	6,21	; f#1
    368  f000				  -	      .byte	6,20	; g1
    369  f000				  -	      .byte	6,18	; g#1
    370  f000				  -	      .byte	6,17	; a1
    371  f000				  -	      .byte	6,16	; a#1
    372  f000				  -	      .byte	6,15	; b1	 63.4Hz
    373  f000				  -
    374  f000				  -			; ****** BUZZY (24 to 39)
    375  f000				  -	      .byte	1,31	; c2	 65.5
    376  f000				  -	      .byte	1,30	; c#2	 67.6
    377  f000				  -	      .byte	1,27	; d2	 72.3
    378  f000				  -	      .byte	1,26	; d#2	 77.6
    379  f000				  -	      .byte	1,24	; e2
    380  f000				  -	      .byte	1,23	; f2
    381  f000				  -	      .byte	1,22	; f#2
    382  f000				  -	      .byte	1,20	; g2
    383  f000				  -	      .byte	1,19	; g#2
    384  f000				  -	      .byte	1,18	; a2
    385  f000				  -	      .byte	1,17	; a#2
    386  f000				  -	      .byte	1,16	; b2
    387  f000				  -	      .byte	1,15	; c3	126.8Hz
    388  f000				  -	      .byte	1,14	; c#3
    389  f000				  -	      .byte	1,13	; d3	149.7Hz
    390  f000				  -	      .byte	1,12	; d#3	161.2Hz (very off)
    391  f000				  -			; ****** PURE (40 to 71) - best key is A3 Major
    392  f000				  -	      .byte	12,31	; e3	163.8Hz
    393  f000				  -	      .byte	12,29	; f3
    394  f000				  -	      .byte	12,28	; f#3
    395  f000				  -	      .byte	12,26	; g3
    396  f000				  -	      .byte	12,24	; g#3
    397  f000				  -	      .byte	12,23	; a3  songs in key of A benefit from Perceptual Tuning
    398  f000				  -	      .byte	12,22	; a#3
    399  f000				  -	      .byte	12,20	; b3
    400  f000				  -	      .byte	12,19	; c4  (middle C)
    401  f000				  -	      .byte	12,18	; c#4
    402  f000				  -	      .byte	12,17	; d4
    403  f000				  -	      .byte	12,16	; d#4
    404  f000				  -	      .byte	12,15	; e4
    405  f000				  -	      .byte	12,14	; f4
    406  f000				  -	      .byte	12,13	; f#4
    407  f000				  -	      .byte	12,12	; g4  (very off)
    408  f000				  -	      .byte	12,12	; g#4
    409  f000				  -	      .byte	12,11	; a4
    410  f000				  -	      .byte	12,10	; a#4
    411  f000				  -	      .byte	4,31	; b4
    412  f000				  -	      .byte	4,29	; c5
    413  f000				  -	      .byte	4,28	; c#5
    414  f000				  -	      .byte	4,26	; d5
    415  f000				  -	      .byte	4,24	; d#5
    416  f000				  -	      .byte	4,23	; e5
    417  f000				  -	      .byte	4,22	; f5
    418  f000				  -	      .byte	4,20	; f#5
    419  f000				  -	      .byte	4,19	; g5
    420  f000				  -	      .byte	4,18	; g#5
    421  f000				  -	      .byte	4,17	; a5
    422  f000				  -	      .byte	4,16	; a#5
    423  f000				  -	      .byte	4,15	; b5
    424  f000				  -
    425  f000				  -			; ****** TUNED WIND (72 to 83)
    426  f000				  -	      .byte	8,30	; c
    427  f000				  -	      .byte	8,28	; c#
    428  f000				  -	      .byte	8,27	; d
    429  f000				  -	      .byte	8,25	; d#
    430  f000				  -	      .byte	8,24	; e
    431  f000				  -	      .byte	8,22	; f
    432  f000				  -	      .byte	8,21	; f#
    433  f000				  -	      .byte	8,20	; g
    434  f000				  -	      .byte	8,18	; g#
    435  f000				  -	      .byte	8,17	; a
    436  f000				  -	      .byte	8,16	; a#
    437  f000				  -	      .byte	8,15	; b
    438  f000				  -
    439  f000				  -	      include	"tiadrumkit.asm"
    440  f000				  -
    441  f000				  -trackerend
    442  f000				  -
    443  f000				  -	      echo	"  (tracker module is using ",[(trackerend-trackerstart)]d," bytes)"
    444  f000				  -
    445  f000					      endif		;MUSICTRACKER
------- FILE constants.78b.asm
   3220  f000					      endif
   3221  f000					      ifnconst	included.hiscore.asm
------- FILE hiscore.asm LEVEL 2 PASS 3
      0  f000					      include	hiscore.asm
      1  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  f000
      3  f000				  -	      ifconst	HSSUPPORT
      4  f000				  -
      5  f000				  -	      ifconst	BANKSETROM
      6  f000				  -	      ifconst	isBANKSETBANK
      7  f000				  -HSCHARSHERE =	1
      8  f000				  -	      endif
      9  f000				  -	      else		; !BANKSETROM so embed the character strings
     10  f000				  -HSCHARSHERE =	1
     11  f000				  -	      endif
     12  f000				  -
     13  f000				  -	      ifnconst	isBANKSETBANK
     14  f000				  -hiscorestart
     15  f000				  -
     16  f000				  -detectatarivoxeeprom
     17  f000				  -hiscoremodulestart
     18  f000				  -			; do a test to see if atarivox eeprom can be accessed, and save results
     19  f000				  -	      jsr	AVoxDetect
     20  f000				  -	      eor	#$ff	; invert for easy 7800basic if...then logic
     21  f000				  -	      sta	avoxdetected
     22  f000				  -	      lda	#$0
     23  f000				  -	      sta	SWACNT
     24  f000				  -	      lda	avoxdetected
     25  f000				  -	      rts
     26  f000				  -
     27  f000				  -detecthsc
     28  f000				  -			; check for the HSC ROM signature...
     29  f000				  -	      lda	XCTRL1s
     30  f000				  -	      ora	#%00001100
     31  f000				  -	      sta	XCTRL1s
     32  f000				  -	      sta	XCTRL1
     33  f000				  -
     34  f000				  -	      lda	$3900
     35  f000				  -	      eor	#$C6
     36  f000				  -	      bne	detecthscfail
     37  f000				  -	      lda	$3904
     38  f000				  -	      eor	#$FE
     39  f000				  -	      bne	detecthscfail
     40  f000				  -
     41  f000				  -			; check if it's initialized...
     42  f000				  -	      ldy	#0
     43  f000				  -	      lda	#$ff
     44  f000				  -checkhscinit
     45  f000				  -	      and	$1000,y
     46  f000				  -	      dey
     47  f000				  -	      bne	checkhscinit
     48  f000				  -	      cmp	#$ff
     49  f000				  -	      beq	dominimalhscinit
     50  f000				  -			; Y is 0
     51  f000				  -	      lda	#0
     52  f000				  -checkhscinit2
     53  f000				  -	      ora	$1000,y
     54  f000				  -	      dey
     55  f000				  -	      bne	checkhscinit2
     56  f000				  -	      cmp	#0
     57  f000				  -	      bne	hscisalreadyinit
     58  f000				  -dominimalhscinit
     59  f000				  -			; if we're here, we need to do a minimal HSC init...
     60  f000				  -	      ldy	#$28
     61  f000				  -hscinitloop1
     62  f000				  -	      lda	hscheader,y
     63  f000				  -	      sta	$1000,y
     64  f000				  -	      dey
     65  f000				  -	      bpl	hscinitloop1
     66  f000				  -	      ldy	#$89
     67  f000				  -	      lda	#$7F
     68  f000				  -hscinitloop2
     69  f000				  -	      sta	$10B3,y
     70  f000				  -	      dey
     71  f000				  -	      cpy	#$ff
     72  f000				  -	      bne	hscinitloop2
     73  f000				  -hscisalreadyinit
     74  f000				  -	      lda	#$ff
     75  f000				  -	      rts
     76  f000				  -hscheader
     77  f000				  -	      .byte	$00,$00,$68,$83,$AA,$55,$9C,$FF,$07,$12,$02,$1F,$00,$00,$00,$00
     78  f000				  -	      .byte	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
     79  f000				  -	      .byte	$00,$00,$00,$00,$00,$00,$00,$00,$03
     80  f000				  -detecthscfail
     81  f000				  -	      lda	XCTRL1s
     82  f000				  -	      and	#%11110111
     83  f000				  -	      sta	XCTRL1s
     84  f000				  -	      lda	#0
     85  f000				  -	      rts
     86  f000				  -	      endif		; isBANKSETBANK
     87  f000				  -
     88  f000				  -	      ifnconst	hiscorefont
     89  f000				  -	      echo	""
     90  f000				  -	      echo	"WARNING: High score support is enabled, but the hiscorefont.png was"
     91  f000				  -	      echo	" NOT imported with incgraphic. The high score display code"
     92  f000				  -	      echo	" has been omitted from this build."
     93  f000				  -	      echo	""
     94  f000				  -	      else		; hiscorefont
     95  f000				  -	      ifnconst	isBANKSETBANK
     96  f000				  -hscdrawscreen
     97  f000				  -
     98  f000				  -			; we use 20 lines on a 24 line display
     99  f000				  -			; HSSCOREY to dynamically centers based on
    100  f000				  -			;HSSCOREY = 0
    101  f000				  -HSSCOREY   =	((WZONECOUNT*WZONEHEIGHT/8)-22)/2
    102  f000				  -HSCURSORY  =	((HSSCOREY/(WZONEHEIGHT/8))*WZONEHEIGHT)
    103  f000				  -
    104  f000				  -	      ifconst	HSSCORESIZE
    105  f000				  -SCORESIZE  =	HSSCORESIZE
    106  f000				  -	      else
    107  f000				  -SCORESIZE  =	6
    108  f000				  -	      endif
    109  f000				  -
    110  f000				  -	      jsr	mutetia
    111  f000				  -	      ifconst	pokeysupport
    112  f000				  -	      jsr	mutepokey
    113  f000				  -	      endif		; pokeysupport
    114  f000				  -
    115  f000				  -			;save shadow registers for later return...
    116  f000				  -	      lda	sCTRL
    117  f000				  -	      pha
    118  f000				  -	      lda	sCHARBASE
    119  f000				  -	      pha
    120  f000				  -
    121  f000				  -	      jsr	blacken320colors
    122  f000				  -	      jsr	drawoverwait
    123  f000				  -	      jsr	drawwait
    124  f000				  -	      jsr	hiscorecleardlmem
    125  f000				  -	      jsr	clearscreen
    126  f000				  -
    127  f000				  -	      lda	#$60
    128  f000				  -	      sta	charactermode
    129  f000				  -
    130  f000				  -			;set the character base to the HSC font
    131  f000				  -	      lda	#>hiscorefont
    132  f000				  -	      sta	CHARBASE
    133  f000				  -	      sta	sCHARBASE
    134  f000				  -	      lda	#%01000011	;Enable DMA, mode=320A
    135  f000				  -	      sta	CTRL
    136  f000				  -	      sta	sCTRL
    137  f000				  -
    138  f000				  -	      lda	#60
    139  f000				  -	      sta	hsjoydebounce
    140  f000				  -
    141  f000				  -	      lda	#0
    142  f000				  -	      sta	hscursorx
    143  f000				  -	      sta	framecounter
    144  f000				  -
    145  f000				  -	      ifnconst	HSCOLORCHASESTART
    146  f000				  -	      lda	#$8D	; default is blue. why not?
    147  f000				  -	      else
    148  f000				  -	      lda	#HSCOLORCHASESTART
    149  f000				  -	      endif
    150  f000				  -	      sta	hscolorchaseindex
    151  f000				  -	      lda	#$0F
    152  f000				  -	      sta	P0C2	; base text is white
    153  f000				  -	      jsr	hschasecolors
    154  f000				  -
    155  f000				  -			; ** plot all of the initials
    156  f000				  -	      lda	#<HSRAMInitials
    157  f000				  -	      sta	temp1	; charmaplo
    158  f000				  -	      lda	#>HSRAMInitials
    159  f000				  -	      sta	temp2	; charmaphi
    160  f000				  -	      lda	#32+29	; palette=0-29 | 32-(width=3)
    161  f000				  -	      sta	temp3	; palette/width
    162  f000				  -	      lda	#104
    163  f000				  -	      sta	temp4	; X
    164  f000				  -	      lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    165  f000				  -	      sta	temp5	; Y
    166  f000				  -plothsinitialsloop
    167  f000				  -	      jsr	plotcharacters
    168  f000				  -	      clc
    169  f000				  -	      lda	temp3
    170  f000				  -	      adc	#32
    171  f000				  -	      sta	temp3
    172  f000				  -	      inc	temp5
    173  f000				  -	      if	WZONEHEIGHT = 8
    174  f000				  -	      inc	temp5
    175  f000				  -	      endif
    176  f000				  -	      clc
    177  f000				  -	      lda	#3
    178  f000				  -	      adc	temp1
    179  f000				  -	      sta	temp1
    180  f000				  -	      cmp	#(<(HSRAMInitials+15))
    181  f000				  -	      bcc	plothsinitialsloop
    182  f000				  -
    183  f000				  -	      ifconst	HSGAMENAMELEN
    184  f000				  -			;plot the game name...
    185  f000				  -	      lda	#<HSGAMENAMEtable
    186  f000				  -	      sta	temp1	; charmaplo
    187  f000				  -	      lda	#>HSGAMENAMEtable
    188  f000				  -	      sta	temp2	; charmaphi
    189  f000				  -	      lda	#(32-HSGAMENAMELEN)	; palette=0*29 | 32-(width=3)
    190  f000				  -	      sta	temp3	; palette/width
    191  f000				  -	      lda	#(80-(HSGAMENAMELEN*2))
    192  f000				  -	      sta	temp4	; X
    193  f000				  -	      lda	#((HSSCOREY+0)/(WZONEHEIGHT/8))
    194  f000				  -	      sta	temp5	; Y
    195  f000				  -	      jsr	plotcharacters
    196  f000				  -	      endif		; HSGAMENAMELEN
    197  f000				  -
    198  f000				  -			;plot "difficulty"...
    199  f000				  -	      ldy	gamedifficulty
    200  f000				  -	      ifnconst	HSNOLEVELNAMES
    201  f000				  -	      lda	highscoredifficultytextlo,y
    202  f000				  -	      sta	temp1
    203  f000				  -	      lda	highscoredifficultytexthi,y
    204  f000				  -	      sta	temp2
    205  f000				  -	      sec
    206  f000				  -	      lda	#32
    207  f000				  -	      sbc	highscoredifficultytextlen,y
    208  f000				  -	      sta	temp3	; palette/width
    209  f000				  -	      sec
    210  f000				  -	      lda	#40
    211  f000				  -	      sbc	highscoredifficultytextlen,y
    212  f000				  -	      asl
    213  f000				  -	      sta	temp4	; X
    214  f000				  -	      else
    215  f000				  -	      lda	#<HSHIGHSCOREStext
    216  f000				  -	      sta	temp1	; charmaplo
    217  f000				  -	      lda	#>HSHIGHSCOREStext
    218  f000				  -	      sta	temp2	; charmaphi
    219  f000				  -	      lda	#(32-11)	; palette=0*29 | 32-(width=3)
    220  f000				  -	      sta	temp3	; palette/width
    221  f000				  -	      lda	#(80-(11*2))
    222  f000				  -	      sta	temp4	; X
    223  f000				  -	      endif		; HSNOLEVELNAMES
    224  f000				  -
    225  f000				  -	      lda	#((HSSCOREY+2)/(WZONEHEIGHT/8))
    226  f000				  -	      sta	temp5	; Y
    227  f000				  -	      jsr	plotcharacters
    228  f000				  -	      ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval, 4=player 2 player evel (joy1)
    229  f000				  -	      bne	carronwithscoreevaluation
    230  f000				  -	      jmp	donoscoreevaluation
    231  f000				  -carronwithscoreevaluation
    232  f000				  -	      dey
    233  f000				  -	      lda	highscorelabeltextlo,y
    234  f000				  -	      sta	temp1
    235  f000				  -	      lda	highscorelabeltexthi,y
    236  f000				  -	      sta	temp2
    237  f000				  -	      sec
    238  f000				  -	      lda	#(32-15)	; palette=0*29 | 32-(width=3)
    239  f000				  -	      sta	temp3	; palette/width
    240  f000				  -	      lda	highscorelabeladjust1,y
    241  f000				  -	      sta	temp4	; X
    242  f000				  -	      lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    243  f000				  -	      sta	temp5	; Y
    244  f000				  -	      jsr	plotcharacters
    245  f000				  -
    246  f000				  -	      ldy	hsdisplaymode	; 0=attact mode, 1=player eval, 2=player 1 eval, 3=player 2 player eval, 4=player 2 player evel (joy1)
    247  f000				  -	      dey
    248  f000				  -			;plot the current player score...
    249  f000				  -	      lda	#(32-SCORESIZE)	; palette=0*32
    250  f000				  -	      sta	temp3	; palette/width
    251  f000				  -	      lda	highscorelabeladjust2,y
    252  f000				  -	      sta	temp4	; X
    253  f000				  -	      lda	#((HSSCOREY+18)/(WZONEHEIGHT/8))
    254  f000				  -	      sta	temp5	; Y
    255  f000				  -
    256  f000				  -	      lda	scorevarlo,y
    257  f000				  -	      sta	temp7	; score variable lo
    258  f000				  -	      lda	scorevarhi,y
    259  f000				  -	      sta	temp8	; score variable hi
    260  f000				  -
    261  f000				  -	      lda	#(hiscorefont_mode | %01100000)	; charactermode
    262  f000				  -	      sta	temp9
    263  f000				  -
    264  f000				  -	      lda	#<(hiscorefont+33)	; +33 to get to '0' character
    265  f000				  -	      sta	temp1	; charmaplo
    266  f000				  -	      lda	#>(hiscorefont+33)
    267  f000				  -	      sta	temp2	; charmaphi
    268  f000				  -	      lda	#SCORESIZE
    269  f000				  -	      sta	temp6
    270  f000				  -	      ifnconst	DOUBLEWIDE
    271  f000				  -	      jsr	plotvalue
    272  f000				  -	      else
    273  f000				  -	      jsr	plotvaluedw
    274  f000				  -	      endif
    275  f000				  -
    276  f000				  -USED_PLOTVALUE =	1	; ensure that plotvalue gets compiled in
    277  f000				  -
    278  f000				  -	      ifconst	HSGAMERANKS
    279  f000				  -
    280  f000				  -	      ldx	#$ff	; start at 0 after the inx...
    281  f000				  -comparescore2rankloop
    282  f000				  -	      inx
    283  f000				  -	      ldy	#0
    284  f000				  -	      lda	rankvalue_0,x
    285  f000				  -	      cmp	(temp7),y
    286  f000				  -	      bcc	score2rankloopdone
    287  f000				  -	      bne	comparescore2rankloop
    288  f000				  -	      iny
    289  f000				  -	      lda	rankvalue_1,x
    290  f000				  -	      cmp	(temp7),y
    291  f000				  -	      bcc	score2rankloopdone
    292  f000				  -	      bne	comparescore2rankloop
    293  f000				  -	      iny
    294  f000				  -	      lda	(temp7),y
    295  f000				  -	      cmp	rankvalue_2,x
    296  f000				  -	      bcs	score2rankloopdone
    297  f000				  -	      jmp	comparescore2rankloop
    298  f000				  -score2rankloopdone
    299  f000				  -	      stx	hsnewscorerank
    300  f000				  -
    301  f000				  -	      lda	ranklabello,x
    302  f000				  -	      sta	temp1
    303  f000				  -	      lda	ranklabelhi,x
    304  f000				  -	      sta	temp2
    305  f000				  -	      sec
    306  f000				  -	      lda	#32	; palette=0*29 | 32-(width=3)
    307  f000				  -	      sbc	ranklabellengths,x
    308  f000				  -	      sta	temp3	; palette/width
    309  f000				  -	      sec
    310  f000				  -	      lda	#(40+6)
    311  f000				  -	      sbc	ranklabellengths,x
    312  f000				  -	      asl
    313  f000				  -	      sta	temp4	; X
    314  f000				  -	      lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    315  f000				  -	      sta	temp5	; Y
    316  f000				  -	      jsr	plotcharacters
    317  f000				  -
    318  f000				  -	      ldx	hsnewscorerank
    319  f000				  -
    320  f000				  -	      lda	#<highscoreranklabel
    321  f000				  -	      sta	temp1
    322  f000				  -	      lda	#>highscoreranklabel
    323  f000				  -	      sta	temp2
    324  f000				  -
    325  f000				  -	      lda	#(32-5)	; palette=0*29 | 32-(width=3)
    326  f000				  -	      sta	temp3	; palette/width
    327  f000				  -	      lda	#(40-6)
    328  f000				  -	      sec
    329  f000				  -	      sbc	ranklabellengths,x
    330  f000				  -	      asl
    331  f000				  -	      sta	temp4	; X
    332  f000				  -	      lda	#((HSSCOREY+20)/(WZONEHEIGHT/8))
    333  f000				  -	      sta	temp5	; Y
    334  f000				  -	      jsr	plotcharacters
    335  f000				  -	      endif		; HSGAMERANKS
    336  f000				  -
    337  f000				  -
    338  f000				  -			; ** which line did this player beat?
    339  f000				  -	      lda	#$ff
    340  f000				  -	      sta	hsnewscoreline
    341  f000				  -	      ldx	#$fd
    342  f000				  -comparescoreadd2x
    343  f000				  -	      inx
    344  f000				  -comparescoreadd1x
    345  f000				  -	      inx
    346  f000				  -comparescore2lineloop
    347  f000				  -	      inc	hsnewscoreline
    348  f000				  -	      inx		; initialrun, x=0
    349  f000				  -	      cpx	#15
    350  f000				  -	      beq	nohighscoreforyou
    351  f000				  -	      ldy	#0
    352  f000				  -	      lda	HSRAMScores,x
    353  f000				  -	      cmp	(temp7),y	; first score digit
    354  f000				  -	      bcc	score2lineloopdonedel1x
    355  f000				  -	      bne	comparescoreadd2x
    356  f000				  -	      iny
    357  f000				  -	      inx
    358  f000				  -	      lda	HSRAMScores,x
    359  f000				  -	      cmp	(temp7),y
    360  f000				  -	      bcc	score2lineloopdonedel2x
    361  f000				  -	      bne	comparescoreadd1x
    362  f000				  -	      iny
    363  f000				  -	      inx
    364  f000				  -	      lda	(temp7),y
    365  f000				  -	      cmp	HSRAMScores,x
    366  f000				  -	      bcs	score2lineloopdonedel3x
    367  f000				  -	      jmp	comparescore2lineloop
    368  f000				  -nohighscoreforyou
    369  f000				  -	      lda	#$ff
    370  f000				  -	      sta	hsnewscoreline
    371  f000				  -	      sta	countdownseconds
    372  f000				  -	      jmp	donoscoreevaluation
    373  f000				  -score2lineloopdonedel3x
    374  f000				  -	      dex
    375  f000				  -score2lineloopdonedel2x
    376  f000				  -	      dex
    377  f000				  -score2lineloopdonedel1x
    378  f000				  -	      dex
    379  f000				  -
    380  f000				  -			; 0 1 2
    381  f000				  -			; 3 4 5
    382  f000				  -			; 6 7 8
    383  f000				  -			; 9 0 1
    384  f000				  -			; 2 3 4
    385  f000				  -
    386  f000				  -	      stx	temp9
    387  f000				  -	      cpx	#11
    388  f000				  -	      beq	postsortscoresuploop
    389  f000				  -	      ldx	#11
    390  f000				  -sortscoresuploop
    391  f000				  -	      lda	HSRAMScores,x
    392  f000				  -	      sta	HSRAMScores+3,x
    393  f000				  -	      lda	HSRAMInitials,x
    394  f000				  -	      sta	HSRAMInitials+3,x
    395  f000				  -	      dex
    396  f000				  -	      cpx	temp9
    397  f000				  -	      bne	sortscoresuploop
    398  f000				  -postsortscoresuploop
    399  f000				  -
    400  f000				  -			;stick the score and cleared initials in the slot...
    401  f000				  -	      inx
    402  f000				  -	      ldy	#0
    403  f000				  -	      sty	hsinitialhold
    404  f000				  -	      lda	(temp7),y
    405  f000				  -	      sta	HSRAMScores,x
    406  f000				  -	      iny
    407  f000				  -	      lda	(temp7),y
    408  f000				  -	      sta	HSRAMScores+1,x
    409  f000				  -	      iny
    410  f000				  -	      lda	(temp7),y
    411  f000				  -	      sta	HSRAMScores+2,x
    412  f000				  -	      lda	#0
    413  f000				  -	      sta	HSRAMInitials,x
    414  f000				  -	      lda	#29
    415  f000				  -	      sta	HSRAMInitials+1,x
    416  f000				  -	      sta	HSRAMInitials+2,x
    417  f000				  -
    418  f000				  -	      stx	hsinitialpos
    419  f000				  -
    420  f000				  -	      ifconst	vox_highscore
    421  f000				  -	      lda	<#vox_highscore
    422  f000				  -	      sta	speech_addr
    423  f000				  -	      lda	>#vox_highscore
    424  f000				  -	      sta	speech_addr+1
    425  f000				  -	      endif		; vox_highscore
    426  f000				  -	      ifconst	sfx_highscore
    427  f000				  -	      lda	<#sfx_highscore
    428  f000				  -	      sta	temp1
    429  f000				  -	      lda	>#sfx_highscore
    430  f000				  -	      sta	temp2
    431  f000				  -	      lda	#0
    432  f000				  -	      sta	temp3
    433  f000				  -	      jsr	schedulesfx
    434  f000				  -	      endif		; sfx_highscore
    435  f000				  -	      ifconst	songdatastart_song_highscore
    436  f000				  -	      lda	#<songchanneltable_song_highscore
    437  f000				  -	      sta	songpointerlo
    438  f000				  -	      lda	#>songchanneltable_song_highscore
    439  f000				  -	      sta	songpointerhi
    440  f000				  -	      lda	#73
    441  f000				  -	      sta	songtempo
    442  f000				  -	      jsr	setsongchannels
    443  f000				  -	      endif		; songdatastart_song_highscore
    444  f000				  -
    445  f000				  -
    446  f000				  -donoscoreevaluation
    447  f000				  -
    448  f000				  -	      lda	#(32+(32-SCORESIZE))	; palette=0*32 | 32-(width=6)
    449  f000				  -	      sta	temp3	; palette/width
    450  f000				  -	      lda	#(72+(4*(6-SCORESIZE)))
    451  f000				  -	      sta	temp4	; X
    452  f000				  -	      lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    453  f000				  -	      sta	temp5	; Y
    454  f000				  -	      lda	#<HSRAMScores
    455  f000				  -	      sta	temp7	; score variable lo
    456  f000				  -	      lda	#>HSRAMScores
    457  f000				  -	      sta	temp8	; score variable hi
    458  f000				  -	      lda	#(hiscorefont_mode | %01100000)	; charactermode
    459  f000				  -	      sta	temp9
    460  f000				  -plothsscoresloop
    461  f000				  -	      lda	#<(hiscorefont+33)	; +33 to get to '0' character
    462  f000				  -	      sta	temp1	; charmaplo
    463  f000				  -	      lda	#>(hiscorefont+33)
    464  f000				  -	      sta	temp2	; charmaphi
    465  f000				  -	      lda	#6
    466  f000				  -	      sta	temp6
    467  f000				  -	      ifnconst	DOUBLEWIDE
    468  f000				  -	      jsr	plotvalue
    469  f000				  -	      else
    470  f000				  -	      jsr	plotvaluedw
    471  f000				  -	      endif
    472  f000				  -	      clc
    473  f000				  -	      lda	temp3
    474  f000				  -	      adc	#32
    475  f000				  -	      sta	temp3
    476  f000				  -	      inc	temp5
    477  f000				  -	      if	WZONEHEIGHT = 8
    478  f000				  -	      inc	temp5
    479  f000				  -	      endif
    480  f000				  -	      clc
    481  f000				  -	      lda	#3
    482  f000				  -	      adc	temp7
    483  f000				  -	      sta	temp7
    484  f000				  -	      cmp	#(<(HSRAMScores+15))
    485  f000				  -	      bcc	plothsscoresloop
    486  f000				  -plothsindex
    487  f000				  -	      lda	#32+31	; palette=0*32 | 32-(width=1)
    488  f000				  -	      sta	temp3	; palette/width
    489  f000				  -	      lda	#44
    490  f000				  -	      sta	temp4	; X
    491  f000				  -	      lda	#((HSSCOREY+6)/(WZONEHEIGHT/8))
    492  f000				  -	      sta	temp5	; Y
    493  f000				  -	      lda	#<hsgameslotnumbers
    494  f000				  -	      sta	temp7	; score variable lo
    495  f000				  -	      lda	#>hsgameslotnumbers
    496  f000				  -	      sta	temp8	; score variable hi
    497  f000				  -	      lda	#(hiscorefont_mode | %01100000)	; charactermode
    498  f000				  -	      sta	temp9
    499  f000				  -plothsindexloop
    500  f000				  -	      lda	#<(hiscorefont+33)
    501  f000				  -	      sta	temp1	; charmaplo
    502  f000				  -	      lda	#>(hiscorefont+33)
    503  f000				  -	      sta	temp2	; charmaphi
    504  f000				  -	      lda	#1
    505  f000				  -	      sta	temp6	; number of characters
    506  f000				  -	      ifnconst	DOUBLEWIDE
    507  f000				  -	      jsr	plotvalue
    508  f000				  -	      else
    509  f000				  -	      jsr	plotvaluedw
    510  f000				  -	      endif
    511  f000				  -	      clc
    512  f000				  -	      lda	temp3
    513  f000				  -	      adc	#32
    514  f000				  -	      sta	temp3
    515  f000				  -	      inc	temp5
    516  f000				  -	      if	WZONEHEIGHT = 8
    517  f000				  -	      inc	temp5
    518  f000				  -	      endif
    519  f000				  -	      inc	temp7
    520  f000				  -	      lda	temp7
    521  f000				  -	      cmp	#(<(hsgameslotnumbers+5))
    522  f000				  -	      bcc	plothsindexloop
    523  f000				  -
    524  f000				  -	      jsr	savescreen
    525  f000				  -	      ifnconst	HSSECONDS
    526  f000				  -	      lda	#6
    527  f000				  -	      else
    528  f000				  -	      lda	#HSSECONDS
    529  f000				  -	      endif
    530  f000				  -
    531  f000				  -	      sta	countdownseconds
    532  f000				  -
    533  f000				  -keepdisplayinghs
    534  f000				  -	      jsr	restorescreen
    535  f000				  -
    536  f000				  -	      jsr	setuphsinpt1
    537  f000				  -
    538  f000				  -	      lda	hsnewscoreline
    539  f000				  -	      bpl	carryonkeepdisplayinghs
    540  f000				  -	      jmp	skipenterscorecontrol
    541  f000				  -carryonkeepdisplayinghs
    542  f000				  -
    543  f000				  -
    544  f000				  -	      ifnconst	HSSECONDS
    545  f000				  -	      lda	#6
    546  f000				  -	      else
    547  f000				  -	      lda	#HSSECONDS
    548  f000				  -	      endif
    549  f000				  -
    550  f000				  -	      sta	countdownseconds
    551  f000				  -
    552  f000				  -			;plot the "cursor" initial sprite...
    553  f000				  -	      lda	hsinitialhold
    554  f000				  -
    555  f000				  -	      sta	temp1
    556  f000				  -	      lda	#>(hiscorefont+32)
    557  f000				  -	      sta	temp2
    558  f000				  -	      lda	#31	; palette=0*32 | 32-(width=1)
    559  f000				  -	      sta	temp3	; palette/width
    560  f000				  -	      lda	hscursorx
    561  f000				  -	      asl
    562  f000				  -	      asl
    563  f000				  -	      clc
    564  f000				  -	      adc	#104
    565  f000				  -	      sta	temp4	; X
    566  f000				  -	      lda	hsnewscoreline
    567  f000				  -	      asl
    568  f000				  -	      asl
    569  f000				  -	      asl
    570  f000				  -	      asl
    571  f000				  -	      adc	#((3*16)+HSCURSORY)
    572  f000				  -	      sta	temp5	; Y
    573  f000				  -	      lda	#%01000000
    574  f000				  -	      sta	temp6
    575  f000				  -	      jsr	plotsprite
    576  f000				  -
    577  f000				  -	      ldx	hscursorx
    578  f000				  -	      ldy	hsdisplaymode
    579  f000				  -	      ifnconst	.HSup
    580  f000				  -	      lda	sSWCHA
    581  f000				  -	      cpy	#3
    582  f000				  -	      bne	hsskipadjustjoystick1
    583  f000				  -	      asl
    584  f000				  -	      asl
    585  f000				  -	      asl
    586  f000				  -	      asl
    587  f000				  -hsskipadjustjoystick1
    588  f000				  -	      sta	hsswcha
    589  f000				  -	      else		; there are user-defined routines!
    590  f000				  -	      jsr	.HSdown
    591  f000				  -	      lda	hsreturn	; b0
    592  f000				  -	      asl
    593  f000				  -	      pha
    594  f000				  -	      jsr	.HSup
    595  f000				  -	      pla
    596  f000				  -	      ora	hsreturn
    597  f000				  -	      asl
    598  f000				  -	      asl
    599  f000				  -	      asl
    600  f000				  -	      asl
    601  f000				  -	      eor	#$FF
    602  f000				  -	      sta	hsswcha
    603  f000				  -	      endif		; .HSup
    604  f000				  -	      lda	SWCHB
    605  f000				  -	      and	#%00000010
    606  f000				  -	      bne	hsskipselectswitch
    607  f000				  -	      lda	#%00010000
    608  f000				  -	      sta	hsswcha
    609  f000				  -	      bne	hsdodebouncecheck
    610  f000				  -hsskipselectswitch
    611  f000				  -	      lda	hsswcha
    612  f000				  -	      and	#%00110000
    613  f000				  -	      cmp	#%00110000
    614  f000				  -	      beq	hsjoystickskipped
    615  f000				  -hsdodebouncecheck
    616  f000				  -	      lda	hsjoydebounce
    617  f000				  -	      beq	hsdontdebounce
    618  f000				  -	      jmp	hspostjoystick
    619  f000				  -hsdontdebounce
    620  f000				  -	      ldx	#1	; small tick sound
    621  f000				  -	      jsr	playhssfx
    622  f000				  -	      lda	hsswcha
    623  f000				  -	      and	#%00110000
    624  f000				  -	      ldx	hscursorx
    625  f000				  -	      cmp	#%00100000	; check down
    626  f000				  -	      bne	hsjoycheckup
    627  f000				  -	      ldy	hsinitialhold
    628  f000				  -	      cpx	#0
    629  f000				  -	      bne	skipavoid31_1
    630  f000				  -	      cpy	#0	; if we're about to change to the <- char (#31) then double-decrement to skip over it
    631  f000				  -	      bne	skipavoid31_1
    632  f000				  -	      dey
    633  f000				  -skipavoid31_1
    634  f000				  -	      dey
    635  f000				  -	      jmp	hssetdebounce
    636  f000				  -hsjoycheckup
    637  f000				  -	      cmp	#%00010000	; check up
    638  f000				  -	      bne	hsjoystickskipped
    639  f000				  -	      ldy	hsinitialhold
    640  f000				  -	      cpx	#0
    641  f000				  -	      bne	skipavoid31_2
    642  f000				  -	      cpy	#30	; if we're about to change to the <- char (#31) then double-increment to skip over it
    643  f000				  -	      bne	skipavoid31_2
    644  f000				  -	      iny
    645  f000				  -skipavoid31_2
    646  f000				  -	      iny
    647  f000				  -hssetdebounce
    648  f000				  -	      tya
    649  f000				  -	      and	#31
    650  f000				  -	      sta	hsinitialhold
    651  f000				  -	      lda	#15
    652  f000				  -	      sta	hsjoydebounce
    653  f000				  -	      bne	hspostjoystick
    654  f000				  -hsjoystickskipped
    655  f000				  -			; check the fire button only when the stick isn't engaged
    656  f000				  -	      lda	hsinpt1
    657  f000				  -	      bpl	hsbuttonskipped
    658  f000				  -	      lda	hsjoydebounce
    659  f000				  -	      bne	hspostjoystick
    660  f000				  -hsfiredontdebounce
    661  f000				  -	      lda	hsinitialhold
    662  f000				  -	      cmp	#31
    663  f000				  -	      beq	hsmovecursorback
    664  f000				  -	      inc	hscursorx
    665  f000				  -	      inc	hsinitialpos
    666  f000				  -	      lda	hscursorx
    667  f000				  -	      cmp	#3
    668  f000				  -	      bne	skiphsentryisdone
    669  f000				  -	      lda	#0
    670  f000				  -	      sta	framecounter
    671  f000				  -	      lda	#$ff
    672  f000				  -	      sta	hsnewscoreline
    673  f000				  -	      dec	hsinitialpos
    674  f000				  -	      bne	skiphsentryisdone
    675  f000				  -hsmovecursorback
    676  f000				  -	      lda	hscursorx
    677  f000				  -	      beq	skiphsmovecursorback
    678  f000				  -	      lda	#29
    679  f000				  -	      ldx	hsinitialpos
    680  f000				  -	      sta	HSRAMInitials,x
    681  f000				  -	      dec	hsinitialpos
    682  f000				  -	      dec	hscursorx
    683  f000				  -	      dex
    684  f000				  -	      lda	HSRAMInitials,x
    685  f000				  -	      sta	hsinitialhold
    686  f000				  -skiphsmovecursorback
    687  f000				  -skiphsentryisdone
    688  f000				  -	      ldx	#0
    689  f000				  -	      jsr	playhssfx
    690  f000				  -	      lda	#20
    691  f000				  -	      sta	hsjoydebounce
    692  f000				  -	      bne	hspostjoystick
    693  f000				  -
    694  f000				  -hsbuttonskipped
    695  f000				  -	      lda	#0
    696  f000				  -	      sta	hsjoydebounce
    697  f000				  -hspostjoystick
    698  f000				  -
    699  f000				  -	      ldx	hsinitialpos
    700  f000				  -	      lda	hsinitialhold
    701  f000				  -	      sta	HSRAMInitials,x
    702  f000				  -
    703  f000				  -	      jmp	skiphschasecolors
    704  f000				  -
    705  f000				  -skipenterscorecontrol
    706  f000				  -	      jsr	hschasecolors
    707  f000				  -	      jsr	setuphsinpt1
    708  f000				  -	      lda	hsjoydebounce
    709  f000				  -	      bne	skiphschasecolors
    710  f000				  -	      lda	hsinpt1
    711  f000				  -	      bmi	returnfromhs
    712  f000				  -skiphschasecolors
    713  f000				  -
    714  f000				  -	      jsr	drawscreen
    715  f000				  -
    716  f000				  -	      lda	countdownseconds
    717  f000				  -	      beq	returnfromhs
    718  f000				  -	      jmp	keepdisplayinghs
    719  f000				  -returnfromhs
    720  f000				  -
    721  f000				  -	      ifconst	songdatastart_song_highscore
    722  f000				  -	      lda	hsdisplaymode
    723  f000				  -	      beq	skipclearHSCsong
    724  f000				  -	      lda	#0
    725  f000				  -	      sta	songtempo
    726  f000				  -skipclearHSCsong
    727  f000				  -	      endif
    728  f000				  -	      jsr	drawwait
    729  f000				  -	      jsr	clearscreen
    730  f000				  -	      lda	#0
    731  f000				  -	      ldy	#7
    732  f000				  -	      jsr	blacken320colors
    733  f000				  -			;lda ssCHARBASE
    734  f000				  -	      pla
    735  f000				  -	      sta	sCHARBASE
    736  f000				  -			;lda ssCTRL
    737  f000				  -	      pla
    738  f000				  -	      sta	sCTRL
    739  f000				  -	      rts
    740  f000				  -
    741  f000				  -setuphsinpt1
    742  f000				  -	      lda	#$ff
    743  f000				  -	      sta	hsinpt1
    744  f000				  -	      lda	hsjoydebounce
    745  f000				  -	      beq	skipdebounceadjust
    746  f000				  -	      dec	hsjoydebounce
    747  f000				  -	      bne	skipstorefirebuttonstatus
    748  f000				  -skipdebounceadjust
    749  f000				  -	      lda	SWCHB
    750  f000				  -	      and	#%00000001
    751  f000				  -	      bne	hscheckresetover
    752  f000				  -	      lda	#$ff
    753  f000				  -	      sta	hsinpt1
    754  f000				  -	      rts
    755  f000				  -hscheckresetover
    756  f000				  -	      ifnconst	.HSselect
    757  f000				  -	      ldx	hsdisplaymode
    758  f000				  -	      cpx	#3
    759  f000				  -	      bne	hsskipadjustjoyfire1
    760  f000				  -	      lda	sINPT3
    761  f000				  -	      jmp	hsskipadjustjoyfire1done
    762  f000				  -hsskipadjustjoyfire1
    763  f000				  -	      lda	sINPT1
    764  f000				  -hsskipadjustjoyfire1done
    765  f000				  -	      sta	hsinpt1
    766  f000				  -	      else		; there are user-defined routines!
    767  f000				  -	      jsr	.HSselect
    768  f000				  -	      lda	hsreturn
    769  f000				  -	      ror		; carry
    770  f000				  -	      ror		; b7
    771  f000				  -	      sta	hsinpt1
    772  f000				  -	      endif		; .HSselect
    773  f000				  -skipstorefirebuttonstatus
    774  f000				  -	      rts
    775  f000				  -
    776  f000				  -blacken320colors
    777  f000				  -	      ldy	#7
    778  f000				  -blacken320colorsloop
    779  f000				  -	      sta	P0C2,y
    780  f000				  -	      dey
    781  f000				  -	      bpl	blacken320colorsloop
    782  f000				  -	      rts
    783  f000				  -
    784  f000				  -hschasecolors
    785  f000				  -	      lda	framecounter
    786  f000				  -	      and	#3
    787  f000				  -	      bne	hschasecolorsreturn
    788  f000				  -	      inc	hscolorchaseindex
    789  f000				  -	      lda	hscolorchaseindex
    790  f000				  -
    791  f000				  -	      sta	P5C2
    792  f000				  -	      sbc	#$02
    793  f000				  -	      sta	P4C2
    794  f000				  -	      sbc	#$02
    795  f000				  -	      sta	P3C2
    796  f000				  -	      sbc	#$02
    797  f000				  -	      sta	P2C2
    798  f000				  -	      sbc	#$02
    799  f000				  -	      sta	P1C2
    800  f000				  -hschasecolorsreturn
    801  f000				  -	      rts
    802  f000				  -
    803  f000				  -playhssfx
    804  f000				  -	      lda	hssfx_lo,x
    805  f000				  -	      sta	temp1
    806  f000				  -	      lda	hssfx_hi,x
    807  f000				  -	      sta	temp2
    808  f000				  -	      lda	#0
    809  f000				  -	      sta	temp3
    810  f000				  -	      jmp	schedulesfx
    811  f000				  -
    812  f000				  -hssfx_lo
    813  f000				  -	      .byte	<sfx_hsletterpositionchange, <sfx_hslettertick
    814  f000				  -hssfx_hi
    815  f000				  -	      .byte	>sfx_hsletterpositionchange, >sfx_hslettertick
    816  f000				  -
    817  f000				  -sfx_hsletterpositionchange
    818  f000				  -	      .byte	$10,$18,$00
    819  f000				  -	      .byte	$02,$06,$08
    820  f000				  -	      .byte	$02,$06,$04
    821  f000				  -	      .byte	$00,$00,$00
    822  f000				  -sfx_hslettertick
    823  f000				  -	      .byte	$10,$18,$00
    824  f000				  -	      .byte	$00,$00,$0a
    825  f000				  -	      .byte	$00,$00,$00
    826  f000				  -
    827  f000				  -highscorelabeladjust1
    828  f000				  -	      .byte	(80-(14*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2)),(80-(16*2)-(SCORESIZE*2))
    829  f000				  -highscorelabeladjust2
    830  f000				  -	      .byte	(80+(14*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2)),(80+(16*2)-(SCORESIZE*2))
    831  f000				  -
    832  f000				  -scorevarlo
    833  f000				  -	      .byte	<(score0+((6-SCORESIZE)/2)),<(score0+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2)),<(score1+((6-SCORESIZE)/2))
    834  f000				  -scorevarhi
    835  f000				  -	      .byte	>(score0+((6-SCORESIZE)/2)),>(score0+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2)),>(score1+((6-SCORESIZE)/2))
    836  f000				  -
    837  f000				  -	      endif		; !isBANKSETBANK
    838  f000				  -
    839  f000				  -	      ifnconst	HSNOLEVELNAMES
    840  f000				  -	      ifnconst	isBANKSETBANK
    841  f000				  -highscoredifficultytextlo
    842  f000				  -	      .byte	<easylevelname, <mediumlevelname, <hardlevelname, <expertlevelname
    843  f000				  -highscoredifficultytexthi
    844  f000				  -	      .byte	>easylevelname, >mediumlevelname, >hardlevelname, >expertlevelname
    845  f000				  -	      endif		; !isBANKSETBANK
    846  f000				  -
    847  f000				  -	      ifnconst	HSCUSTOMLEVELNAMES
    848  f000				  -	      ifnconst	isBANKSETBANK
    849  f000				  -highscoredifficultytextlen
    850  f000				  -	      .byte	22, 30, 26, 24
    851  f000				  -	      endif		; !isBANKSETBANK
    852  f000				  -
    853  f000				  -	      ifconst	HSCHARSHERE
    854  f000				  -
    855  f000				  -easylevelname
    856  f000				  -	      .byte	$04,$00,$12,$18,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    857  f000				  -mediumlevelname
    858  f000				  -	      .byte	$08,$0d,$13,$04,$11,$0c,$04,$03,$08,$00,$13,$04,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    859  f000				  -hardlevelname
    860  f000				  -	      .byte	$00,$03,$15,$00,$0d,$02,$04,$03,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    861  f000				  -expertlevelname
    862  f000				  -	      .byte	$04,$17,$0f,$04,$11,$13,$1d,$0b,$04,$15,$04,$0b,$1d,$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    863  f000				  -	      endif		; HSCHARSHERE
    864  f000				  -	      else		; HSCUSTOMLEVELNAMES
    865  f000				  -	      include	"7800hsgamediffnames.asm"
    866  f000				  -	      endif		; HSCUSTOMLEVELNAMES
    867  f000				  -	      else		; HSNOLEVELNAMES
    868  f000				  -	      ifconst	HSCHARSHERE
    869  f000				  -HSHIGHSCOREStext
    870  f000				  -	      .byte	$07,$08,$06,$07,$1d,$12,$02,$0e,$11,$04,$12
    871  f000				  -	      endif		; HSCHARSHERE
    872  f000				  -	      endif		; HSNOLEVELNAMES
    873  f000				  -
    874  f000				  -	      ifnconst	isBANKSETBANK
    875  f000				  -highscorelabeltextlo
    876  f000				  -	      .byte	<player0label, <player1label, <player2label, <player2label
    877  f000				  -highscorelabeltexthi
    878  f000				  -	      .byte	>player0label, >player1label, >player2label, >player2label
    879  f000				  -	      endif		; !isBANKSETBANK
    880  f000				  -
    881  f000				  -	      ifconst	HSCHARSHERE
    882  f000				  -player0label
    883  f000				  -	      .byte	$0f,$0b,$00,$18,$04,$11,$1d,$12,$02,$0e,$11,$04,$1a,$1d,$1d
    884  f000				  -
    885  f000				  -player1label
    886  f000				  -	      .byte	$0f,$0b,$00,$18,$04,$11,$1d,$22,$1d,$12,$02,$0e,$11,$04,$1a
    887  f000				  -
    888  f000				  -player2label
    889  f000				  -	      .byte	$0f,$0b,$00,$18,$04,$11,$1d,$23,$1d,$12,$02,$0e,$11,$04,$1a
    890  f000				  -	      endif		; HSCHARSHERE
    891  f000				  -
    892  f000				  -
    893  f000				  -	      ifconst	HSGAMENAMELEN
    894  f000				  -	      ifconst	HSCHARSHERE
    895  f000				  -HSGAMENAMEtable
    896  f000				  -	      include	"7800hsgamename.asm"
    897  f000				  -	      endif		; HSCHARSHERE
    898  f000				  -	      endif		; HSGAMENAMELEN
    899  f000				  -	      ifconst	HSGAMERANKS
    900  f000				  -	      include	"7800hsgameranks.asm"
    901  f000				  -	      ifconst	HSCHARSHERE
    902  f000				  -highscoreranklabel
    903  f000				  -	      .byte	$11,$00,$0d,$0a,$1a
    904  f000				  -	      endif		; HSCHARSHERE
    905  f000				  -	      endif		; HSGAMERANKS
    906  f000				  -
    907  f000				  -			;ensure our table doesn't wrap a page...
    908  f000				  -	      if	((<*)>251)
    909  f000				  -	      align	256
    910  f000				  -	      endif
    911  f000				  -hsgameslotnumbers
    912  f000				  -	      .byte	33,34,35,36,37
    913  f000				  -	      endif		; hiscorefont
    914  f000				  -
    915  f000				  -
    916  f000				  -	      ifnconst	isBANKSETBANK
    917  f000				  -loaddifficultytable
    918  f000				  -	      lda	gamedifficulty
    919  f000				  -	      and	#$03	; ensure the user hasn't selected an invalid difficulty
    920  f000				  -	      sta	gamedifficulty
    921  f000				  -	      cmp	hsdifficulty	; check game difficulty is the same as RAM table
    922  f000				  -	      bne	loaddifficultytablecontinue1
    923  f000				  -	      rts		; this high score difficulty table is already loaded
    924  f000				  -loaddifficultytablecontinue1
    925  f000				  -	      lda	gamedifficulty
    926  f000				  -	      sta	hsdifficulty
    927  f000				  -			;we need to check the device for the table
    928  f000				  -	      lda	hsdevice
    929  f000				  -	      bne	loaddifficultytablecontinue2
    930  f000				  -			; there's no save device. clear out this table.
    931  f000				  -	      jmp	cleardifficultytablemem
    932  f000				  -loaddifficultytablecontinue2
    933  f000				  -	      lda	hsdevice
    934  f000				  -	      and	#1
    935  f000				  -	      beq	memdeviceisntHSC
    936  f000				  -	      jmp	loaddifficultytableHSC
    937  f000				  -memdeviceisntHSC
    938  f000				  -	      jmp	loaddifficultytableAVOX
    939  f000				  -
    940  f000				  -savedifficultytable
    941  f000				  -			;*** we need to check which device we should use...
    942  f000				  -	      lda	hsdevice
    943  f000				  -	      bne	savedifficultytablerealdevice
    944  f000				  -	      rts		; its a ram device
    945  f000				  -savedifficultytablerealdevice
    946  f000				  -	      and	#1
    947  f000				  -	      beq	savememdeviceisntHSC
    948  f000				  -	      jmp	savedifficultytableHSC
    949  f000				  -savememdeviceisntHSC
    950  f000				  -	      jmp	savedifficultytableAVOX
    951  f000				  -
    952  f000				  -savedifficultytableAVOX
    953  f000				  -			; the load call already setup the memory structure and atarivox memory location
    954  f000				  -	      jsr	savealoadedHSCtablecontinue
    955  f000				  -savedifficultytableAVOXskipconvert
    956  f000				  -	      lda	#HSIDHI
    957  f000				  -	      sta	eeprombuffer
    958  f000				  -	      lda	#HSIDLO
    959  f000				  -	      sta	eeprombuffer+1
    960  f000				  -	      lda	hsdifficulty
    961  f000				  -	      sta	eeprombuffer+2
    962  f000				  -	      lda	#32
    963  f000				  -	      jsr	AVoxWriteBytes
    964  f000				  -	      rts
    965  f000				  -
    966  f000				  -savedifficultytableHSC
    967  f000				  -			;we always load a table before reaching here, so the
    968  f000				  -			;memory structures from the load should be intact...
    969  f000				  -	      ldy	hsgameslot
    970  f000				  -	      bpl	savealoadedHSCtable
    971  f000				  -	      rts
    972  f000				  -savealoadedHSCtable
    973  f000				  -	      lda	HSCGameDifficulty,y
    974  f000				  -	      cmp	#$7F
    975  f000				  -	      bne	savealoadedHSCtablecontinue
    976  f000				  -	      jsr	initializeHSCtableentry
    977  f000				  -savealoadedHSCtablecontinue
    978  f000				  -			;convert our RAM table to HSC format and write it out...
    979  f000				  -	      ldy	#0
    980  f000				  -	      ldx	#0
    981  f000				  -savedifficultytableScores
    982  f000				  -
    983  f000				  -	      lda	HSRAMInitials,x
    984  f000				  -	      sta	temp3
    985  f000				  -	      lda	HSRAMInitials+1,x
    986  f000				  -	      sta	temp4
    987  f000				  -	      lda	HSRAMInitials+2,x
    988  f000				  -	      sta	temp5
    989  f000				  -	      jsr	encodeHSCInitials	; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
    990  f000				  -
    991  f000				  -	      lda	temp1
    992  f000				  -	      sta	(HSGameTableLo),y
    993  f000				  -	      iny
    994  f000				  -	      lda	temp2
    995  f000				  -	      sta	(HSGameTableLo),y
    996  f000				  -	      iny
    997  f000				  -
    998  f000				  -	      lda	HSRAMScores,x
    999  f000				  -	      sta	(HSGameTableLo),y
   1000  f000				  -	      iny
   1001  f000				  -	      lda	HSRAMScores+1,x
   1002  f000				  -	      sta	(HSGameTableLo),y
   1003  f000				  -	      iny
   1004  f000				  -	      lda	HSRAMScores+2,x
   1005  f000				  -	      sta	(HSGameTableLo),y
   1006  f000				  -	      iny
   1007  f000				  -	      inx
   1008  f000				  -	      inx
   1009  f000				  -	      inx		; +3
   1010  f000				  -	      cpx	#15
   1011  f000				  -	      bne	savedifficultytableScores
   1012  f000				  -	      rts
   1013  f000				  -
   1014  f000				  -loaddifficultytableHSC
   1015  f000				  -			; routine responsible for loading the difficulty table from HSC
   1016  f000				  -	      jsr	findindexHSC
   1017  f000				  -	      ldy	hsgameslot
   1018  f000				  -	      lda	HSCGameDifficulty,y
   1019  f000				  -	      cmp	#$7F
   1020  f000				  -	      bne	loaddifficultytableHSCcontinue
   1021  f000				  -			;there was an error. use a new RAM table instead...
   1022  f000				  -	      jsr	initializeHSCtableentry
   1023  f000				  -	      jmp	cleardifficultytablemem
   1024  f000				  -loaddifficultytableHSCcontinue
   1025  f000				  -			; parse the data into the HS memory...
   1026  f000				  -	      ldy	#0
   1027  f000				  -	      ldx	#0
   1028  f000				  -loaddifficultytableScores
   1029  f000				  -	      lda	(HSGameTableLo),y
   1030  f000				  -	      sta	temp1
   1031  f000				  -	      iny
   1032  f000				  -	      lda	(HSGameTableLo),y
   1033  f000				  -	      sta	temp2
   1034  f000				  -	      jsr	decodeHSCInitials	; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
   1035  f000				  -	      iny
   1036  f000				  -	      lda	(HSGameTableLo),y
   1037  f000				  -	      sta	HSRAMScores,x
   1038  f000				  -	      lda	temp3
   1039  f000				  -	      sta	HSRAMInitials,x
   1040  f000				  -	      inx
   1041  f000				  -	      iny
   1042  f000				  -	      lda	(HSGameTableLo),y
   1043  f000				  -	      sta	HSRAMScores,x
   1044  f000				  -	      lda	temp4
   1045  f000				  -	      sta	HSRAMInitials,x
   1046  f000				  -	      inx
   1047  f000				  -	      iny
   1048  f000				  -	      lda	(HSGameTableLo),y
   1049  f000				  -	      sta	HSRAMScores,x
   1050  f000				  -	      lda	temp5
   1051  f000				  -	      sta	HSRAMInitials,x
   1052  f000				  -	      inx
   1053  f000				  -	      iny
   1054  f000				  -	      cpx	#15
   1055  f000				  -	      bne	loaddifficultytableScores
   1056  f000				  -	      ldx	#14
   1057  f000				  -	      lda	#$ff
   1058  f000				  -validatescoresloop
   1059  f000				  -	      and	HSRAMScores,x
   1060  f000				  -	      dex
   1061  f000				  -	      bpl	validatescoresloop
   1062  f000				  -	      cmp	#$ff
   1063  f000				  -	      bne	exitloaddifficultytableScores
   1064  f000				  -	      jmp	cleardifficultytablemem
   1065  f000				  -exitloaddifficultytableScores
   1066  f000				  -	      rts
   1067  f000				  -
   1068  f000				  -decodeHSCInitials
   1069  f000				  -			; takes 2 byte initials from temp1,2 and stores 3 byte initials in temp3,4,5
   1070  f000				  -			; 2 bytes are packed in the form: 22211111 22_33333
   1071  f000				  -	      lda	#0
   1072  f000				  -	      sta	temp4
   1073  f000				  -	      lda	temp1
   1074  f000				  -	      and	#%00011111
   1075  f000				  -	      sta	temp3
   1076  f000				  -
   1077  f000				  -	      lda	temp2
   1078  f000				  -	      and	#%00011111
   1079  f000				  -	      sta	temp5
   1080  f000				  -
   1081  f000				  -	      lda	temp1
   1082  f000				  -	      asl
   1083  f000				  -	      rol	temp4
   1084  f000				  -	      asl
   1085  f000				  -	      rol	temp4
   1086  f000				  -	      asl
   1087  f000				  -	      rol	temp4
   1088  f000				  -	      lda	temp2
   1089  f000				  -	      asl
   1090  f000				  -	      rol	temp4
   1091  f000				  -	      asl
   1092  f000				  -	      rol	temp4
   1093  f000				  -	      rts
   1094  f000				  -encodeHSCInitials
   1095  f000				  -			; takes 3 byte initials from temp3,4,5 and stores 2 byte initials in temp1,2
   1096  f000				  -			; 2 bytes are packed in the form: 22211111 22_33333
   1097  f000				  -			; start with packing temp1...
   1098  f000				  -	      lda	temp4
   1099  f000				  -	      and	#%00011100
   1100  f000				  -	      sta	temp1
   1101  f000				  -	      asl	temp1
   1102  f000				  -	      asl	temp1
   1103  f000				  -	      asl	temp1
   1104  f000				  -	      lda	temp3
   1105  f000				  -	      and	#%00011111
   1106  f000				  -	      ora	temp1
   1107  f000				  -	      sta	temp1
   1108  f000				  -			; ...temp1 is now packed, on to temp2...
   1109  f000				  -	      lda	temp5
   1110  f000				  -	      asl
   1111  f000				  -	      asl
   1112  f000				  -	      ror	temp4
   1113  f000				  -	      ror
   1114  f000				  -	      ror	temp4
   1115  f000				  -	      ror
   1116  f000				  -	      sta	temp2
   1117  f000				  -	      rts
   1118  f000				  -
   1119  f000				  -findindexHSCerror
   1120  f000				  -			;the HSC is stuffed. return the bad slot flag
   1121  f000				  -	      ldy	#$ff
   1122  f000				  -	      sty	hsgameslot
   1123  f000				  -	      rts
   1124  f000				  -
   1125  f000				  -findindexHSC
   1126  f000				  -HSCGameID1 =	$1029
   1127  f000				  -HSCGameID2 =	$106E
   1128  f000				  -HSCGameDifficulty =	$10B3
   1129  f000				  -HSCGameIndex =	$10F8
   1130  f000				  -			; routine responsible for finding the game index from HSC
   1131  f000				  -			; call with x=0 to create a new table if none exist, call with x=$ff to avoid creating new tables
   1132  f000				  -			; the HS loading routine will use x=$ff, the HS saving routine will use x=0
   1133  f000				  -	      ldy	#69	; start +1 to account for the dey
   1134  f000				  -findindexHSCloop
   1135  f000				  -	      dey
   1136  f000				  -	      bmi	findindexHSCerror
   1137  f000				  -	      lda	HSCGameDifficulty,y
   1138  f000				  -	      cmp	#$7F
   1139  f000				  -	      beq	findourindexHSC
   1140  f000				  -	      cmp	gamedifficulty
   1141  f000				  -	      bne	findindexHSCloop
   1142  f000				  -	      lda	HSCGameID1,y
   1143  f000				  -	      cmp	#HSIDHI
   1144  f000				  -	      bne	findindexHSCloop
   1145  f000				  -	      lda	HSCGameID2,y
   1146  f000				  -	      cmp	#HSIDLO
   1147  f000				  -	      bne	findindexHSCloop
   1148  f000				  -findourindexHSC
   1149  f000				  -			; if we're here we found our index in the table
   1150  f000				  -			; or we found the first empty one
   1151  f000				  -	      sty	hsgameslot
   1152  f000				  -	      jsr	setupHSCGamepointer	; setup the pointer to the HS Table for this game...
   1153  f000				  -	      rts
   1154  f000				  -
   1155  f000				  -
   1156  f000				  -initializeHSCtableentry
   1157  f000				  -	      ldy	hsgameslot
   1158  f000				  -			; we need to make a new entry...
   1159  f000				  -	      lda	#HSIDHI
   1160  f000				  -	      sta	HSCGameID1,y
   1161  f000				  -	      lda	#HSIDLO
   1162  f000				  -	      sta	HSCGameID2,y
   1163  f000				  -	      lda	gamedifficulty
   1164  f000				  -	      sta	HSCGameDifficulty,y
   1165  f000				  -	      ldx	#0
   1166  f000				  -fixHSDGameDifficultylistLoop
   1167  f000				  -	      inx
   1168  f000				  -	      txa
   1169  f000				  -	      sta	HSCGameIndex,y
   1170  f000				  -	      iny
   1171  f000				  -	      cpy	#69
   1172  f000				  -	      bne	fixHSDGameDifficultylistLoop
   1173  f000				  -	      rts
   1174  f000				  -
   1175  f000				  -setupHSCGamepointer
   1176  f000				  -			; this routines sets (HSGameTableLo) pointing to the game's HS table
   1177  f000				  -	      lda	#$17
   1178  f000				  -	      sta	HSGameTableHi
   1179  f000				  -	      lda	#$FA
   1180  f000				  -	      sta	HSGameTableLo
   1181  f000				  -setupHSCGamepointerLoop
   1182  f000				  -	      lda	HSGameTableLo
   1183  f000				  -	      sec
   1184  f000				  -	      sbc	#25
   1185  f000				  -	      sta	HSGameTableLo
   1186  f000				  -	      lda	HSGameTableHi
   1187  f000				  -	      sbc	#0
   1188  f000				  -	      sta	HSGameTableHi
   1189  f000				  -	      iny
   1190  f000				  -	      cpy	#69
   1191  f000				  -	      bne	setupHSCGamepointerLoop
   1192  f000				  -	      rts
   1193  f000				  -
   1194  f000				  -loaddifficultytableAVOX
   1195  f000				  -			; routine responsible for loading the difficulty table from Avox
   1196  f000				  -			; we reuse HSC routines to format data to/from our Avox RAM buffer...
   1197  f000				  -	      lda	#>(eeprombuffer+3)
   1198  f000				  -	      sta	HSGameTableHi
   1199  f000				  -	      lda	#<(eeprombuffer+3)
   1200  f000				  -	      sta	HSGameTableLo
   1201  f000				  -
   1202  f000				  -			; the start location in EEPROM, subtract 32...
   1203  f000				  -	      lda	#$5F
   1204  f000				  -	      sta	HSVoxHi
   1205  f000				  -	      lda	#$E0
   1206  f000				  -	      sta	HSVoxLo
   1207  f000				  -	      lda	#0
   1208  f000				  -	      sta	temp1
   1209  f000				  -loaddifficultytableAVOXloop
   1210  f000				  -	      inc	temp1
   1211  f000				  -	      beq	loaddifficultytableAVOXfull
   1212  f000				  -	      clc
   1213  f000				  -	      lda	HSVoxLo
   1214  f000				  -	      adc	#32
   1215  f000				  -	      sta	HSVoxLo
   1216  f000				  -	      lda	HSVoxHi
   1217  f000				  -	      adc	#0
   1218  f000				  -	      sta	HSVoxHi
   1219  f000				  -	      lda	#3
   1220  f000				  -	      jsr	AVoxReadBytes	; read in 3 bytes, ID1,ID2,Difficulty
   1221  f000				  -	      lda	eeprombuffer
   1222  f000				  -	      cmp	#$FF
   1223  f000				  -	      beq	loaddifficultytableAVOXempty
   1224  f000				  -	      cmp	#HSIDHI
   1225  f000				  -	      bne	loaddifficultytableAVOXloop
   1226  f000				  -	      lda	eeprombuffer+1
   1227  f000				  -	      cmp	#HSIDLO
   1228  f000				  -	      bne	loaddifficultytableAVOXloop
   1229  f000				  -	      lda	eeprombuffer+2
   1230  f000				  -	      cmp	gamedifficulty
   1231  f000				  -	      bne	loaddifficultytableAVOXloop
   1232  f000				  -loaddifficultytableAVOXdone
   1233  f000				  -	      lda	#32
   1234  f000				  -	      jsr	AVoxReadBytes
   1235  f000				  -	      jsr	loaddifficultytableHSCcontinue
   1236  f000				  -	      rts
   1237  f000				  -loaddifficultytableAVOXfull
   1238  f000				  -	      lda	#0
   1239  f000				  -	      sta	hsdevice	; looks like all 255 entries are taken... disable it.
   1240  f000				  -loaddifficultytableAVOXempty
   1241  f000				  -	      jmp	cleardifficultytablemem
   1242  f000				  -	      rts
   1243  f000				  -
   1244  f000				  -cleardifficultytablemem
   1245  f000				  -	      ldy	#29
   1246  f000				  -	      lda	#0
   1247  f000				  -cleardifficultytablememloop
   1248  f000				  -	      sta	HSRAMTable,y
   1249  f000				  -	      dey
   1250  f000				  -	      bpl	cleardifficultytablememloop
   1251  f000				  -	      rts
   1252  f000				  -hiscoremoduleend
   1253  f000				  -
   1254  f000				  -hiscorecleardlmem
   1255  f000				  -	      ldx	#(WZONECOUNT-1)
   1256  f000				  -hiscorecleardlmemloop1
   1257  f000				  -	      lda	DLPOINTL,x
   1258  f000				  -	      sta	dlpnt
   1259  f000				  -	      lda	DLPOINTH,x
   1260  f000				  -	      sta	dlpnt+1
   1261  f000				  -	      lda	#0
   1262  f000				  -	      ldy	#17
   1263  f000				  -hiscorecleardlmemloop2
   1264  f000				  -	      sta	(dlpnt),y
   1265  f000				  -	      dey
   1266  f000				  -	      bpl	hiscorecleardlmemloop2
   1267  f000				  -	      dex
   1268  f000				  -	      bpl	hiscorecleardlmemloop1
   1269  f000				  -	      rts
   1270  f000				  -
   1271  f000				  -	      ifconst	DOUBLEWIDE
   1272  f000				  -plotvaluedw
   1273  f000				  -plotdigitcount =	temp6
   1274  f000				  -	      lda	#0
   1275  f000				  -	      tay
   1276  f000				  -	      ldx	valbufend
   1277  f000				  -
   1278  f000				  -	      lda	plotdigitcount
   1279  f000				  -	      and	#1
   1280  f000				  -	      beq	pvnibble2chardw
   1281  f000				  -	      lda	#0
   1282  f000				  -	      sta	VALBUFFER,x	; just in case we skip this digit
   1283  f000				  -	      beq	pvnibble2char_skipnibbledw
   1284  f000				  -
   1285  f000				  -pvnibble2chardw
   1286  f000				  -			; high nibble...
   1287  f000				  -	      lda	(temp7),y
   1288  f000				  -	      and	#$f0
   1289  f000				  -	      lsr
   1290  f000				  -	      lsr
   1291  f000				  -	      lsr
   1292  f000				  -	      lsr
   1293  f000				  -
   1294  f000				  -	      clc
   1295  f000				  -	      adc	temp1	; add the offset to character graphics to our value
   1296  f000				  -	      sta	VALBUFFER,x
   1297  f000				  -	      inx
   1298  f000				  -	      dec	plotdigitcount
   1299  f000				  -pvnibble2char_skipnibbledw
   1300  f000				  -			; low nibble...
   1301  f000				  -	      lda	(temp7),y
   1302  f000				  -	      and	#$0f
   1303  f000				  -	      clc
   1304  f000				  -	      adc	temp1	; add the offset to character graphics to our value
   1305  f000				  -	      sta	VALBUFFER,x
   1306  f000				  -	      inx
   1307  f000				  -	      iny
   1308  f000				  -
   1309  f000				  -	      dec	plotdigitcount
   1310  f000				  -	      bne	pvnibble2chardw
   1311  f000				  -			;point to the start of our valuebuffer
   1312  f000				  -	      clc
   1313  f000				  -	      lda	#<VALBUFFER
   1314  f000				  -	      adc	valbufend
   1315  f000				  -	      sta	temp1
   1316  f000				  -	      lda	#>VALBUFFER
   1317  f000				  -	      adc	#0
   1318  f000				  -	      sta	temp2
   1319  f000				  -
   1320  f000				  -			;advance valbufend to the end of our value buffer
   1321  f000				  -	      stx	valbufend
   1322  f000				  -
   1323  f000				  -	      ifnconst	plotvalueonscreen
   1324  f000				  -	      jmp	plotcharacters
   1325  f000				  -	      else
   1326  f000				  -	      jmp	plotcharacterslive
   1327  f000				  -	      endif
   1328  f000				  -	      endif		; DOUBLEWIDE
   1329  f000				  -
   1330  f000				  -hiscoreend
   1331  f000				  -	      echo	" (hiscore module is using ",[(hiscoreend-hiscorestart)]d," bytes)"
   1332  f000				  -	      endif		; !isBANKSETBANK
   1333  f000					      endif		; HSSUPPORT
   1334  f000
------- FILE constants.78b.asm
   3223  f000					      endif
   3224  f000					      ifnconst	included.fourbitfade.asm
------- FILE fourbitfade.asm LEVEL 2 PASS 3
      0  f000					      include	fourbitfade.asm
      1  f000							; ** fourbit fade, which is useful for audio levels and brightness fades
      2  f000							; ** input:  A=value to fade, fourbitfadevalue=global fade value
      3  f000							; **	      N.B. the global fade value is in the upper nibble. i.e. $Fx-0x
      4  f000							; ** output: A=faded value in lo nibble. orig top nibble is preserved,
      5  f000							; **	      other registers are preserved
      6  f000
      7  f000				  -	      ifconst	FOURBITFADE
      8  f000				  -
      9  f000				  -			; non-interrupt routine
     10  f000				  -
     11  f000				  -fourbitfade
     12  f000				  -	      sty	fourbittemp1
     13  f000				  -	      pha
     14  f000				  -	      and	#$0F
     15  f000				  -	      ora	fourbitfadevalue
     16  f000				  -	      tay
     17  f000				  -	      pla
     18  f000				  -	      and	#$F0
     19  f000				  -	      ora	fourbitfadelut,y
     20  f000				  -	      ldy	fourbittemp1	; restore Y
     21  f000				  -	      rts
     22  f000				  -
     23  f000				  -			; interrupt routine
     24  f000				  -
     25  f000				  -fourbitfadeint
     26  f000				  -	      sty	fourbittemp1int
     27  f000				  -	      pha
     28  f000				  -	      and	#$0F
     29  f000				  -	      ora	fourbitfadevalueint
     30  f000				  -	      tay
     31  f000				  -	      pla
     32  f000				  -	      and	#$F0
     33  f000				  -	      ora	fourbitfadelut,y
     34  f000				  -	      ldy	fourbittemp1int	; restore Y
     35  f000				  -	      rts
     36  f000				  -
     37  f000				  -fourbitfadelut
     38  f000				  -	      .byte	$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
     39  f000				  -	      .byte	$00,$00,$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$01,$01,$01
     40  f000				  -	      .byte	$00,$00,$00,$00,$00,$00,$01,$01,$01,$01,$01,$02,$02,$02,$02,$02
     41  f000				  -	      .byte	$00,$00,$00,$00,$01,$01,$01,$01,$02,$02,$02,$02,$03,$03,$03,$03
     42  f000				  -	      .byte	$00,$00,$00,$00,$01,$01,$01,$02,$02,$02,$03,$03,$03,$04,$04,$04
     43  f000				  -	      .byte	$00,$00,$00,$01,$01,$01,$02,$02,$03,$03,$03,$04,$04,$04,$05,$05
     44  f000				  -	      .byte	$00,$00,$00,$01,$01,$02,$02,$03,$03,$03,$04,$04,$05,$05,$06,$06
     45  f000				  -	      .byte	$00,$00,$01,$01,$02,$02,$03,$03,$04,$04,$05,$05,$06,$06,$07,$07
     46  f000				  -	      .byte	$00,$00,$01,$01,$02,$02,$03,$03,$04,$05,$05,$06,$06,$07,$07,$08
     47  f000				  -	      .byte	$00,$00,$01,$01,$02,$03,$03,$04,$05,$05,$06,$06,$07,$08,$08,$09
     48  f000				  -	      .byte	$00,$00,$01,$02,$02,$03,$04,$04,$05,$06,$06,$07,$08,$08,$09,$0a
     49  f000				  -	      .byte	$00,$00,$01,$02,$03,$03,$04,$05,$06,$06,$07,$08,$09,$09,$0a,$0b
     50  f000				  -	      .byte	$00,$00,$01,$02,$03,$04,$04,$05,$06,$07,$08,$08,$09,$0a,$0b,$0c
     51  f000				  -	      .byte	$00,$00,$01,$02,$03,$04,$05,$06,$07,$07,$08,$09,$0a,$0b,$0c,$0d
     52  f000				  -	      .byte	$00,$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e
     53  f000				  -	      .byte	$00,$01,$02,$03,$04,$05,$06,$07,$08,$09,$0a,$0b,$0c,$0d,$0e,$0f
     54  f000				  -
     55  f000				  -fourbitfadeend
     56  f000				  -
     57  f000				  -	      echo	"  (fourbitfade module is using ",[(fourbitfadeend-fourbitfade)]d," bytes of rom)"
     58  f000				  -
     59  f000					      endif
------- FILE constants.78b.asm
   3226  f000					      endif
   3227  f000					      ifnconst	included.plotsprite4.asm
------- FILE plotsprite4.asm LEVEL 2 PASS 3
      0  f000					      include	plotsprite4.asm
      1  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  f000
      3  f000				  -	      ifconst	PLOTSP4
      4  f000				  -
      5  f000				  -plotsprite4
      6  f000				  -	      ifnconst	NODRAWWAIT
      7  f000				  -	      ifconst	DOUBLEBUFFER
      8  f000				  -	      lda	doublebufferstate
      9  f000				  -	      bne	skipplotsprite4wait
     10  f000				  -	      endif		; DOUBLEBUFFER
     11  f000				  -	      ifconst	DEBUGWAITCOLOR
     12  f000				  -	      lda	#$41
     13  f000				  -	      sta	BACKGRND
     14  f000				  -	      endif
     15  f000				  -plotsprite4wait
     16  f000				  -	      lda	visibleover
     17  f000				  -	      bne	plotsprite4wait
     18  f000				  -skipplotsprite4wait
     19  f000				  -	      ifconst	DEBUGWAITCOLOR
     20  f000				  -	      lda	#$0
     21  f000				  -	      sta	BACKGRND
     22  f000				  -	      endif
     23  f000				  -	      endif
     24  f000				  -
     25  f000				  -			;arguments:
     26  f000				  -			; temp1=lo graphicdata
     27  f000				  -			; temp2=hi graphicdata
     28  f000				  -			; temp3=palette | width byte
     29  f000				  -			; temp4=x
     30  f000				  -			; temp5=y
     31  f000				  -
     32  f000				  -	      lda	temp5	;Y position
     33  f000				  -	      lsr		; 2 - Divide by 8 or 16
     34  f000				  -	      lsr		; 2
     35  f000				  -	      lsr		; 2
     36  f000				  -	      if	WZONEHEIGHT = 16
     37  f000				  -	      lsr		; 2
     38  f000				  -	      endif
     39  f000				  -
     40  f000				  -	      tax
     41  f000				  -
     42  f000				  -	      ifnconst	NOLIMITCHECKING
     43  f000				  -
     44  f000				  -			; the next block allows for vertical masking, and ensures we don't overwrite non-DL memory
     45  f000				  -
     46  f000				  -	      cmp	#WZONECOUNT
     47  f000				  -
     48  f000				  -	      bcc	continueplotsprite41	; the sprite is fully on-screen, so carry on...
     49  f000				  -			; otherwise, check to see if the bottom half is in zone 0...
     50  f000				  -
     51  f000				  -	      if	WZONEHEIGHT = 16
     52  f000				  -	      cmp	#15
     53  f000				  -	      else
     54  f000				  -	      cmp	#31
     55  f000				  -	      endif
     56  f000				  -
     57  f000				  -	      bne	exitplotsprite41
     58  f000				  -	      ldx	#0
     59  f000				  -	      jmp	continueplotsprite42
     60  f000				  -exitplotsprite41
     61  f000				  -	      rts
     62  f000				  -	      endif
     63  f000				  -
     64  f000				  -continueplotsprite41
     65  f000				  -
     66  f000				  -	      ifconst	VSCROLL
     67  f000				  -	      ldy	Xx3,x
     68  f000				  -	      lda	DLLMEM+11,y
     69  f000				  -	      else		; !VSCROLL
     70  f000				  -	      lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
     71  f000				  -	      endif		; !VSCROLL
     72  f000				  -	      ifconst	DOUBLEBUFFER
     73  f000				  -	      clc
     74  f000				  -	      adc	doublebufferdloffset
     75  f000				  -	      endif		; DOUBLEBUFFER
     76  f000				  -	      sta	dlpnt
     77  f000				  -	      ifconst	VSCROLL
     78  f000				  -	      lda	DLLMEM+10,y
     79  f000				  -	      else		; !VSCROLL
     80  f000				  -	      lda	DLPOINTH,x
     81  f000				  -	      endif		; !VSCROLL
     82  f000				  -	      ifconst	DOUBLEBUFFER
     83  f000				  -	      adc	#0
     84  f000				  -	      endif		; DOUBLEBUFFER
     85  f000				  -	      sta	dlpnt+1
     86  f000				  -
     87  f000				  -			;Create DL entry for upper part of sprite
     88  f000				  -
     89  f000				  -	      ldy	dlend,x	;Get the index to the end of this DL
     90  f000				  -
     91  f000				  -	      ifconst	CHECKOVERWRITE
     92  f000				  -	      cpy	#DLLASTOBJ
     93  f000				  -	      beq	checkcontinueplotsprite42
     94  f000				  -continueplotsprite41a
     95  f000				  -	      endif
     96  f000				  -
     97  f000				  -	      lda	temp1	; graphic data, lo byte
     98  f000				  -	      sta	(dlpnt),y	;Low byte of data address
     99  f000				  -
    100  f000				  -	      iny
    101  f000				  -	      lda	temp3	;palette|width
    102  f000				  -	      sta	(dlpnt),y
    103  f000				  -
    104  f000				  -	      iny
    105  f000				  -	      lda	temp5	;Y position
    106  f000				  -	      and	#(WZONEHEIGHT - 1)
    107  f000				  -	      cmp	#1	; clear carry if our sprite is just in this zone
    108  f000				  -	      ora	temp2	; graphic data, hi byte
    109  f000				  -	      sta	(dlpnt),y
    110  f000				  -
    111  f000				  -	      iny
    112  f000				  -	      lda	temp4	;Horizontal position
    113  f000				  -	      sta	(dlpnt),y
    114  f000				  -
    115  f000				  -	      iny
    116  f000				  -	      sty	dlend,x
    117  f000				  -
    118  f000				  -	      ifconst	ALWAYSTERMINATE
    119  f000				  -	      iny
    120  f000				  -	      lda	#0
    121  f000				  -	      sta	(dlpnt),y
    122  f000				  -	      endif
    123  f000				  -
    124  f000				  -checkcontinueplotsprite42
    125  f000				  -
    126  f000				  -	      bcc	doneSPDL4	;branch if the sprite was fully in the last zone
    127  f000				  -
    128  f000				  -			;Create DL entry for lower part of sprite
    129  f000				  -
    130  f000				  -	      inx		;Next region
    131  f000				  -
    132  f000				  -	      ifnconst	NOLIMITCHECKING
    133  f000				  -	      cpx	#WZONECOUNT
    134  f000				  -
    135  f000				  -	      bcc	continueplotsprite42	; the second half of the sprite is fully on-screen, so carry on...
    136  f000				  -	      rts
    137  f000				  -continueplotsprite42
    138  f000				  -	      endif
    139  f000				  -
    140  f000				  -	      ifconst	VSCROLL
    141  f000				  -	      ldy	Xx3,x
    142  f000				  -	      lda	DLLMEM+11,y
    143  f000				  -	      else		; !VSCROLL
    144  f000				  -	      lda	DLPOINTL,x	;Get pointer to next DL
    145  f000				  -	      endif		; !VSCROLL
    146  f000				  -	      ifconst	DOUBLEBUFFER
    147  f000				  -	      clc
    148  f000				  -	      adc	doublebufferdloffset
    149  f000				  -	      endif		; DOUBLEBUFFER
    150  f000				  -	      sta	dlpnt
    151  f000				  -	      ifconst	VSCROLL
    152  f000				  -	      lda	DLLMEM+10,y
    153  f000				  -	      else		; !VSCROLL
    154  f000				  -	      lda	DLPOINTH,x
    155  f000				  -	      endif		; !VSCROLL
    156  f000				  -	      ifconst	DOUBLEBUFFER
    157  f000				  -	      adc	#0
    158  f000				  -	      endif		; DOUBLEBUFFER
    159  f000				  -	      sta	dlpnt+1
    160  f000				  -	      ldy	dlend,x	;Get the index to the end of this DL
    161  f000				  -
    162  f000				  -	      ifconst	CHECKOVERWRITE
    163  f000				  -	      cpy	#DLLASTOBJ
    164  f000				  -	      bne	continueplotsprite42a
    165  f000				  -	      rts
    166  f000				  -continueplotsprite42a
    167  f000				  -	      endif
    168  f000				  -
    169  f000				  -	      lda	temp1	; graphic data, lo byte
    170  f000				  -	      sta	(dlpnt),y
    171  f000				  -
    172  f000				  -	      iny
    173  f000				  -	      lda	temp3	;palette|width
    174  f000				  -	      sta	(dlpnt),y
    175  f000				  -
    176  f000				  -	      iny
    177  f000				  -	      lda	temp5	;Y position
    178  f000				  -	      anc	#(WZONEHEIGHT - 1)	; undocumented. A=A&IMM, then move bit 7 into carry
    179  f000				  -	      ora	temp2	; graphic data, hi byte
    180  f000				  -	      sbc	#(WZONEHEIGHT-1)	; start at the DMA hole. -1 because carry is clear
    181  f000				  -	      sta	(dlpnt),y
    182  f000				  -
    183  f000				  -	      iny
    184  f000				  -	      lda	temp4	;Horizontal position
    185  f000				  -	      sta	(dlpnt),y
    186  f000				  -
    187  f000				  -	      iny
    188  f000				  -	      sty	dlend,x
    189  f000				  -
    190  f000				  -	      ifconst	ALWAYSTERMINATE
    191  f000				  -	      iny
    192  f000				  -	      lda	#0
    193  f000				  -	      sta	(dlpnt),y
    194  f000				  -	      endif
    195  f000				  -
    196  f000				  -doneSPDL4
    197  f000				  -	      rts
    198  f000				  -
    199  f000					      endif		; PLOTSP4
------- FILE constants.78b.asm
   3229  f000					      endif
   3230  f000					      ifnconst	included.lzsa1compression.asm
------- FILE lzsa1compression.asm LEVEL 2 PASS 3
      0  f000					      include	lzsa1compression.asm
      1  f000							; ***************************************************************************
      2  f000							; ***************************************************************************
      3  f000							;
      4  f000							; lzsa1_6502.s
      5  f000							;
      6  f000							; NMOS 6502 decompressor for data stored in Emmanuel Marty's LZSA1 format.
      7  f000							;
      8  f000							; Decompresses a raw LZSA1 block, created with the command-line lzsa utility:
      9  f000							;     lzsa -r <original_file> <compressed_file>
     10  f000							;
     11  f000							; in:
     12  f000							; * LZSA_SRC_LO and LZSA_SRC_HI contain the compressed raw block address
     13  f000							; * LZSA_DST_LO and LZSA_DST_HI contain the destination buffer address
     14  f000							;
     15  f000							; out:
     16  f000							; * the destination buffer will contain the decompressed data
     17  f000							; * LZSA_DST_LO and LZSA_DST_HI contain the last decompressed byte address +1
     18  f000							;
     19  f000							; ***************************************************************************
     20  f000							;
     21  f000							; This code is written for the ACME assembler.
     22  f000							;
     23  f000							; The code is 165 bytes for the small version, and 191 bytes for the normal.
     24  f000							;
     25  f000							; Copyright John Brandwood 2021.
     26  f000							;
     27  f000							; Changes intruduced by Mike Saarna, 2023:
     28  f000							;    -converted to DASM format.
     29  f000							;    -generalised memory locations, for easier incorporation into 7800basic
     30  f000							;    -removed self-modifying code, for execution from rom.
     31  f000							;    -added LZSAFASTCOPYBYTE optimisation ; +24 bytes rom, ~10% quicker
     32  f000							;
     33  f000							; get the original unmodified code from:
     34  f000							; https://raw.githubusercontent.com/emmanuel-marty/lzsa
     35  f000							;
     36  f000							; Distributed under the Boost Software License, Version 1.0.
     37  f000							; (See accompanying file LICENSE_1_0.txt or copy at
     38  f000							; http://www.boost.org/LICENSE_1_0.txt)
     39  f000							;
     40  f000							; ***************************************************************************
     41  f000							; ***************************************************************************
     42  f000
     43  f000
     44  f000
     45  f000							; ***************************************************************************
     46  f000							; ***************************************************************************
     47  f000							;
     48  f000							; Decompression Options & Macros
     49  f000							;
     50  f000
     51  f000							;
     52  f000							; Choose size over decompression speed (within sane limits)?
     53  f000							;
     54  f000
     55  f000		       00 00	   LZSA_SMALL_SIZE =	0
     56  f000		       00 01	   LZSAFASTCOPYBYTE =	1	; +24 bytes rom, ~10% quicker
     57  f000
     58  f000							; ***************************************************************************
     59  f000							; ***************************************************************************
     60  f000							;
     61  f000							; ZP memory allocations... (temp1-temp9 are 7800basic ZP locations)
     62  f000		       00 42	   LSZA1ZPRAM =	temp1
     63  f000		       00 42	   lzsa_winptr =	LSZA1ZPRAM	; 1 word (temp1+temp2)
     64  f000		       00 44	   lzsa_srcptr =	LSZA1ZPRAM + 2	; 1 word (temp3+temp4)
     65  f000		       00 46	   lzsa_dstptr =	LSZA1ZPRAM + 4	; 1 word (temp5+temp6)
     66  f000
     67  f000							; Doesn't need to be ZP allocations...
     68  f000		       00 48	   LSZA1TEMPRAM =	temp7
     69  f000		       00 48	   lzsa_cmdbuf =	LSZA1TEMPRAM	; 1 byte (temp7)
     70  f000		       00 49	   lzsa_cp_npages =	LSZA1TEMPRAM + 1	; 1 byte (temp8)
     71  f000		       00 4a	   lzsa_lz_npages =	LSZA1TEMPRAM + 2	; 1 byte (temp9)
     72  f000
     73  f000							; Alternate names for previous allocations...
     74  f000		       00 42	   lzsa_offset =	lzsa_winptr
     75  f000		       00 44	   LZSA_SRC_LO =	lzsa_srcptr
     76  f000		       00 45	   LZSA_SRC_HI =	lzsa_srcptr+1
     77  f000		       00 46	   LZSA_DST_LO =	lzsa_dstptr
     78  f000		       00 47	   LZSA_DST_HI =	lzsa_dstptr+1
     79  f000
     80  f000				  -	      ifconst	lzsa1support
     81  f000				  -
     82  f000				  -lzsa1modulestart
     83  f000				  -
     84  f000				  -	      if	LZSAFASTCOPYBYTE = 1
     85  f000				  -.cp_fixpointer
     86  f000				  -			; the optimised pointer adjustment fails if .cp_byte copied a whole page.
     87  f000				  -			; so we deal with it as a special case here, out of the regular .cp_byte flow.
     88  f000				  -			; this only happens rarely.
     89  f000				  -	      inc	lzsa_srcptr+1	; CC
     90  f000				  -	      inc	lzsa_dstptr+1
     91  f000				  -	      bcc	.cp_skip3	; always taken
     92  f000				  -			; each of these happen infrequently (~1 in 256 byte copies)
     93  f000				  -.cp_fixsrc1
     94  f000				  -	      inc	lzsa_srcptr+1
     95  f000				  -	      clc
     96  f000				  -	      bcc	.cp_skip1
     97  f000				  -.cp_fixsrc2
     98  f000				  -	      inc	lzsa_dstptr+1
     99  f000				  -	      clc
    100  f000				  -	      bcc	.cp_skip2
    101  f000				  -	      endif
    102  f000				  -
    103  f000				  -			; ***************************************************************************
    104  f000				  -			; ***************************************************************************
    105  f000				  -			;
    106  f000				  -			; lzsa1_unpack - Decompress data stored in Emmanuel Marty's LZSA1 format.
    107  f000				  -			;
    108  f000				  -			; Args: lzsa_srcptr = ptr to compessed data
    109  f000				  -			; Args: lzsa_dstptr = ptr to output buffer
    110  f000				  -			;
    111  f000				  -
    112  f000				  -
    113  f000				  -DECOMPRESS_LZSA1_FAST
    114  f000				  -lzsa1_unpack
    115  f000				  -	      ldy	#0	; Initialize source index.
    116  f000				  -	      ldx	#0	; Initialize hi-byte of length.
    117  f000				  -	      stx	lzsa_cp_npages
    118  f000				  -	      stx	lzsa_lz_npages
    119  f000				  -
    120  f000				  -			;
    121  f000				  -			; Copy bytes from compressed source data.
    122  f000				  -			;
    123  f000				  -			; N.B. X=0 is expected and guaranteed when we get here.
    124  f000				  -			;
    125  f000				  -
    126  f000				  -.cp_length
    127  f000				  -	      if	LZSA_SMALL_SIZE = 1
    128  f000				  -
    129  f000				  -	      jsr	.get_byte
    130  f000				  -
    131  f000				  -	      else		; !LZSA_SMALL_SIZE
    132  f000				  -
    133  f000				  -	      lda	(lzsa_srcptr),y
    134  f000				  -	      inc	lzsa_srcptr+0
    135  f000				  -	      bne	.cp_skip0
    136  f000				  -	      inc	lzsa_srcptr+1
    137  f000				  -
    138  f000				  -	      endif		; !LZSA_SMALL_SIZE
    139  f000				  -
    140  f000				  -.cp_skip0
    141  f000				  -	      sta	lzsa_cmdbuf	; Preserve this for later.
    142  f000				  -	      and	#$70	; Extract literal length.
    143  f000				  -	      lsr		; Set CC before ...
    144  f000				  -	      beq	.lz_offset	; Skip directly to match?
    145  f000				  -
    146  f000				  -	      lsr		; Get 3-bit literal length.
    147  f000				  -	      lsr
    148  f000				  -	      lsr
    149  f000				  -	      cmp	#$07	; Extended length?
    150  f000				  -	      bcc	.cp_got_len
    151  f000				  -
    152  f000				  -	      jsr	.get_length	; X=0, CS from CMP, returns CC.
    153  f000				  -	      stx	lzsa_cp_npages	; Hi-byte of length.
    154  f000				  -
    155  f000				  -.cp_got_len
    156  f000				  -	      tax		; Lo-byte of length.
    157  f000				  -
    158  f000				  -	      if	LZSAFASTCOPYBYTE = 0
    159  f000				  -
    160  f000				  -.cp_byte		; CC throughout the execution of this .cp_page loop.
    161  f000				  -	      lda	(lzsa_srcptr),y	; 5
    162  f000				  -	      sta	(lzsa_dstptr),y	; 5
    163  f000				  -	      inc	lzsa_srcptr+0	; 5
    164  f000				  -	      bne	.cp_skip1	; 3
    165  f000				  -	      inc	lzsa_srcptr+1
    166  f000				  -.cp_skip1
    167  f000				  -	      inc	lzsa_dstptr+0	; 5
    168  f000				  -	      bne	.cp_skip2	; 3
    169  f000				  -	      inc	lzsa_dstptr+1
    170  f000				  -.cp_skip2
    171  f000				  -	      dex		; 2
    172  f000				  -	      bne	.cp_byte	; 3
    173  f000				  -			;  ~29 cycles overall for X=1
    174  f000				  -			;  ~58 cycles overall for X=2
    175  f000				  -			;  ~87 cycles overall for X=3
    176  f000				  -			; ...
    177  f000				  -			; ~174 cycles overall for X=6
    178  f000				  -
    179  f000				  -	      else		; LZSAFASTCOPYBYTE != 0
    180  f000				  -
    181  f000				  -			; according to 7800heat, this loop is hot. It runs on average ~6x.
    182  f000				  -
    183  f000				  -.cp_byte		; CC throughout the execution of this .cp_page loop.
    184  f000				  -	      lda	(lzsa_srcptr),y	; 5+
    185  f000				  -	      sta	(lzsa_dstptr),y	; 5+
    186  f000				  -	      iny		; 2
    187  f000				  -	      dex		; 2
    188  f000				  -	      bne	.cp_byte	; 3/2
    189  f000				  -			; ~17 cycles each iteration
    190  f000				  -	      tya		; 2
    191  f000				  -	      beq	.cp_fixpointer	; 2 unlikely branch - only if we copied a full page
    192  f000				  -	      adc	lzsa_srcptr+0	; 3
    193  f000				  -	      sta	lzsa_srcptr+0	; 3
    194  f000				  -	      bcs	.cp_fixsrc1	; 2 (typical)
    195  f000				  -.cp_skip1
    196  f000				  -	      tya		; 2
    197  f000				  -	      adc	lzsa_dstptr+0	; 3
    198  f000				  -	      sta	lzsa_dstptr+0	; 3
    199  f000				  -	      bcs	.cp_fixsrc2	; 2 (typical)
    200  f000				  -.cp_skip2
    201  f000				  -	      ldy	#0	; 2
    202  f000				  -.cp_skip3
    203  f000				  -			; ~24 cycles overhead, typical
    204  f000				  -
    205  f000				  -			; ~41	cycles for X=1 (+12  cycles vs non-optimized)
    206  f000				  -			; ~58	cycles for X=2 (  0  cycles vs non-optimized)
    207  f000				  -			; ~75	cycles for X=3 (-12  cycles vs non-optimized)
    208  f000				  -			; ...
    209  f000				  -			; ~126 cycles for X=6 (-48  cycles vs non-optimized)
    210  f000				  -	      endif		; ! LZSAFASTCOPYBYTE = 0
    211  f000				  -
    212  f000				  -.cp_npages
    213  f000				  -	      lda	lzsa_cp_npages	; Any full pages left to copy?
    214  f000				  -	      beq	.lz_offset
    215  f000				  -
    216  f000				  -	      dec	lzsa_cp_npages	; Unlikely, so can be slow.
    217  f000				  -	      bcc	.cp_byte	; Always true!
    218  f000				  -
    219  f000				  -	      if	LZSA_SMALL_SIZE = 1
    220  f000				  -
    221  f000				  -			; Copy bytes from decompressed window.
    222  f000				  -			;
    223  f000				  -			; Shorter but slower version.
    224  f000				  -			;
    225  f000				  -			; N.B. X=0 is expected and guaranteed when we get here.
    226  f000				  -			;
    227  f000				  -
    228  f000				  -.lz_offset
    229  f000				  -	      jsr	.get_byte	; Get offset-lo.
    230  f000				  -
    231  f000				  -.offset_lo
    232  f000				  -	      adc	lzsa_dstptr+0	; Always CC from .cp_page loop.
    233  f000				  -	      sta	lzsa_winptr+0
    234  f000				  -
    235  f000				  -	      lda	#$FF
    236  f000				  -	      bit	lzsa_cmdbuf
    237  f000				  -	      bpl	.offset_hi
    238  f000				  -
    239  f000				  -	      jsr	.get_byte	; Get offset-hi.
    240  f000				  -
    241  f000				  -.offset_hi
    242  f000				  -	      adc	lzsa_dstptr+1	; lzsa_winptr < lzsa_dstptr, so
    243  f000				  -	      sta	lzsa_winptr+1	; always leaves CS.
    244  f000				  -
    245  f000				  -.lz_length
    246  f000				  -	      lda	lzsa_cmdbuf	; X=0 from previous loop.
    247  f000				  -	      and	#$0F
    248  f000				  -	      adc	#$03 - 1	; CS from previous ADC.
    249  f000				  -	      cmp	#$12	; Extended length?
    250  f000				  -	      bcc	.lz_got_len
    251  f000				  -
    252  f000				  -	      jsr	.get_length	; CS from CMP, X=0, returns CC.
    253  f000				  -	      stx	lzsa_lz_npages	; Hi-byte of length.
    254  f000				  -
    255  f000				  -.lz_got_len
    256  f000				  -	      tax		; Lo-byte of length.
    257  f000				  -
    258  f000				  -.lz_byte
    259  f000				  -	      lda	(lzsa_winptr),y	; CC throughout the execution of
    260  f000				  -	      sta	(lzsa_dstptr),y	; of this .lz_page loop.
    261  f000				  -	      inc	lzsa_winptr+0
    262  f000				  -	      bne	.lz_skip1
    263  f000				  -	      inc	lzsa_winptr+1
    264  f000				  -.lz_skip1
    265  f000				  -	      inc	lzsa_dstptr+0
    266  f000				  -	      bne	.lz_skip2
    267  f000				  -	      inc	lzsa_dstptr+1
    268  f000				  -.lz_skip2
    269  f000				  -	      dex
    270  f000				  -	      bne	.lz_byte
    271  f000				  -.lz_npages
    272  f000				  -	      lda	lzsa_lz_npages	; Any full pages left to copy?
    273  f000				  -	      beq	.cp_length
    274  f000				  -
    275  f000				  -	      dec	lzsa_lz_npages	; Unlikely, so can be slow.
    276  f000				  -	      bcc	.lz_byte	; Always true!
    277  f000				  -
    278  f000				  -	      else		; !LZSA_SMALL_SIZE
    279  f000				  -
    280  f000				  -			;
    281  f000				  -			; Copy bytes from decompressed window.
    282  f000				  -			;
    283  f000				  -			; Longer but faster.
    284  f000				  -			;
    285  f000				  -			; N.B. X=0 is expected and guaranteed when we get here.
    286  f000				  -			;
    287  f000				  -
    288  f000				  -.lz_offset
    289  f000				  -	      lda	(lzsa_srcptr),y	; Get offset-lo.
    290  f000				  -	      inc	lzsa_srcptr+0
    291  f000				  -	      bne	.offset_lo
    292  f000				  -	      inc	lzsa_srcptr+1
    293  f000				  -
    294  f000				  -.offset_lo
    295  f000				  -	      sta	lzsa_offset+0
    296  f000				  -
    297  f000				  -	      lda	#$FF	; Get offset-hi.
    298  f000				  -	      bit	lzsa_cmdbuf
    299  f000				  -	      bpl	.offset_hi
    300  f000				  -
    301  f000				  -	      lda	(lzsa_srcptr),y
    302  f000				  -	      inc	lzsa_srcptr+0
    303  f000				  -	      bne	.offset_hi
    304  f000				  -	      inc	lzsa_srcptr+1
    305  f000				  -
    306  f000				  -.offset_hi
    307  f000				  -	      sta	lzsa_offset+1
    308  f000				  -
    309  f000				  -.lz_length
    310  f000				  -	      lda	lzsa_cmdbuf	; X=0 from previous loop.
    311  f000				  -	      and	#$0F
    312  f000				  -	      adc	#$03	; Always CC from .cp_page loop.
    313  f000				  -	      cmp	#$12	; Extended length?
    314  f000				  -	      bcc	.got_lz_len
    315  f000				  -
    316  f000				  -	      jsr	.get_length	; X=0, CS from CMP, returns CC.
    317  f000				  -
    318  f000				  -.got_lz_len
    319  f000				  -	      inx		; Hi-byte of length+256.
    320  f000				  -
    321  f000				  -	      eor	#$FF	; Negate the lo-byte of length
    322  f000				  -	      tay
    323  f000				  -	      eor	#$FF
    324  f000				  -
    325  f000				  -.get_lz_dst
    326  f000				  -	      adc	lzsa_dstptr+0	; Calc address of partial page.
    327  f000				  -	      sta	lzsa_dstptr+0	; Always CC from previous CMP.
    328  f000				  -	      iny
    329  f000				  -	      bcs	.get_lz_win
    330  f000				  -	      beq	.get_lz_win	; Is lo-byte of length zero?
    331  f000				  -	      dec	lzsa_dstptr+1
    332  f000				  -
    333  f000				  -.get_lz_win
    334  f000				  -	      clc		; Calc address of match.
    335  f000				  -	      adc	lzsa_offset+0	; N.B. Offset is negative!
    336  f000				  -	      sta	lzsa_winptr+0
    337  f000				  -	      lda	lzsa_dstptr+1
    338  f000				  -	      adc	lzsa_offset+1
    339  f000				  -	      sta	lzsa_winptr+1
    340  f000				  -
    341  f000				  -			; according to 7800heat, this loop is hot. It runs on average ~7.5x.
    342  f000				  -			; TODO: see if there's a chance to unroll it.
    343  f000				  -.lz_byte
    344  f000				  -	      lda	(lzsa_winptr),y
    345  f000				  -	      sta	(lzsa_dstptr),y
    346  f000				  -	      iny
    347  f000				  -	      bne	.lz_byte
    348  f000				  -
    349  f000				  -	      inc	lzsa_dstptr+1
    350  f000				  -	      dex		; Any full pages left to copy?
    351  f000				  -	      bne	.lz_more
    352  f000				  -
    353  f000				  -	      jmp	.cp_length	; Loop around to the beginning.
    354  f000				  -
    355  f000				  -.lz_more
    356  f000				  -	      inc	lzsa_winptr+1	; Unlikely, so can be slow.
    357  f000				  -	      bne	.lz_byte	; Always true!
    358  f000				  -
    359  f000				  -	      endif		; !LZSA_SMALL_SIZE
    360  f000				  -
    361  f000				  -			;
    362  f000				  -			; Get 16-bit length in X:A register pair, return with CC.
    363  f000				  -			;
    364  f000				  -			; N.B. X=0 is expected and guaranteed when we get here.
    365  f000				  -			;
    366  f000				  -
    367  f000				  -.get_length
    368  f000				  -	      clc		; Add on the next byte to get
    369  f000				  -	      adc	(lzsa_srcptr),y	; the length.
    370  f000				  -	      inc	lzsa_srcptr+0
    371  f000				  -	      bne	.skip_inc
    372  f000				  -	      inc	lzsa_srcptr+1
    373  f000				  -.skip_inc
    374  f000				  -
    375  f000				  -	      bcc	.got_length	; No overflow means done.
    376  f000				  -	      clc		; MUST return CC!
    377  f000				  -	      tax		; Preserve overflow value.
    378  f000				  -
    379  f000				  -.extra_byte
    380  f000				  -	      jsr	.get_byte	; So rare, this can be slow!
    381  f000				  -	      pha
    382  f000				  -	      txa		; Overflow to 256 or 257?
    383  f000				  -	      beq	.extra_word
    384  f000				  -
    385  f000				  -.check_length
    386  f000				  -	      pla		; Length-lo.
    387  f000				  -	      bne	.got_length	; Check for zero.
    388  f000				  -	      dex		; Do one less page loop if so.
    389  f000				  -.got_length
    390  f000				  -	      rts
    391  f000				  -
    392  f000				  -.extra_word
    393  f000				  -	      jsr	.get_byte	; So rare, this can be slow!
    394  f000				  -	      tax
    395  f000				  -	      bne	.check_length	; Length-hi == 0 at EOF.
    396  f000				  -
    397  f000				  -.finished
    398  f000				  -	      pla		; Length-lo.
    399  f000				  -	      pla		; Decompression completed, pop
    400  f000				  -	      pla		; return address.
    401  f000				  -	      rts
    402  f000				  -
    403  f000				  -.get_byte
    404  f000				  -	      lda	(lzsa_srcptr),y	; Subroutine version for when
    405  f000				  -	      inc	lzsa_srcptr+0	; inlining isn't advantageous.
    406  f000				  -	      bne	.got_byte
    407  f000				  -	      inc	lzsa_srcptr+1	; Inc & test for bank overflow.
    408  f000				  -.got_byte
    409  f000				  -	      rts
    410  f000				  -
    411  f000				  -lzsa1moduleend
    412  f000				  -
    413  f000				  -	      echo	"  (lzsa1compression module is using ",[(lzsa1moduleend-lzsa1modulestart)]d," bytes of rom)"
    414  f000				  -
    415  f000					      endif		; lzsa1support
------- FILE constants.78b.asm
   3232  f000					      endif
   3233  f000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   3234  f000
   3235  f000							;standard routimes needed for pretty much all games
   3236  f000
   3237  f000							; some definitions used with "set debug color"
   3238  f000		       00 91	   DEBUGCALC  =	$91
   3239  f000		       00 41	   DEBUGWASTE =	$41
   3240  f000		       00 c1	   DEBUGDRAW  =	$C1
   3241  f000
   3242  f000							;NMI and IRQ handlers
   3243  f000				   NMI
   3244  f000							;VISIBLEOVER is 255 while the screen is drawn, and 0 right after the visible screen is done.
   3245  f000		       48		      pha		; save A
   3246  f001		       d8		      cld
   3247  f002		       a5 4d		      lda	visibleover
   3248  f004		       49 ff		      eor	#255
   3249  f006		       85 4d		      sta	visibleover
   3250  f008				  -	      ifconst	DEBUGINTERRUPT
   3251  f008				  -	      and	#$93
   3252  f008				  -	      sta	BACKGRND
   3253  f008					      endif
   3254  f008		       8a		      txa		; save X
   3255  f009		       48		      pha
   3256  f00a		       98		      tya		; save Y
   3257  f00b		       48		      pha
   3258  f00c		       ce b2 01 	      dec	interruptindex
   3259  f00f		       d0 03		      bne	skipreallyoffvisible
   3260  f011		       4c 6b f0 	      jmp	reallyoffvisible
   3261  f014				   skipreallyoffvisible
   3262  f014		       a5 4d		      lda	visibleover
   3263  f016		       d0 03		      bne	carryontopscreenroutine
   3264  f018				  -	      ifconst	.bottomscreenroutine
   3265  f018				  -	      lda	interrupthold
   3266  f018				  -	      beq	skipbottomroutine
   3267  f018				  -	      jsr	.bottomscreenroutine
   3268  f018				  -skipbottomroutine
   3269  f018					      endif
   3270  f018		       4c 79 f0 	      jmp	NMIexit
   3271  f01b				   carryontopscreenroutine
   3272  f01b				  -	      ifconst	.topscreenroutine
   3273  f01b				  -	      lda	interrupthold
   3274  f01b				  -	      beq	skiptoproutine
   3275  f01b				  -	      jsr	.topscreenroutine
   3276  f01b				  -skiptoproutine
   3277  f01b					      endif
   3278  f01b					      ifnconst	CANARYOFF
   3279  f01b		       ad c2 01 	      lda	canary
   3280  f01e		       f0 07		      beq	skipcanarytriggered
   3281  f020		       a9 45		      lda	#$45
   3282  f022		       85 20		      sta	BACKGRND
   3283  f024		       4c 63 f0 	      jmp	skipbrkolorset	; common crash dump routine, if available
   3284  f027				   skipcanarytriggered
   3285  f027					      endif
   3286  f027
   3287  f027		       ee 3e 21 	      inc	frameslost	; this is balanced with a "dec frameslost" when drawscreen is called.
   3288  f02a
   3289  f02a							; ** Other important routines that need to regularly run, and can run onscreen.
   3290  f02a							; ** Atarivox can't go here, because Maria might interrupt it while it's bit-banging.
   3291  f02a
   3292  f02a				  -	      ifconst	LONGCONTROLLERREAD
   3293  f02a				  -longcontrollerreads		; ** controllers that take a lot of time to read. We use much of the visible screen here.
   3294  f02a				  -	      ldy	port1control
   3295  f02a				  -	      lda	longreadtype,y
   3296  f02a				  -	      beq	LLRET1
   3297  f02a				  -	      tay
   3298  f02a				  -	      lda	longreadroutinehiP1,y
   3299  f02a				  -	      sta	inttemp4
   3300  f02a				  -	      lda	longreadroutineloP1,y
   3301  f02a				  -	      sta	inttemp3
   3302  f02a				  -	      jmp	(inttemp3)
   3303  f02a				  -LLRET1
   3304  f02a				  -	      ldy	port0control
   3305  f02a				  -	      lda	longreadtype,y
   3306  f02a				  -	      beq	LLRET0
   3307  f02a				  -	      tay
   3308  f02a				  -	      lda	longreadroutinehiP0,y
   3309  f02a				  -	      sta	inttemp4
   3310  f02a				  -	      lda	longreadroutineloP0,y
   3311  f02a				  -	      sta	inttemp3
   3312  f02a				  -	      jmp	(inttemp3)
   3313  f02a				  -LLRET0
   3314  f02a				  -
   3315  f02a				  -
   3316  f02a				  -	      ifconst	PADDLERANGE
   3317  f02a				  -TIMEVAL    =	PADDLERANGE
   3318  f02a				  -	      else
   3319  f02a				  -TIMEVAL    =	160
   3320  f02a				  -	      endif
   3321  f02a				  -TIMEOFFSET =	10
   3322  f02a				  -
   3323  f02a					      endif		; LONGCONTROLLERREAD
   3324  f02a
   3325  f02a
   3326  f02a		       20 03 f2 	      jsr	servicesfxchannels
   3327  f02d				  -	      ifconst	MUSICTRACKER
   3328  f02d				  -	      jsr	servicesong
   3329  f02d					      endif		; MUSICTRACKER
   3330  f02d				  -	      ifconst	RMT
   3331  f02d				  -	      ifnconst	RMTOFFSPEED
   3332  f02d				  -	      ifconst	RMTPALSPEED
   3333  f02d				  -	      lda	ntscslowframe
   3334  f02d				  -	      bne	skiprasterupdate
   3335  f02d				  -	      endif
   3336  f02d				  -	      endif
   3337  f02d				  -	      lda	rasterpause
   3338  f02d				  -	      beq	skiprasterupdate
   3339  f02d				  -	      ifconst	PAUSESILENT
   3340  f02d				  -	      lda	pausestate
   3341  f02d				  -	      bne	skiprasterupdate
   3342  f02d				  -	      endif
   3343  f02d				  -	      jsr	RASTERMUSICTRACKER+3
   3344  f02d				  -skiprasterupdate
   3345  f02d				  -RMT_Iend
   3346  f02d					      endif
   3347  f02d
   3348  f02d		       ee a4 01 	      inc	framecounter
   3349  f030		       ad a4 01 	      lda	framecounter
   3350  f033		       29 3f		      and	#63
   3351  f035		       d0 08		      bne	skipcountdownseconds
   3352  f037		       ad a5 01 	      lda	countdownseconds
   3353  f03a		       f0 03		      beq	skipcountdownseconds
   3354  f03c		       ce a5 01 	      dec	countdownseconds
   3355  f03f				   skipcountdownseconds
   3356  f03f
   3357  f03f		       a2 01		      ldx	#1
   3358  f041				   buttonreadloop
   3359  f041		       8a		      txa
   3360  f042		       48		      pha
   3361  f043		       bc b8 01 	      ldy	port0control,x
   3362  f046		       b9 df f1 	      lda	buttonhandlerlo,y
   3363  f049		       85 da		      sta	inttemp3
   3364  f04b		       b9 d2 f1 	      lda	buttonhandlerhi,y
   3365  f04e		       85 db		      sta	inttemp4
   3366  f050		       05 da		      ora	inttemp3
   3367  f052		       f0 03		      beq	buttonreadloopreturn
   3368  f054		       6c da 00 	      jmp	(inttemp3)
   3369  f057				   buttonreadloopreturn
   3370  f057		       68		      pla
   3371  f058		       aa		      tax
   3372  f059		       ca		      dex
   3373  f05a		       10 e5		      bpl	buttonreadloop
   3374  f05c
   3375  f05c				  -	      ifconst	DOUBLEBUFFER
   3376  f05c				  -	      lda	doublebufferminimumframeindex
   3377  f05c				  -	      beq	skipdoublebufferminimumframeindexadjust
   3378  f05c				  -	      dec	doublebufferminimumframeindex
   3379  f05c				  -skipdoublebufferminimumframeindexadjust
   3380  f05c					      endif
   3381  f05c
   3382  f05c		       4c 79 f0 	      jmp	NMIexit
   3383  f05f
   3384  f05f				   IRQ			; the only source of non-nmi interrupt should be the BRK opcode.
   3385  f05f					      ifnconst	BREAKPROTECTOFF
   3386  f05f		       a9 1a		      lda	#$1A
   3387  f061		       85 20		      sta	BACKGRND
   3388  f063				   skipbrkolorset
   3389  f063				   skipbrkdetected
   3390  f063		       a9 60		      lda	#$60
   3391  f065		       8d 07 21 	      sta	sCTRL
   3392  f068		       85 3c		      sta	CTRL
   3393  f06a					      ifnconst	hiscorefont
   3394  f06a		       02		      .byte.b	$02	; KIL/JAM
   3395  f06b				  -	      else		; hiscorefont is present
   3396  f06b				  -	      ifconst	CRASHDUMP
   3397  f06b				  -	      bit	MSTAT
   3398  f06b				  -	      bpl	skipbrkdetected	; wait for vblank to ensure we're clear of NMI
   3399  f06b				  -
   3400  f06b				  -	      ifconst	dumpbankswitch
   3401  f06b				  -	      lda	dumpbankswitch
   3402  f06b				  -	      pha
   3403  f06b				  -	      endif
   3404  f06b				  -
   3405  f06b				  -			; bankswitch if needed, to get to the hiscore font
   3406  f06b				  -	      ifconst	bankswitchmode
   3407  f06b				  -	      ifconst	included.hiscore.asm.bank
   3408  f06b				  -	      ifconst	MCPDEVCART
   3409  f06b				  -	      lda	#($18 | included.hiscore.asm.bank)
   3410  f06b				  -	      sta	$3000
   3411  f06b				  -	      else
   3412  f06b				  -	      lda	#(included.hiscore.asm.bank)
   3413  f06b				  -	      sta	$8000
   3414  f06b				  -	      endif
   3415  f06b				  -	      endif		; included.hiscore.asm.bank
   3416  f06b				  -	      endif		; bankswitchmode
   3417  f06b				  -
   3418  f06b				  -	      ifconst	DOUBLEBUFFER
   3419  f06b				  -			;turn off double-buffering, if on...
   3420  f06b				  -	      lda	#>DLLMEM
   3421  f06b				  -	      sta	DPPH
   3422  f06b				  -	      lda	#<DLLMEM
   3423  f06b				  -	      sta	DPPL
   3424  f06b				  -	      endif
   3425  f06b				  -
   3426  f06b				  -	      lda	#$00
   3427  f06b				  -	      sta	P0C2
   3428  f06b				  -
   3429  f06b				  -			;update the second-from-top DL...
   3430  f06b				  -	      ldy	#8
   3431  f06b				  -NMIupdatetopDL
   3432  f06b				  -	      lda	show2700,y
   3433  f06b				  -	      sta	ZONE1ADDRESS,y
   3434  f06b				  -	      dey
   3435  f06b				  -	      bpl	NMIupdatetopDL
   3436  f06b				  -
   3437  f06b				  -			; the hiscore font is present, so we try to output the stack
   3438  f06b				  -	      ldy	#0
   3439  f06b				  -copystackloop
   3440  f06b				  -	      pla
   3441  f06b				  -	      pha
   3442  f06b				  -	      lsr
   3443  f06b				  -	      lsr
   3444  f06b				  -	      lsr
   3445  f06b				  -	      lsr
   3446  f06b				  -	      tax
   3447  f06b				  -	      lda	hiscorehexlut,x
   3448  f06b				  -	      sta	$2700,y
   3449  f06b				  -	      iny
   3450  f06b				  -
   3451  f06b				  -	      pla
   3452  f06b				  -	      and	#$0F
   3453  f06b				  -	      tax
   3454  f06b				  -	      lda	hiscorehexlut,x
   3455  f06b				  -	      sta	$2700,y
   3456  f06b				  -	      iny
   3457  f06b				  -
   3458  f06b				  -	      lda	#27	; period
   3459  f06b				  -	      sta	$2700,y
   3460  f06b				  -	      iny
   3461  f06b				  -
   3462  f06b				  -	      cpy	#30
   3463  f06b				  -	      bne	copystackloop
   3464  f06b				  -
   3465  f06b				  -	      lda	#>hiscorefont
   3466  f06b				  -	      sta	CHARBASE
   3467  f06b				  -	      sta	sCHARBASE
   3468  f06b				  -	      lda	#%01000011	;Enable DMA, mode=320A
   3469  f06b				  -	      sta	CTRL
   3470  f06b				  -	      sta	sCTRL
   3471  f06b				  -	      .byte	$02	; KIL/JAM
   3472  f06b				  -hiscorehexlut
   3473  f06b				  -			; 0 1 2 3 4 5 6 7 8 9 A B C D E F
   3474  f06b				  -	      .byte	33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 0, 1, 2, 3, 4, 5
   3475  f06b				  -show2700
   3476  f06b				  -			; lo mode hi width=29 x EODL
   3477  f06b				  -	      .byte	$00, %01100000, $27, 3, 20, 0,0,0
   3478  f06b				  -	      else		; CRASHDUMP
   3479  f06b				  -	      .byte	$02	; KIL/JAM
   3480  f06b				  -	      endif		; crashdump
   3481  f06b					      endif		; hiscorefont
   3482  f06b				  -	      else
   3483  f06b				  -	      RTI
   3484  f06b					      endif
   3485  f06b
   3486  f06b				  -	      ifconst	LONGCONTROLLERREAD
   3487  f06b				  -
   3488  f06b				  -longreadtype
   3489  f06b				  -	      .byte	0, 0, 0, 1	; NONE PROLINE LIGHTGUN PADDLE
   3490  f06b				  -	      .byte	2, 0, 3, 0	; TRKBALL VCSSTICK DRIVING KEYPAD
   3491  f06b				  -	      .byte	3, 3, 0, 0	; STMOUSE AMOUSE ATARIVOX SNES
   3492  f06b				  -
   3493  f06b				  -longreadroutineloP0
   3494  f06b				  -	      .byte	<LLRET0	; 0 = no routine
   3495  f06b				  -	      .byte	<paddleport0update	; 1 = paddle
   3496  f06b				  -	      .byte	<trakball0update	; 2 = trakball
   3497  f06b				  -	      .byte	<mouse0update	; 3 = mouse
   3498  f06b				  -
   3499  f06b				  -longreadroutinehiP0
   3500  f06b				  -	      .byte	>LLRET0	; 0 = no routine
   3501  f06b				  -	      .byte	>paddleport0update	; 1 = paddle
   3502  f06b				  -	      .byte	>trakball0update	; 2 = trackball
   3503  f06b				  -	      .byte	>mouse0update	; 3 = mouse
   3504  f06b				  -
   3505  f06b				  -longreadroutineloP1
   3506  f06b				  -	      .byte	<LLRET1	; 0 = no routine
   3507  f06b				  -	      .byte	<paddleport1update	; 1 = paddle
   3508  f06b				  -	      .byte	<trakball1update	; 2 = trakball
   3509  f06b				  -	      .byte	<mouse1update	; 3 = mouse
   3510  f06b				  -
   3511  f06b				  -longreadroutinehiP1
   3512  f06b				  -	      .byte	>LLRET1	; 0 = no routine
   3513  f06b				  -	      .byte	>paddleport1update	; 1 = paddle
   3514  f06b				  -	      .byte	>trakball1update	; 2 = trackball
   3515  f06b				  -	      .byte	>mouse1update	; 3 = mouse
   3516  f06b				  -
   3517  f06b				  -
   3518  f06b				  -SETTIM64T
   3519  f06b				  -	      bne	skipdefaulttime
   3520  f06b				  -	      ifnconst	PADDLESMOOTHINGOFF
   3521  f06b				  -	      lda	#(TIMEVAL+TIMEOFFSET+1)
   3522  f06b				  -	      else
   3523  f06b				  -	      lda	#(TIMEVAL+TIMEOFFSET)
   3524  f06b				  -	      endif
   3525  f06b				  -skipdefaulttime
   3526  f06b				  -	      tay
   3527  f06b				  -	      dey
   3528  f06b				  -.setTIM64Tloop
   3529  f06b				  -	      sta	TIM64T
   3530  f06b				  -	      cpy	INTIM
   3531  f06b				  -	      bne	.setTIM64Tloop
   3532  f06b				  -	      rts
   3533  f06b					      endif		; LONGCONTROLLERREAD
   3534  f06b
   3535  f06b				   reallyoffvisible
   3536  f06b		       85 24		      sta	WSYNC
   3537  f06d
   3538  f06d		       a9 00		      lda	#0
   3539  f06f		       85 4d		      sta	visibleover
   3540  f071				  -	      ifconst	DEBUGINTERRUPT
   3541  f071				  -	      sta	BACKGRND
   3542  f071					      endif
   3543  f071
   3544  f071		       a9 03		      lda	#3
   3545  f073		       8d b2 01 	      sta	interruptindex
   3546  f076
   3547  f076		       20 4b f1 	      jsr	uninterruptableroutines
   3548  f079
   3549  f079				  -	      ifconst	.userinterrupt
   3550  f079				  -	      lda	interrupthold
   3551  f079				  -	      beq	skipuserintroutine
   3552  f079				  -	      jsr	.userinterrupt
   3553  f079				  -skipuserintroutine
   3554  f079					      endif
   3555  f079
   3556  f079				  -	      ifconst	KEYPADSUPPORT
   3557  f079				  -	      jsr	keypadcolumnread
   3558  f079				  -	      jsr	keypadrowselect
   3559  f079					      endif
   3560  f079
   3561  f079				   NMIexit
   3562  f079		       68		      pla
   3563  f07a		       a8		      tay
   3564  f07b		       68		      pla
   3565  f07c		       aa		      tax
   3566  f07d		       68		      pla
   3567  f07e		       40		      RTI
   3568  f07f
   3569  f07f				   clearscreen
   3570  f07f		       a2 0b		      ldx	#(WZONECOUNT-1)
   3571  f081		       a9 00		      lda	#0
   3572  f083				   clearscreenloop
   3573  f083		       95 65		      sta	dlend,x
   3574  f085		       ca		      dex
   3575  f086		       10 fb		      bpl	clearscreenloop
   3576  f088		       a9 00		      lda	#0
   3577  f08a		       8d ad 01 	      sta	valbufend	; clear the bcd value buffer
   3578  f08d		       8d ae 01 	      sta	valbufendsave
   3579  f090		       60		      rts
   3580  f091
   3581  f091				   restorescreen
   3582  f091		       a2 0b		      ldx	#(WZONECOUNT-1)
   3583  f093		       a9 00		      lda	#0
   3584  f095				   restorescreenloop
   3585  f095		       b5 82		      lda	dlendsave,x
   3586  f097		       95 65		      sta	dlend,x
   3587  f099		       ca		      dex
   3588  f09a		       10 f9		      bpl	restorescreenloop
   3589  f09c		       ad ae 01 	      lda	valbufendsave
   3590  f09f		       8d ad 01 	      sta	valbufend
   3591  f0a2		       60		      rts
   3592  f0a3
   3593  f0a3				   savescreen
   3594  f0a3		       a2 0b		      ldx	#(WZONECOUNT-1)
   3595  f0a5				   savescreenloop
   3596  f0a5		       b5 65		      lda	dlend,x
   3597  f0a7		       95 82		      sta	dlendsave,x
   3598  f0a9		       ca		      dex
   3599  f0aa		       10 f9		      bpl	savescreenloop
   3600  f0ac		       ad ad 01 	      lda	valbufend
   3601  f0af		       8d ae 01 	      sta	valbufendsave
   3602  f0b2				  -	      ifconst	DOUBLEBUFFER
   3603  f0b2				  -	      lda	doublebufferstate
   3604  f0b2				  -	      beq	savescreenrts
   3605  f0b2				  -	      lda	#1
   3606  f0b2				  -	      sta	doublebufferbufferdirty
   3607  f0b2				  -savescreenrts
   3608  f0b2					      endif		; DOUBLEBUFFER
   3609  f0b2		       60		      rts
   3610  f0b3
   3611  f0b3				   drawscreen
   3612  f0b3
   3613  f0b3				  -	      ifconst	interrupthold
   3614  f0b3				  -	      lda	#$FF
   3615  f0b3				  -	      sta	interrupthold	; if the user called drawscreen, we're ready for interrupts
   3616  f0b3					      endif
   3617  f0b3
   3618  f0b3		       a9 00		      lda	#0
   3619  f0b5		       85 42		      sta	temp1	; not B&W if we're here...
   3620  f0b7
   3621  f0b7				   drawscreenwait
   3622  f0b7		       a5 4d		      lda	visibleover
   3623  f0b9		       d0 fc		      bne	drawscreenwait	; make sure the visible screen isn't being drawn
   3624  f0bb
   3625  f0bb							;restore some registers in case the game changed them mid-screen...
   3626  f0bb		       ad 07 21 	      lda	sCTRL
   3627  f0be		       05 42		      ora	temp1
   3628  f0c0		       85 3c		      sta	CTRL
   3629  f0c2		       ad 0b 21 	      lda	sCHARBASE
   3630  f0c5		       85 34		      sta	CHARBASE
   3631  f0c7
   3632  f0c7							;ensure all of the display list is terminated...
   3633  f0c7		       20 31 f1 	      jsr	terminatedisplaylist
   3634  f0ca
   3635  f0ca					      ifnconst	pauseroutineoff
   3636  f0ca		       20 d5 f0 	      jsr	pauseroutine
   3637  f0cd					      endif		; pauseroutineoff
   3638  f0cd
   3639  f0cd							; Make sure the visible screen has *started* before we exit. That way we can rely on drawscreen
   3640  f0cd							; delaying a full frame, but still allowing time for basic calculations.
   3641  f0cd				   visiblescreenstartedwait
   3642  f0cd		       a5 4d		      lda	visibleover
   3643  f0cf		       f0 fc		      beq	visiblescreenstartedwait
   3644  f0d1				   visiblescreenstartedwaitdone
   3645  f0d1		       ce 3e 21 	      dec	frameslost	; ; this gets balanced with an "inc frameslost" by an NMI at the top of the screen
   3646  f0d4		       60		      rts
   3647  f0d5
   3648  f0d5					      ifnconst	pauseroutineoff
   3649  f0d5							; check to see if pause was pressed and released
   3650  f0d5				   pauseroutine
   3651  f0d5		       ad b3 01 	      lda	pausedisable
   3652  f0d8		       d0 47		      bne	leavepauseroutine
   3653  f0da		       a9 08		      lda	#8
   3654  f0dc		       2c 82 02 	      bit	SWCHB
   3655  f0df		       f0 22		      beq	pausepressed
   3656  f0e1
   3657  f0e1				  -	      ifconst	SNES0PAUSE
   3658  f0e1				  -	      lda	port0control
   3659  f0e1				  -	      cmp	#11
   3660  f0e1				  -	      bne	skipsnes0pause
   3661  f0e1				  -	      lda	snesdetected0
   3662  f0e1				  -	      beq	skipsnes0pause
   3663  f0e1				  -	      lda	snes2atari0hi
   3664  f0e1				  -	      and	#%00010000
   3665  f0e1				  -	      beq	pausepressed
   3666  f0e1				  -skipsnes0pause
   3667  f0e1					      endif
   3668  f0e1				  -	      ifconst	SNES1PAUSE
   3669  f0e1				  -
   3670  f0e1				  -	      lda	port1control
   3671  f0e1				  -	      cmp	#11
   3672  f0e1				  -	      bne	skipsnes1pause
   3673  f0e1				  -	      lda	snesdetected1
   3674  f0e1				  -	      beq	skipsnes1pause
   3675  f0e1				  -	      lda	snes2atari1hi
   3676  f0e1				  -	      and	#%00010000
   3677  f0e1				  -	      beq	pausepressed
   3678  f0e1				  -skipsnes1pause
   3679  f0e1					      endif
   3680  f0e1				  -	      ifconst	SNESNPAUSE
   3681  f0e1				  -	      ldx	snesport
   3682  f0e1				  -	      lda	port0control,x
   3683  f0e1				  -	      cmp	#11
   3684  f0e1				  -	      bne	skipsnesNpause
   3685  f0e1				  -	      lda	snesdetected0,x
   3686  f0e1				  -	      beq	skipsnesNpause
   3687  f0e1				  -	      lda	snes2atari0hi,x
   3688  f0e1				  -	      and	#%00010000
   3689  f0e1				  -	      beq	pausepressed
   3690  f0e1				  -skipsnesNpause
   3691  f0e1					      endif
   3692  f0e1				  -	      ifconst	MULTIBUTTONPAUSE
   3693  f0e1				  -	      ldx	#1
   3694  f0e1				  -multibuttonpauseloop
   3695  f0e1				  -	      lda	port0control,x
   3696  f0e1				  -	      cmp	#11
   3697  f0e1				  -	      bcc	multibuttonpauseloopbottom
   3698  f0e1				  -	      lda	sINPT1,x
   3699  f0e1				  -	      and	#1
   3700  f0e1				  -	      beq	pausepressed
   3701  f0e1				  -multibuttonpauseloopbottom
   3702  f0e1				  -	      dex
   3703  f0e1				  -	      bpl	multibuttonpauseloop
   3704  f0e1					      endif		; MULTIBUTTONPAUSE
   3705  f0e1
   3706  f0e1							;pause isn't pressed
   3707  f0e1		       a9 00		      lda	#0
   3708  f0e3		       8d ac 01 	      sta	pausebuttonflag	; clear pause hold state in case its set
   3709  f0e6
   3710  f0e6							;check if we're in an already paused state
   3711  f0e6		       ad 00 21 	      lda	pausestate
   3712  f0e9		       f0 36		      beq	leavepauseroutine	; nope, leave
   3713  f0eb
   3714  f0eb		       c9 01		      cmp	#1	; last frame was the start of pausing
   3715  f0ed		       f0 2b		      beq	enterpausestate2	; move from state 1 to 2
   3716  f0ef
   3717  f0ef		       c9 02		      cmp	#2
   3718  f0f1		       f0 34		      beq	carryonpausing
   3719  f0f3
   3720  f0f3							;pausestate must be >2, which means we're ending an unpause
   3721  f0f3		       a9 00		      lda	#0
   3722  f0f5		       8d ac 01 	      sta	pausebuttonflag
   3723  f0f8		       8d 00 21 	      sta	pausestate
   3724  f0fb		       ad 07 21 	      lda	sCTRL
   3725  f0fe		       85 3c		      sta	CTRL
   3726  f100		       4c 21 f1 	      jmp	leavepauseroutine
   3727  f103
   3728  f103				   pausepressed
   3729  f103							;pause is pressed
   3730  f103		       ad ac 01 	      lda	pausebuttonflag
   3731  f106		       c9 ff		      cmp	#$ff
   3732  f108		       f0 1d		      beq	carryonpausing
   3733  f10a
   3734  f10a							;its a new press, increment the state
   3735  f10a		       ee 00 21 	      inc	pausestate
   3736  f10d
   3737  f10d							;silence volume at the start and end of pausing
   3738  f10d		       a9 00		      lda	#0
   3739  f10f		       85 19		      sta	AUDV0
   3740  f111		       85 1a		      sta	AUDV1
   3741  f113
   3742  f113				  -	      ifconst	pokeysupport
   3743  f113				  -	      ldy	#7
   3744  f113				  -pausesilencepokeyaudioloop
   3745  f113				  -	      sta	(pokeybase),y
   3746  f113				  -	      dey
   3747  f113				  -	      bpl	pausesilencepokeyaudioloop
   3748  f113					      endif		; pokeysupport
   3749  f113
   3750  f113		       a9 ff		      lda	#$ff
   3751  f115		       8d ac 01 	      sta	pausebuttonflag
   3752  f118		       d0 0d		      bne	carryonpausing
   3753  f11a
   3754  f11a				   enterpausestate2
   3755  f11a		       a9 02		      lda	#2
   3756  f11c		       8d 00 21 	      sta	pausestate
   3757  f11f		       d0 06		      bne	carryonpausing
   3758  f121				   leavepauseroutine
   3759  f121		       ad 07 21 	      lda	sCTRL
   3760  f124		       85 3c		      sta	CTRL
   3761  f126		       60		      rts
   3762  f127				   carryonpausing
   3763  f127				  -	      ifconst	.pause
   3764  f127				  -	      jsr	.pause
   3765  f127					      endif		; .pause
   3766  f127		       ad 07 21 	      lda	sCTRL
   3767  f12a		       09 80		      ora	#%10000000	; turn off colorburst during pause...
   3768  f12c		       85 3c		      sta	CTRL
   3769  f12e		       4c d5 f0 	      jmp	pauseroutine
   3770  f131					      endif		; pauseroutineoff
   3771  f131
   3772  f131
   3773  f131				  -	      ifconst	DOUBLEBUFFER
   3774  f131				  -skipterminatedisplaylistreturn
   3775  f131				  -	      rts
   3776  f131					      endif		; DOUBLEBUFFER
   3777  f131				   terminatedisplaylist
   3778  f131				  -	      ifconst	DOUBLEBUFFER
   3779  f131				  -	      lda	doublebufferstate
   3780  f131				  -	      bne	skipterminatedisplaylistreturn	; double-buffering runs it's own DL termination code
   3781  f131					      endif		; DOUBLEBUFFER
   3782  f131				   terminatedisplaybuffer
   3783  f131							;add DL end entry on each DL
   3784  f131		       a2 0b		      ldx	#(WZONECOUNT-1)
   3785  f133				   dlendloop
   3786  f133				  -	      ifconst	VSCROLL
   3787  f133				  -	      ldy	Xx3,x
   3788  f133				  -	      lda	DLLMEM+11,y
   3789  f133					      else		; !VSCROLL
   3790  f133		       bd 14 f5 	      lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
   3791  f136					      endif		; !VSCROLL
   3792  f136				  -	      ifconst	DOUBLEBUFFER
   3793  f136				  -	      clc
   3794  f136				  -	      adc	doublebufferdloffset
   3795  f136					      endif		; DOUBLEBUFFER
   3796  f136		       85 63		      sta	dlpnt
   3797  f138				  -	      ifconst	VSCROLL
   3798  f138				  -	      lda	DLLMEM+10,y
   3799  f138					      else		; !VSCROLL
   3800  f138		       bd 08 f5 	      lda	DLPOINTH,x
   3801  f13b					      endif		; !VSCROLL
   3802  f13b				  -	      ifconst	DOUBLEBUFFER
   3803  f13b				  -	      adc	#0
   3804  f13b					      endif		; DOUBLEBUFFER
   3805  f13b		       85 64		      sta	dlpnt+1
   3806  f13d		       b4 65		      ldy	dlend,x
   3807  f13f		       a9 00		      lda	#$00
   3808  f141				   dlendmoreloops
   3809  f141		       c8		      iny
   3810  f142		       91 63		      sta	(dlpnt),y
   3811  f144				  -	      ifconst	FRAMESKIPGLITCHFIXWEAK
   3812  f144				  -	      cpy	#DLLASTOBJ+1
   3813  f144				  -	      beq	dlendthiszonedone
   3814  f144				  -	      iny
   3815  f144				  -	      iny
   3816  f144				  -	      iny
   3817  f144				  -	      iny
   3818  f144				  -	      iny
   3819  f144				  -	      sta	(dlpnt),y
   3820  f144				  -dlendthiszonedone
   3821  f144					      endif	FRAMESKIPGLITCHFIXWEAK
   3822  f144				  -	      ifconst	FRAMESKIPGLITCHFIX
   3823  f144				  -	      iny
   3824  f144				  -	      iny
   3825  f144				  -	      iny
   3826  f144				  -	      iny
   3827  f144				  -	      cpy	#DLLASTOBJ-1
   3828  f144				  -	      bcc	dlendmoreloops
   3829  f144					      endif		; FRAMESKIPGLITCHFIX
   3830  f144		       ca		      dex
   3831  f145		       10 ec		      bpl	dlendloop
   3832  f147
   3833  f147					      ifnconst	pauseroutineoff
   3834  f147		       20 d5 f0 	      jsr	pauseroutine
   3835  f14a					      endif		; pauseroutineoff
   3836  f14a		       60		      rts
   3837  f14b
   3838  f14b				   uninterruptableroutines
   3839  f14b							; this is for routines that must happen off the visible screen, each frame.
   3840  f14b
   3841  f14b				  -	      ifconst	AVOXVOICE
   3842  f14b				  -	      jsr	serviceatarivoxqueue
   3843  f14b					      endif
   3844  f14b				  -	      ifconst	MEGA7800SUPPORT
   3845  f14b				  -	      ldx	#1
   3846  f14b				  -mega7800polling
   3847  f14b				  -	      lda	port0control,x
   3848  f14b				  -	      cmp	#12	; mega7800
   3849  f14b				  -	      bne	mega7800handlercheck2
   3850  f14b				  -	      jsr	mega7800handler
   3851  f14b				  -	      jmp	mega7800handlerdone
   3852  f14b				  -mega7800handlercheck2
   3853  f14b				  -	      ifconst	MULTIBUTTON
   3854  f14b				  -	      cmp	#1	; proline
   3855  f14b				  -	      bne	mega7800handlerdone
   3856  f14b				  -	      lda	framecounter
   3857  f14b				  -	      eor	#7	; avoid the same frame as the snes2atari probe
   3858  f14b				  -	      and	#63
   3859  f14b				  -	      bne	mega7800handlerdone
   3860  f14b				  -	      lda	#12
   3861  f14b				  -	      sta	port0control,x
   3862  f14b				  -	      jsr	mega7800handler
   3863  f14b				  -	      endif		; MULTIBUTTON
   3864  f14b				  -mega7800handlerdone
   3865  f14b				  -	      dex
   3866  f14b				  -	      bpl	mega7800polling
   3867  f14b					      endif		; MEGA7800SUPPORT
   3868  f14b
   3869  f14b		       a9 00		      lda	#0
   3870  f14d		       8d b7 01 	      sta	palfastframe
   3871  f150		       8d b6 01 	      sta	ntscslowframe
   3872  f153		       ac b5 01 	      ldy	palframes
   3873  f156		       c8		      iny
   3874  f157		       ae 09 21 	      ldx	paldetected	; 0=ntsc 1=pal
   3875  f15a		       f0 06		      beq	ntsc2palskipcheck
   3876  f15c				   pal2ntscskipcheck
   3877  f15c		       c0 05		      cpy	#5	; every 5th frame, add a frame
   3878  f15e		       d0 0b		      bne	palframeskipdone
   3879  f160		       f0 04		      beq	frameskipdo
   3880  f162				   ntsc2palskipcheck
   3881  f162		       c0 06		      cpy	#6	; every 6th frame, drop a frame
   3882  f164		       d0 05		      bne	palframeskipdone
   3883  f166				   frameskipdo
   3884  f166		       fe b6 01 	      inc	ntscslowframe,x
   3885  f169		       a0 00		      ldy	#0
   3886  f16b				   palframeskipdone
   3887  f16b		       8c b5 01 	      sty	palframes
   3888  f16e				   skippalframeadjusting
   3889  f16e
   3890  f16e				  -	      ifconst	MUSICTRACKER
   3891  f16e				  -			; We normally run the servicesong routine from the top-screen interrupt, but if it
   3892  f16e				  -			; happens to interrupt the scheduling of a sound effect in the game code, we skip it.
   3893  f16e				  -			; If that happens, we try again here. Chances are very small we'll run into the same
   3894  f16e				  -			; problem twice, and if we do, we just drop a musical note or two.
   3895  f16e				  -	      lda	sfxschedulemissed
   3896  f16e				  -	      beq	servicesongwasnotmissed
   3897  f16e				  -	      jsr	servicesong
   3898  f16e				  -servicesongwasnotmissed
   3899  f16e					      endif		; MUSICTRACKER
   3900  f16e
   3901  f16e				  -	      ifconst	RMT
   3902  f16e				  -	      ifnconst	RMTPALSPEED
   3903  f16e				  -	      ifnconst	RMTOFFSPEED
   3904  f16e				  -	      ifconst	PAUSESILENT
   3905  f16e				  -	      lda	pausestate
   3906  f16e				  -	      bne	skiprasterupdate2
   3907  f16e				  -	      endif
   3908  f16e				  -	      lda	palfastframe
   3909  f16e				  -	      beq	skiprasterupdate2
   3910  f16e				  -	      lda	rasterpause
   3911  f16e				  -	      beq	skiprasterupdate2
   3912  f16e				  -	      jsr	RASTERMUSICTRACKER+3
   3913  f16e				  -skiprasterupdate2
   3914  f16e				  -	      endif
   3915  f16e				  -	      endif
   3916  f16e					      endif
   3917  f16e
   3918  f16e		       60		      rts
   3919  f16f
   3920  f16f				   serviceatarivoxqueue
   3921  f16f				  -	      ifconst	AVOXVOICE
   3922  f16f				  -	      lda	voxlock
   3923  f16f				  -	      bne	skipvoxprocessing	; the vox is in the middle of speech address update
   3924  f16f				  -skipvoxqueuesizedec
   3925  f16f				  -	      jmp	processavoxvoice
   3926  f16f				  -skipvoxprocessing
   3927  f16f				  -	      rts
   3928  f16f				  -
   3929  f16f				  -processavoxvoice
   3930  f16f				  -	      ifconst	HSSUPPORT
   3931  f16f				  -			; ** we skip speech if hi-score is on and no vox was detected
   3932  f16f				  -			; ** this is to avoid later collision with snes pads.
   3933  f16f				  -	      lda	hsdevice
   3934  f16f				  -	      and	#2
   3935  f16f				  -	      beq	processavoxvoicereturn
   3936  f16f				  -	      endif		; HSSUPPORT
   3937  f16f				  -	      lda	avoxenable
   3938  f16f				  -	      bne	avoxfixport
   3939  f16f				  -	      SPKOUT	tempavox
   3940  f16f				  -	      rts
   3941  f16f				  -avoxfixport
   3942  f16f				  -	      lda	#0	; restore the port to all bits as inputs...
   3943  f16f				  -	      sta	CTLSWA
   3944  f16f				  -	      rts
   3945  f16f				  -silenceavoxvoice
   3946  f16f				  -	      SPEAK	avoxsilentdata
   3947  f16f				  -processavoxvoicereturn
   3948  f16f				  -	      rts
   3949  f16f				  -avoxsilentdata
   3950  f16f				  -	      .byte	31,255
   3951  f16f					      else
   3952  f16f		       60		      rts
   3953  f170					      endif		; AVOXVOICE
   3954  f170
   3955  f170				   prolinebuttonpadhandler
   3956  f170				  -	      ifconst	MULTIBUTTON
   3957  f170				  -	      lda	framecounter
   3958  f170				  -	      and	#63
   3959  f170				  -	      bne	jbhandlercont1
   3960  f170				  -	      jsr	setonebuttonmode
   3961  f170				  -	      lda	#11
   3962  f170				  -	      sta	port0control,x
   3963  f170				  -	      jsr	snes2atari_signal_go
   3964  f170				  -	      lda	port0control,x
   3965  f170				  -	      cmp	#1	; check if it's still a proline
   3966  f170				  -	      beq	jbhandlercont1
   3967  f170				  -	      jmp	buttonreadloopreturn
   3968  f170				  -jbhandlercont1
   3969  f170				  -	      lda	#2
   3970  f170				  -	      sta	multibuttoncount0,x
   3971  f170					      endif		; MULTIBUTTON
   3972  f170				   joybuttonpadhandler
   3973  f170		       ad 31 21 	      lda	sSWCHA	; clear previous dirs for this pad, from
   3974  f173		       1d c2 f1 	      ora	SWCHA_DIRMASK,x	; our sSWCHA nibble.
   3975  f176		       8d 31 21 	      sta	sSWCHA
   3976  f179		       ad 80 02 	      lda	SWCHA	; load th actual joystick dirs, ensuring
   3977  f17c		       1d c3 f1 	      ora	SWCHA_DIRMASK+1,x	; we don't change the other nibble.
   3978  f17f		       2d 31 21 	      and	sSWCHA
   3979  f182		       8d 31 21 	      sta	sSWCHA
   3980  f185				   joybuttonhandler
   3981  f185		       8a		      txa
   3982  f186		       0a		      asl
   3983  f187		       a8		      tay
   3984  f188		       b9 08 00 	      lda	INPT0,y
   3985  f18b		       4a		      lsr
   3986  f18c							;ora #%00111111
   3987  f18c		       9d 02 21 	      sta	sINPT1,x
   3988  f18f		       b9 09 00 	      lda	INPT1,y
   3989  f192		       29 80		      and	#%10000000
   3990  f194		       1d 02 21 	      ora	sINPT1,x
   3991  f197		       9d 02 21 	      sta	sINPT1,x
   3992  f19a
   3993  f19a		       b5 0c		      lda	INPT4,x
   3994  f19c		       30 19		      bmi	.skip1bjoyfirecheck
   3995  f19e							;one button joystick is down
   3996  f19e		       49 80		      eor	#%10000000
   3997  f1a0		       9d 02 21 	      sta	sINPT1,x
   3998  f1a3
   3999  f1a3		       ad b1 01 	      lda	joybuttonmode
   4000  f1a6		       3d 87 f4 	      and	thisjoy2buttonbit,x
   4001  f1a9		       f0 0c		      beq	.skip1bjoyfirecheck
   4002  f1ab		       ad b1 01 	      lda	joybuttonmode
   4003  f1ae		       1d 87 f4 	      ora	thisjoy2buttonbit,x
   4004  f1b1		       8d b1 01 	      sta	joybuttonmode
   4005  f1b4		       8d 82 02 	      sta	SWCHB
   4006  f1b7				   .skip1bjoyfirecheck
   4007  f1b7		       a9 3f		      lda	#%00111111
   4008  f1b9		       1d 02 21 	      ora	sINPT1,x
   4009  f1bc		       9d 02 21 	      sta	sINPT1,x	; ensure multibutton bits are hi
   4010  f1bf		       4c 57 f0 	      jmp	buttonreadloopreturn
   4011  f1c2
   4012  f1c2				   SWCHA_DIRMASK
   4013  f1c2							;  p0	p1  p0
   4014  f1c2		       f0 0f f0 	      .byte.b	$F0,$0F,$F0
   4015  f1c5
   4016  f1c5				   gunbuttonhandler		; outside of the conditional, so our button handler LUT is valid
   4017  f1c5				  -	      ifconst	LIGHTGUNSUPPORT
   4018  f1c5				  -	      cpx	#0
   4019  f1c5				  -	      bne	secondportgunhandler
   4020  f1c5				  -firstportgunhandler
   4021  f1c5				  -	      lda	SWCHA
   4022  f1c5				  -	      asl
   4023  f1c5				  -	      asl
   4024  f1c5				  -	      asl		; shift D4 to D7
   4025  f1c5				  -	      and	#%10000000
   4026  f1c5				  -	      eor	#%10000000
   4027  f1c5				  -	      sta	sINPT1
   4028  f1c5				  -	      jmp	buttonreadloopreturn
   4029  f1c5				  -secondportgunhandler
   4030  f1c5				  -	      lda	SWCHA
   4031  f1c5				  -	      lsr		; shift D0 into carry
   4032  f1c5				  -	      lsr		; shift carry into D7
   4033  f1c5				  -	      and	#%10000000
   4034  f1c5				  -	      eor	#%10000000
   4035  f1c5				  -	      sta	sINPT3
   4036  f1c5				  -	      jmp	buttonreadloopreturn
   4037  f1c5					      endif		; LIGHTGUNSUPPORT
   4038  f1c5
   4039  f1c5				   controlsusing2buttoncode
   4040  f1c5		       00		      .byte.b	0	; 00=no controller plugged in
   4041  f1c6		       01		      .byte.b	1	; 01=proline joystick
   4042  f1c7		       00		      .byte.b	0	; 02=lightgun
   4043  f1c8		       00		      .byte.b	0	; 03=paddle
   4044  f1c9		       01		      .byte.b	1	; 04=trakball
   4045  f1ca		       01		      .byte.b	1	; 05=vcs joystick
   4046  f1cb		       01		      .byte.b	1	; 06=driving control
   4047  f1cc		       00		      .byte.b	0	; 07=keypad control
   4048  f1cd		       00		      .byte.b	0	; 08=st mouse/cx80
   4049  f1ce		       00		      .byte.b	0	; 09=amiga mouse
   4050  f1cf		       01		      .byte.b	1	; 10=atarivox
   4051  f1d0		       00		      .byte.b	0	; 11=snes2atari
   4052  f1d1		       00		      .byte.b	0	; 12=mega7800
   4053  f1d2
   4054  f1d2				   buttonhandlerhi
   4055  f1d2		       00		      .byte.b	0	; 00=no controller plugged in
   4056  f1d3		       f1		      .byte.b	>prolinebuttonpadhandler	; 01=proline joystick
   4057  f1d4		       f1		      .byte.b	>gunbuttonhandler	; 02=lightgun
   4058  f1d5		       f4		      .byte.b	>paddlebuttonhandler	; 03=paddle
   4059  f1d6		       f1		      .byte.b	>joybuttonhandler	; 04=trakball
   4060  f1d7		       f1		      .byte.b	>joybuttonpadhandler	; 05=vcs joystick
   4061  f1d8		       f1		      .byte.b	>joybuttonhandler	; 06=driving control
   4062  f1d9		       00		      .byte.b	0	; 07=keypad
   4063  f1da		       f4		      .byte.b	>mousebuttonhandler	; 08=st mouse
   4064  f1db		       f4		      .byte.b	>mousebuttonhandler	; 09=amiga mouse
   4065  f1dc		       f1		      .byte.b	>joybuttonhandler	; 10=atarivox
   4066  f1dd		       f0		      .byte.b	>snes2atarihandler	; 11=snes
   4067  f1de		       00		      .byte.b	0	; 12=mega7800
   4068  f1df				   buttonhandlerlo
   4069  f1df		       00		      .byte.b	0	; 00=no controller plugged in
   4070  f1e0		       70		      .byte.b	<prolinebuttonpadhandler	; 01=proline joystick
   4071  f1e1		       c5		      .byte.b	<gunbuttonhandler	; 02=lightgun
   4072  f1e2		       57		      .byte.b	<paddlebuttonhandler	; 03=paddle
   4073  f1e3		       85		      .byte.b	<joybuttonhandler	; 04=trakball
   4074  f1e4		       70		      .byte.b	<joybuttonpadhandler	; 05=vcs joystick
   4075  f1e5		       85		      .byte.b	<joybuttonhandler	; 06=driving control
   4076  f1e6		       00		      .byte.b	0	; 07=keypad
   4077  f1e7		       57		      .byte.b	<mousebuttonhandler	; 08=st mouse
   4078  f1e8		       57		      .byte.b	<mousebuttonhandler	; 09=amiga mouse
   4079  f1e9		       85		      .byte.b	<joybuttonhandler	; 10=atarivox
   4080  f1ea		       00		      .byte.b	<snes2atarihandler	; 11=snes
   4081  f1eb		       00		      .byte.b	0	; 12=mega7800
   4082  f1ec
   4083  f1ec				   drawwait
   4084  f1ec		       24 4d		      bit	visibleover	; 255 if screen is being drawn, 0 when not.
   4085  f1ee		       30 fc		      bmi	drawwait	; make sure the visible screen isn't being drawn
   4086  f1f0		       60		      rts
   4087  f1f1
   4088  f1f1				   drawoverwait
   4089  f1f1		       24 4d		      bit	visibleover	; 255 if screen is being drawn, 0 when not.
   4090  f1f3		       10 fc		      bpl	drawoverwait	; make sure the visible screen is being drawn
   4091  f1f5		       60		      rts
   4092  f1f6
   4093  f1f6
   4094  f1f6				   mutetia
   4095  f1f6		       a9 00		      lda	#0
   4096  f1f8		       a2 03		      ldx	#3
   4097  f1fa				   mutetialoop
   4098  f1fa		       95 4e		      sta	sfx1pointlo,x
   4099  f1fc		       95 17		      sta	AUDF0,x
   4100  f1fe		       ca		      dex
   4101  f1ff		       10 f9		      bpl	mutetialoop
   4102  f201		       60		      rts
   4103  f202
   4104  f202				   servicesfxchannelsdone
   4105  f202					      ifnconst	pokeysupport
   4106  f202		       60		      rts
   4107  f203				  -	      else
   4108  f203				  -	      jmp	checkpokeyplaying
   4109  f203					      endif
   4110  f203				   servicesfxchannels
   4111  f203				  -	      ifconst	PAUSESILENT
   4112  f203				  -	      lda	pausestate
   4113  f203				  -	      beq	servicesfxchannels_1
   4114  f203				  -	      rts
   4115  f203				  -servicesfxchannels_1
   4116  f203					      endif
   4117  f203		       a2 ff		      ldx	#255
   4118  f205				   servicesfxchannelsloop
   4119  f205		       e8		      inx
   4120  f206					      ifnconst	TIASFXMONO
   4121  f206		       e0 02		      cpx	#2
   4122  f208				  -	      else
   4123  f208				  -	      cpx	#1
   4124  f208					      endif
   4125  f208		       f0 f8		      beq	servicesfxchannelsdone
   4126  f20a
   4127  f20a		       a5 de		      lda	sfxschedulelock	; =1 if locked
   4128  f20c		       d0 f4		      bne	servicesfxchannelsdone	; exit if a pointer may be mid-way change
   4129  f20e
   4130  f20e		       b5 4e		      lda	sfx1pointlo,x
   4131  f210		       85 dc		      sta	inttemp5
   4132  f212		       15 50		      ora	sfx1pointhi,x
   4133  f214		       f0 ef		      beq	servicesfxchannelsloop
   4134  f216		       b5 50		      lda	sfx1pointhi,x
   4135  f218		       85 dd		      sta	inttemp6
   4136  f21a
   4137  f21a		       b5 58		      lda	sfx1tick,x
   4138  f21c		       f0 05		      beq	servicesfx_cont1	; this chunk is over, load the next!
   4139  f21e		       d6 58		      dec	sfx1tick,x	; frame countdown is non-zero, subtract one
   4140  f220		       4c 05 f2 	      jmp	servicesfxchannelsloop
   4141  f223				   servicesfx_cont1
   4142  f223
   4143  f223		       a0 01		      ldy	#1	; check to see if they're changing the frame countdown
   4144  f225		       b1 dc		      lda	(inttemp5),y
   4145  f227		       c9 10		      cmp	#$10
   4146  f229		       d0 1b		      bne	servicesfx_cont1a
   4147  f22b		       a0 02		      ldy	#2
   4148  f22d		       b1 dc		      lda	(inttemp5),y
   4149  f22f		       95 56		      sta	sfx1frames,x	; change the frame countdown
   4150  f231		       a9 00		      lda	#0
   4151  f233		       95 58		      sta	sfx1tick,x
   4152  f235							; advance the sound pointer by 3...
   4153  f235		       b5 4e		      lda	sfx1pointlo,x
   4154  f237		       18		      clc
   4155  f238		       69 03		      adc	#3
   4156  f23a		       95 4e		      sta	sfx1pointlo,x
   4157  f23c		       b5 50		      lda	sfx1pointhi,x
   4158  f23e		       69 00		      adc	#0
   4159  f240		       95 50		      sta	sfx1pointhi,x
   4160  f242							; and then fetch another sample for this channel...
   4161  f242		       ca		      dex
   4162  f243		       4c 05 f2 	      jmp	servicesfxchannelsloop
   4163  f246				   servicesfx_cont1a
   4164  f246
   4165  f246		       b5 56		      lda	sfx1frames,x	; set the frame countdown for this sound chunk
   4166  f248		       95 58		      sta	sfx1tick,x
   4167  f24a
   4168  f24a		       b5 52		      lda	sfx1priority,x	; decrease the sound's priority if its non-zero
   4169  f24c		       f0 02		      beq	servicesfx_cont2
   4170  f24e		       d6 52		      dec	sfx1priority,x
   4171  f250				   servicesfx_cont2
   4172  f250
   4173  f250		       a0 00		      ldy	#0	; play the sound
   4174  f252		       b1 dc		      lda	(inttemp5),y
   4175  f254		       85 d8		      sta	inttemp1
   4176  f256
   4177  f256				  -	      ifconst	MUSICTRACKER
   4178  f256				  -	      lda	sfx1notedata,x
   4179  f256				  -	      beq	exitmusictracker	; exit if this isn't a pitched instrument
   4180  f256				  -	      ldy	#0
   4181  f256				  -	      sty	inttemp2
   4182  f256				  -	      clc
   4183  f256				  -	      adc	(inttemp5),y
   4184  f256				  -	      asl		; x2
   4185  f256				  -	      tay
   4186  f256				  -	      lda	tiatrackeroctavenotes,y
   4187  f256				  -	      sta	AUDC0,x
   4188  f256				  -	      iny
   4189  f256				  -	      lda	tiatrackeroctavenotes,y
   4190  f256				  -	      sta	AUDF0,x
   4191  f256				  -	      ldy	#1
   4192  f256				  -	      jmp	sfxvolumeentrypt
   4193  f256				  -exitmusictracker
   4194  f256				  -	      lda	inttemp1
   4195  f256					      endif		; MUSICTRACKER
   4196  f256
   4197  f256		       18		      clc
   4198  f257		       75 54		      adc	sfx1poffset,x	; take into account any pitch modification
   4199  f259		       95 17		      sta	AUDF0,x
   4200  f25b		       c8		      iny
   4201  f25c		       b1 dc		      lda	(inttemp5),y
   4202  f25e		       95 15		      sta	AUDC0,x
   4203  f260		       85 d9		      sta	inttemp2
   4204  f262		       c8		      iny
   4205  f263				   sfxvolumeentrypt
   4206  f263				  -	      ifconst	TIAVOLUME
   4207  f263				  -	      lda	tiavolume
   4208  f263				  -	      asl
   4209  f263				  -	      asl
   4210  f263				  -	      asl
   4211  f263				  -	      asl
   4212  f263				  -	      sta	fourbitfadevalueint
   4213  f263					      endif		; TIAVOLUME
   4214  f263		       b1 dc		      lda	(inttemp5),y
   4215  f265				  -	      ifconst	TIAVOLUME
   4216  f265				  -	      jsr	fourbitfadeint
   4217  f265					      endif		; TIAVOLUME
   4218  f265		       95 19		      sta	AUDV0,x
   4219  f267		       c9 10		      cmp	#$10
   4220  f269		       b0 19		      bcs	sfxsoundloop	; AUDV0>$0F means the sound is looped while priority is active
   4221  f26b
   4222  f26b		       05 d9		      ora	inttemp2
   4223  f26d		       05 d8		      ora	inttemp1	; check if F|C|V=0
   4224  f26f		       f0 23		      beq	zerosfx	; if so, we're at the end of the sound.
   4225  f271
   4226  f271				   advancesfxpointer
   4227  f271							; advance the pointer to the next sound chunk
   4228  f271		       c8		      iny
   4229  f272		       84 da		      sty	inttemp3
   4230  f274		       18		      clc
   4231  f275		       b5 4e		      lda	sfx1pointlo,x
   4232  f277		       65 da		      adc	inttemp3
   4233  f279		       95 4e		      sta	sfx1pointlo,x
   4234  f27b		       b5 50		      lda	sfx1pointhi,x
   4235  f27d		       69 00		      adc	#0
   4236  f27f		       95 50		      sta	sfx1pointhi,x
   4237  f281		       4c 05 f2 	      jmp	servicesfxchannelsloop
   4238  f284
   4239  f284				   sfxsoundloop
   4240  f284		       48		      pha
   4241  f285		       b5 52		      lda	sfx1priority,x
   4242  f287		       d0 04		      bne	sfxsoundloop_carryon
   4243  f289		       68		      pla		; fix the stack before we go
   4244  f28a		       4c 71 f2 	      jmp	advancesfxpointer
   4245  f28d				   sfxsoundloop_carryon
   4246  f28d		       68		      pla
   4247  f28e		       29 f0		      and	#$F0
   4248  f290		       4a		      lsr
   4249  f291		       4a		      lsr
   4250  f292		       4a		      lsr
   4251  f293		       4a		      lsr
   4252  f294
   4253  f294				   zerosfx
   4254  f294		       95 4e		      sta	sfx1pointlo,x
   4255  f296		       95 50		      sta	sfx1pointhi,x
   4256  f298		       95 52		      sta	sfx1priority,x
   4257  f29a		       4c 05 f2 	      jmp	servicesfxchannelsloop
   4258  f29d
   4259  f29d
   4260  f29d				   schedulesfx
   4261  f29d							; called with sfxinstrumentlo=<data sfxinstrumenthi=>data sfxpitchoffset=pitch-offset sfxnoteindex=note index
   4262  f29d		       a0 00		      ldy	#0
   4263  f29f				  -	      ifconst	pokeysupport
   4264  f29f				  -	      lda	sfxinstrumenthi
   4265  f29f				  -	      beq	scheduletiasfx	; drums have undefined instrument
   4266  f29f				  -	      lda	(sfxinstrumentlo),y
   4267  f29f				  -	      cmp	#$20	; POKEY?
   4268  f29f				  -	      bne	scheduletiasfx
   4269  f29f				  -	      jmp	schedulepokeysfx
   4270  f29f					      endif
   4271  f29f				   scheduletiasfx
   4272  f29f							;cmp #$10 ; TIA?
   4273  f29f							;beq continuescheduletiasfx
   4274  f29f							; rts ; unhandled!!!
   4275  f29f				   continuescheduletiasfx
   4276  f29f					      ifnconst	TIASFXMONO
   4277  f29f		       a5 50		      lda	sfx1pointhi
   4278  f2a1		       f0 15		      beq	schedulesfx1	;if channel 1 is idle, use it
   4279  f2a3		       a5 51		      lda	sfx2pointhi
   4280  f2a5		       f0 15		      beq	schedulesfx2	;if channel 2 is idle, use it
   4281  f2a7							; Both channels are scheduled.
   4282  f2a7		       a5 e1		      lda	sfxinstrumenthi
   4283  f2a9		       f0 06		      beq	skipscheduledrums
   4284  f2ab		       a0 01		      ldy	#1
   4285  f2ad		       b1 e0		      lda	(sfxinstrumentlo),y
   4286  f2af		       d0 01		      bne	interruptsfx
   4287  f2b1				   skipscheduledrums
   4288  f2b1		       60		      rts		; the new sound has 0 priority and both channels are busy. Skip playing it.
   4289  f2b2				   interruptsfx
   4290  f2b2							;Compare which active sound has a lower priority. We'll interrupt the lower one.
   4291  f2b2		       a5 52		      lda	sfx1priority
   4292  f2b4		       c5 53		      cmp	sfx2priority
   4293  f2b6		       b0 04		      bcs	schedulesfx2
   4294  f2b8					      endif		; !TIASFXMONO
   4295  f2b8
   4296  f2b8				   schedulesfx1
   4297  f2b8		       a2 00		      ldx	#0	; channel 1
   4298  f2ba					      ifnconst	TIASFXMONO
   4299  f2ba		       f0 02		      beq	skipschedulesfx2
   4300  f2bc				   schedulesfx2
   4301  f2bc		       a2 01		      ldx	#1	; channel 2
   4302  f2be				   skipschedulesfx2
   4303  f2be					      endif		; !TIASFXMONO
   4304  f2be
   4305  f2be				  -	      ifconst	MUSICTRACKER
   4306  f2be				  -	      lda	sfxnoteindex
   4307  f2be				  -	      bpl	skipdrumkitoverride
   4308  f2be				  -	      and	#$7F	; subtract 128
   4309  f2be				  -	      sec
   4310  f2be				  -	      sbc	#4	; drums start at 132, i.e. octave 10
   4311  f2be				  -	      asl
   4312  f2be				  -	      tay
   4313  f2be				  -	      lda	tiadrumkitdefinition,y
   4314  f2be				  -	      sta	sfxinstrumentlo
   4315  f2be				  -	      iny
   4316  f2be				  -	      lda	tiadrumkitdefinition,y
   4317  f2be				  -	      sta	sfxinstrumenthi
   4318  f2be				  -	      lda	#0
   4319  f2be				  -	      sta	sfxnoteindex	; and tell the driver it's a non-pitched instrument
   4320  f2be				  -skipdrumkitoverride
   4321  f2be					      endif		; MUSICTRACKER
   4322  f2be		       a0 01		      ldy	#1	; get priority and sound-resolution (in frames)
   4323  f2c0		       b1 e0		      lda	(sfxinstrumentlo),y
   4324  f2c2		       95 52		      sta	sfx1priority,x
   4325  f2c4		       c8		      iny
   4326  f2c5		       b1 e0		      lda	(sfxinstrumentlo),y
   4327  f2c7		       95 56		      sta	sfx1frames,x
   4328  f2c9		       a5 e0		      lda	sfxinstrumentlo
   4329  f2cb		       18		      clc
   4330  f2cc		       69 03		      adc	#3
   4331  f2ce		       95 4e		      sta	sfx1pointlo,x
   4332  f2d0		       a5 e1		      lda	sfxinstrumenthi
   4333  f2d2		       69 00		      adc	#0
   4334  f2d4		       95 50		      sta	sfx1pointhi,x
   4335  f2d6		       a5 e2		      lda	sfxpitchoffset
   4336  f2d8		       95 54		      sta	sfx1poffset,x
   4337  f2da		       a9 00		      lda	#0
   4338  f2dc		       95 58		      sta	sfx1tick,x
   4339  f2de		       a5 e3		      lda	sfxnoteindex
   4340  f2e0		       95 cd		      sta	sfx1notedata,x
   4341  f2e2		       60		      rts
   4342  f2e3
   4343  f2e3				   plotsprite
   4344  f2e3					      ifnconst	NODRAWWAIT
   4345  f2e3				  -	      ifconst	DOUBLEBUFFER
   4346  f2e3				  -	      lda	doublebufferstate
   4347  f2e3				  -	      bne	skipplotspritewait
   4348  f2e3					      endif		; DOUBLEBUFFER
   4349  f2e3				  -	      ifconst	DEBUGWAITCOLOR
   4350  f2e3				  -	      lda	#$41
   4351  f2e3				  -	      sta	BACKGRND
   4352  f2e3					      endif
   4353  f2e3				   plotspritewait
   4354  f2e3		       a5 4d		      lda	visibleover
   4355  f2e5		       d0 fc		      bne	plotspritewait
   4356  f2e7				   skipplotspritewait
   4357  f2e7				  -	      ifconst	DEBUGWAITCOLOR
   4358  f2e7				  -	      lda	#$0
   4359  f2e7				  -	      sta	BACKGRND
   4360  f2e7					      endif
   4361  f2e7					      endif
   4362  f2e7
   4363  f2e7							;arguments:
   4364  f2e7							; temp1=lo graphicdata
   4365  f2e7							; temp2=hi graphicdata
   4366  f2e7							; temp3=palette | width byte
   4367  f2e7							; temp4=x
   4368  f2e7							; temp5=y
   4369  f2e7							; temp6=mode
   4370  f2e7		       a5 46		      lda	temp5	;Y position
   4371  f2e9		       4a		      lsr		; 2 - Divide by 8 or 16
   4372  f2ea		       4a		      lsr		; 2
   4373  f2eb		       4a		      lsr		; 2
   4374  f2ec					      if	WZONEHEIGHT = 16
   4375  f2ec		       4a		      lsr		; 2
   4376  f2ed					      endif
   4377  f2ed
   4378  f2ed		       aa		      tax
   4379  f2ee
   4380  f2ee					      ifnconst	NOLIMITCHECKING
   4381  f2ee
   4382  f2ee							; the next block allows for vertical masking, and ensures we don't overwrite non-DL memory
   4383  f2ee
   4384  f2ee		       c9 0c		      cmp	#WZONECOUNT
   4385  f2f0
   4386  f2f0		       90 0a		      bcc	continueplotsprite1	; the sprite is fully on-screen, so carry on...
   4387  f2f2							; otherwise, check to see if the bottom half is in zone 0...
   4388  f2f2
   4389  f2f2					      if	WZONEHEIGHT = 16
   4390  f2f2		       c9 0f		      cmp	#15
   4391  f2f4				  -	      else
   4392  f2f4				  -	      cmp	#31
   4393  f2f4					      endif
   4394  f2f4
   4395  f2f4		       d0 05		      bne	exitplotsprite1
   4396  f2f6		       a2 00		      ldx	#0
   4397  f2f8		       4c 31 f3 	      jmp	continueplotsprite2
   4398  f2fb				   exitplotsprite1
   4399  f2fb		       60		      rts
   4400  f2fc
   4401  f2fc				   continueplotsprite1
   4402  f2fc					      endif
   4403  f2fc
   4404  f2fc				  -	      ifconst	VSCROLL
   4405  f2fc				  -	      ldy	Xx3,x
   4406  f2fc				  -	      lda	DLLMEM+11,y
   4407  f2fc					      else		; !VSCROLL
   4408  f2fc		       bd 14 f5 	      lda	DLPOINTL,x	;Get pointer to DL that this sprite starts in
   4409  f2ff					      endif		; !VSCROLL
   4410  f2ff				  -	      ifconst	DOUBLEBUFFER
   4411  f2ff				  -	      clc
   4412  f2ff				  -	      adc	doublebufferdloffset
   4413  f2ff					      endif		; DOUBLEBUFFER
   4414  f2ff		       85 63		      sta	dlpnt
   4415  f301				  -	      ifconst	VSCROLL
   4416  f301				  -	      lda	DLLMEM+10,y
   4417  f301					      else		; !VSCROLL
   4418  f301		       bd 08 f5 	      lda	DLPOINTH,x
   4419  f304					      endif		; !VSCROLL
   4420  f304				  -	      ifconst	DOUBLEBUFFER
   4421  f304				  -	      adc	#0
   4422  f304					      endif		; DOUBLEBUFFER
   4423  f304		       85 64		      sta	dlpnt+1
   4424  f306
   4425  f306							;Create DL entry for upper part of sprite
   4426  f306
   4427  f306		       b4 65		      ldy	dlend,x	;Get the index to the end of this DL
   4428  f308
   4429  f308				  -	      ifconst	CHECKOVERWRITE
   4430  f308				  -	      cpy	#DLLASTOBJ
   4431  f308				  -	      beq	checkcontinueplotsprite2
   4432  f308				  -continueplotsprite1a
   4433  f308					      endif
   4434  f308
   4435  f308		       a5 42		      lda	temp1	; graphic data, lo byte
   4436  f30a		       91 63		      sta	(dlpnt),y	;Low byte of data address
   4437  f30c
   4438  f30c					      ifnconst	ATOMICSPRITEUPDATE
   4439  f30c		       c8		      iny
   4440  f30d		       a5 47		      lda	temp6
   4441  f30f		       91 63		      sta	(dlpnt),y
   4442  f311				  -	      else
   4443  f311				  -	      iny
   4444  f311				  -	      sty	temp8
   4445  f311					      endif
   4446  f311
   4447  f311		       c8		      iny
   4448  f312
   4449  f312		       a5 46		      lda	temp5	;Y position
   4450  f314		       29 0f		      and	#(WZONEHEIGHT - 1)
   4451  f316		       c9 01		      cmp	#1	; clear carry if our sprite is just in this zone
   4452  f318		       05 43		      ora	temp2	; graphic data, hi byte
   4453  f31a		       91 63		      sta	(dlpnt),y
   4454  f31c
   4455  f31c		       c8		      iny
   4456  f31d		       a5 44		      lda	temp3	;palette|width
   4457  f31f		       91 63		      sta	(dlpnt),y
   4458  f321
   4459  f321		       c8		      iny
   4460  f322		       a5 45		      lda	temp4	;Horizontal position
   4461  f324		       91 63		      sta	(dlpnt),y
   4462  f326
   4463  f326		       c8		      iny
   4464  f327		       94 65		      sty	dlend,x
   4465  f329
   4466  f329				  -	      ifconst	ALWAYSTERMINATE
   4467  f329				  -	      iny
   4468  f329				  -	      lda	#0
   4469  f329				  -	      sta	(dlpnt),y
   4470  f329					      endif
   4471  f329
   4472  f329				  -	      ifconst	ATOMICSPRITEUPDATE
   4473  f329				  -	      ldy	temp8
   4474  f329				  -	      lda	temp6
   4475  f329				  -	      sta	(dlpnt),y
   4476  f329					      endif
   4477  f329
   4478  f329				   checkcontinueplotsprite2
   4479  f329
   4480  f329		       90 33		      bcc	doneSPDL	;branch if the sprite was fully in the last zone
   4481  f32b
   4482  f32b							;Create DL entry for lower part of sprite
   4483  f32b
   4484  f32b		       e8		      inx		;Next region
   4485  f32c
   4486  f32c					      ifnconst	NOLIMITCHECKING
   4487  f32c		       e0 0c		      cpx	#WZONECOUNT
   4488  f32e
   4489  f32e		       90 01		      bcc	continueplotsprite2	; the second half of the sprite is fully on-screen, so carry on...
   4490  f330		       60		      rts
   4491  f331				   continueplotsprite2
   4492  f331					      endif
   4493  f331
   4494  f331				  -	      ifconst	VSCROLL
   4495  f331				  -	      ldy	Xx3,x
   4496  f331				  -	      lda	DLLMEM+11,y
   4497  f331					      else		; !VSCROLL
   4498  f331		       bd 14 f5 	      lda	DLPOINTL,x	;Get pointer to next DL
   4499  f334					      endif		; !VSCROLL
   4500  f334				  -	      ifconst	DOUBLEBUFFER
   4501  f334				  -	      clc
   4502  f334				  -	      adc	doublebufferdloffset
   4503  f334					      endif		; DOUBLEBUFFER
   4504  f334		       85 63		      sta	dlpnt
   4505  f336				  -	      ifconst	VSCROLL
   4506  f336				  -	      lda	DLLMEM+10,y
   4507  f336					      else		; !VSCROLL
   4508  f336		       bd 08 f5 	      lda	DLPOINTH,x
   4509  f339					      endif		; !VSCROLL
   4510  f339				  -	      ifconst	DOUBLEBUFFER
   4511  f339				  -	      adc	#0
   4512  f339					      endif		; DOUBLEBUFFER
   4513  f339		       85 64		      sta	dlpnt+1
   4514  f33b		       b4 65		      ldy	dlend,x	;Get the index to the end of this DL
   4515  f33d
   4516  f33d				  -	      ifconst	CHECKOVERWRITE
   4517  f33d				  -	      cpy	#DLLASTOBJ
   4518  f33d				  -	      bne	continueplotsprite2a
   4519  f33d				  -	      rts
   4520  f33d				  -continueplotsprite2a
   4521  f33d					      endif
   4522  f33d
   4523  f33d		       a5 42		      lda	temp1	; graphic data, lo byte
   4524  f33f		       91 63		      sta	(dlpnt),y
   4525  f341
   4526  f341					      ifnconst	ATOMICSPRITEUPDATE
   4527  f341		       c8		      iny
   4528  f342		       a5 47		      lda	temp6
   4529  f344		       91 63		      sta	(dlpnt),y
   4530  f346				  -	      else
   4531  f346				  -	      iny
   4532  f346				  -	      sty	temp8
   4533  f346					      endif
   4534  f346
   4535  f346		       c8		      iny
   4536  f347
   4537  f347		       a5 46		      lda	temp5	;Y position
   4538  f349		       0b 0f		      anc	#(WZONEHEIGHT - 1)	; undocumented. A=A&IMM, then move bit 7 into carry
   4539  f34b		       05 43		      ora	temp2	; graphic data, hi byte
   4540  f34d		       e9 0f		      sbc	#(WZONEHEIGHT-1)	; start at the DMA hole. -1 because carry is clear
   4541  f34f		       91 63		      sta	(dlpnt),y
   4542  f351
   4543  f351		       c8		      iny
   4544  f352
   4545  f352		       a5 44		      lda	temp3	;palette|width
   4546  f354		       91 63		      sta	(dlpnt),y
   4547  f356
   4548  f356		       c8		      iny
   4549  f357
   4550  f357		       a5 45		      lda	temp4	;Horizontal position
   4551  f359		       91 63		      sta	(dlpnt),y
   4552  f35b
   4553  f35b		       c8		      iny
   4554  f35c		       94 65		      sty	dlend,x
   4555  f35e
   4556  f35e				  -	      ifconst	ALWAYSTERMINATE
   4557  f35e				  -	      iny
   4558  f35e				  -	      lda	#0
   4559  f35e				  -	      sta	(dlpnt),y
   4560  f35e					      endif
   4561  f35e
   4562  f35e				  -	      ifconst	ATOMICSPRITEUPDATE
   4563  f35e				  -	      ldy	temp8
   4564  f35e				  -	      lda	temp6
   4565  f35e				  -	      sta	(dlpnt),y
   4566  f35e					      endif
   4567  f35e
   4568  f35e				   doneSPDL
   4569  f35e		       60		      rts
   4570  f35f
   4571  f35f				  -	      ifconst	VSCROLL
   4572  f35f				  -			; x3 table for fast DLL parsing
   4573  f35f				  -Xx3
   4574  f35f				  -	      .byte	0,3,6,9,12,15,18,21,24,27
   4575  f35f				  -	      .byte	30,33,36,39,42,45,48,51,54,57
   4576  f35f				  -	      .byte	60,63,66,69,72,75,78,81,84,87
   4577  f35f				  -maskscrollsprite
   4578  f35f				  -	      .byte	$00,%11000000,($D0+WZONEHEIGHT),0,160	; 5*2 + 32*3 = 106 cycles
   4579  f35f				  -	      .byte	$00,1,($D0+WZONEHEIGHT),160	; 4*2 + 31*3 = 101 cycles
   4580  f35f				  -	      .byte	$00,1,($D0+WZONEHEIGHT),160	; 4*2 + 31*3 = 101 cycles
   4581  f35f				  -	      .byte	$00,1,($D0+WZONEHEIGHT),160	; 4*2 + 31*3 = 101 cycles
   4582  f35f				  -	      .byte	$00,%01000000,($D0+WZONEHEIGHT),16,160	; 5*2 + 16*3 =  58 cycles
   4583  f35f				  -			; MAX	============ 467 cycles
   4584  f35f				  -			; MIN	============  59 cycles
   4585  f35f				  -maskscrollspriteend
   4586  f35f					      endif		; VSCROLL
   4587  f35f
   4588  f35f				   lockzonex
   4589  f35f				  -	      ifconst	ZONELOCKS
   4590  f35f				  -	      ldy	dlend,x
   4591  f35f				  -	      cpy	#DLLASTOBJ
   4592  f35f				  -	      beq	lockzonexreturn	; the zone is either stuffed or locked. abort!
   4593  f35f				  -	      lda	DLPOINTL,x
   4594  f35f				  -	      ifconst	DOUBLEBUFFER
   4595  f35f				  -	      clc
   4596  f35f				  -	      adc	doublebufferdloffset
   4597  f35f				  -	      endif		; DOUBLEBUFFER
   4598  f35f				  -	      sta	dlpnt
   4599  f35f				  -	      lda	DLPOINTH,x
   4600  f35f				  -	      ifconst	DOUBLEBUFFER
   4601  f35f				  -	      adc	#0
   4602  f35f				  -	      endif		; DOUBLEBUFFER
   4603  f35f				  -	      sta	dlpnt+1
   4604  f35f				  -	      iny
   4605  f35f				  -	      lda	#0
   4606  f35f				  -	      sta	(dlpnt),y
   4607  f35f				  -	      dey
   4608  f35f				  -	      tya
   4609  f35f				  -	      ldy	#(DLLASTOBJ-1)
   4610  f35f				  -	      sta	(dlpnt),y
   4611  f35f				  -	      iny
   4612  f35f				  -	      sty	dlend,x
   4613  f35f				  -lockzonexreturn
   4614  f35f				  -	      rts
   4615  f35f					      endif		; ZONELOCKS
   4616  f35f				   unlockzonex
   4617  f35f				  -	      ifconst	ZONELOCKS
   4618  f35f				  -	      ldy	dlend,x
   4619  f35f				  -	      cpy	#DLLASTOBJ
   4620  f35f				  -	      bne	unlockzonexreturn	; if the zone isn't stuffed, it's not locked. abort!
   4621  f35f				  -	      lda	DLPOINTL,x
   4622  f35f				  -	      ifconst	DOUBLEBUFFER
   4623  f35f				  -	      clc
   4624  f35f				  -	      adc	doublebufferdloffset
   4625  f35f				  -	      endif		; DOUBLEBUFFER
   4626  f35f				  -	      sta	dlpnt
   4627  f35f				  -	      lda	DLPOINTH,x
   4628  f35f				  -	      ifconst	DOUBLEBUFFER
   4629  f35f				  -	      adc	#0
   4630  f35f				  -	      endif		; DOUBLEBUFFER
   4631  f35f				  -	      sta	dlpnt+1
   4632  f35f				  -	      dey
   4633  f35f				  -	      lda	(dlpnt),y
   4634  f35f				  -	      tay
   4635  f35f				  -	      sty	dlend,x
   4636  f35f				  -unlockzonexreturn
   4637  f35f					      endif		; ZONELOCKS
   4638  f35f		       60		      rts
   4639  f360
   4640  f360				   plotcharloop
   4641  f360							; ** read from a data indirectly pointed to from temp8,temp9
   4642  f360							; ** format is: lo_data, hi_data, palette|width, x, y
   4643  f360							; ** format ends with lo_data | hi_data = 0
   4644  f360
   4645  f360				  -	      ifconst	DOUBLEBUFFER
   4646  f360				  -	      lda	doublebufferstate
   4647  f360				  -	      bne	skipplotcharloopwait
   4648  f360					      endif		; DOUBLEBUFFER
   4649  f360				  -	      ifconst	DEBUGWAITCOLOR
   4650  f360				  -	      lda	#$61
   4651  f360				  -	      sta	BACKGRND
   4652  f360					      endif
   4653  f360				   plotcharloopwait
   4654  f360		       a5 4d		      lda	visibleover
   4655  f362		       d0 fc		      bne	plotcharloopwait
   4656  f364				  -	      ifconst	DEBUGWAITCOLOR
   4657  f364				  -	      lda	#0
   4658  f364				  -	      sta	BACKGRND
   4659  f364					      endif
   4660  f364				   skipplotcharloopwait
   4661  f364				   plotcharlooploop
   4662  f364		       a0 00		      ldy	#0
   4663  f366		       b1 49		      lda	(temp8),y
   4664  f368		       85 42		      sta	temp1
   4665  f36a		       c8		      iny
   4666  f36b		       b1 49		      lda	(temp8),y
   4667  f36d		       85 43		      sta	temp2
   4668  f36f		       05 42		      ora	temp1
   4669  f371		       d0 01		      bne	plotcharloopcontinue
   4670  f373							;the pointer=0, so return
   4671  f373		       60		      rts
   4672  f374				   plotcharloopcontinue
   4673  f374		       c8		      iny
   4674  f375		       b1 49		      lda	(temp8),y
   4675  f377		       85 44		      sta	temp3
   4676  f379		       c8		      iny
   4677  f37a		       b1 49		      lda	(temp8),y
   4678  f37c		       85 45		      sta	temp4
   4679  f37e		       c8		      iny
   4680  f37f		       b1 49		      lda	(temp8),y
   4681  f381							;sta temp5 ; not needed with our late entry.
   4682  f381		       20 9a f3 	      jsr	plotcharactersskipentry
   4683  f384		       a5 49		      lda	temp8
   4684  f386		       18		      clc
   4685  f387		       69 05		      adc	#5
   4686  f389		       85 49		      sta	temp8
   4687  f38b		       a5 4a		      lda	temp9
   4688  f38d		       69 00		      adc	#0
   4689  f38f		       85 4a		      sta	temp9
   4690  f391		       4c 64 f3 	      jmp	plotcharlooploop
   4691  f394
   4692  f394				   plotcharacters
   4693  f394				  -	      ifconst	DOUBLEBUFFER
   4694  f394				  -	      lda	doublebufferstate
   4695  f394				  -	      bne	skipplotcharacterswait
   4696  f394					      endif		; DOUBLEBUFFER
   4697  f394				  -	      ifconst	DEBUGWAITCOLOR
   4698  f394				  -	      lda	#$41
   4699  f394				  -	      sta	BACKGRND
   4700  f394					      endif
   4701  f394				   plotcharacterswait
   4702  f394		       a5 4d		      lda	visibleover
   4703  f396		       d0 fc		      bne	plotcharacterswait
   4704  f398				  -	      ifconst	DEBUGWAITCOLOR
   4705  f398				  -	      sta	BACKGRND
   4706  f398					      endif
   4707  f398				   skipplotcharacterswait
   4708  f398							;arguments:
   4709  f398							; temp1=lo charactermap
   4710  f398							; temp2=hi charactermap
   4711  f398							; temp3=palette | width byte
   4712  f398							; temp4=x
   4713  f398							; temp5=y
   4714  f398
   4715  f398		       a5 46		      lda	temp5	;Y position
   4716  f39a
   4717  f39a				   plotcharactersskipentry
   4718  f39a
   4719  f39a							;ifconst ZONEHEIGHT
   4720  f39a							; if ZONEHEIGHT = 16
   4721  f39a							; and #$0F
   4722  f39a							; endif
   4723  f39a							; if ZONEHEIGHT = 8
   4724  f39a							; and #$1F
   4725  f39a							; endif
   4726  f39a							;else
   4727  f39a							; and #$0F
   4728  f39a							;endif
   4729  f39a
   4730  f39a		       aa		      tax
   4731  f39b
   4732  f39b				  -	      ifconst	VSCROLL
   4733  f39b				  -	      ldy	Xx3,x
   4734  f39b				  -	      lda	DLLMEM+11,y
   4735  f39b					      else		; !VSCROLL
   4736  f39b		       bd 14 f5 	      lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   4737  f39e					      endif		; !VSCROLL
   4738  f39e				  -	      ifconst	DOUBLEBUFFER
   4739  f39e				  -	      clc
   4740  f39e				  -	      adc	doublebufferdloffset
   4741  f39e					      endif		; DOUBLEBUFFER
   4742  f39e		       85 63		      sta	dlpnt
   4743  f3a0				  -	      ifconst	VSCROLL
   4744  f3a0				  -	      lda	DLLMEM+10,y
   4745  f3a0					      else		; !VSCROLL
   4746  f3a0		       bd 08 f5 	      lda	DLPOINTH,x
   4747  f3a3					      endif		; !VSCROLL
   4748  f3a3				  -	      ifconst	DOUBLEBUFFER
   4749  f3a3				  -	      adc	#0
   4750  f3a3					      endif		; DOUBLEBUFFER
   4751  f3a3		       85 64		      sta	dlpnt+1
   4752  f3a5
   4753  f3a5							;Create DL entry for the characters
   4754  f3a5
   4755  f3a5		       b4 65		      ldy	dlend,x	;Get the index to the end of this DL
   4756  f3a7
   4757  f3a7				  -	      ifconst	CHECKOVERWRITE
   4758  f3a7				  -	      cpy	#DLLASTOBJ
   4759  f3a7				  -	      bne	continueplotcharacters
   4760  f3a7				  -	      rts
   4761  f3a7				  -continueplotcharacters
   4762  f3a7					      endif
   4763  f3a7
   4764  f3a7		       a5 42		      lda	temp1	; character map data, lo byte
   4765  f3a9		       91 63		      sta	(dlpnt),y	;(1) store low address
   4766  f3ab
   4767  f3ab		       c8		      iny
   4768  f3ac		       ad 06 21 	      lda	charactermode
   4769  f3af		       91 63		      sta	(dlpnt),y	;(2) store mode
   4770  f3b1
   4771  f3b1		       c8		      iny
   4772  f3b2		       a5 43		      lda	temp2	; character map, hi byte
   4773  f3b4		       91 63		      sta	(dlpnt),y	;(3) store high address
   4774  f3b6
   4775  f3b6		       c8		      iny
   4776  f3b7		       a5 44		      lda	temp3	;palette|width
   4777  f3b9		       91 63		      sta	(dlpnt),y	;(4) store palette|width
   4778  f3bb
   4779  f3bb		       c8		      iny
   4780  f3bc		       a5 45		      lda	temp4	;Horizontal position
   4781  f3be		       91 63		      sta	(dlpnt),y	;(5) store horizontal position
   4782  f3c0
   4783  f3c0		       c8		      iny
   4784  f3c1		       94 65		      sty	dlend,x	; save display list end byte
   4785  f3c3		       60		      rts
   4786  f3c4
   4787  f3c4
   4788  f3c4				  -	      ifconst	plotvalueonscreen
   4789  f3c4				  -plotcharacterslive
   4790  f3c4				  -			; a version of plotcharacters that draws live and minimally disrupts the screen...
   4791  f3c4				  -
   4792  f3c4				  -			;arguments:
   4793  f3c4				  -			; temp1=lo charactermap
   4794  f3c4				  -			; temp2=hi charactermap
   4795  f3c4				  -			; temp3=palette | width byte
   4796  f3c4				  -			; temp4=x
   4797  f3c4				  -			; temp5=y
   4798  f3c4				  -
   4799  f3c4				  -	      lda	temp5	;Y position
   4800  f3c4				  -
   4801  f3c4				  -	      tax
   4802  f3c4				  -
   4803  f3c4				  -	      ifconst	VSCROLL
   4804  f3c4				  -	      ldy	Xx3,x
   4805  f3c4				  -	      lda	DLLMEM+11,y
   4806  f3c4				  -	      else		; !VSCROLL
   4807  f3c4				  -	      lda	DLPOINTL,x	;Get pointer to DL that the characters are in
   4808  f3c4				  -	      endif		; !VSCROLL
   4809  f3c4				  -	      ifconst	DOUBLEBUFFER
   4810  f3c4				  -	      clc
   4811  f3c4				  -	      adc	doublebufferdloffset
   4812  f3c4				  -	      endif		; DOUBLEBUFFER
   4813  f3c4				  -	      sta	dlpnt
   4814  f3c4				  -	      ifconst	VSCROLL
   4815  f3c4				  -	      lda	DLLMEM+10,y
   4816  f3c4				  -	      else		; !VSCROLL
   4817  f3c4				  -	      lda	DLPOINTH,x
   4818  f3c4				  -	      endif		; !VSCROLL
   4819  f3c4				  -	      ifconst	DOUBLEBUFFER
   4820  f3c4				  -	      adc	#0
   4821  f3c4				  -	      endif		; DOUBLEBUFFER
   4822  f3c4				  -	      sta	dlpnt+1
   4823  f3c4				  -
   4824  f3c4				  -			;Create DL entry for the characters
   4825  f3c4				  -
   4826  f3c4				  -	      ldy	dlend,x	;Get the index to the end of this DL
   4827  f3c4				  -
   4828  f3c4				  -	      ifconst	CHECKOVERWRITE
   4829  f3c4				  -	      cpy	#DLLASTOBJ
   4830  f3c4				  -	      bne	continueplotcharacterslive
   4831  f3c4				  -	      rts
   4832  f3c4				  -continueplotcharacterslive
   4833  f3c4				  -	      endif
   4834  f3c4				  -
   4835  f3c4				  -	      lda	temp1	; character map data, lo byte
   4836  f3c4				  -	      sta	(dlpnt),y	;(1) store low address
   4837  f3c4				  -
   4838  f3c4				  -	      iny
   4839  f3c4				  -			; we don't add the second byte yet, since the charmap could briefly
   4840  f3c4				  -			; render without a proper character map address, width, or position.
   4841  f3c4				  -	      lda	charactermode
   4842  f3c4				  -	      sta	(dlpnt),y	;(2) store mode
   4843  f3c4				  -
   4844  f3c4				  -	      iny
   4845  f3c4				  -	      lda	temp2	; character map, hi byte
   4846  f3c4				  -	      sta	(dlpnt),y	;(3) store high address
   4847  f3c4				  -
   4848  f3c4				  -	      iny
   4849  f3c4				  -	      lda	temp3	;palette|width
   4850  f3c4				  -	      sta	(dlpnt),y	;(4) store palette|width
   4851  f3c4				  -
   4852  f3c4				  -	      iny
   4853  f3c4				  -	      lda	temp4	;Horizontal position
   4854  f3c4				  -	      sta	(dlpnt),y	;(5) store horizontal position
   4855  f3c4				  -
   4856  f3c4				  -	      iny
   4857  f3c4				  -	      sty	dlend,x	; save display list end byte
   4858  f3c4				  -
   4859  f3c4				  -	      rts
   4860  f3c4					      endif		;plotcharacterslive
   4861  f3c4
   4862  f3c4				  -	      ifconst	USED_PLOTVALUE
   4863  f3c4				  -plotvalue
   4864  f3c4				  -			; calling 7800basic command:
   4865  f3c4				  -			; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   4866  f3c4				  -			; ...displays the variable as BCD digits
   4867  f3c4				  -			;
   4868  f3c4				  -			; asm sub arguments:
   4869  f3c4				  -			; temp1=lo charactermap
   4870  f3c4				  -			; temp2=hi charactermap
   4871  f3c4				  -			; temp3=palette | width byte
   4872  f3c4				  -			; temp4=x
   4873  f3c4				  -			; temp5=y
   4874  f3c4				  -			; temp6=number of digits
   4875  f3c4				  -			; temp7=lo variable
   4876  f3c4				  -			; temp8=hi variable
   4877  f3c4				  -			; temp9=character mode
   4878  f3c4				  -
   4879  f3c4				  -plotdigitcount =	temp6
   4880  f3c4				  -
   4881  f3c4				  -	      ifconst	ZONELOCKS
   4882  f3c4				  -	      ldx	temp5
   4883  f3c4				  -	      ldy	dlend,x
   4884  f3c4				  -	      cpy	#DLLASTOBJ
   4885  f3c4				  -	      bne	carryonplotvalue
   4886  f3c4				  -	      rts
   4887  f3c4				  -carryonplotvalue
   4888  f3c4				  -	      endif
   4889  f3c4				  -
   4890  f3c4				  -	      lda	#0
   4891  f3c4				  -	      tay
   4892  f3c4				  -	      ldx	valbufend
   4893  f3c4				  -
   4894  f3c4				  -	      lda	plotdigitcount
   4895  f3c4				  -	      and	#1
   4896  f3c4				  -	      beq	pvnibble2char
   4897  f3c4				  -	      lda	#0
   4898  f3c4				  -	      sta	VALBUFFER,x	; just in case we skip this digit
   4899  f3c4				  -	      beq	pvnibble2char_skipnibble
   4900  f3c4				  -
   4901  f3c4				  -pvnibble2char
   4902  f3c4				  -			; high nibble...
   4903  f3c4				  -	      lda	(temp7),y
   4904  f3c4				  -	      and	#$f0
   4905  f3c4				  -	      lsr
   4906  f3c4				  -	      lsr
   4907  f3c4				  -	      lsr
   4908  f3c4				  -	      ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   4909  f3c4				  -	      lsr
   4910  f3c4				  -	      endif
   4911  f3c4				  -
   4912  f3c4				  -	      clc
   4913  f3c4				  -	      adc	temp1	; add the offset to character graphics to our value
   4914  f3c4				  -	      sta	VALBUFFER,x
   4915  f3c4				  -	      inx
   4916  f3c4				  -	      dec	plotdigitcount
   4917  f3c4				  -
   4918  f3c4				  -pvnibble2char_skipnibble
   4919  f3c4				  -			; low nibble...
   4920  f3c4				  -	      lda	(temp7),y
   4921  f3c4				  -	      and	#$0f
   4922  f3c4				  -	      ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   4923  f3c4				  -	      asl
   4924  f3c4				  -	      endif
   4925  f3c4				  -	      clc
   4926  f3c4				  -	      adc	temp1	; add the offset to character graphics to our value
   4927  f3c4				  -	      sta	VALBUFFER,x
   4928  f3c4				  -	      inx
   4929  f3c4				  -	      iny
   4930  f3c4				  -
   4931  f3c4				  -	      dec	plotdigitcount
   4932  f3c4				  -	      bne	pvnibble2char
   4933  f3c4				  -
   4934  f3c4				  -			;point to the start of our valuebuffer
   4935  f3c4				  -	      clc
   4936  f3c4				  -	      lda	#<VALBUFFER
   4937  f3c4				  -	      adc	valbufend
   4938  f3c4				  -	      sta	temp1
   4939  f3c4				  -	      lda	#>VALBUFFER
   4940  f3c4				  -	      adc	#0
   4941  f3c4				  -	      sta	temp2
   4942  f3c4				  -
   4943  f3c4				  -			;advance valbufend to the end of our value buffer
   4944  f3c4				  -	      stx	valbufend
   4945  f3c4				  -
   4946  f3c4				  -	      ifnconst	plotvalueonscreen
   4947  f3c4				  -	      jmp	plotcharacters
   4948  f3c4				  -	      else
   4949  f3c4				  -	      jmp	plotcharacterslive
   4950  f3c4				  -	      endif
   4951  f3c4				  -
   4952  f3c4					      endif		; USED_PLOTVALUE
   4953  f3c4
   4954  f3c4
   4955  f3c4				  -	      ifconst	USED_PLOTVALUEEXTRA
   4956  f3c4				  -plotdigitcount =	temp6
   4957  f3c4				  -plotvalueextra
   4958  f3c4				  -			; calling 7800basic command:
   4959  f3c4				  -			; plotvalue digit_gfx palette variable/data number_of_digits screen_x screen_y
   4960  f3c4				  -			; ...displays the variable as BCD digits
   4961  f3c4				  -			;
   4962  f3c4				  -			; asm sub arguments:
   4963  f3c4				  -			; temp1=lo charactermap
   4964  f3c4				  -			; temp2=hi charactermap
   4965  f3c4				  -			; temp3=palette | width byte
   4966  f3c4				  -			; temp4=x
   4967  f3c4				  -			; temp5=y
   4968  f3c4				  -			; temp6=number of digits
   4969  f3c4				  -			; temp7=lo variable
   4970  f3c4				  -			; temp8=hi variable
   4971  f3c4				  -
   4972  f3c4				  -	      lda	#0
   4973  f3c4				  -	      tay
   4974  f3c4				  -	      ldx	valbufend
   4975  f3c4				  -	      ifnconst	plotvalueonscreen
   4976  f3c4				  -	      sta	VALBUFFER,x
   4977  f3c4				  -	      endif
   4978  f3c4				  -
   4979  f3c4				  -	      lda	plotdigitcount
   4980  f3c4				  -	      and	#1
   4981  f3c4				  -
   4982  f3c4				  -	      bne	pvnibble2char_skipnibbleextra
   4983  f3c4				  -
   4984  f3c4				  -pvnibble2charextra
   4985  f3c4				  -			; high nibble...
   4986  f3c4				  -	      lda	(temp7),y
   4987  f3c4				  -	      and	#$f0
   4988  f3c4				  -	      lsr
   4989  f3c4				  -	      lsr
   4990  f3c4				  -	      ifnconst	DOUBLEWIDE	; multiply value by 2 for double-width
   4991  f3c4				  -	      lsr
   4992  f3c4				  -	      endif
   4993  f3c4				  -	      clc
   4994  f3c4				  -	      adc	temp1	; add the offset to character graphics to our value
   4995  f3c4				  -	      sta	VALBUFFER,x
   4996  f3c4				  -	      inx
   4997  f3c4				  -
   4998  f3c4				  -			; second half of the digit
   4999  f3c4				  -	      clc
   5000  f3c4				  -	      adc	#1
   5001  f3c4				  -	      sta	VALBUFFER,x
   5002  f3c4				  -	      inx
   5003  f3c4				  -	      dec	plotdigitcount
   5004  f3c4				  -
   5005  f3c4				  -pvnibble2char_skipnibbleextra
   5006  f3c4				  -			; low nibble...
   5007  f3c4				  -	      lda	(temp7),y
   5008  f3c4				  -	      and	#$0f
   5009  f3c4				  -	      ifconst	DOUBLEWIDE	; multiply value by 2 for double-width
   5010  f3c4				  -	      asl
   5011  f3c4				  -	      endif
   5012  f3c4				  -	      asl
   5013  f3c4				  -
   5014  f3c4				  -	      clc
   5015  f3c4				  -	      adc	temp1	; add the offset to character graphics to our value
   5016  f3c4				  -	      sta	VALBUFFER,x
   5017  f3c4				  -	      inx
   5018  f3c4				  -
   5019  f3c4				  -	      clc
   5020  f3c4				  -	      adc	#1
   5021  f3c4				  -	      sta	VALBUFFER,x
   5022  f3c4				  -	      inx
   5023  f3c4				  -	      iny
   5024  f3c4				  -
   5025  f3c4				  -	      dec	plotdigitcount
   5026  f3c4				  -	      bne	pvnibble2charextra
   5027  f3c4				  -
   5028  f3c4				  -			;point to the start of our valuebuffer
   5029  f3c4				  -	      clc
   5030  f3c4				  -	      lda	#<VALBUFFER
   5031  f3c4				  -	      adc	valbufend
   5032  f3c4				  -	      sta	temp1
   5033  f3c4				  -	      lda	#>VALBUFFER
   5034  f3c4				  -	      adc	#0
   5035  f3c4				  -	      sta	temp2
   5036  f3c4				  -
   5037  f3c4				  -			;advance valbufend to the end of our value buffer
   5038  f3c4				  -	      stx	valbufend
   5039  f3c4				  -
   5040  f3c4				  -	      ifnconst	plotvalueonscreen
   5041  f3c4				  -	      jmp	plotcharacters
   5042  f3c4				  -	      else
   5043  f3c4				  -	      jmp	plotcharacterslive
   5044  f3c4				  -	      endif
   5045  f3c4					      endif		; USED_PLOTVALUEEXTRA
   5046  f3c4
   5047  f3c4				   boxcollision
   5048  f3c4				  -	      ifconst	BOXCOLLISION
   5049  f3c4				  -			; the worst case cycle-time for the code below is 43 cycles.
   5050  f3c4				  -			; unfortunately, prior to getting here we've burned 44 cycles in argument setup. eep!
   5051  f3c4				  -
   5052  f3c4				  -			;__boxx1 = accumulator
   5053  f3c4				  -			;__boxy1 = y
   5054  f3c4				  -__boxw1    =	temp3
   5055  f3c4				  -__boxh1    =	temp4
   5056  f3c4				  -
   5057  f3c4				  -__boxx2    =	temp5
   5058  f3c4				  -__boxy2    =	temp6
   5059  f3c4				  -__boxw2    =	temp7
   5060  f3c4				  -__boxh2    =	temp8
   5061  f3c4				  -
   5062  f3c4				  -DoXCollisionCheck
   5063  f3c4				  -			;lda __boxx1 ; skipped. already in the accumulator
   5064  f3c4				  -	      cmp	__boxx2	;3
   5065  f3c4				  -	      bcs	X1isbiggerthanX2	;2/3
   5066  f3c4				  -X2isbiggerthanX1
   5067  f3c4				  -			; carry is clear
   5068  f3c4				  -	      adc	__boxw1	;3
   5069  f3c4				  -	      cmp	__boxx2	;3
   5070  f3c4				  -	      bcs	DoYCollisionCheck	;3/2
   5071  f3c4				  -	      rts		;6 - carry clear, no collision
   5072  f3c4				  -X1isbiggerthanX2
   5073  f3c4				  -	      clc		;2
   5074  f3c4				  -	      sbc	__boxw2	;3
   5075  f3c4				  -	      cmp	__boxx2	;3
   5076  f3c4				  -	      bcs	noboxcollision	;3/2
   5077  f3c4				  -DoYCollisionCheck
   5078  f3c4				  -	      tya		; 2 ; use to be "lda __boxy1"
   5079  f3c4				  -	      cmp	__boxy2	;3
   5080  f3c4				  -	      bcs	Y1isbiggerthanY2	;3/2
   5081  f3c4				  -Y2isbiggerthanY1
   5082  f3c4				  -			; carry is clear
   5083  f3c4				  -	      adc	__boxh1	;3
   5084  f3c4				  -	      cmp	__boxy2	;3
   5085  f3c4				  -	      rts		;6
   5086  f3c4				  -Y1isbiggerthanY2
   5087  f3c4				  -	      clc		;2
   5088  f3c4				  -	      sbc	__boxh2	;3
   5089  f3c4				  -	      cmp	__boxy2	;3
   5090  f3c4				  -	      bcs	noboxcollision	;3/2
   5091  f3c4				  -yesboxcollision
   5092  f3c4				  -	      sec		;2
   5093  f3c4				  -	      rts		;6
   5094  f3c4				  -noboxcollision
   5095  f3c4				  -	      clc		;2
   5096  f3c4				  -	      rts		;6
   5097  f3c4					      endif		; BOXCOLLISION
   5098  f3c4
   5099  f3c4				   randomize
   5100  f3c4		       a5 40		      lda	rand
   5101  f3c6		       4a		      lsr
   5102  f3c7		       26 41		      rol	rand16
   5103  f3c9		       90 02		      bcc	noeor
   5104  f3cb		       49 b4		      eor	#$B4
   5105  f3cd				   noeor
   5106  f3cd		       85 40		      sta	rand
   5107  f3cf		       45 41		      eor	rand16
   5108  f3d1		       60		      rts
   5109  f3d2
   5110  f3d2							; *** bcd conversion routine courtesy Omegamatrix
   5111  f3d2							; *** http://atariage.com/forums/blog/563/entry-10832-hex-to-bcd-conversion-0-99/
   5112  f3d2				  -	      ifconst	.calledfunction_converttobcd
   5113  f3d2				  -converttobcd
   5114  f3d2				  -			;value to convert is in the accumulator
   5115  f3d2				  -	      sta	temp1
   5116  f3d2				  -	      lsr
   5117  f3d2				  -	      adc	temp1
   5118  f3d2				  -	      ror
   5119  f3d2				  -	      lsr
   5120  f3d2				  -	      lsr
   5121  f3d2				  -	      adc	temp1
   5122  f3d2				  -	      ror
   5123  f3d2				  -	      adc	temp1
   5124  f3d2				  -	      ror
   5125  f3d2				  -	      lsr
   5126  f3d2				  -	      and	#$3C
   5127  f3d2				  -	      sta	temp2
   5128  f3d2				  -	      lsr
   5129  f3d2				  -	      adc	temp2
   5130  f3d2				  -	      adc	temp1
   5131  f3d2				  -	      rts		; return the result in the accumulator
   5132  f3d2					      endif		; .calledfunction_converttobcd
   5133  f3d2
   5134  f3d2				  -	      ifconst	.calledfunction_mul8
   5135  f3d2				  -			; Y and A contain multiplicands, result in A
   5136  f3d2				  -mul8
   5137  f3d2				  -	      sty	temp1
   5138  f3d2				  -	      sta	temp2
   5139  f3d2				  -	      lda	#0
   5140  f3d2				  -reptmul8
   5141  f3d2				  -	      lsr	temp2
   5142  f3d2				  -	      bcc	skipmul8
   5143  f3d2				  -	      clc
   5144  f3d2				  -	      adc	temp1
   5145  f3d2				  -			;bcs donemul8 might save cycles?
   5146  f3d2				  -skipmul8
   5147  f3d2				  -			;beq donemul8 might save cycles?
   5148  f3d2				  -	      asl	temp1
   5149  f3d2				  -	      bne	reptmul8
   5150  f3d2				  -donemul8
   5151  f3d2				  -	      rts
   5152  f3d2					      endif		; .calledfunction_mul8
   5153  f3d2
   5154  f3d2				  -	      ifconst	.calledfunction_div8
   5155  f3d2				  -div8
   5156  f3d2				  -			; A=numerator Y=denominator, result in A
   5157  f3d2				  -	      cpy	#2
   5158  f3d2				  -	      bcc	div8end+1	;div by 0 = bad, div by 1=no calc needed, so bail out
   5159  f3d2				  -	      sty	temp1
   5160  f3d2				  -	      ldy	#$ff
   5161  f3d2				  -div8loop
   5162  f3d2				  -	      sbc	temp1
   5163  f3d2				  -	      iny
   5164  f3d2				  -	      bcs	div8loop
   5165  f3d2				  -div8end
   5166  f3d2				  -	      tya
   5167  f3d2				  -			; result in A
   5168  f3d2				  -	      rts
   5169  f3d2					      endif		; .calledfunction_div8
   5170  f3d2
   5171  f3d2				  -	      ifconst	.calledfunction_mul16
   5172  f3d2				  -			; Y and A contain multiplicands, result in temp2,A=low, temp1=high
   5173  f3d2				  -mul16
   5174  f3d2				  -	      sty	temp1
   5175  f3d2				  -	      sta	temp2
   5176  f3d2				  -
   5177  f3d2				  -	      lda	#0
   5178  f3d2				  -	      ldx	#8
   5179  f3d2				  -	      lsr	temp1
   5180  f3d2				  -mul16_1
   5181  f3d2				  -	      bcc	mul16_2
   5182  f3d2				  -	      clc
   5183  f3d2				  -	      adc	temp2
   5184  f3d2				  -mul16_2
   5185  f3d2				  -	      ror
   5186  f3d2				  -	      ror	temp1
   5187  f3d2				  -	      dex
   5188  f3d2				  -	      bne	mul16_1
   5189  f3d2				  -	      sta	temp2
   5190  f3d2				  -	      rts
   5191  f3d2					      endif		; .calledfunction_mul16
   5192  f3d2
   5193  f3d2				  -	      ifconst	.calledfunction_div16
   5194  f3d2				  -			; div int/int
   5195  f3d2				  -			; numerator in A, denom in temp1
   5196  f3d2				  -			; returns with quotient in A, remainder in temp1
   5197  f3d2				  -div16
   5198  f3d2				  -	      sta	temp2
   5199  f3d2				  -	      sty	temp1
   5200  f3d2				  -	      lda	#0
   5201  f3d2				  -	      ldx	#8
   5202  f3d2				  -	      asl	temp2
   5203  f3d2				  -div16_1
   5204  f3d2				  -	      rol
   5205  f3d2				  -	      cmp	temp1
   5206  f3d2				  -	      bcc	div16_2
   5207  f3d2				  -	      sbc	temp1
   5208  f3d2				  -div16_2
   5209  f3d2				  -	      rol	temp2
   5210  f3d2				  -	      dex
   5211  f3d2				  -	      bne	div16_1
   5212  f3d2				  -	      sta	temp1
   5213  f3d2				  -	      lda	temp2
   5214  f3d2				  -	      rts
   5215  f3d2					      endif		; .calledfunction_div16
   5216  f3d2
   5217  f3d2				  -	      ifconst	bankswitchmode
   5218  f3d2				  -BS_jsr
   5219  f3d2				  -	      ifconst	dumpbankswitch
   5220  f3d2				  -	      sta	dumpbankswitch
   5221  f3d2				  -	      endif
   5222  f3d2				  -	      ifconst	MCPDEVCART
   5223  f3d2				  -	      ora	#$18
   5224  f3d2				  -	      sta	$3000
   5225  f3d2				  -	      else
   5226  f3d2				  -	      sta	$8000
   5227  f3d2				  -	      endif
   5228  f3d2				  -	      pla
   5229  f3d2				  -	      tax
   5230  f3d2				  -	      pla
   5231  f3d2				  -	      rts
   5232  f3d2				  -
   5233  f3d2				  -BS_return
   5234  f3d2				  -	      pla		; bankswitch bank
   5235  f3d2				  -	      ifconst	dumpbankswitch
   5236  f3d2				  -	      sta	dumpbankswitch
   5237  f3d2				  -	      endif
   5238  f3d2				  -	      ifconst	BANKRAM
   5239  f3d2				  -	      sta	currentbank
   5240  f3d2				  -	      ora	currentrambank
   5241  f3d2				  -	      endif
   5242  f3d2				  -	      ifconst	MCPDEVCART
   5243  f3d2				  -	      ora	#$18
   5244  f3d2				  -	      sta	$3000
   5245  f3d2				  -	      else
   5246  f3d2				  -	      sta	$8000
   5247  f3d2				  -	      endif
   5248  f3d2				  -	      pla		; bankswitch $0 flag
   5249  f3d2				  -	      rts
   5250  f3d2					      endif
   5251  f3d2
   5252  f3d2				   checkselectswitch
   5253  f3d2		       ad 82 02 	      lda	SWCHB	; check the real select switch...
   5254  f3d5		       29 02		      and	#%00000010
   5255  f3d7				   checkselectswitchreturn
   5256  f3d7		       60		      rts
   5257  f3d8
   5258  f3d8				   checkresetswitch
   5259  f3d8		       ad 82 02 	      lda	SWCHB	; check the real reset switch...
   5260  f3db		       29 01		      and	#%00000001
   5261  f3dd		       60		      rts
   5262  f3de
   5263  f3de				  -	      ifconst	FINESCROLLENABLED
   5264  f3de				  -finescrolldlls
   5265  f3de				  -	      ldx	temp1	; first DLL index x3
   5266  f3de				  -	      lda	DLLMEM,x
   5267  f3de				  -	      and	#%11110000
   5268  f3de				  -	      ora	finescrolly
   5269  f3de				  -	      sta	DLLMEM,x
   5270  f3de				  -
   5271  f3de				  -	      ldx	temp2	; last DLL index x3
   5272  f3de				  -	      lda	DLLMEM,x
   5273  f3de				  -	      and	#%11110000
   5274  f3de				  -	      ora	finescrolly
   5275  f3de				  -	      eor	#(WZONEHEIGHT-1)
   5276  f3de				  -	      sta	DLLMEM,x
   5277  f3de				  -	      rts
   5278  f3de					      endif		; FINESCROLLENABLED
   5279  f3de
   5280  f3de				  -	      ifconst	USED_ADJUSTVISIBLE
   5281  f3de				  -adjustvisible
   5282  f3de				  -			; called with temp1=first visible zone *3, temp2=last visible zone *3
   5283  f3de				  -	      jsr	waitforvblankstart	; ensure vblank just started
   5284  f3de				  -	      ldx	visibleDLLstart
   5285  f3de				  -findfirstinterrupt
   5286  f3de				  -	      lda	DLLMEM,x
   5287  f3de				  -	      bmi	foundfirstinterrupt
   5288  f3de				  -	      inx
   5289  f3de				  -	      inx
   5290  f3de				  -	      inx
   5291  f3de				  -	      bne	findfirstinterrupt
   5292  f3de				  -foundfirstinterrupt
   5293  f3de				  -	      and	#%01111111	; clear the interrupt bit
   5294  f3de				  -	      sta	DLLMEM,x
   5295  f3de				  -	      ifconst	DOUBLEBUFFER
   5296  f3de				  -	      sta	DLLMEM+DBOFFSET,x
   5297  f3de				  -	      endif		; DOUBLEBUFFER
   5298  f3de				  -	      ldx	overscanDLLstart
   5299  f3de				  -findlastinterrupt
   5300  f3de				  -	      lda	DLLMEM,x
   5301  f3de				  -	      bmi	foundlastinterrupt
   5302  f3de				  -	      dex
   5303  f3de				  -	      dex
   5304  f3de				  -	      dex
   5305  f3de				  -	      bne	findlastinterrupt
   5306  f3de				  -foundlastinterrupt
   5307  f3de				  -	      and	#%01111111	; clear the interrupt bit
   5308  f3de				  -	      sta	DLLMEM,x
   5309  f3de				  -	      ifconst	DOUBLEBUFFER
   5310  f3de				  -	      sta	DLLMEM+DBOFFSET,x
   5311  f3de				  -	      endif		; DOUBLEBUFFER
   5312  f3de				  -			;now we need to set the new interrupts
   5313  f3de				  -	      clc
   5314  f3de				  -	      lda	temp1
   5315  f3de				  -	      adc	visibleDLLstart
   5316  f3de				  -	      tax
   5317  f3de				  -	      lda	DLLMEM,x
   5318  f3de				  -	      ora	#%10000000
   5319  f3de				  -	      sta	DLLMEM,x
   5320  f3de				  -	      ifconst	DOUBLEBUFFER
   5321  f3de				  -	      sta	DLLMEM+DBOFFSET,x
   5322  f3de				  -	      endif		; DOUBLEBUFFER
   5323  f3de				  -	      clc
   5324  f3de				  -	      lda	temp2
   5325  f3de				  -	      adc	visibleDLLstart
   5326  f3de				  -	      tax
   5327  f3de				  -	      lda	DLLMEM,x
   5328  f3de				  -	      ora	#%10000000
   5329  f3de				  -	      sta	DLLMEM,x
   5330  f3de				  -	      ifconst	DOUBLEBUFFER
   5331  f3de				  -	      sta	DLLMEM+DBOFFSET,x
   5332  f3de				  -	      endif		; DOUBLEBUFFER
   5333  f3de				  -	      jsr	vblankresync
   5334  f3de				  -	      rts
   5335  f3de					      endif		; USED_ADJUSTVISIBLE
   5336  f3de
   5337  f3de				   vblankresync
   5338  f3de		       20 4e f4 	      jsr	waitforvblankstart	; ensure vblank just started
   5339  f3e1		       a9 00		      lda	#0
   5340  f3e3		       85 4d		      sta	visibleover
   5341  f3e5		       a9 03		      lda	#3
   5342  f3e7		       8d b2 01 	      sta	interruptindex
   5343  f3ea		       60		      rts
   5344  f3eb
   5345  f3eb				   createallgamedlls
   5346  f3eb		       a0 3c		      ldy	#(DLLLUTEND-DLLLUT)
   5347  f3ed				   createallgamedllsloop
   5348  f3ed		       88		      dey
   5349  f3ee		       b9 12 f4 	      lda	DLLLUT,y
   5350  f3f1		       99 00 18 	      sta	DLLMEM,y
   5351  f3f4				  -	      ifconst	DOUBLEBUFFER
   5352  f3f4				  -	      sta	DLLMEM+DBOFFSET,y
   5353  f3f4					      endif		; DOUBLEBUFFER
   5354  f3f4		       c0 00		      cpy	#0
   5355  f3f6		       d0 f5		      bne	createallgamedllsloop
   5356  f3f8
   5357  f3f8				  -	      ifconst	DOUBLEBUFFER
   5358  f3f8				  -	      ldy	#(DLLLUTNONVISSTART-DLLLUTVISSTART)
   5359  f3f8				  -fixdoublebuffer
   5360  f3f8				  -	      dey
   5361  f3f8				  -	      lda	DLLMEM+DBOFFSET+DLLLUTVISSTART-DLLLUT,y
   5362  f3f8				  -	      clc
   5363  f3f8				  -	      adc	#DOUBLEBUFFEROFFSET
   5364  f3f8				  -	      sta	DLLMEM+DBOFFSET+DLLLUTVISSTART-DLLLUT,y
   5365  f3f8				  -	      dey
   5366  f3f8				  -	      lda	DLLMEM+DBOFFSET+DLLLUTVISSTART-DLLLUT,y
   5367  f3f8				  -	      adc	#0
   5368  f3f8				  -	      sta	DLLMEM+DBOFFSET+DLLLUTVISSTART-DLLLUT,y
   5369  f3f8				  -	      dey
   5370  f3f8				  -	      bne	fixdoublebuffer
   5371  f3f8					      endif
   5372  f3f8
   5373  f3f8				  -	      ifconst	BANKSET_DL_IN_CARTRAM
   5374  f3f8				  -			; N.B. banksets doesn't in-fact allow DL in cart-ram, so this conditional
   5375  f3f8				  -			; is always skipped. This is here in case some day the limitation is
   5376  f3f8				  -			; worked around, but it's untested.
   5377  f3f8				  -
   5378  f3f8				  -			; With bankset cart ram, we added $8000 to the DL address so plot
   5379  f3f8				  -			; functions would hit the cart-ram write-address. We need to subtract $80
   5380  f3f8				  -			; so Maria will read from the cart-ram read-address.
   5381  f3f8				  -	      ldy	#(DLLLUTNONVISSTART-DLLLUTVISSTART)
   5382  f3f8				  -fixbanksetaddresses
   5383  f3f8				  -	      dey
   5384  f3f8				  -	      dey
   5385  f3f8				  -	      lda	DLLMEM+DLLLUTVISSTART-DLLLUT,y
   5386  f3f8				  -	      and	#%01111111
   5387  f3f8				  -	      sta	DLLMEM+DLLLUTVISSTART-DLLLUT,y
   5388  f3f8				  -	      ifconst	DOUBLEBUFFER
   5389  f3f8				  -	      lda	DLLMEM+DBOFFSET+DLLLUTVISSTART-DLLLUT,y
   5390  f3f8				  -	      and	#%01111111
   5391  f3f8				  -	      sta	DLLMEM+DBOFFSET+DLLLUTVISSTART-DLLLUT,y
   5392  f3f8				  -	      endif		; DOUBLEBUFFER
   5393  f3f8				  -	      dey
   5394  f3f8				  -	      bne	fixbanksetaddresses
   5395  f3f8					      endif		; BANKSET_DL_IN_CARTRAM
   5396  f3f8
   5397  f3f8		       ad 09 21 	      lda	paldetected
   5398  f3fb		       f0 0a		      beq	skippaladjust
   5399  f3fd		       a9 4f		      lda	#($0F|(WZONEHEIGHT*4))	; +15 lines
   5400  f3ff		       8d 06 18 	      sta	DLLMEM+6
   5401  f402				  -	      ifconst	DOUBLEBUFFER
   5402  f402				  -	      sta	DLLMEM+DBOFFSET+6
   5403  f402					      endif
   5404  f402					      if	WSCREENHEIGHT = 192
   5405  f402		       a9 4d		      lda	#($0D|(WZONEHEIGHT*4))	; +6 lines
   5406  f404				  -	      else
   5407  f404				  -	      lda	#($07|(WZONEHEIGHT*4))	; +6 lines
   5408  f404					      endif		;
   5409  f404		       8d 03 18 	      sta	DLLMEM+3
   5410  f407				  -	      ifconst	DOUBLEBUFFER
   5411  f407				  -	      sta	DLLMEM+DBOFFSET+3
   5412  f407					      endif		; DOUBLEBUFFER
   5413  f407
   5414  f407				   skippaladjust
   5415  f407
   5416  f407							; save the DL markers...
   5417  f407		       a9 09		      lda	#(DLLLUTVISSTART-DLLLUT)
   5418  f409		       8d 3c 21 	      sta	visibleDLLstart
   5419  f40c		       a9 2d		      lda	#(DLLLUTNONVISSTART-DLLLUT)
   5420  f40e		       8d 3d 21 	      sta	overscanDLLstart
   5421  f411		       60		      rts
   5422  f412
   5423  f412							; N.B. max DLL length is 112 bytes (for double-buffered)
   5424  f412
   5425  f412				   DLLLUT
   5426  f412					      if	WSCREENHEIGHT = 192
   5427  f412		       4f 21 00 	      .byte.b	($0F|(WZONEHEIGHT*4)),$21,$00	; 16 blank lines
   5428  f415		       47 21 00 	      .byte.b	($07|(WZONEHEIGHT*4)),$21,$00	;  8 blank lines
   5429  f418		       40 21 00 	      .byte.b	($00|(WZONEHEIGHT*4)),$21,$00	;  1 blank lines
   5430  f41b							;=25 blank lines
   5431  f41b					      endif		; WSCREENHEIGHT = 192
   5432  f41b				  -	      if	WSCREENHEIGHT = 208
   5433  f41b				  -	      .byte	($0E|(WZONEHEIGHT*4)),$21,$00	; 15 blank lines
   5434  f41b				  -	      .byte	($00|(WZONEHEIGHT*4)),$21,$00	;  1 blank lines
   5435  f41b				  -	      .byte	($00|(WZONEHEIGHT*4)),$21,$00	;  1 blank lines
   5436  f41b				  -			;=17 blank lines
   5437  f41b					      endif		; WSCREENHEIGHT = 208
   5438  f41b				  -	      if	WSCREENHEIGHT = 224
   5439  f41b				  -	      .byte	($06|(WZONEHEIGHT*4)),$21,$00	;  7 blank lines
   5440  f41b				  -	      .byte	($00|(WZONEHEIGHT*4)),$21,$00	;  1 blank lines
   5441  f41b				  -	      .byte	($00|(WZONEHEIGHT*4)),$21,$00	;  1 blank lines
   5442  f41b				  -			;= 9 blank lines
   5443  f41b					      endif		; WSCREENHEIGHT = 224
   5444  f41b
   5445  f41b				   DLLLUTVISSTART
   5446  f41b		       cf 18 80 	      .byte.b	($80|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE0ADDRESS,<ZONE0ADDRESS
   5447  f41e							;	 ^--NMI 1: start of visible
   5448  f41e		       4f 19 20 	      .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE1ADDRESS,<ZONE1ADDRESS
   5449  f421		       4f 19 c0 	      .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE2ADDRESS,<ZONE2ADDRESS
   5450  f424		       4f 1a 60 	      .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE3ADDRESS,<ZONE3ADDRESS
   5451  f427		       4f 1b 00 	      .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE4ADDRESS,<ZONE4ADDRESS
   5452  f42a		       4f 1b a0 	      .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE5ADDRESS,<ZONE5ADDRESS
   5453  f42d		       4f 1c 40 	      .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE6ADDRESS,<ZONE6ADDRESS
   5454  f430		       4f 1c e0 	      .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE7ADDRESS,<ZONE7ADDRESS
   5455  f433		       4f 1d 80 	      .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE8ADDRESS,<ZONE8ADDRESS
   5456  f436		       4f 1e 20 	      .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE9ADDRESS,<ZONE9ADDRESS
   5457  f439		       4f 1e c0 	      .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE10ADDRESS,<ZONE10ADDRESS
   5458  f43c		       4f 1f 60 	      .byte.b	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE11ADDRESS,<ZONE11ADDRESS
   5459  f43f				  -	      ifconst	ZONE12ADDRESS
   5460  f43f				  -	      .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE12ADDRESS,<ZONE12ADDRESS
   5461  f43f					      endif
   5462  f43f				  -	      ifconst	ZONE13ADDRESS
   5463  f43f				  -	      .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE13ADDRESS,<ZONE13ADDRESS
   5464  f43f					      endif
   5465  f43f				  -	      ifconst	ZONE14ADDRESS
   5466  f43f				  -	      .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE14ADDRESS,<ZONE14ADDRESS
   5467  f43f					      endif
   5468  f43f				  -	      ifconst	ZONE15ADDRESS
   5469  f43f				  -	      .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE15ADDRESS,<ZONE15ADDRESS
   5470  f43f					      endif
   5471  f43f				  -	      ifconst	ZONE16ADDRESS
   5472  f43f				  -	      .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE16ADDRESS,<ZONE16ADDRESS
   5473  f43f					      endif
   5474  f43f				  -	      ifconst	ZONE17ADDRESS
   5475  f43f				  -	      .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE17ADDRESS,<ZONE17ADDRESS
   5476  f43f					      endif
   5477  f43f				  -	      ifconst	ZONE18ADDRESS
   5478  f43f				  -	      .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE18ADDRESS,<ZONE18ADDRESS
   5479  f43f					      endif
   5480  f43f				  -	      ifconst	ZONE19ADDRESS
   5481  f43f				  -	      .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE19ADDRESS,<ZONE19ADDRESS
   5482  f43f					      endif
   5483  f43f				  -	      ifconst	ZONE20ADDRESS
   5484  f43f				  -	      .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE20ADDRESS,<ZONE20ADDRESS
   5485  f43f					      endif
   5486  f43f				  -	      ifconst	ZONE21ADDRESS
   5487  f43f				  -	      .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE21ADDRESS,<ZONE21ADDRESS
   5488  f43f					      endif
   5489  f43f				  -	      ifconst	ZONE22ADDRESS
   5490  f43f				  -	      .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE22ADDRESS,<ZONE22ADDRESS
   5491  f43f					      endif
   5492  f43f				  -	      ifconst	ZONE23ADDRESS
   5493  f43f				  -	      .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE23ADDRESS,<ZONE23ADDRESS
   5494  f43f					      endif
   5495  f43f				  -	      ifconst	ZONE24ADDRESS
   5496  f43f				  -	      .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE24ADDRESS,<ZONE24ADDRESS
   5497  f43f					      endif
   5498  f43f				  -	      ifconst	ZONE25ADDRESS
   5499  f43f				  -	      .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE25ADDRESS,<ZONE25ADDRESS
   5500  f43f					      endif
   5501  f43f				  -	      ifconst	ZONE26ADDRESS
   5502  f43f				  -	      .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE26ADDRESS,<ZONE26ADDRESS
   5503  f43f					      endif
   5504  f43f				  -	      ifconst	ZONE27ADDRESS
   5505  f43f				  -	      .byte	($00|(WZONEHEIGHT*4)|(WZONEHEIGHT-1)),>ZONE27ADDRESS,<ZONE27ADDRESS
   5506  f43f					      endif
   5507  f43f				   DLLLUTNONVISSTART
   5508  f43f		       c3 21 00 	      .byte.b	($83|(WZONEHEIGHT*4)),$21,$00	;  4 blank lines
   5509  f442							;	 ^--NMI 2: start of non-visible
   5510  f442		       cf 21 00 	      .byte.b	($8F|(WZONEHEIGHT*4)),$21,$00	; 16 blank lines
   5511  f445							;	 ^--NMI 3: start of overscan
   5512  f445		       4f 21 00 	      .byte.b	($0F|(WZONEHEIGHT*4)),$21,$00	; 16 blank lines
   5513  f448		       4f 21 00 	      .byte.b	($0F|(WZONEHEIGHT*4)),$21,$00	; 16 blank lines
   5514  f44b		       4f 21 00 	      .byte.b	($0F|(WZONEHEIGHT*4)),$21,$00	; 16 blank lines
   5515  f44e				   DLLLUTEND
   5516  f44e							;echo "DLL size: ",[(DLLLUTEND-DLLLUT)]d,"bytes"
   5517  f44e							;echo "DLL code size: ",[(DLLLUTEND-createallgamedlls)]d,"bytes"
   5518  f44e
   5519  f44e				   waitforvblankstart
   5520  f44e				   vblankendwait
   5521  f44e		       24 28		      BIT	MSTAT
   5522  f450		       30 fc		      bmi	vblankendwait
   5523  f452				   vblankstartwait
   5524  f452		       24 28		      BIT	MSTAT
   5525  f454		       10 fc		      bpl	vblankstartwait
   5526  f456		       60		      rts
   5527  f457
   5528  f457				  -	      ifconst	DOUBLEBUFFER
   5529  f457				  -flipdisplaybufferreturn
   5530  f457				  -	      rts
   5531  f457				  -flipdisplaybuffer
   5532  f457				  -	      ifconst	interrupthold
   5533  f457				  -	      lda	#$FF
   5534  f457				  -	      sta	interrupthold
   5535  f457				  -	      endif
   5536  f457				  -	      lda	doublebufferstate
   5537  f457				  -	      beq	flipdisplaybufferreturn	; exit if we're not in double-buffer
   5538  f457				  -
   5539  f457				  -	      jsr	terminatedisplaybuffer	; terminate the working buffer before we flip
   5540  f457				  -
   5541  f457				  -			; ensure we don't flip mid-display. otherwise the displayed DL will be the one the game is working on.
   5542  f457				  -
   5543  f457				  -flipdisplaybufferwait1
   5544  f457				  -	      lda	visibleover
   5545  f457				  -	      beq	flipdisplaybufferwait1
   5546  f457				  -
   5547  f457				  -flipdisplaybufferwait
   5548  f457				  -	      lda	visibleover
   5549  f457				  -	      bne	flipdisplaybufferwait
   5550  f457				  -
   5551  f457				  -quickbufferflip
   5552  f457				  -	      lda	doublebufferstate
   5553  f457				  -	      lsr		; /2, so we'll see 0 or 1, rather than 1 or 3
   5554  f457				  -	      tax
   5555  f457				  -
   5556  f457				  -	      lda	doublebufferminimumframetarget
   5557  f457				  -	      beq	skipminimumframecode
   5558  f457				  -	      lda	doublebufferminimumframeindex
   5559  f457				  -	      bne	flipdisplaybufferwait1
   5560  f457				  -	      lda	doublebufferminimumframetarget
   5561  f457				  -	      sta	doublebufferminimumframeindex
   5562  f457				  -skipminimumframecode
   5563  f457				  -
   5564  f457				  -	      lda	DLLMEMLutHi,x
   5565  f457				  -	      sta	DPPH
   5566  f457				  -	      lda	DLLMEMLutLo,x
   5567  f457				  -	      sta	DPPL
   5568  f457				  -
   5569  f457				  -	      lda	NewPageflipstate,x
   5570  f457				  -	      sta	doublebufferstate
   5571  f457				  -	      lda	NewPageflipoffset,x
   5572  f457				  -	      sta	doublebufferdloffset
   5573  f457				  -
   5574  f457				  -	      ifnconst	BANKSET_DL_IN_CARTRAM
   5575  f457				  -	      lda	doublebufferbufferdirty
   5576  f457				  -	      beq	flipdisplaybufferreturn
   5577  f457				  -
   5578  f457				  -			; The doublebuffer buffer is dirty, so the game code must have issued a savescreen recently.
   5579  f457				  -			; To make savescreen work with the new working buffer, we need to copy over the saved objects
   5580  f457				  -			; from the displayed buffer to the working buffer...
   5581  f457				  -
   5582  f457				  -	      lda	doublebufferdloffset
   5583  f457				  -	      eor	#DOUBLEBUFFEROFFSET
   5584  f457				  -	      sta	temp6	; make temp6 the anti-doublebufferdloffset variable
   5585  f457				  -
   5586  f457				  -	      ldx	#(WZONECOUNT-1)
   5587  f457				  -copybufferzoneloop
   5588  f457				  -
   5589  f457				  -	      lda	DLPOINTL,x
   5590  f457				  -	      clc
   5591  f457				  -	      adc	doublebufferdloffset
   5592  f457				  -	      sta	temp1
   5593  f457				  -	      lda	DLPOINTH,x
   5594  f457				  -	      adc	#0
   5595  f457				  -	      sta	temp2
   5596  f457				  -
   5597  f457				  -	      lda	DLPOINTL,x
   5598  f457				  -	      clc
   5599  f457				  -	      adc	temp6
   5600  f457				  -	      sta	temp3
   5601  f457				  -	      lda	DLPOINTH,x
   5602  f457				  -	      adc	#0
   5603  f457				  -	      sta	temp4
   5604  f457				  -
   5605  f457				  -	      lda	dlendsave,x
   5606  f457				  -	      tay
   5607  f457				  -copybuffercharsloop
   5608  f457				  -	      lda	(temp3),y
   5609  f457				  -	      sta	(temp1),y
   5610  f457				  -	      dey
   5611  f457				  -	      bpl	copybuffercharsloop
   5612  f457				  -	      dex
   5613  f457				  -	      bpl	copybufferzoneloop
   5614  f457				  -	      lda	#0
   5615  f457				  -	      sta	doublebufferbufferdirty
   5616  f457				  -	      endif		; ! BANKSET_DL_IN_CARTRAM
   5617  f457				  -	      rts
   5618  f457				  -
   5619  f457				  -doublebufferoff
   5620  f457				  -	      lda	#1
   5621  f457				  -	      sta	doublebufferstate
   5622  f457				  -	      jsr	flipdisplaybuffer
   5623  f457				  -	      lda	#0
   5624  f457				  -	      sta	doublebufferstate
   5625  f457				  -	      sta	doublebufferdloffset
   5626  f457				  -	      rts
   5627  f457				  -
   5628  f457				  -DLLMEMLutLo
   5629  f457				  -	      .byte	<DLLMEM,<(DLLMEM+DBOFFSET)
   5630  f457				  -DLLMEMLutHi
   5631  f457				  -	      .byte	>DLLMEM,>(DLLMEM+DBOFFSET)
   5632  f457				  -NewPageflipstate
   5633  f457				  -	      .byte	3,1
   5634  f457				  -NewPageflipoffset
   5635  f457				  -	      .byte	DOUBLEBUFFEROFFSET,0
   5636  f457				  -
   5637  f457					      endif		; DOUBLEBUFFER
   5638  f457
   5639  f457				  -	      ifconst	MOUSESUPPORT
   5640  f457				  -
   5641  f457				  -rotationalcompare
   5642  f457				  -			; old = 00 01 10 11
   5643  f457				  -	      .byte	$00, $01, $ff, $00	; new=00
   5644  f457				  -	      .byte	$ff, $00, $00, $01	; new=01
   5645  f457				  -	      .byte	$01, $00, $00, $ff	; new=10
   5646  f457				  -	      .byte	$00, $ff, $01, $00	; new=11
   5647  f457				  -
   5648  f457				  -			; 0000YyXx st mouse
   5649  f457				  -
   5650  f457				  -			; 0000xyXY amiga mouse
   5651  f457				  -
   5652  f457				  -	      ifconst	MOUSEXONLY
   5653  f457				  -amigatoataribits		; swap bits 1 and 4...
   5654  f457				  -	      .byte	%0000, %0000, %0010, %0010
   5655  f457				  -	      .byte	%0000, %0000, %0010, %0010
   5656  f457				  -	      .byte	%0001, %0001, %0011, %0011
   5657  f457				  -	      .byte	%0001, %0001, %0011, %0011
   5658  f457				  -
   5659  f457				  -			; null change bits
   5660  f457				  -	      .byte	%0000, %0001, %0010, %0011
   5661  f457				  -	      .byte	%0000, %0001, %0010, %0011
   5662  f457				  -	      .byte	%0000, %0001, %0010, %0011
   5663  f457				  -	      .byte	%0000, %0001, %0010, %0011
   5664  f457				  -
   5665  f457				  -	      else		; !MOUSEXONLY
   5666  f457				  -
   5667  f457				  -amigatoataribits		; swap bits 1 and 4...
   5668  f457				  -	      .byte	%0000, %1000, %0010, %1010
   5669  f457				  -	      .byte	%0100, %1100, %0110, %1110
   5670  f457				  -	      .byte	%0001, %1001, %0011, %1011
   5671  f457				  -	      .byte	%0101, %1101, %0111, %1111
   5672  f457				  -			; null change bits
   5673  f457				  -	      .byte	%0000, %0001, %0010, %0011
   5674  f457				  -	      .byte	%0100, %0101, %0110, %0111
   5675  f457				  -	      .byte	%1000, %1001, %1010, %1011
   5676  f457				  -	      .byte	%1100, %1101, %1110, %1111
   5677  f457				  -	      endif		; !MOUSEXONLY
   5678  f457				  -
   5679  f457					      endif		; MOUSESUPPORT
   5680  f457
   5681  f457				   mouse0update
   5682  f457				  -	      ifconst	MOUSE0SUPPORT
   5683  f457				  -
   5684  f457				  -mousetableselect =	inttemp2
   5685  f457				  -mousexdelta =	inttemp3
   5686  f457				  -mouseydelta =	inttemp4
   5687  f457				  -lastSWCHA  =	inttemp6
   5688  f457				  -
   5689  f457				  -			; 0000YyXx st mouse
   5690  f457				  -			; 0000xyXY amiga mouse
   5691  f457				  -
   5692  f457				  -	      lda	#$ff
   5693  f457				  -	      sta	lastSWCHA
   5694  f457				  -
   5695  f457				  -	      ldy	port0control
   5696  f457				  -
   5697  f457				  -	      lda	#%00010000
   5698  f457				  -	      cpy	#9	; AMIGA?
   5699  f457				  -	      bne	skipamigabitsfix0
   5700  f457				  -	      lda	#0
   5701  f457				  -skipamigabitsfix0
   5702  f457				  -	      sta	mousetableselect
   5703  f457				  -	      ifconst	DRIVINGBOOST
   5704  f457				  -	      cpy	#6	; DRIVING?
   5705  f457				  -	      bne	skipdriving0setup
   5706  f457				  -			; swap mousex0 and mousey0. mousex seen by the 7800basic program
   5707  f457				  -			; trails the actual mousex0, so we can smoothly interpolate toward
   5708  f457				  -			; the actual position. This actual position is stored in mousey0
   5709  f457				  -			; after the driver has run.
   5710  f457				  -	      ldx	mousex0
   5711  f457				  -	      lda	mousey0
   5712  f457				  -	      stx	mousey0
   5713  f457				  -	      sta	mousex0
   5714  f457				  -skipdriving0setup
   5715  f457				  -	      endif		; DRIVINGBOOST
   5716  f457				  -
   5717  f457				  -	      lda	#0
   5718  f457				  -	      sta	mousexdelta
   5719  f457				  -	      sta	mouseydelta
   5720  f457				  -
   5721  f457				  -	      ifnconst	MOUSETIME
   5722  f457				  -	      ifnconst	MOUSEXONLY
   5723  f457				  -	      lda	#180	; minimum for x+y
   5724  f457				  -	      else
   5725  f457				  -	      lda	#100	; minimum for just x
   5726  f457				  -	      endif
   5727  f457				  -	      else
   5728  f457				  -	      lda	#MOUSETIME
   5729  f457				  -	      endif
   5730  f457				  -	      jsr	SETTIM64T	; INTIM is in Y
   5731  f457				  -
   5732  f457				  -mouse0updateloop
   5733  f457				  -	      lda	SWCHA
   5734  f457				  -	      asr	#%11110000	; Undocumented. A = A & #IMM, then LSR A.
   5735  f457				  -	      cmp	lastSWCHA
   5736  f457				  -	      beq	mouse0loopcondition
   5737  f457				  -	      sta	lastSWCHA
   5738  f457				  -	      lsr
   5739  f457				  -	      lsr
   5740  f457				  -	      lsr
   5741  f457				  -
   5742  f457				  -	      ora	mousetableselect	; atari/amiga decoding table selection
   5743  f457				  -
   5744  f457				  -			; st mice encode on different bits/joystick-lines than amiga mice...
   5745  f457				  -			; 0000YyXx st mouse
   5746  f457				  -			; 0000xyXY amiga mouse
   5747  f457				  -			; ...so can shuffle the amiga bits to reuse the st driver.
   5748  f457				  -	      tay
   5749  f457				  -	      lax	amigatoataribits,y
   5750  f457				  -
   5751  f457				  -	      ifnconst	MOUSEXONLY
   5752  f457				  -			; first the Y...
   5753  f457				  -	      and	#%00001100
   5754  f457				  -	      ora	mousecodey0
   5755  f457				  -	      tay
   5756  f457				  -	      lda	rotationalcompare,y
   5757  f457				  -	      clc
   5758  f457				  -	      adc	mouseydelta
   5759  f457				  -	      sta	mouseydelta
   5760  f457				  -	      tya
   5761  f457				  -	      lsr
   5762  f457				  -	      lsr
   5763  f457				  -	      sta	mousecodey0
   5764  f457				  -	      txa
   5765  f457				  -			; ...then the X...
   5766  f457				  -	      and	#%00000011
   5767  f457				  -	      tax
   5768  f457				  -	      endif		; !MOUSEXONLY
   5769  f457				  -
   5770  f457				  -	      asl
   5771  f457				  -	      asl
   5772  f457				  -	      ora	mousecodex0
   5773  f457				  -	      tay
   5774  f457				  -	      lda	rotationalcompare,y
   5775  f457				  -	      adc	mousexdelta	; carry was clear by previous ASL
   5776  f457				  -	      sta	mousexdelta
   5777  f457				  -	      stx	mousecodex0
   5778  f457				  -mouse0loopcondition
   5779  f457				  -	      lda	TIMINT
   5780  f457				  -	      bpl	mouse0updateloop
   5781  f457				  -
   5782  f457				  -			; *** adapt to selected device resolution.
   5783  f457				  -	      ldx	port0control
   5784  f457				  -
   5785  f457				  -	      ifconst	PRECISIONMOUSING
   5786  f457				  -	      ldy	port0resolution
   5787  f457				  -	      bne	mouse0halveddone
   5788  f457				  -	      cpx	#6	; half-resolution is no good for driving wheels
   5789  f457				  -	      beq	mouse0halveddone
   5790  f457				  -			; resolution=0 is half mouse resolution, necessary for precision
   5791  f457				  -			; mousing on a 160x240 screen with a 1000 dpi mouse.
   5792  f457				  -
   5793  f457				  -	      lda	mousexdelta
   5794  f457				  -	      cmp	#$80
   5795  f457				  -	      ror		; do a signed divide by 2.
   5796  f457				  -	      clc
   5797  f457				  -	      adc	mousex0
   5798  f457				  -	      sta	mousex0
   5799  f457				  -	      ifnconst	MOUSEXONLY
   5800  f457				  -	      lda	mouseydelta
   5801  f457				  -	      clc
   5802  f457				  -	      adc	mousey0
   5803  f457				  -	      sta	mousey0
   5804  f457				  -	      endif
   5805  f457				  -			; at half resolution we just exit after updating x and y
   5806  f457				  -	      jmp	LLRET0
   5807  f457				  -mouse0halveddone
   5808  f457				  -	      endif		; PRECISIONMOUSING
   5809  f457				  -
   5810  f457				  -	      ifnconst	MOUSEXONLY
   5811  f457				  -	      asl	mouseydelta	; *2 because Y resolution is finer
   5812  f457				  -	      ldy	port0resolution
   5813  f457				  -	      dey
   5814  f457				  -	      lda	#0
   5815  f457				  -mousey0resolutionfix
   5816  f457				  -	      clc
   5817  f457				  -	      adc	mouseydelta
   5818  f457				  -	      dey
   5819  f457				  -	      bpl	mousey0resolutionfix
   5820  f457				  -	      clc
   5821  f457				  -	      adc	mousey0
   5822  f457				  -	      sta	mousey0
   5823  f457				  -	      endif		; MOUSEXONLY
   5824  f457				  -
   5825  f457				  -	      ldy	port0resolution
   5826  f457				  -	      dey
   5827  f457				  -	      lda	#0
   5828  f457				  -mousex0resolutionfix
   5829  f457				  -	      clc
   5830  f457				  -	      adc	mousexdelta
   5831  f457				  -	      dey
   5832  f457				  -	      bpl	mousex0resolutionfix
   5833  f457				  -	      ifnconst	DRIVINGBOOST
   5834  f457				  -	      clc
   5835  f457				  -	      adc	mousex0
   5836  f457				  -	      sta	mousex0
   5837  f457				  -	      else
   5838  f457				  -	      cpx	#6
   5839  f457				  -	      beq	carryonmouse0boost
   5840  f457				  -	      clc
   5841  f457				  -	      adc	mousex0
   5842  f457				  -	      sta	mousex0
   5843  f457				  -	      jmp	LLRET0
   5844  f457				  -carryonmouse0boost
   5845  f457				  -	      sta	mousexdelta
   5846  f457				  -	      clc
   5847  f457				  -	      adc	mousecodey0
   5848  f457				  -	      sta	mousecodey0
   5849  f457				  -	      clc
   5850  f457				  -	      adc	mousex0
   5851  f457				  -	      tay		; save the target X
   5852  f457				  -	      adc	mousey0	; average in the smoothly-trailing X
   5853  f457				  -	      ror
   5854  f457				  -	      sta	mousex0	; mousex0 now has the smoothly trailing X
   5855  f457				  -	      sty	mousey0	; and mousey0 has the the target X
   5856  f457				  -
   5857  f457				  -			; check to see if the coordinate wrapped. If so, undo the averaging code.
   5858  f457				  -			; A has mousex0, the smoothly trailing X
   5859  f457				  -	      sbc	mousey0	; less the target X
   5860  f457				  -	      bpl	skipabsolutedrive0
   5861  f457				  -	      eor	#$ff
   5862  f457				  -skipabsolutedrive0
   5863  f457				  -	      cmp	#64	; just an unreasonably large change
   5864  f457				  -	      bcc	skipdrivewrapfix0
   5865  f457				  -	      sty	mousex0	; if X wrapped, we catch the trailing X up to the target X
   5866  f457				  -skipdrivewrapfix0
   5867  f457				  -
   5868  f457				  -			; get rid of the tweening if the distance travelled was very small
   5869  f457				  -	      lda	mousexdelta
   5870  f457				  -	      cmp	port0resolution
   5871  f457				  -	      bcs	skipbetweenfix0
   5872  f457				  -	      lda	mousex0
   5873  f457				  -	      sta	mousey0
   5874  f457				  -skipbetweenfix0
   5875  f457				  -
   5876  f457				  -drivingboostreductioncheck0
   5877  f457				  -			; The below code amounts to mousecodey0=mousecodey0-(mousecodey0/8)
   5878  f457				  -			; +ve mousecodey0 is converted to -ve to do the calculation, and then
   5879  f457				  -			; negated again because truncation during BCD math results in
   5880  f457				  -			; differing magnitudes, depending if the value is +ve or -ve.
   5881  f457				  -driving0fix
   5882  f457				  -	      lax	mousecodey0
   5883  f457				  -	      cmp	#$80
   5884  f457				  -	      bcs	driving0skipnegate1
   5885  f457				  -	      eor	#$FF
   5886  f457				  -	      adc	#1
   5887  f457				  -	      sta	mousecodey0
   5888  f457				  -driving0skipnegate1
   5889  f457				  -	      cmp	#$80
   5890  f457				  -	      ror
   5891  f457				  -	      cmp	#$80
   5892  f457				  -	      ror
   5893  f457				  -	      cmp	#$80
   5894  f457				  -	      ror
   5895  f457				  -	      sta	inttemp1
   5896  f457				  -	      lda	mousecodey0
   5897  f457				  -	      sec
   5898  f457				  -	      sbc	inttemp1
   5899  f457				  -	      cpx	#$80
   5900  f457				  -	      bcs	driving0skipnegate2
   5901  f457				  -	      eor	#$FF
   5902  f457				  -	      adc	#1
   5903  f457				  -driving0skipnegate2
   5904  f457				  -	      sta	mousecodey0
   5905  f457				  -drivingboostdone0
   5906  f457				  -	      endif		; DRIVINGBOOST
   5907  f457				  -
   5908  f457				  -	      jmp	LLRET0
   5909  f457				  -
   5910  f457					      endif		; MOUSE0SUPPORT
   5911  f457
   5912  f457				   mouse1update
   5913  f457				  -	      ifconst	MOUSE1SUPPORT
   5914  f457				  -
   5915  f457				  -mousetableselect =	inttemp2
   5916  f457				  -mousexdelta =	inttemp3
   5917  f457				  -mouseydelta =	inttemp4
   5918  f457				  -lastSWCHA  =	inttemp6
   5919  f457				  -
   5920  f457				  -			; 0000YyXx st mouse
   5921  f457				  -			; 0000xyXY amiga mouse
   5922  f457				  -
   5923  f457				  -	      lda	#$ff
   5924  f457				  -	      sta	lastSWCHA
   5925  f457				  -
   5926  f457				  -	      ldy	port1control
   5927  f457				  -
   5928  f457				  -	      lda	#%00010000
   5929  f457				  -	      cpy	#9	; AMIGA?
   5930  f457				  -	      bne	skipamigabitsfix1
   5931  f457				  -	      lda	#0
   5932  f457				  -skipamigabitsfix1
   5933  f457				  -	      sta	mousetableselect
   5934  f457				  -	      ifconst	DRIVINGBOOST
   5935  f457				  -	      cpy	#6	; DRIVING?
   5936  f457				  -	      bne	skipdriving1setup
   5937  f457				  -			; swap mousex1 and mousey1. mousex seen by the 7800basic program
   5938  f457				  -			; trails the actual mousex1, so we can smoothly interpolate toward
   5939  f457				  -			; the actual position. This actual position is stored in mousey1
   5940  f457				  -			; after the driver has run.
   5941  f457				  -	      ldx	mousex1
   5942  f457				  -	      lda	mousey1
   5943  f457				  -	      stx	mousey1
   5944  f457				  -	      sta	mousex1
   5945  f457				  -skipdriving1setup
   5946  f457				  -	      endif		; DRIVINGBOOST
   5947  f457				  -
   5948  f457				  -	      lda	#0
   5949  f457				  -	      sta	mousexdelta
   5950  f457				  -	      sta	mouseydelta
   5951  f457				  -
   5952  f457				  -	      ifnconst	MOUSETIME
   5953  f457				  -	      ifnconst	MOUSEXONLY
   5954  f457				  -	      lda	#180	; minimum for x+y
   5955  f457				  -	      else
   5956  f457				  -	      lda	#100	; minimum for just x
   5957  f457				  -	      endif
   5958  f457				  -	      else
   5959  f457				  -	      lda	#MOUSETIME
   5960  f457				  -	      endif
   5961  f457				  -	      jsr	SETTIM64T	; INTIM is in Y
   5962  f457				  -
   5963  f457				  -mouse1updateloop
   5964  f457				  -	      lda	SWCHA
   5965  f457				  -	      and	#%00001111
   5966  f457				  -	      cmp	lastSWCHA
   5967  f457				  -	      beq	mouse1loopcondition
   5968  f457				  -	      sta	lastSWCHA
   5969  f457				  -
   5970  f457				  -	      ora	mousetableselect	; atari/amiga decoding table selection
   5971  f457				  -
   5972  f457				  -			; st mice encode on different bits/joystick-lines than amiga mice...
   5973  f457				  -			; 0000YyXx st mouse
   5974  f457				  -			; 0000xyXY amiga mouse
   5975  f457				  -			; ...so can shuffle the amiga bits to reuse the st driver.
   5976  f457				  -	      tay
   5977  f457				  -	      lax	amigatoataribits,y
   5978  f457				  -
   5979  f457				  -	      ifnconst	MOUSEXONLY
   5980  f457				  -			; first the Y...
   5981  f457				  -	      and	#%00001100
   5982  f457				  -	      ora	mousecodey1
   5983  f457				  -	      tay
   5984  f457				  -	      lda	rotationalcompare,y
   5985  f457				  -	      clc
   5986  f457				  -	      adc	mouseydelta
   5987  f457				  -	      sta	mouseydelta
   5988  f457				  -	      tya
   5989  f457				  -	      lsr
   5990  f457				  -	      lsr
   5991  f457				  -	      sta	mousecodey1
   5992  f457				  -	      txa
   5993  f457				  -			; ...then the X...
   5994  f457				  -	      and	#%00000011
   5995  f457				  -	      tax
   5996  f457				  -	      endif		; !MOUSEXONLY
   5997  f457				  -
   5998  f457				  -	      asl
   5999  f457				  -	      asl
   6000  f457				  -	      ora	mousecodex1
   6001  f457				  -	      tay
   6002  f457				  -	      lda	rotationalcompare,y
   6003  f457				  -	      adc	mousexdelta	; carry was clear by previous ASL
   6004  f457				  -	      sta	mousexdelta
   6005  f457				  -	      stx	mousecodex1
   6006  f457				  -mouse1loopcondition
   6007  f457				  -	      lda	TIMINT
   6008  f457				  -	      bpl	mouse1updateloop
   6009  f457				  -
   6010  f457				  -			; *** adapt to selected device resolution.
   6011  f457				  -	      ldx	port1control
   6012  f457				  -
   6013  f457				  -	      ifconst	PRECISIONMOUSING
   6014  f457				  -	      ldy	port1resolution
   6015  f457				  -	      bne	mouse1halveddone
   6016  f457				  -	      cpx	#6	; half-resolution is no good for driving wheels
   6017  f457				  -	      beq	mouse1halveddone
   6018  f457				  -			; resolution=0 is half mouse resolution, necessary for precision
   6019  f457				  -			; mousing on a 160x240 screen with a 1000 dpi mouse.
   6020  f457				  -
   6021  f457				  -	      lda	mousexdelta
   6022  f457				  -	      cmp	#$80
   6023  f457				  -	      ror		; do a signed divide by 2.
   6024  f457				  -	      clc
   6025  f457				  -	      adc	mousex1
   6026  f457				  -	      sta	mousex1
   6027  f457				  -	      ifnconst	MOUSEXONLY
   6028  f457				  -	      lda	mouseydelta
   6029  f457				  -	      clc
   6030  f457				  -	      adc	mousey1
   6031  f457				  -	      sta	mousey1
   6032  f457				  -	      endif
   6033  f457				  -			; at half resolution we just exit after updating x and y
   6034  f457				  -	      jmp	LLRET1
   6035  f457				  -mouse1halveddone
   6036  f457				  -	      endif		; PRECISIONMOUSING
   6037  f457				  -
   6038  f457				  -	      ifnconst	MOUSEXONLY
   6039  f457				  -	      asl	mouseydelta	; *2 because Y resolution is finer
   6040  f457				  -	      ldy	port1resolution
   6041  f457				  -	      dey
   6042  f457				  -	      lda	#0
   6043  f457				  -mousey1resolutionfix
   6044  f457				  -	      clc
   6045  f457				  -	      adc	mouseydelta
   6046  f457				  -	      dey
   6047  f457				  -	      bpl	mousey1resolutionfix
   6048  f457				  -	      clc
   6049  f457				  -	      adc	mousey1
   6050  f457				  -	      sta	mousey1
   6051  f457				  -	      endif		; MOUSEXONLY
   6052  f457				  -
   6053  f457				  -	      ldy	port1resolution
   6054  f457				  -	      dey
   6055  f457				  -	      lda	#0
   6056  f457				  -mousex1resolutionfix
   6057  f457				  -	      clc
   6058  f457				  -	      adc	mousexdelta
   6059  f457				  -	      dey
   6060  f457				  -	      bpl	mousex1resolutionfix
   6061  f457				  -	      ifnconst	DRIVINGBOOST
   6062  f457				  -	      clc
   6063  f457				  -	      adc	mousex1
   6064  f457				  -	      sta	mousex1
   6065  f457				  -	      else
   6066  f457				  -	      cpx	#6
   6067  f457				  -	      beq	carryonmouse1boost
   6068  f457				  -	      clc
   6069  f457				  -	      adc	mousex1
   6070  f457				  -	      sta	mousex1
   6071  f457				  -	      jmp	LLRET1
   6072  f457				  -carryonmouse1boost
   6073  f457				  -	      sta	mousexdelta
   6074  f457				  -	      clc
   6075  f457				  -	      adc	mousecodey1
   6076  f457				  -	      sta	mousecodey1
   6077  f457				  -	      clc
   6078  f457				  -	      adc	mousex1
   6079  f457				  -	      tay		; save the target X
   6080  f457				  -	      adc	mousey1	; average in the smoothly-trailing X
   6081  f457				  -	      ror
   6082  f457				  -	      sta	mousex1	; mousex0 now has the smoothly trailing X
   6083  f457				  -	      sty	mousey1	; and mousey0 has the the target X
   6084  f457				  -
   6085  f457				  -			; check to see if the coordinate wrapped. If so, undo the averaging code.
   6086  f457				  -			; A has mousex1, the smoothly trailing X
   6087  f457				  -	      sbc	mousey1	; less the target X
   6088  f457				  -	      bpl	skipabsolutedrive1
   6089  f457				  -	      eor	#$ff
   6090  f457				  -skipabsolutedrive1
   6091  f457				  -	      cmp	#64	; just an unreasonably large change
   6092  f457				  -	      bcc	skipdrivewrapfix1
   6093  f457				  -	      sty	mousex1	; if X wrapped, we catch the trailing X up to the target X
   6094  f457				  -skipdrivewrapfix1
   6095  f457				  -
   6096  f457				  -			; get rid of the tweening if the distance travelled was very small
   6097  f457				  -	      lda	mousexdelta
   6098  f457				  -	      cmp	port1resolution
   6099  f457				  -	      bcs	skipbetweenfix1
   6100  f457				  -	      lda	mousex1
   6101  f457				  -	      sta	mousey1
   6102  f457				  -skipbetweenfix1
   6103  f457				  -
   6104  f457				  -drivingboostreductioncheck1
   6105  f457				  -			; The below code amounts to mousecodey0=mousecodey0-(mousecodey0/8)
   6106  f457				  -			; +ve mousecodey0 is converted to -ve to do the calculation, and then
   6107  f457				  -			; negated again because truncation during BCD math results in
   6108  f457				  -			; differing magnitudes, depending if the value is +ve or -ve.
   6109  f457				  -driving1fix
   6110  f457				  -	      lax	mousecodey1
   6111  f457				  -	      cmp	#$80
   6112  f457				  -	      bcs	driving0skipnegate1
   6113  f457				  -	      eor	#$FF
   6114  f457				  -	      adc	#1
   6115  f457				  -	      sta	mousecodey1
   6116  f457				  -driving0skipnegate1
   6117  f457				  -	      cmp	#$80
   6118  f457				  -	      ror
   6119  f457				  -	      cmp	#$80
   6120  f457				  -	      ror
   6121  f457				  -	      cmp	#$80
   6122  f457				  -	      ror
   6123  f457				  -	      sta	inttemp1
   6124  f457				  -	      lda	mousecodey1
   6125  f457				  -	      sec
   6126  f457				  -	      sbc	inttemp1
   6127  f457				  -	      cpx	#$80
   6128  f457				  -	      bcs	driving1skipnegate2
   6129  f457				  -	      eor	#$FF
   6130  f457				  -	      adc	#1
   6131  f457				  -driving1skipnegate2
   6132  f457				  -	      sta	mousecodey1
   6133  f457				  -drivingboostdone1
   6134  f457				  -	      endif		; DRIVINGBOOST
   6135  f457				  -
   6136  f457				  -	      jmp	LLRET1
   6137  f457				  -
   6138  f457					      endif		; MOUSE1SUPPORT
   6139  f457
   6140  f457
   6141  f457				   trakball0update
   6142  f457				  -	      ifconst	TRAKBALL0SUPPORT
   6143  f457				  -	      ifnconst	TRAKTIME
   6144  f457				  -	      ifnconst	TRAKXONLY
   6145  f457				  -	      lda	#180	; minimum for x+y
   6146  f457				  -	      else		; !TRAKXONLY
   6147  f457				  -	      lda	#100	; minimum for just x
   6148  f457				  -	      endif		; !TRAKXONLY
   6149  f457				  -	      else		; !TRAKTIME
   6150  f457				  -	      lda	#TRAKTIME
   6151  f457				  -	      endif		; !TRAKTIME
   6152  f457				  -	      jsr	SETTIM64T	; INTIM is in Y
   6153  f457				  -	      ldx	#0
   6154  f457				  -	      ifnconst	TRAKXONLY
   6155  f457				  -	      ldy	#0
   6156  f457				  -	      endif		; TRAKXONLY
   6157  f457				  -trakball0updateloop
   6158  f457				  -	      lda	SWCHA
   6159  f457				  -	      and	#%00110000
   6160  f457				  -	      cmp	trakballcodex0
   6161  f457				  -	      sta	trakballcodex0
   6162  f457				  -	      beq	trakball0movementXdone
   6163  f457				  -	      and	#%00010000
   6164  f457				  -	      beq	trakball0negativeX
   6165  f457				  -trakball0positiveX
   6166  f457				  -			;(2 from beq)
   6167  f457				  -	      inx		; 2
   6168  f457				  -	      jmp	trakball0movementXdone	; 3
   6169  f457				  -trakball0negativeX
   6170  f457				  -			;(3 from beq)
   6171  f457				  -	      dex		; 2
   6172  f457				  -	      nop		; 2
   6173  f457				  -trakball0movementXdone
   6174  f457				  -
   6175  f457				  -	      ifnconst	TRAKXONLY
   6176  f457				  -	      lda	SWCHA
   6177  f457				  -	      and	#%11000000
   6178  f457				  -	      cmp	trakballcodey0
   6179  f457				  -	      sta	trakballcodey0
   6180  f457				  -	      beq	trakball0movementYdone
   6181  f457				  -	      and	#%01000000
   6182  f457				  -	      beq	trakball0negativeY
   6183  f457				  -trakball0positiveY
   6184  f457				  -			;(2 from beq)
   6185  f457				  -	      iny		; 2
   6186  f457				  -	      jmp	trakball0movementYdone	; 3
   6187  f457				  -trakball0negativeY
   6188  f457				  -			;(3 from beq)
   6189  f457				  -	      dey		; 2
   6190  f457				  -	      nop		; 2
   6191  f457				  -trakball0movementYdone
   6192  f457				  -	      endif		; !TRAKXONLY
   6193  f457				  -
   6194  f457				  -	      lda	TIMINT
   6195  f457				  -	      bpl	trakball0updateloop
   6196  f457				  -	      lda	#0
   6197  f457				  -	      cpx	#0
   6198  f457				  -	      beq	trakball0skipXadjust
   6199  f457				  -	      clc
   6200  f457				  -trakball0Xloop
   6201  f457				  -	      adc	port0resolution
   6202  f457				  -	      dex
   6203  f457				  -	      bne	trakball0Xloop
   6204  f457				  -	      clc
   6205  f457				  -	      adc	trakballx0
   6206  f457				  -	      sta	trakballx0
   6207  f457				  -trakball0skipXadjust
   6208  f457				  -	      ifnconst	TRAKXONLY
   6209  f457				  -	      lda	#0
   6210  f457				  -	      cpy	#0
   6211  f457				  -	      beq	trakball0skipYadjust
   6212  f457				  -	      clc
   6213  f457				  -trakball0yloop
   6214  f457				  -	      adc	port0resolution
   6215  f457				  -	      dey
   6216  f457				  -	      bne	trakball0yloop
   6217  f457				  -	      clc
   6218  f457				  -	      adc	trakbally0
   6219  f457				  -	      sta	trakbally0
   6220  f457				  -trakball0skipYadjust
   6221  f457				  -	      endif		; !TRAKXONLY
   6222  f457				  -
   6223  f457				  -	      jmp	LLRET0
   6224  f457					      endif
   6225  f457
   6226  f457
   6227  f457
   6228  f457				   trakball1update
   6229  f457				  -	      ifconst	TRAKBALL1SUPPORT
   6230  f457				  -	      ifnconst	TRAKTIME
   6231  f457				  -	      ifnconst	TRAKXONLY
   6232  f457				  -	      lda	#180	; minimum for x+y
   6233  f457				  -	      else		; !TRAKXONLY
   6234  f457				  -	      lda	#100	; minimum for just x
   6235  f457				  -	      endif		; !TRAKXONLY
   6236  f457				  -	      else		; !TRAKTIME
   6237  f457				  -	      lda	#TRAKTIME
   6238  f457				  -	      endif		; !TRAKTIME
   6239  f457				  -	      jsr	SETTIM64T	; INTIM is in Y
   6240  f457				  -	      ldx	#0
   6241  f457				  -	      ifnconst	TRAKXONLY
   6242  f457				  -	      ldy	#0
   6243  f457				  -	      endif		; TRAKXONLY
   6244  f457				  -trakball1updateloop
   6245  f457				  -	      lda	SWCHA
   6246  f457				  -	      and	#%00000011
   6247  f457				  -	      cmp	trakballcodex1
   6248  f457				  -	      sta	trakballcodex1
   6249  f457				  -	      beq	trakball1movementXdone
   6250  f457				  -	      and	#%00000001
   6251  f457				  -	      beq	trakball1negativeX
   6252  f457				  -trakball1positiveX
   6253  f457				  -			;(2 from beq)
   6254  f457				  -	      inx		; 2
   6255  f457				  -	      jmp	trakball1movementXdone	; 3
   6256  f457				  -trakball1negativeX
   6257  f457				  -			;(3 from beq)
   6258  f457				  -	      dex		; 2
   6259  f457				  -	      nop		; 2
   6260  f457				  -trakball1movementXdone
   6261  f457				  -
   6262  f457				  -	      ifnconst	TRAKXONLY
   6263  f457				  -	      lda	SWCHA
   6264  f457				  -	      and	#%00001100
   6265  f457				  -	      cmp	trakballcodey1
   6266  f457				  -	      sta	trakballcodey1
   6267  f457				  -	      beq	trakball1movementYdone
   6268  f457				  -	      and	#%00000100
   6269  f457				  -	      beq	trakball1negativeY
   6270  f457				  -trakball1positiveY
   6271  f457				  -			;(2 from beq)
   6272  f457				  -	      iny		; 2
   6273  f457				  -	      jmp	trakball1movementYdone	; 3
   6274  f457				  -trakball1negativeY
   6275  f457				  -			;(3 from beq)
   6276  f457				  -	      dey		; 2
   6277  f457				  -	      nop		; 2
   6278  f457				  -trakball1movementYdone
   6279  f457				  -	      endif		; !TRAKXONLY
   6280  f457				  -
   6281  f457				  -	      lda	TIMINT
   6282  f457				  -	      bpl	trakball1updateloop
   6283  f457				  -	      lda	#0
   6284  f457				  -	      cpx	#0
   6285  f457				  -	      beq	trakball1skipXadjust
   6286  f457				  -	      clc
   6287  f457				  -trakball1Xloop
   6288  f457				  -	      adc	port1resolution
   6289  f457				  -	      dex
   6290  f457				  -	      bne	trakball1Xloop
   6291  f457				  -	      clc
   6292  f457				  -	      adc	trakballx1
   6293  f457				  -	      sta	trakballx1
   6294  f457				  -trakball1skipXadjust
   6295  f457				  -	      ifnconst	TRAKXONLY
   6296  f457				  -	      lda	#0
   6297  f457				  -	      cpy	#0
   6298  f457				  -	      beq	trakball1skipYadjust
   6299  f457				  -	      clc
   6300  f457				  -trakball1yloop
   6301  f457				  -	      adc	port1resolution
   6302  f457				  -	      dey
   6303  f457				  -	      bne	trakball1yloop
   6304  f457				  -	      clc
   6305  f457				  -	      adc	trakbally1
   6306  f457				  -	      sta	trakbally1
   6307  f457				  -trakball1skipYadjust
   6308  f457				  -	      endif		; !TRAKXONLY
   6309  f457				  -
   6310  f457				  -	      jmp	LLRET1
   6311  f457					      endif
   6312  f457
   6313  f457
   6314  f457				   paddleport0update
   6315  f457				  -	      ifconst	PADDLE0SUPPORT
   6316  f457				  -	      lda	#6
   6317  f457				  -	      sta	VBLANK	; start charging the paddle caps
   6318  f457				  -	      lda	#0	; use PADDLE timing
   6319  f457				  -	      jsr	SETTIM64T	; INTIM is in Y
   6320  f457				  -
   6321  f457				  -paddleport0updateloop
   6322  f457				  -	      lda	INPT0
   6323  f457				  -	      bmi	skippaddle0setposition
   6324  f457				  -	      sty	paddleposition0
   6325  f457				  -skippaddle0setposition
   6326  f457				  -	      ifconst	TWOPADDLESUPPORT
   6327  f457				  -	      lda	INPT1
   6328  f457				  -	      bmi	skippaddle1setposition
   6329  f457				  -	      sty	paddleposition1
   6330  f457				  -skippaddle1setposition
   6331  f457				  -	      endif
   6332  f457				  -	      ldy	INTIM
   6333  f457				  -	      cpy	#TIMEOFFSET
   6334  f457				  -	      bcs	paddleport0updateloop
   6335  f457				  -
   6336  f457				  -	      lda	#%10000110
   6337  f457				  -	      sta	VBLANK	; dump paddles to ground... this may not be great for genesis controllers
   6338  f457				  -	      sec
   6339  f457				  -	      lda	paddleposition0
   6340  f457				  -	      sbc	#TIMEOFFSET
   6341  f457				  -	      ifconst	PADDLESCALEX2
   6342  f457				  -	      asl
   6343  f457				  -	      endif
   6344  f457				  -
   6345  f457				  -	      ifnconst	PADDLESMOOTHINGOFF
   6346  f457				  -	      clc
   6347  f457				  -	      adc	paddleprevious0
   6348  f457				  -	      ror
   6349  f457				  -	      sta	paddleprevious0
   6350  f457				  -	      endif
   6351  f457				  -
   6352  f457				  -	      sta	paddleposition0
   6353  f457				  -
   6354  f457				  -	      ifconst	TWOPADDLESUPPORT
   6355  f457				  -	      sec
   6356  f457				  -	      lda	paddleposition1
   6357  f457				  -	      sbc	#TIMEOFFSET
   6358  f457				  -	      ifconst	PADDLESCALEX2
   6359  f457				  -	      asl
   6360  f457				  -	      endif
   6361  f457				  -
   6362  f457				  -	      ifnconst	PADDLESMOOTHINGOFF
   6363  f457				  -	      clc
   6364  f457				  -	      adc	paddleprevious1
   6365  f457				  -	      ror
   6366  f457				  -	      sta	paddleprevious1
   6367  f457				  -	      endif
   6368  f457				  -	      sta	paddleposition1
   6369  f457				  -	      endif		; TWOPADDLESUPPORT
   6370  f457				  -
   6371  f457				  -	      jmp	LLRET0
   6372  f457					      endif
   6373  f457
   6374  f457				   paddleport1update
   6375  f457				  -	      ifconst	PADDLE1SUPPORT
   6376  f457				  -	      lda	#6
   6377  f457				  -	      sta	VBLANK	; start charging the paddle caps
   6378  f457				  -
   6379  f457				  -	      lda	#0	; use PADDLE timing
   6380  f457				  -	      jsr	SETTIM64T	; INTIM is in Y
   6381  f457				  -
   6382  f457				  -paddleport1updateloop
   6383  f457				  -	      lda	INPT2
   6384  f457				  -	      bmi	skippaddle2setposition
   6385  f457				  -	      sty	paddleposition2
   6386  f457				  -skippaddle2setposition
   6387  f457				  -	      ifconst	TWOPADDLESUPPORT
   6388  f457				  -	      lda	INPT3
   6389  f457				  -	      bmi	skippaddle3setposition
   6390  f457				  -	      sty	paddleposition3
   6391  f457				  -skippaddle3setposition
   6392  f457				  -	      endif
   6393  f457				  -	      ldy	INTIM
   6394  f457				  -	      cpy	#TIMEOFFSET
   6395  f457				  -	      bcs	paddleport1updateloop
   6396  f457				  -
   6397  f457				  -	      lda	#%10000110
   6398  f457				  -	      sta	VBLANK	; dump paddles to ground... this may not be great for genesis controllers
   6399  f457				  -	      sec
   6400  f457				  -	      lda	paddleposition2
   6401  f457				  -	      sbc	#TIMEOFFSET
   6402  f457				  -	      ifconst	PADDLESCALEX2
   6403  f457				  -	      asl
   6404  f457				  -	      endif
   6405  f457				  -
   6406  f457				  -	      ifnconst	PADDLESMOOTHINGOFF
   6407  f457				  -	      clc
   6408  f457				  -	      adc	paddleprevious2
   6409  f457				  -	      ror
   6410  f457				  -	      sta	paddleprevious2
   6411  f457				  -	      endif
   6412  f457				  -
   6413  f457				  -	      sta	paddleposition2
   6414  f457				  -
   6415  f457				  -	      ifconst	TWOPADDLESUPPORT
   6416  f457				  -	      sec
   6417  f457				  -	      lda	paddleposition3
   6418  f457				  -	      sbc	#TIMEOFFSET
   6419  f457				  -	      ifconst	PADDLESCALEX2
   6420  f457				  -	      asl
   6421  f457				  -	      endif
   6422  f457				  -
   6423  f457				  -	      ifnconst	PADDLESMOOTHINGOFF
   6424  f457				  -	      clc
   6425  f457				  -	      adc	paddleprevious3
   6426  f457				  -	      ror
   6427  f457				  -	      sta	paddleprevious3
   6428  f457				  -	      endif
   6429  f457				  -	      sta	paddleposition3
   6430  f457				  -	      endif		; TWOPADDLESUPPORT
   6431  f457				  -
   6432  f457				  -	      jmp	LLRET1
   6433  f457					      endif
   6434  f457
   6435  f457
   6436  f457				   paddlebuttonhandler		; outside of conditional, for button-handler LUT
   6437  f457				  -	      ifconst	PADDLESUPPORT
   6438  f457				  -			; x=0|1 for port, rather than paddle #.
   6439  f457				  -			; Only the first paddle button will integrate into "joy0fire" testing. If the
   6440  f457				  -			; game wants to support 2 paddles, up to the game to instead test the
   6441  f457				  -			; joystick right+left directions instead.
   6442  f457				  -	      lda	SWCHA	; top of nibble is first paddle button
   6443  f457				  -	      cpx	#0	; port 0?
   6444  f457				  -	      beq	skippaddleport2shift
   6445  f457				  -	      asl		; shift second port to upper nibble
   6446  f457				  -	      asl
   6447  f457				  -	      asl
   6448  f457				  -	      asl
   6449  f457				  -skippaddleport2shift
   6450  f457				  -	      and	#%11000000
   6451  f457				  -	      eor	#%11000000	; invert
   6452  f457				  -	      sta	sINPT1,x
   6453  f457				  -	      jmp	buttonreadloopreturn
   6454  f457					      endif		; PADDLESUPPORT
   6455  f457
   6456  f457				   mousebuttonhandler		; outside of conditional, for button-handler LUT
   6457  f457				  -	      ifconst	MOUSESUPPORT
   6458  f457				  -			; stick the mouse buttons in the correct shadow register...
   6459  f457				  -	      txa
   6460  f457				  -	      asl
   6461  f457				  -	      tay		; y=x*2
   6462  f457				  -	      lda	INPT4,x
   6463  f457				  -	      eor	#%10000000
   6464  f457				  -	      lsr
   6465  f457				  -	      sta	sINPT1,x
   6466  f457				  -
   6467  f457				  -	      lda	INPT1,y
   6468  f457				  -	      and	#%10000000
   6469  f457				  -	      eor	#%10000000
   6470  f457				  -	      ora	sINPT1,x
   6471  f457				  -	      sta	sINPT1,x
   6472  f457				  -	      jmp	buttonreadloopreturn
   6473  f457					      endif		; MOUSESUPPORT
   6474  f457
   6475  f457				  -	      ifconst	KEYPADSUPPORT
   6476  f457				  -			; ** select keypad rows 0 to 3 over 4 frames...
   6477  f457				  -keypadrowselect
   6478  f457				  -	      inc	keypadcounter
   6479  f457				  -	      ldy	#0
   6480  f457				  -	      lda	port0control
   6481  f457				  -	      cmp	#7
   6482  f457				  -	      bne	skipport0val
   6483  f457				  -	      iny		; y=y+1
   6484  f457				  -skipport0val
   6485  f457				  -	      lda	port1control
   6486  f457				  -	      cmp	#7
   6487  f457				  -	      bne	skipport1val
   6488  f457				  -	      iny
   6489  f457				  -	      iny		; y=y+2
   6490  f457				  -skipport1val
   6491  f457				  -	      cpy	#0
   6492  f457				  -	      beq	exitkeypadrowselect
   6493  f457				  -	      lda	keyrowdirectionmask,y
   6494  f457				  -	      sta	CTLSWA
   6495  f457				  -	      tya
   6496  f457				  -	      asl
   6497  f457				  -	      asl
   6498  f457				  -	      sta	inttemp1
   6499  f457				  -	      lda	keypadcounter
   6500  f457				  -	      and	#3
   6501  f457				  -	      ora	inttemp1
   6502  f457				  -	      tax
   6503  f457				  -	      lda	keyrowselectvalue,x
   6504  f457				  -	      sta	SWCHA
   6505  f457				  -exitkeypadrowselect
   6506  f457				  -	      rts
   6507  f457				  -
   6508  f457				  -keyrowdirectionmask
   6509  f457				  -	      .byte	#%00000000	; 0 : port0=input port1=input
   6510  f457				  -	      .byte	#%11110000	; 1 : port0=output port1=input
   6511  f457				  -	      .byte	#%00001111	; 2 : port0=input port1=output
   6512  f457				  -	      .byte	#%11111111	; 3 : port0=output port1=output
   6513  f457				  -
   6514  f457				  -keyrowselectvalue
   6515  f457				  -	      .byte	#%00000000, #%00000000, #%00000000, #%00000000	; no row selected, all pins high, always
   6516  f457				  -	      .byte	#%11100000, #%11010000, #%10110000, #%01110000	; p0 keypad in
   6517  f457				  -	      .byte	#%00001110, #%00001101, #%00001011, #%00000111	; p1 keypad in
   6518  f457				  -	      .byte	#%11101110, #%11011101, #%10111011, #%01110111	; p0+p1 keypads in
   6519  f457					      endif		; KEYPADSUPPORT
   6520  f457
   6521  f457				  -	      ifconst	KEYPADSUPPORT
   6522  f457				  -			; TODO - split into compile-time KEYPAD0SUPPORT and KEYPAD1SUPPORT
   6523  f457				  -keypadcolumnread
   6524  f457				  -	      lda	port0control
   6525  f457				  -	      cmp	#7
   6526  f457				  -	      bne	skipkeypadcolumnread0
   6527  f457				  -	      lda	keypadcounter
   6528  f457				  -	      and	#3
   6529  f457				  -	      asl		; x2 because keypad variables are interleaved
   6530  f457				  -	      tax
   6531  f457				  -	      lda	#0
   6532  f457				  -	      sta	keypadmatrix0a,x
   6533  f457				  -	      lda	INPT0
   6534  f457				  -	      cmp	#$80
   6535  f457				  -	      rol	keypadmatrix0a,x
   6536  f457				  -	      lda	INPT1
   6537  f457				  -	      cmp	#$80
   6538  f457				  -	      rol	keypadmatrix0a,x
   6539  f457				  -	      lda	INPT4
   6540  f457				  -	      cmp	#$80
   6541  f457				  -	      rol	keypadmatrix0a,x
   6542  f457				  -	      lda	keypadmatrix0a,x
   6543  f457				  -	      eor	#%00000111
   6544  f457				  -	      sta	keypadmatrix0a,x
   6545  f457				  -skipkeypadcolumnread0
   6546  f457				  -
   6547  f457				  -	      lda	port1control
   6548  f457				  -	      cmp	#7
   6549  f457				  -	      bne	skipkeypadcolumnread1
   6550  f457				  -	      lda	keypadcounter
   6551  f457				  -	      and	#3
   6552  f457				  -	      asl		; x2 because keypad variables are interleaved
   6553  f457				  -	      tax
   6554  f457				  -	      lda	#0
   6555  f457				  -	      sta	keypadmatrix1a,x
   6556  f457				  -	      rol	keypadmatrix1a,x
   6557  f457				  -	      lda	INPT2
   6558  f457				  -	      cmp	#$80
   6559  f457				  -	      rol	keypadmatrix1a,x
   6560  f457				  -	      lda	INPT3
   6561  f457				  -	      cmp	#$80
   6562  f457				  -	      rol	keypadmatrix1a,x
   6563  f457				  -	      lda	INPT5
   6564  f457				  -	      cmp	#$80
   6565  f457				  -	      rol	keypadmatrix1a,x
   6566  f457				  -	      lda	keypadmatrix1a,x
   6567  f457				  -	      eor	#%00000111
   6568  f457				  -	      sta	keypadmatrix1a,x
   6569  f457				  -skipkeypadcolumnread1
   6570  f457				  -	      rts
   6571  f457					      endif		; KEYPADSUPPORT
   6572  f457
   6573  f457				   setportforinput
   6574  f457		       ad 81 02 	      lda	CTLSWA
   6575  f45a		       3d c2 f1 	      and	SWCHA_DIRMASK,x
   6576  f45d		       8d 81 02 	      sta	CTLSWA
   6577  f460		       60		      rts
   6578  f461
   6579  f461				   setonebuttonmode
   6580  f461		       a9 06		      lda	#6	; in case we're in unlocked-bios mode
   6581  f463		       85 01		      sta	VBLANK	; if we were on paddles, the line is grounded out.
   6582  f465		       a9 14		      lda	#$14
   6583  f467		       8d 83 02 	      sta	CTLSWB
   6584  f46a		       ad 82 02 	      lda	SWCHB
   6585  f46d		       1d 87 f4 	      ora	thisjoy2buttonbit,x	; disable: write 1 to the 2-button bit
   6586  f470		       8d 82 02 	      sta	SWCHB
   6587  f473		       60		      rts
   6588  f474
   6589  f474				   settwobuttonmode
   6590  f474		       a9 06		      lda	#6	; in case we're in unlocked-bios mode
   6591  f476		       85 01		      sta	VBLANK	; if we were on paddles, the line is grounded out.
   6592  f478		       a9 14		      lda	#$14
   6593  f47a		       8d 83 02 	      sta	CTLSWB
   6594  f47d		       ad 82 02 	      lda	SWCHB
   6595  f480		       3d 88 f4 	      and	thisjoy2buttonbit+1,x	; enable: write 0 to the 2-button bit
   6596  f483		       8d 82 02 	      sta	SWCHB
   6597  f486		       60		      rts
   6598  f487
   6599  f487				   thisjoy2buttonbit
   6600  f487							; p0	p1   p0
   6601  f487		       04 10 04 	      .byte.b	$04, $10, $04
   6602  f48a
   6603  f48a				  -	      ifconst	CHANGEDMAHOLES
   6604  f48a				  -removedmaholes
   6605  f48a				  -	      ldx	#0
   6606  f48a				  -removedllholesloop
   6607  f48a				  -	      lda	DLLMEM,x
   6608  f48a				  -	      and	#%10001111
   6609  f48a				  -	      sta	DLLMEM,x
   6610  f48a				  -	      ifconst	DOUBLEBUFFER
   6611  f48a				  -	      sta	DLLMEM+DBOFFSET,x
   6612  f48a				  -	      endif
   6613  f48a				  -	      inx
   6614  f48a				  -	      inx
   6615  f48a				  -	      inx
   6616  f48a				  -	      ifconst	DOUBLEBUFFER
   6617  f48a				  -	      cpx	#DBOFFSET
   6618  f48a				  -	      bcc	removedllholesloop
   6619  f48a				  -	      else
   6620  f48a				  -	      bpl	removedllholesloop
   6621  f48a				  -	      endif
   6622  f48a				  -	      rts
   6623  f48a				  -
   6624  f48a				  -createdmaholes
   6625  f48a				  -	      ldx	#0
   6626  f48a				  -createdllholesloop
   6627  f48a				  -	      lda	DLLMEM,x
   6628  f48a				  -	      ora	#(WZONEHEIGHT*4)
   6629  f48a				  -	      sta	DLLMEM,x
   6630  f48a				  -	      ifconst	DOUBLEBUFFER
   6631  f48a				  -	      sta	DLLMEM+DBOFFSET,x
   6632  f48a				  -	      endif
   6633  f48a				  -	      inx
   6634  f48a				  -	      inx
   6635  f48a				  -	      inx
   6636  f48a				  -	      ifconst	DOUBLEBUFFER
   6637  f48a				  -	      cpx	#DBOFFSET
   6638  f48a				  -	      bcc	createdllholesloop
   6639  f48a				  -	      else
   6640  f48a				  -	      bpl	createdllholesloop
   6641  f48a				  -	      endif
   6642  f48a				  -	      rts
   6643  f48a					      endif
   6644  f48a
   6645  f48a							; Provided under the CC0 license. See the included LICENSE.txt for details.
   6646  f48a
   6647  f48a				   START
   6648  f48a				   start
   6649  f48a
   6650  f48a							;******** more or less the Atari recommended startup procedure
   6651  f48a
   6652  f48a		       78		      sei
   6653  f48b		       d8		      cld
   6654  f48c
   6655  f48c					      ifnconst	NOTIALOCK
   6656  f48c		       a9 07		      lda	#$07
   6657  f48e				  -	      else
   6658  f48e				  -	      lda	#$06
   6659  f48e					      endif
   6660  f48e		       85 01		      sta	INPTCTRL	;lock 7800 into 7800 mode
   6661  f490		       a9 7f		      lda	#$7F
   6662  f492		       85 3c		      sta	CTRL	;disable DMA
   6663  f494		       a9 00		      lda	#$00
   6664  f496		       85 38		      sta	OFFSET
   6665  f498					      ifnconst	NOTIALOCK
   6666  f498		       85 01		      sta	INPTCTRL
   6667  f49a		       85 20		      sta	BACKGRND	; black default, in case a flash cart is using something else
   6668  f49c					      endif
   6669  f49c		       a2 ff		      ldx	#$FF
   6670  f49e		       9a		      txs
   6671  f49f
   6672  f49f							;************** Clear Memory
   6673  f49f
   6674  f49f							; ** Clear 1800-27FF, pg0+pg1 memory.
   6675  f49f				   ClearMemPages
   6676  f49f		       a9 00		      lda	#0
   6677  f4a1		       a8		      tay		; y=0
   6678  f4a2		       85 80		      sta	$80
   6679  f4a4		       a2 18		      ldx	#$18
   6680  f4a6				   ClearMemPagesLoop
   6681  f4a6		       86 81		      stx	$81	; needed for when we step on ZP memory
   6682  f4a8		       91 80		      sta	($80),y	;Store data
   6683  f4aa		       c8		      iny		;Next byte
   6684  f4ab		       d0 f9		      bne	ClearMemPagesLoop
   6685  f4ad		       e8		      inx
   6686  f4ae		       e0 28		      cpx	#$28
   6687  f4b0		       d0 f4		      bne	ClearMemPagesLoop
   6688  f4b2		       85 81		      sta	$81
   6689  f4b4
   6690  f4b4							;seed random number with hopefully-random timer value
   6691  f4b4		       a9 01		      lda	#1
   6692  f4b6		       0d 84 02 	      ora	INTIM
   6693  f4b9		       85 40		      sta	rand
   6694  f4bb
   6695  f4bb							; detect the console type...
   6696  f4bb				   pndetectvblankstart
   6697  f4bb		       a5 28		      lda	MSTAT
   6698  f4bd		       10 fc		      bpl	pndetectvblankstart	; if we're not in VBLANK, wait for it to start
   6699  f4bf				   pndetectvblankover
   6700  f4bf		       a5 28		      lda	MSTAT
   6701  f4c1		       30 fc		      bmi	pndetectvblankover	; then wait for it to be over
   6702  f4c3		       a0 00		      ldy	#$00
   6703  f4c5		       a2 00		      ldx	#$00
   6704  f4c7				   pndetectvblankhappening
   6705  f4c7		       a5 28		      lda	MSTAT
   6706  f4c9		       30 07		      bmi	pndetectinvblank	; if VBLANK starts, exit our counting loop
   6707  f4cb		       85 24		      sta	WSYNC
   6708  f4cd		       85 24		      sta	WSYNC
   6709  f4cf		       e8		      inx
   6710  f4d0		       d0 f5		      bne	pndetectvblankhappening
   6711  f4d2				   pndetectinvblank
   6712  f4d2		       e0 7d		      cpx	#125
   6713  f4d4		       90 02		      bcc	pndetecispal
   6714  f4d6		       a0 01		      ldy	#$01
   6715  f4d8				   pndetecispal
   6716  f4d8		       8c 09 21 	      sty	paldetected
   6717  f4db
   6718  f4db		       20 eb f3 	      jsr	createallgamedlls
   6719  f4de
   6720  f4de		       a9 18		      lda	#>DLLMEM
   6721  f4e0		       85 2c		      sta	DPPH
   6722  f4e2		       a9 00		      lda	#<DLLMEM
   6723  f4e4		       85 30		      sta	DPPL
   6724  f4e6
   6725  f4e6				  -	      ifconst	pokeysupport
   6726  f4e6				  -			; pokey support is compiled in, so try to detect it...
   6727  f4e6				  -	      jsr	detectpokeylocation
   6728  f4e6					      endif
   6729  f4e6
   6730  f4e6		       a9 01		      lda	#1	; default for port 0 and 1 is a regular joystick
   6731  f4e8		       8d b8 01 	      sta	port0control
   6732  f4eb		       8d b9 01 	      sta	port1control
   6733  f4ee
   6734  f4ee							;Setup port A to read mode
   6735  f4ee							;lda #$00
   6736  f4ee							;sta SWCHA
   6737  f4ee							;sta CTLSWA
   6738  f4ee
   6739  f4ee				  -	      ifconst	HSSUPPORT
   6740  f4ee				  -	      ifconst	bankswitchmode
   6741  f4ee				  -	      ifconst	included.hiscore.asm.bank
   6742  f4ee				  -	      ifconst	MCPDEVCART
   6743  f4ee				  -	      lda	#($18 | included.hiscore.asm.bank)
   6744  f4ee				  -	      ifconst	dumpbankswitch
   6745  f4ee				  -	      sta	dumpbankswitch
   6746  f4ee				  -	      endif
   6747  f4ee				  -	      sta	$3000
   6748  f4ee				  -	      else
   6749  f4ee				  -	      lda	#(included.hiscore.asm.bank)
   6750  f4ee				  -	      ifconst	dumpbankswitch
   6751  f4ee				  -	      sta	dumpbankswitch
   6752  f4ee				  -	      endif
   6753  f4ee				  -	      sta	$8000
   6754  f4ee				  -	      endif
   6755  f4ee				  -	      endif		; included.hiscore.asm.bank
   6756  f4ee				  -	      endif		; bankswitchmode
   6757  f4ee				  -			; try to detect HSC
   6758  f4ee				  -	      jsr	detecthsc
   6759  f4ee				  -	      and	#1
   6760  f4ee				  -	      sta	hsdevice
   6761  f4ee				  -skipHSCdetect
   6762  f4ee				  -			; try to detect AtariVox eeprom
   6763  f4ee				  -	      jsr	detectatarivoxeeprom
   6764  f4ee				  -	      and	#2
   6765  f4ee				  -	      ora	hsdevice
   6766  f4ee				  -	      cmp	#3
   6767  f4ee				  -	      bne	storeAinhsdevice
   6768  f4ee				  -			; For now, we tie break by giving HSC priority over AtariVox.
   6769  f4ee				  -			; Later we should check each device's priority byte if set, instead,
   6770  f4ee				  -	      lda	#2
   6771  f4ee				  -storeAinhsdevice
   6772  f4ee				  -	      sta	hsdevice
   6773  f4ee				  -	      lda	#$ff
   6774  f4ee				  -	      sta	hsdifficulty
   6775  f4ee				  -	      sta	hsgameslot
   6776  f4ee				  -	      sta	hsnewscoreline
   6777  f4ee					      endif		; HSSUPPORT
   6778  f4ee
   6779  f4ee				  -	      ifconst	AVOXVOICE
   6780  f4ee				  -	      jsr	silenceavoxvoice
   6781  f4ee					      endif
   6782  f4ee
   6783  f4ee				  -	      ifconst	RMT
   6784  f4ee				  -	      ifconst	RMTVOLUME
   6785  f4ee				  -	      lda	#$F0	; default to full RMT volume
   6786  f4ee				  -	      sta	rmtvolume
   6787  f4ee				  -	      ifconst	TIAVOLUME
   6788  f4ee				  -	      sta	tiavolume
   6789  f4ee				  -	      endif		; TIAVOLUME
   6790  f4ee				  -	      endif		; RMTVOLUME
   6791  f4ee					      else		; !RMT
   6792  f4ee				  -	      ifconst	TIAVOLUME
   6793  f4ee				  -	      lda	#$F0	; default to full TIA volume
   6794  f4ee				  -	      sta	tiavolume
   6795  f4ee					      endif		; TIAVOLUME
   6796  f4ee					      endif		; RMT
   6797  f4ee
   6798  f4ee				  -	      ifconst	bankswitchmode
   6799  f4ee				  -			; we need to switch to the first bank as a default. this needs to
   6800  f4ee				  -			; happen before DMA, in case there's a topscreenroutine in bank 0
   6801  f4ee				  -	      ifconst	MCPDEVCART
   6802  f4ee				  -	      lda	#$18	; xxx11nnn - switch to bank 0
   6803  f4ee				  -	      ifconst	dumpbankswitch
   6804  f4ee				  -	      sta	dumpbankswitch
   6805  f4ee				  -	      endif
   6806  f4ee				  -	      sta	$3000
   6807  f4ee				  -	      else
   6808  f4ee				  -	      lda	#0
   6809  f4ee				  -	      ifconst	dumpbankswitch
   6810  f4ee				  -	      sta	dumpbankswitch
   6811  f4ee				  -	      endif
   6812  f4ee				  -	      sta	$8000
   6813  f4ee				  -	      endif
   6814  f4ee					      endif
   6815  f4ee
   6816  f4ee							; CTRL 76543210
   6817  f4ee							; 7 colorburst kill
   6818  f4ee							; 6,5 dma ctrl 2=normal DMA, 3=no DMA
   6819  f4ee							; 4 character width 1=2 byte chars, 0=1 byte chars
   6820  f4ee							; 3 border control 0=background color border, 1=black border
   6821  f4ee							; 2 kangaroo mode 0=transparency, 1=kangaroo
   6822  f4ee							; 1,0 read mode 0=160x2/160x4 1=N/A 2=320B/320D 3=320A/320C
   6823  f4ee
   6824  f4ee				  -	      ifconst	DOUBLEWIDE
   6825  f4ee				  -	      lda	#%01010000	;Enable DMA, mode=160x2/160x4, 2x character width
   6826  f4ee					      else
   6827  f4ee		       a9 40		      lda	#%01000000	;Enable DMA, mode=160x2/160x4
   6828  f4f0					      endif
   6829  f4f0
   6830  f4f0		       20 4e f4 	      jsr	waitforvblankstart	; give the some vblank time to minimally update the display
   6831  f4f3
   6832  f4f3		       85 3c		      sta	CTRL
   6833  f4f5		       8d 07 21 	      sta	sCTRL
   6834  f4f8
   6835  f4f8		       20 de f3 	      jsr	vblankresync
   6836  f4fb
   6837  f4fb		       a2 01		      ldx	#1
   6838  f4fd		       20 74 f4 	      jsr	settwobuttonmode
   6839  f500		       a2 00		      ldx	#0
   6840  f502		       20 74 f4 	      jsr	settwobuttonmode
   6841  f505
   6842  f505					      ifnconst	.altgamestart
   6843  f505		       4c 00 80 	      jmp	game
   6844  f508				  -	      else
   6845  f508				  -	      jmp	.altgamestart
   6846  f508					      endif
   6847  f508
   6848  f508							; Provided under the CC0 license. See the included LICENSE.txt for details.
   6849  f508
   6850  f508							; A tunable parameter, to claim some memory back from DL usage
   6851  f508		       00 00	   MEMSKIP    =	$00
   6852  f508
   6853  f508							;************** Setup DLL entries
   6854  f508
   6855  f508							; setup some working definitions, to avoid ifnconst mess elsewhere...
   6856  f508					      ifnconst	SCREENHEIGHT
   6857  f508		       00 c0	   WSCREENHEIGHT =	192
   6858  f508				  -	      else
   6859  f508				  -WSCREENHEIGHT =	SCREENHEIGHT
   6860  f508					      endif
   6861  f508
   6862  f508					      ifnconst	ZONEHEIGHT
   6863  f508		       00 10	   WZONEHEIGHT =	16
   6864  f508				  -	      else
   6865  f508				  -WZONEHEIGHT =	ZONEHEIGHT
   6866  f508					      endif
   6867  f508
   6868  f508					      ifnconst	ZONECOUNT
   6869  f508				  -	      ifconst	VSCROLL
   6870  f508				  -WZONECOUNT =	((WSCREENHEIGHT/WZONEHEIGHT)+1)
   6871  f508					      else		; !VSCROLL
   6872  f508		       00 0c	   WZONECOUNT =	(WSCREENHEIGHT/WZONEHEIGHT)
   6873  f508					      endif		; !VSCROLL
   6874  f508				  -	      else
   6875  f508				  -	      ifconst	VSCROLL
   6876  f508				  -WZONECOUNT =	(ZONECOUNT+1)
   6877  f508				  -	      else		; !VSCROLL
   6878  f508				  -WZONECOUNT =	ZONECOUNT
   6879  f508				  -	      endif		; !VSCROLL
   6880  f508					      endif
   6881  f508
   6882  f508							; top of the frame, non-visible lines. this is based on NTSC,
   6883  f508							; but we add in extra NV lines at the end of the display to ensure
   6884  f508							; our PAL friends can play the game without it crashing.
   6885  f508		       00 19	   NVLINES    =	((243-WSCREENHEIGHT)/2)
   6886  f508
   6887  f508					      ifnconst	DLMEMSTART
   6888  f508					      ifnconst	DOUBLEBUFFER
   6889  f508				   WDLMEMSTART SET	$1880
   6890  f508				  -	      else
   6891  f508				  -WDLMEMSTART SET	$18E0
   6892  f508					      endif		; DOUBLEBUFFER
   6893  f508				  -	      else
   6894  f508				  -WDLMEMSTART SET	DLMEMSTART
   6895  f508					      endif
   6896  f508
   6897  f508				  -	      if	MEMSKIP > 0
   6898  f508				  -	      echo	"   ",[WDLMEMSTART],"to",[WDLMEMSTART+MEMSKIP-1],"was freed for game usage with MEMSKIP."
   6899  f508				  -WDLMEMSTART SET	(WDLMEMSTART + MEMSKIP)
   6900  f508					      endif		; MEMSKIP > 0
   6901  f508
   6902  f508					      ifnconst	DLMEMEND
   6903  f508				  -	      ifconst	EXTRADLMEMORY
   6904  f508				  -WDLMEMEND  =	$23FF
   6905  f508					      else
   6906  f508		       1f ff	   WDLMEMEND  =	$1FFF
   6907  f508					      endif
   6908  f508				  -	      else
   6909  f508				  -WDLMEMEND  =	DLMEMEND
   6910  f508					      endif
   6911  f508
   6912  f508
   6913  f508				   WMEMSIZE   SET	(WDLMEMEND-WDLMEMSTART+1)
   6914  f508
   6915  f508				  -	      ifconst	VSCROLL
   6916  f508				  -	      ifnconst	DOUBLEBUFFER
   6917  f508				  -			; give the last zone extra ram for the dma mask objects...
   6918  f508				  -WMEMSIZE   SET	(WMEMSIZE-(maskscrollspriteend-maskscrollsprite))
   6919  f508				  -	      endif		; DOUBLEBUFFER
   6920  f508					      endif		; VSCROLL
   6921  f508
   6922  f508					      ifnconst	DOUBLEBUFFER
   6923  f508		       00 9b	   DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-2)/5)*5)	; -2 to always ensure we have 1x double-byte terminator
   6924  f508				  -	      else
   6925  f508				  -DLLASTOBJ  =	((((WMEMSIZE/WZONECOUNT)-4)/10)*5)	; -4 to always ensure we have 2x double-byte terminators
   6926  f508					      endif
   6927  f508
   6928  f508		       00 9d	   TDOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)	; offset between DL buffers. ie. half the real DL
   6929  f508				  -	      if	TDOUBLEBUFFEROFFSET > 255
   6930  f508				  -DOUBLEBUFFEROFFSET =	255
   6931  f508					      else
   6932  f508		       00 9d	   DOUBLEBUFFEROFFSET =	(DLLASTOBJ+2)
   6933  f508					      endif
   6934  f508
   6935  f508				  -	      ifconst	EXTRADLMEMORY
   6936  f508				  -SECONDDLHALFSTART SET	$2300
   6937  f508					      endif
   6938  f508
   6939  f508				   DLPOINTH
   6940  f508				   DLINDEX    SET	0
   6941  f508					      REPEAT	WZONECOUNT
   6942  f508				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6943  f508				  -	      ifconst	EXTRADLMEMORY
   6944  f508				  -	      if	TMPMEMADDRESS > $1FFF
   6945  f508				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6946  f508				  -	      else
   6947  f508				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6948  f508				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6949  f508				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6950  f508				  -	      endif
   6951  f508				  -	      endif		; TMPMEMADDRESS > $1FFF
   6952  f508					      endif		; EXTRADLMEMORY
   6953  f508							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6954  f508		       18		      .byte.b	>TMPMEMADDRESS
   6955  f508				   DLINDEX    SET	DLINDEX + 1
   6941  f508					      REPEND
   6942  f508				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6943  f509				  -	      ifconst	EXTRADLMEMORY
   6944  f509				  -	      if	TMPMEMADDRESS > $1FFF
   6945  f509				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6946  f509				  -	      else
   6947  f509				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6948  f509				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6949  f509				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6950  f509				  -	      endif
   6951  f509				  -	      endif		; TMPMEMADDRESS > $1FFF
   6952  f509					      endif		; EXTRADLMEMORY
   6953  f509							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6954  f509		       19		      .byte.b	>TMPMEMADDRESS
   6955  f509				   DLINDEX    SET	DLINDEX + 1
   6941  f509					      REPEND
   6942  f509				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6943  f50a				  -	      ifconst	EXTRADLMEMORY
   6944  f50a				  -	      if	TMPMEMADDRESS > $1FFF
   6945  f50a				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6946  f50a				  -	      else
   6947  f50a				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6948  f50a				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6949  f50a				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6950  f50a				  -	      endif
   6951  f50a				  -	      endif		; TMPMEMADDRESS > $1FFF
   6952  f50a					      endif		; EXTRADLMEMORY
   6953  f50a							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6954  f50a		       19		      .byte.b	>TMPMEMADDRESS
   6955  f50a				   DLINDEX    SET	DLINDEX + 1
   6941  f50a					      REPEND
   6942  f50a				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6943  f50b				  -	      ifconst	EXTRADLMEMORY
   6944  f50b				  -	      if	TMPMEMADDRESS > $1FFF
   6945  f50b				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6946  f50b				  -	      else
   6947  f50b				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6948  f50b				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6949  f50b				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6950  f50b				  -	      endif
   6951  f50b				  -	      endif		; TMPMEMADDRESS > $1FFF
   6952  f50b					      endif		; EXTRADLMEMORY
   6953  f50b							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6954  f50b		       1a		      .byte.b	>TMPMEMADDRESS
   6955  f50b				   DLINDEX    SET	DLINDEX + 1
   6941  f50b					      REPEND
   6942  f50b				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6943  f50c				  -	      ifconst	EXTRADLMEMORY
   6944  f50c				  -	      if	TMPMEMADDRESS > $1FFF
   6945  f50c				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6946  f50c				  -	      else
   6947  f50c				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6948  f50c				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6949  f50c				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6950  f50c				  -	      endif
   6951  f50c				  -	      endif		; TMPMEMADDRESS > $1FFF
   6952  f50c					      endif		; EXTRADLMEMORY
   6953  f50c							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6954  f50c		       1b		      .byte.b	>TMPMEMADDRESS
   6955  f50c				   DLINDEX    SET	DLINDEX + 1
   6941  f50c					      REPEND
   6942  f50c				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6943  f50d				  -	      ifconst	EXTRADLMEMORY
   6944  f50d				  -	      if	TMPMEMADDRESS > $1FFF
   6945  f50d				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6946  f50d				  -	      else
   6947  f50d				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6948  f50d				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6949  f50d				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6950  f50d				  -	      endif
   6951  f50d				  -	      endif		; TMPMEMADDRESS > $1FFF
   6952  f50d					      endif		; EXTRADLMEMORY
   6953  f50d							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6954  f50d		       1b		      .byte.b	>TMPMEMADDRESS
   6955  f50d				   DLINDEX    SET	DLINDEX + 1
   6941  f50d					      REPEND
   6942  f50d				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6943  f50e				  -	      ifconst	EXTRADLMEMORY
   6944  f50e				  -	      if	TMPMEMADDRESS > $1FFF
   6945  f50e				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6946  f50e				  -	      else
   6947  f50e				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6948  f50e				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6949  f50e				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6950  f50e				  -	      endif
   6951  f50e				  -	      endif		; TMPMEMADDRESS > $1FFF
   6952  f50e					      endif		; EXTRADLMEMORY
   6953  f50e							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6954  f50e		       1c		      .byte.b	>TMPMEMADDRESS
   6955  f50e				   DLINDEX    SET	DLINDEX + 1
   6941  f50e					      REPEND
   6942  f50e				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6943  f50f				  -	      ifconst	EXTRADLMEMORY
   6944  f50f				  -	      if	TMPMEMADDRESS > $1FFF
   6945  f50f				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6946  f50f				  -	      else
   6947  f50f				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6948  f50f				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6949  f50f				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6950  f50f				  -	      endif
   6951  f50f				  -	      endif		; TMPMEMADDRESS > $1FFF
   6952  f50f					      endif		; EXTRADLMEMORY
   6953  f50f							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6954  f50f		       1c		      .byte.b	>TMPMEMADDRESS
   6955  f50f				   DLINDEX    SET	DLINDEX + 1
   6941  f50f					      REPEND
   6942  f50f				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6943  f510				  -	      ifconst	EXTRADLMEMORY
   6944  f510				  -	      if	TMPMEMADDRESS > $1FFF
   6945  f510				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6946  f510				  -	      else
   6947  f510				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6948  f510				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6949  f510				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6950  f510				  -	      endif
   6951  f510				  -	      endif		; TMPMEMADDRESS > $1FFF
   6952  f510					      endif		; EXTRADLMEMORY
   6953  f510							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6954  f510		       1d		      .byte.b	>TMPMEMADDRESS
   6955  f510				   DLINDEX    SET	DLINDEX + 1
   6941  f510					      REPEND
   6942  f510				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6943  f511				  -	      ifconst	EXTRADLMEMORY
   6944  f511				  -	      if	TMPMEMADDRESS > $1FFF
   6945  f511				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6946  f511				  -	      else
   6947  f511				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6948  f511				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6949  f511				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6950  f511				  -	      endif
   6951  f511				  -	      endif		; TMPMEMADDRESS > $1FFF
   6952  f511					      endif		; EXTRADLMEMORY
   6953  f511							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6954  f511		       1e		      .byte.b	>TMPMEMADDRESS
   6955  f511				   DLINDEX    SET	DLINDEX + 1
   6941  f511					      REPEND
   6942  f511				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6943  f512				  -	      ifconst	EXTRADLMEMORY
   6944  f512				  -	      if	TMPMEMADDRESS > $1FFF
   6945  f512				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6946  f512				  -	      else
   6947  f512				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6948  f512				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6949  f512				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6950  f512				  -	      endif
   6951  f512				  -	      endif		; TMPMEMADDRESS > $1FFF
   6952  f512					      endif		; EXTRADLMEMORY
   6953  f512							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6954  f512		       1e		      .byte.b	>TMPMEMADDRESS
   6955  f512				   DLINDEX    SET	DLINDEX + 1
   6941  f512					      REPEND
   6942  f512				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6943  f513				  -	      ifconst	EXTRADLMEMORY
   6944  f513				  -	      if	TMPMEMADDRESS > $1FFF
   6945  f513				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6946  f513				  -	      else
   6947  f513				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6948  f513				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6949  f513				  -SECONDDLHALFSTART SET	TMPMEMADDRESS
   6950  f513				  -	      endif
   6951  f513				  -	      endif		; TMPMEMADDRESS > $1FFF
   6952  f513					      endif		; EXTRADLMEMORY
   6953  f513							;echo " "," ZONE",[DLINDEX]d,"ADDRESS: ",TMPMEMADDRESS
   6954  f513		       1f		      .byte.b	>TMPMEMADDRESS
   6955  f513				   DLINDEX    SET	DLINDEX + 1
   6956  f514					      REPEND
   6957  f514
   6958  f514				  -	      ifconst	EXTRADLMEMORY
   6959  f514				  -	      echo	"   ",[SECONDDLHALFSTART],"to",[$27FF],"was claimed as extra DL memory."
   6960  f514					      endif
   6961  f514
   6962  f514
   6963  f514				   DLPOINTL
   6964  f514				   DLINDEX    SET	0
   6965  f514					      REPEAT	WZONECOUNT
   6966  f514				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6967  f514				  -	      ifconst	EXTRADLMEMORY
   6968  f514				  -	      if	TMPMEMADDRESS > $1FFF
   6969  f514				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6970  f514				  -	      else
   6971  f514				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6972  f514				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6973  f514				  -	      endif
   6974  f514				  -	      endif		; TMPMEMADDRESS > $1FFF
   6975  f514					      endif		; EXTRADLMEMORY
   6976  f514		       80		      .byte.b	<TMPMEMADDRESS
   6977  f514				   DLINDEX    SET	DLINDEX + 1
   6965  f514					      REPEND
   6966  f514				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6967  f515				  -	      ifconst	EXTRADLMEMORY
   6968  f515				  -	      if	TMPMEMADDRESS > $1FFF
   6969  f515				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6970  f515				  -	      else
   6971  f515				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6972  f515				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6973  f515				  -	      endif
   6974  f515				  -	      endif		; TMPMEMADDRESS > $1FFF
   6975  f515					      endif		; EXTRADLMEMORY
   6976  f515		       20		      .byte.b	<TMPMEMADDRESS
   6977  f515				   DLINDEX    SET	DLINDEX + 1
   6965  f515					      REPEND
   6966  f515				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6967  f516				  -	      ifconst	EXTRADLMEMORY
   6968  f516				  -	      if	TMPMEMADDRESS > $1FFF
   6969  f516				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6970  f516				  -	      else
   6971  f516				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6972  f516				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6973  f516				  -	      endif
   6974  f516				  -	      endif		; TMPMEMADDRESS > $1FFF
   6975  f516					      endif		; EXTRADLMEMORY
   6976  f516		       c0		      .byte.b	<TMPMEMADDRESS
   6977  f516				   DLINDEX    SET	DLINDEX + 1
   6965  f516					      REPEND
   6966  f516				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6967  f517				  -	      ifconst	EXTRADLMEMORY
   6968  f517				  -	      if	TMPMEMADDRESS > $1FFF
   6969  f517				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6970  f517				  -	      else
   6971  f517				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6972  f517				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6973  f517				  -	      endif
   6974  f517				  -	      endif		; TMPMEMADDRESS > $1FFF
   6975  f517					      endif		; EXTRADLMEMORY
   6976  f517		       60		      .byte.b	<TMPMEMADDRESS
   6977  f517				   DLINDEX    SET	DLINDEX + 1
   6965  f517					      REPEND
   6966  f517				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6967  f518				  -	      ifconst	EXTRADLMEMORY
   6968  f518				  -	      if	TMPMEMADDRESS > $1FFF
   6969  f518				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6970  f518				  -	      else
   6971  f518				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6972  f518				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6973  f518				  -	      endif
   6974  f518				  -	      endif		; TMPMEMADDRESS > $1FFF
   6975  f518					      endif		; EXTRADLMEMORY
   6976  f518		       00		      .byte.b	<TMPMEMADDRESS
   6977  f518				   DLINDEX    SET	DLINDEX + 1
   6965  f518					      REPEND
   6966  f518				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6967  f519				  -	      ifconst	EXTRADLMEMORY
   6968  f519				  -	      if	TMPMEMADDRESS > $1FFF
   6969  f519				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6970  f519				  -	      else
   6971  f519				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6972  f519				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6973  f519				  -	      endif
   6974  f519				  -	      endif		; TMPMEMADDRESS > $1FFF
   6975  f519					      endif		; EXTRADLMEMORY
   6976  f519		       a0		      .byte.b	<TMPMEMADDRESS
   6977  f519				   DLINDEX    SET	DLINDEX + 1
   6965  f519					      REPEND
   6966  f519				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6967  f51a				  -	      ifconst	EXTRADLMEMORY
   6968  f51a				  -	      if	TMPMEMADDRESS > $1FFF
   6969  f51a				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6970  f51a				  -	      else
   6971  f51a				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6972  f51a				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6973  f51a				  -	      endif
   6974  f51a				  -	      endif		; TMPMEMADDRESS > $1FFF
   6975  f51a					      endif		; EXTRADLMEMORY
   6976  f51a		       40		      .byte.b	<TMPMEMADDRESS
   6977  f51a				   DLINDEX    SET	DLINDEX + 1
   6965  f51a					      REPEND
   6966  f51a				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6967  f51b				  -	      ifconst	EXTRADLMEMORY
   6968  f51b				  -	      if	TMPMEMADDRESS > $1FFF
   6969  f51b				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6970  f51b				  -	      else
   6971  f51b				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6972  f51b				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6973  f51b				  -	      endif
   6974  f51b				  -	      endif		; TMPMEMADDRESS > $1FFF
   6975  f51b					      endif		; EXTRADLMEMORY
   6976  f51b		       e0		      .byte.b	<TMPMEMADDRESS
   6977  f51b				   DLINDEX    SET	DLINDEX + 1
   6965  f51b					      REPEND
   6966  f51b				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6967  f51c				  -	      ifconst	EXTRADLMEMORY
   6968  f51c				  -	      if	TMPMEMADDRESS > $1FFF
   6969  f51c				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6970  f51c				  -	      else
   6971  f51c				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6972  f51c				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6973  f51c				  -	      endif
   6974  f51c				  -	      endif		; TMPMEMADDRESS > $1FFF
   6975  f51c					      endif		; EXTRADLMEMORY
   6976  f51c		       80		      .byte.b	<TMPMEMADDRESS
   6977  f51c				   DLINDEX    SET	DLINDEX + 1
   6965  f51c					      REPEND
   6966  f51c				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6967  f51d				  -	      ifconst	EXTRADLMEMORY
   6968  f51d				  -	      if	TMPMEMADDRESS > $1FFF
   6969  f51d				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6970  f51d				  -	      else
   6971  f51d				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6972  f51d				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6973  f51d				  -	      endif
   6974  f51d				  -	      endif		; TMPMEMADDRESS > $1FFF
   6975  f51d					      endif		; EXTRADLMEMORY
   6976  f51d		       20		      .byte.b	<TMPMEMADDRESS
   6977  f51d				   DLINDEX    SET	DLINDEX + 1
   6965  f51d					      REPEND
   6966  f51d				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6967  f51e				  -	      ifconst	EXTRADLMEMORY
   6968  f51e				  -	      if	TMPMEMADDRESS > $1FFF
   6969  f51e				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6970  f51e				  -	      else
   6971  f51e				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6972  f51e				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6973  f51e				  -	      endif
   6974  f51e				  -	      endif		; TMPMEMADDRESS > $1FFF
   6975  f51e					      endif		; EXTRADLMEMORY
   6976  f51e		       c0		      .byte.b	<TMPMEMADDRESS
   6977  f51e				   DLINDEX    SET	DLINDEX + 1
   6965  f51e					      REPEND
   6966  f51e				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6967  f51f				  -	      ifconst	EXTRADLMEMORY
   6968  f51f				  -	      if	TMPMEMADDRESS > $1FFF
   6969  f51f				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6970  f51f				  -	      else
   6971  f51f				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6972  f51f				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6973  f51f				  -	      endif
   6974  f51f				  -	      endif		; TMPMEMADDRESS > $1FFF
   6975  f51f					      endif		; EXTRADLMEMORY
   6976  f51f		       60		      .byte.b	<TMPMEMADDRESS
   6977  f51f				   DLINDEX    SET	DLINDEX + 1
   6978  f520					      REPEND
   6979  f520
   6980  f520
   6981  f520				   DLINDEX    SET	0
   6982  f520					      REPEAT	WZONECOUNT
   6983  f520				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6984  f520				  -	      ifconst	EXTRADLMEMORY
   6985  f520				  -	      if	TMPMEMADDRESS > $1FFF
   6986  f520				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6987  f520				  -	      else
   6988  f520				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6989  f520				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6990  f520				  -	      endif
   6991  f520				  -	      endif		; TMPMEMADDRESS > $1FFF
   6992  f520					      endif		; EXTRADLMEMORY
   6993  f520
   6994  f520		       18 80	   ZONE0ADDRESS =	TMPMEMADDRESS
   6995  f520				   LASTZONEADDRESS SET	TMPMEMADDRESS
   6996  f520
   6997  f520				   DLINDEX    SET	DLINDEX + 1
   6982  f520					      REPEND
   6983  f520				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6984  f520				  -	      ifconst	EXTRADLMEMORY
   6985  f520				  -	      if	TMPMEMADDRESS > $1FFF
   6986  f520				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6987  f520				  -	      else
   6988  f520				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6989  f520				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6990  f520				  -	      endif
   6991  f520				  -	      endif		; TMPMEMADDRESS > $1FFF
   6992  f520					      endif		; EXTRADLMEMORY
   6993  f520
   6994  f520		       19 20	   ZONE1ADDRESS =	TMPMEMADDRESS
   6995  f520				   LASTZONEADDRESS SET	TMPMEMADDRESS
   6996  f520
   6997  f520				   DLINDEX    SET	DLINDEX + 1
   6982  f520					      REPEND
   6983  f520				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6984  f520				  -	      ifconst	EXTRADLMEMORY
   6985  f520				  -	      if	TMPMEMADDRESS > $1FFF
   6986  f520				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6987  f520				  -	      else
   6988  f520				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6989  f520				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6990  f520				  -	      endif
   6991  f520				  -	      endif		; TMPMEMADDRESS > $1FFF
   6992  f520					      endif		; EXTRADLMEMORY
   6993  f520
   6994  f520		       19 c0	   ZONE2ADDRESS =	TMPMEMADDRESS
   6995  f520				   LASTZONEADDRESS SET	TMPMEMADDRESS
   6996  f520
   6997  f520				   DLINDEX    SET	DLINDEX + 1
   6982  f520					      REPEND
   6983  f520				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6984  f520				  -	      ifconst	EXTRADLMEMORY
   6985  f520				  -	      if	TMPMEMADDRESS > $1FFF
   6986  f520				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6987  f520				  -	      else
   6988  f520				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6989  f520				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6990  f520				  -	      endif
   6991  f520				  -	      endif		; TMPMEMADDRESS > $1FFF
   6992  f520					      endif		; EXTRADLMEMORY
   6993  f520
   6994  f520		       1a 60	   ZONE3ADDRESS =	TMPMEMADDRESS
   6995  f520				   LASTZONEADDRESS SET	TMPMEMADDRESS
   6996  f520
   6997  f520				   DLINDEX    SET	DLINDEX + 1
   6982  f520					      REPEND
   6983  f520				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6984  f520				  -	      ifconst	EXTRADLMEMORY
   6985  f520				  -	      if	TMPMEMADDRESS > $1FFF
   6986  f520				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6987  f520				  -	      else
   6988  f520				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6989  f520				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6990  f520				  -	      endif
   6991  f520				  -	      endif		; TMPMEMADDRESS > $1FFF
   6992  f520					      endif		; EXTRADLMEMORY
   6993  f520
   6994  f520		       1b 00	   ZONE4ADDRESS =	TMPMEMADDRESS
   6995  f520				   LASTZONEADDRESS SET	TMPMEMADDRESS
   6996  f520
   6997  f520				   DLINDEX    SET	DLINDEX + 1
   6982  f520					      REPEND
   6983  f520				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6984  f520				  -	      ifconst	EXTRADLMEMORY
   6985  f520				  -	      if	TMPMEMADDRESS > $1FFF
   6986  f520				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6987  f520				  -	      else
   6988  f520				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6989  f520				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6990  f520				  -	      endif
   6991  f520				  -	      endif		; TMPMEMADDRESS > $1FFF
   6992  f520					      endif		; EXTRADLMEMORY
   6993  f520
   6994  f520		       1b a0	   ZONE5ADDRESS =	TMPMEMADDRESS
   6995  f520				   LASTZONEADDRESS SET	TMPMEMADDRESS
   6996  f520
   6997  f520				   DLINDEX    SET	DLINDEX + 1
   6982  f520					      REPEND
   6983  f520				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6984  f520				  -	      ifconst	EXTRADLMEMORY
   6985  f520				  -	      if	TMPMEMADDRESS > $1FFF
   6986  f520				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6987  f520				  -	      else
   6988  f520				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6989  f520				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6990  f520				  -	      endif
   6991  f520				  -	      endif		; TMPMEMADDRESS > $1FFF
   6992  f520					      endif		; EXTRADLMEMORY
   6993  f520
   6994  f520		       1c 40	   ZONE6ADDRESS =	TMPMEMADDRESS
   6995  f520				   LASTZONEADDRESS SET	TMPMEMADDRESS
   6996  f520
   6997  f520				   DLINDEX    SET	DLINDEX + 1
   6982  f520					      REPEND
   6983  f520				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6984  f520				  -	      ifconst	EXTRADLMEMORY
   6985  f520				  -	      if	TMPMEMADDRESS > $1FFF
   6986  f520				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6987  f520				  -	      else
   6988  f520				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6989  f520				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6990  f520				  -	      endif
   6991  f520				  -	      endif		; TMPMEMADDRESS > $1FFF
   6992  f520					      endif		; EXTRADLMEMORY
   6993  f520
   6994  f520		       1c e0	   ZONE7ADDRESS =	TMPMEMADDRESS
   6995  f520				   LASTZONEADDRESS SET	TMPMEMADDRESS
   6996  f520
   6997  f520				   DLINDEX    SET	DLINDEX + 1
   6982  f520					      REPEND
   6983  f520				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6984  f520				  -	      ifconst	EXTRADLMEMORY
   6985  f520				  -	      if	TMPMEMADDRESS > $1FFF
   6986  f520				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6987  f520				  -	      else
   6988  f520				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6989  f520				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6990  f520				  -	      endif
   6991  f520				  -	      endif		; TMPMEMADDRESS > $1FFF
   6992  f520					      endif		; EXTRADLMEMORY
   6993  f520
   6994  f520		       1d 80	   ZONE8ADDRESS =	TMPMEMADDRESS
   6995  f520				   LASTZONEADDRESS SET	TMPMEMADDRESS
   6996  f520
   6997  f520				   DLINDEX    SET	DLINDEX + 1
   6982  f520					      REPEND
   6983  f520				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6984  f520				  -	      ifconst	EXTRADLMEMORY
   6985  f520				  -	      if	TMPMEMADDRESS > $1FFF
   6986  f520				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6987  f520				  -	      else
   6988  f520				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6989  f520				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6990  f520				  -	      endif
   6991  f520				  -	      endif		; TMPMEMADDRESS > $1FFF
   6992  f520					      endif		; EXTRADLMEMORY
   6993  f520
   6994  f520		       1e 20	   ZONE9ADDRESS =	TMPMEMADDRESS
   6995  f520				   LASTZONEADDRESS SET	TMPMEMADDRESS
   6996  f520
   6997  f520				   DLINDEX    SET	DLINDEX + 1
   6982  f520					      REPEND
   6983  f520				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6984  f520				  -	      ifconst	EXTRADLMEMORY
   6985  f520				  -	      if	TMPMEMADDRESS > $1FFF
   6986  f520				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6987  f520				  -	      else
   6988  f520				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6989  f520				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6990  f520				  -	      endif
   6991  f520				  -	      endif		; TMPMEMADDRESS > $1FFF
   6992  f520					      endif		; EXTRADLMEMORY
   6993  f520
   6994  f520		       1e c0	   ZONE10ADDRESS =	TMPMEMADDRESS
   6995  f520				   LASTZONEADDRESS SET	TMPMEMADDRESS
   6996  f520
   6997  f520				   DLINDEX    SET	DLINDEX + 1
   6982  f520					      REPEND
   6983  f520				   TMPMEMADDRESS SET	(((DLINDEX*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART)
   6984  f520				  -	      ifconst	EXTRADLMEMORY
   6985  f520				  -	      if	TMPMEMADDRESS > $1FFF
   6986  f520				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6987  f520				  -	      else
   6988  f520				  -	      if	((((DLINDEX+1)*WMEMSIZE)/WZONECOUNT)+WDLMEMSTART) > $1FFF
   6989  f520				  -TMPMEMADDRESS SET	(TMPMEMADDRESS + $300)
   6990  f520				  -	      endif
   6991  f520				  -	      endif		; TMPMEMADDRESS > $1FFF
   6992  f520					      endif		; EXTRADLMEMORY
   6993  f520
   6994  f520		       1f 60	   ZONE11ADDRESS =	TMPMEMADDRESS
   6995  f520				   LASTZONEADDRESS SET	TMPMEMADDRESS
   6996  f520
   6997  f520				   DLINDEX    SET	DLINDEX + 1
   6998  f520					      REPEND
   6999  f520
   7000  f520
     $1880 to $1fff used as zone memory, allowing 31 display objects per zone.
   7001  f520					      echo	"   ",[WDLMEMSTART],"to",[WDLMEMEND],"used as zone memory, allowing",[(DLLASTOBJ/5)]d,"display objects per zone."
   7002  f520
   7003  f520				   DLHEIGHT
   7004  f520					      REPEAT	WZONECOUNT
   7005  f520		       0f		      .byte.b	(WZONEHEIGHT-1)
   7004  f520					      REPEND
   7005  f521		       0f		      .byte.b	(WZONEHEIGHT-1)
   7004  f521					      REPEND
   7005  f522		       0f		      .byte.b	(WZONEHEIGHT-1)
   7004  f522					      REPEND
   7005  f523		       0f		      .byte.b	(WZONEHEIGHT-1)
   7004  f523					      REPEND
   7005  f524		       0f		      .byte.b	(WZONEHEIGHT-1)
   7004  f524					      REPEND
   7005  f525		       0f		      .byte.b	(WZONEHEIGHT-1)
   7004  f525					      REPEND
   7005  f526		       0f		      .byte.b	(WZONEHEIGHT-1)
   7004  f526					      REPEND
   7005  f527		       0f		      .byte.b	(WZONEHEIGHT-1)
   7004  f527					      REPEND
   7005  f528		       0f		      .byte.b	(WZONEHEIGHT-1)
   7004  f528					      REPEND
   7005  f529		       0f		      .byte.b	(WZONEHEIGHT-1)
   7004  f529					      REPEND
   7005  f52a		       0f		      .byte.b	(WZONEHEIGHT-1)
   7004  f52a					      REPEND
   7005  f52b		       0f		      .byte.b	(WZONEHEIGHT-1)
   7006  f52c					      REPEND
   7007  f52c
   7008  f52c							; Provided under the CC0 license. See the included LICENSE.txt for details.
   7009  f52c
   7010  f52c							; a simple guard, than ensures the 7800basic code hasn't
   7011  f52c							; spilled into the encryption area...
     2642 bytes left in the 7800basic reserved area.
   7012  f52c					      echo	"   ",($FF7E-*)d,"bytes left in the 7800basic reserved area."
   7013  f52c				  -	      if	(*>$FF7D)
   7014  f52c				  -	      echo
   7015  f52c				  -	      echo	"***************************"
   7016  f52c				  -	      echo	"*** Abort: ROM Overflow ***"
   7017  f52c				  -	      echo	"***************************"
   7018  f52c				  -	      ERR		; abort the assembly
   7019  f52c					      endif
   7020  f52c
   7021  f52c							; throw a compile
   7022  f52c				  -	      ifconst	RMT
   7023  f52c				  -	      ifnconst	pokeysupport
   7024  f52c				  -	      echo
   7025  f52c				  -	      echo	"************************************************************"
   7026  f52c				  -	      echo	"*** ABORT: RMT Tracker requires 'set pokeysupport $xxxx' ***"
   7027  f52c				  -	      echo	"************************************************************"
   7028  f52c				  -	      ERR		; abort
   7029  f52c				  -	      endif		; pokeysupport
   7030  f52c				  -	      ifnconst	pokeyaddress
   7031  f52c				  -	      echo
   7032  f52c				  -	      echo	"************************************************************"
   7033  f52c				  -	      echo	"*** ABORT: RMT Tracker requires 'set pokeysupport $xxxx' ***"
   7034  f52c				  -	      echo	"************************************************************"
   7035  f52c				  -	      ERR		; abort
   7036  f52c				  -	      endif		; pokeyaddress
   7037  f52c					      endif
   7038  f52c
   7039  f52c							; Provided under the CC0 license. See the included LICENSE.txt for details.
   7040  f52c
   7041  f52c				  -	      ifconst	DEV
   7042  f52c				  -	      ifnconst	ZONEHEIGHT
   7043  f52c				  -	      echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   7044  f52c				  -	      else
   7045  f52c				  -	      if	ZONEHEIGHT = 8
   7046  f52c				  -	      echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   7047  f52c				  -	      else
   7048  f52c				  -	      echo	"* the 4k 7800basic area has",[($FF7E - *)]d,"bytes free."
   7049  f52c				  -	      endif
   7050  f52c				  -	      endif
   7051  f52c					      endif
   7052  f52c
   7053  f52c				  -	      if	START_OF_ROM = .
   7054  f52c				  -	      .byte	0
   7055  f52c					      endif
   7056  f52c				   START_OF_ROM SET	0
   7057  f52c
   7058  f52c							; FF7E/FF7F contains the 7800basic crc checksum word
   7059  f52c
   7060  f52c							; FF80 - FFF7 contains the 7800 encryption key
   7061  f52c
   7062  f52c					      ifnconst	bankswitchmode
   7063  fff8					      ORG	$FFF8
   7064  fff8				  -	      else
   7065  fff8				  -	      ifconst	ROM128K
   7066  fff8				  -	      ORG	$27FF8
   7067  fff8				  -	      RORG	$FFF8
   7068  fff8				  -	      endif
   7069  fff8				  -	      ifconst	ROM144K
   7070  fff8				  -	      ORG	$27FF8
   7071  fff8				  -	      RORG	$FFF8
   7072  fff8				  -	      endif
   7073  fff8				  -	      ifconst	ROM256K
   7074  fff8				  -	      ORG	$47FF8
   7075  fff8				  -	      RORG	$FFF8
   7076  fff8				  -	      endif
   7077  fff8				  -	      ifconst	ROM272K
   7078  fff8				  -	      ORG	$47FF8
   7079  fff8				  -	      RORG	$FFF8
   7080  fff8				  -	      endif
   7081  fff8				  -	      ifconst	ROM512K
   7082  fff8				  -	      ORG	$87FF8
   7083  fff8				  -	      RORG	$FFF8
   7084  fff8				  -	      endif
   7085  fff8				  -	      ifconst	ROM528K
   7086  fff8				  -	      ORG	$87FF8
   7087  fff8				  -	      RORG	$FFF8
   7088  fff8				  -	      endif
   7089  fff8					      endif
   7090  fff8
   7091  fff8
   7092  fff8		       ff		      .byte.b	$FF	; region verification. $FF=all regions
   7093  fff9		       f7		      .byte.b	$F7	; high nibble:  encryption check from $N000 to $FF7F. we only hash the last 4k for faster boot.
   7094  fffa							; low nibble :  N=7 atari rainbow start, N=3 no atari rainbow
   7095  fffa
   7096  fffa							;Vectors
   7097  fffa		       00 f0		      .word.w	NMI
   7098  fffc		       8a f4		      .word.w	START
   7099  fffe		       5f f0		      .word.w	IRQ
   7100  10000
